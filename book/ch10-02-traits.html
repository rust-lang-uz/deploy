<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Traitlar: umumiy xatti-harakatni aniqlash - Rust dasturlash tili</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust dasturlash tili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Muqaddima</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Kirish</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Ishni boshlash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> O'rnatish</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Taxmin qilish o'yinini dasturlash</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Umumiy dasturlash tushunchalari</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> O'zgaruvchilar va o'zgaruvchanlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Ma'lumotlar turlari</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funksiyalar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Izohlar</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Ownershipni tushunish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership nima?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencelar va  Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slice turi</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Tegishli ma'lumotlarni tuzish uchun Structdan foydalanish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Structlarni aniqlash va yaratish</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Structs yordamida namunaviy dastur</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod sintaksisi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumlar va patternlarni moslashtirish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumni aniqlash</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Control Flow konstruksiyasi</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let bilan qisqacha Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> O'sib borayotgan loyihalarni Paketlar, Cratelar va Modullar bilan boshqarish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketlar va Cratelar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Qo'llanish doirasi va maxfiylikni nazorat qilish uchun modullarni aniqlash</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modul daraxtidagi elementga murojaat qilish yo'llari</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use kalit so'zi bilan yo'llarni qamrab olish</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modullarni turli fayllarga ajratish</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Umumiy to'plamlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectorlar bilan qiymatlar ro'yxatini saqlash</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 kodlangan matnni Stringlar bilan saqlash</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Mapda bog'langan qiymatlarga ega kalitlarni saqlash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Xatolar bilan ishlash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! bilan tuzatib bo'lmaydigan xatolar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result bilan tiklanadigan xatolar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! yoki panic! emas</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Umumiy turlar, traitlar va lifetime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generik ma'lumotlar turlari</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Traitlar: umumiy xatti-harakatni aniqlash</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referencelarni lifetime bilan tekshirish</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Avtomatlashtirilgan testlarni yozish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testlarni qanday yozish kerak</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Sinovlar qanday o'tkazilishini nazorat qilish</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test tashkil etish</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O loyihasi: Buyruqlar qatori dasturini yaratish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Buyruqlar qatori argumentini qabul qilishs</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Faylni o'qish</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modullikni yaxshilash va xatolarni qayta ishlash uchun refactoring</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Sinovga asoslangan ishlab chiqish bilan kutubxonaning funksionalligini rivojlantirish</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Environment o'zgaruvchilari bilan ishlash</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Xato xabarlarini standart chiqish o'rniga standart xatoga yozish</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funksional til xususiyatlari: iteratorlar va closurelar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closurelar: Environmentni qamrab oladigan anonim funksiyalar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iteratorlar bilan bir qator elementlarga ishlov berish</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O loyihamizni takomillashtirish</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Ishlash samaradorligini solishtirish: Looplar va iteratorlar</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo va Crates.io haqida ko'proq</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Reliz profillari bilan structlarni moslashtirish</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crateni Crates.io-ga nashr qilish</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspacelar</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Binary fayllarni Crates.io'dan cargo install bilan o'rnatish</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Maxsus buyruqlar bilan Cargoni kengaytirish</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointerlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Heapdagi ma'lumotlarni ko'rsatish uchun Box&lt;T&gt; dan foydalanish</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Traitidan foydalangan holda oddiy referencelar kabi Smart Pointerlar bilan ishlash</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Traiti bilan tozalashda kodni ishga tushirish</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, reference hisoblangan Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; va ichki o'zgaruvchanlik namunasi</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Qo'rqmas parallellik</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodni bir vaqtning o'zida ishga tushirish uchun threadlardan foydalanish</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Threadlar orasidagi ma'lumotlarni uzatish uchun xabar uzatishdan(Message Passing) foydalanish</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync va Send traitlari bilan kengaytiriladigan parallellik</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustning ob'ektga yo'naltirilgan dasturlash xususiyatlari- OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Ob'ektga yo'naltirilgan tillarning xususiyatlari</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Har xil turdagi qiymatlarga ruxsat beruvchi trait ob'ektlaridan foydalanish</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ob'ektga yo'naltirilgan dizayn patternini implement qilish</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patternlar va Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Sintaksisi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Kengaytirilgan Xususiyatlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Xavfsiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Murakkab Traitlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Kengaytirilgan Turlar</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Kengaytirilgan funksiyalar va closurelar</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Yakuniy loyiha: Ko'p tarmoqli veb-serverni qurish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Yagona tarmoqli veb-serverni qurish</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Bizning yagona tarmoqli serverimizni ko'p tarmoqli serverga aylantirish</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Ajoyib o'chirish va tozalash</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ilova</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Kalit so'zlar</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatorlar va Symbollar</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Hosilaviy Traitlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Foydali Development Toollar</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Nashrlar</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitobning tarjimalari</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust qanday yasaladi va “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust dasturlash tili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="traitlar-umumiy-xatti-harakatni-aniqlash"><a class="header" href="#traitlar-umumiy-xatti-harakatni-aniqlash">Traitlar: umumiy xatti-harakatni aniqlash</a></h2>
<p><em>trait</em> ma'lum bir turga ega bo'lgan va boshqa turlar bilan bo'lishishi mumkin bo'lgan funksionallikni belgilaydi. Biz umumiy xatti-harakatni mavhum tarzda aniqlash uchun traitlardan foydalanishimiz mumkin. Generik tur ma'lum xatti-harakatlarga ega bo'lgan har qanday tur bo'lishi mumkinligini aniqlash uchun <em>trait (bound)chegaralari</em> dan foydalanishimiz mumkin.</p>
<blockquote>
<p>Eslatma: Traitlar ba'zi farqlarga ega bo'lsa-da, ko'pincha boshqa tillarda
<em>interfeyslar</em> deb ataladigan xususiyatga o'xshaydi.</p>
</blockquote>
<h3 id="traitni-aniqlash"><a class="header" href="#traitni-aniqlash">Traitni aniqlash</a></h3>
<p>Turning xatti-harakati biz ushbu turga murojaat qilishimiz mumkin bo'lgan metodlardan iborat. Agar biz ushbu turlarning barchasida bir xil metodlarni chaqira olsak, har xil turlar bir xil xatti-harakatlarga ega. Trait ta'riflari - bu qandaydir maqsadga erishish uchun zarur bo'lgan xatti-harakatlar to'plamini aniqlash uchun metod imzolarini birgalikda guruhlash usuli.</p>
<p>Misol uchun, bizda turli xil va hajmdagi matnlarni o'z ichiga olgan bir nechta structlar mavjud deylik: ma'lum bir joyda joylashtirilgan yangiliklarni o'z ichiga olgan <code>YangiMaqola</code> structi va eng ko'pi 280 belgidan iborat bo'lishi mumkin bo'lgan <code>Maqola</code> yangi post, retpost yoki boshqa postga javob ekanligini ko'rsatadigan metama'lumotlar.</p>
<p>Biz <code>YangiMaqola</code> yoki <code>Maqola</code> misolida saqlanishi mumkin bo‘lgan ma’lumotlarning qisqacha mazmunini ko‘rsata oladigan <code>aggregator</code> nomli media agregator kutubxonasini yaratmoqchimiz. Buni amalga oshirish uchun bizga har bir tur bo'yicha xulosa kerak bo'ladi va biz ushbu xulosani misolda <code>umumiy_xulosa</code> metodini chaqirish orqali so'raymiz. 10-12 ro'yxatda ushbu xatti-harakatni ifodalovchi umumiy <code>Xulosa</code> traitining ta'rifi ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Xulosa {
    fn umumiy_xulosa(&amp;self) -&gt; String;
}</code></pre>
<p><span class="caption">Roʻyxat 10-12: <code>umumiy_xulosa</code> metodi bilan taʼminlangan xatti-harakatlardan iborat <code>Xulosa</code> traiti</span></p>
<p>Bu yerda biz <code>trait</code> kalit so'zidan foydalanib traitni e'lon qilamiz, so'ngra belgi nomi, bu holda <code>Xulosa</code>. Shuningdek, biz ushbu traitni <code>pub</code> deb e’lon qildik, shunda bu cratega bog‘liq bo‘lgan cratelar ham bu traitdan foydalanishi mumkin, buni bir necha misollarda ko‘ramiz. Jingalak qavslar ichida biz ushbu traitni amalga oshiradigan turlarning xatti-harakatlarini tavsiflovchi metod imzolarini e'lon qilamiz, bu holda <code>fn umumiy_xulosa(&amp;self) -&gt; String</code>.</p>
<p>Metod imzosidan so'ng, jingalak qavslar ichida amalga oshirish o'rniga, biz nuqta-verguldan foydalanamiz. Ushbu traitni amalga oshiradigan har bir tur metod tanasi uchun o'ziga xos xatti-harakatni ta'minlashi kerak. Kompilyator <code>Xulosa</code> traitiga ega boʻlgan har qanday turda aynan shu imzo bilan aniqlangan <code>umumiy_xulosa</code> metodi boʻlishini talab qiladi.</p>
<p>Traitining tanasida bir nechta metodlar bo'lishi mumkin: metod imzolari har bir satrda bittadan ko'rsatilgan va har bir satr nuqtali vergul bilan tugaydi.</p>
<h3 id="turga-xos-traitni-amalga-oshirish"><a class="header" href="#turga-xos-traitni-amalga-oshirish">Turga xos traitni amalga oshirish</a></h3>
<p>Endi biz <code>Xulosa</code> traiti metodlarining kerakli imzolarini aniqlaganimizdan so‘ng, uni media agregatorimizdagi turlarga qo‘llashimiz mumkin. 10-13 roʻyxat sarlavhadan foydalanadigan <code>YangiMaqola</code> structidagi <code>Xulosa</code> traitining amalga oshirilishini koʻrsatadi, muallif va <code>umumiy_xulosa</code> qaytish qiymatini yaratish uchun joy. <code>Maqola</code> structi uchun biz <code>umumiy_xulosa</code>ni foydalanuvchi nomi va undan keyin maqolaning butun matni sifatida belgilaymiz, maqola mazmuni allaqachon 280 belgi bilan cheklangan deb hisoblaymiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct YangiMaqola {
    pub sarlavha: String,
    pub manzil: String,
    pub muallif: String,
    pub mazmuni: String,
}

impl Xulosa for YangiMaqola {
    fn umumiy_xulosa(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.sarlavha, self.muallif, self.manzil)
    }
}

pub struct Maqola {
    pub foydalanuvchi: String,
    pub mazmuni: String,
    pub javob_berish: bool,
    pub repost: bool,
}

impl Xulosa for Maqola {
    fn umumiy_xulosa(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
    }
}</code></pre>
<p><span class="caption">Roʻyxat 10-13: <code>Xulosa</code> traitini <code>YangiMaqola</code> va <code>Maqola</code> turlariga joriy qilish</span></p>
<p>Traitni turga tatbiq etish odatiy usullarni amalga oshirishga o'xshaydi. Farqi shundaki, <code>impl</code> dan so'ng biz amalga oshirmoqchi bo'lgan trait nomini qo'yamiz, so'ng <code>for</code> kalit so'zidan foydalanamiz va keyin traitni amalga oshirmoqchi bo'lgan tur nomini belgilaymiz. <code>impl</code> blokida biz trait ta'rifi belgilagan metod imzolarini qo'yamiz. Har bir imzodan keyin nuqta-vergul qo'yish o'rniga, biz jingalak qavslardan foydalanamiz va metod tanasini o'ziga xos xatti-harakat bilan to'ldiramiz, biz traitning metodlari ma'lum bir turga ega bo'lishini xohlaymiz.</p>
<p>Kutubxona <code>YangiMaqola</code> va <code>Maqola</code>da <code>Xulosa</code> traitini joriy qilganligi sababli, crate foydalanuvchilari <code>YangiMaqola</code> va <code>Maqola</code> misollaridagi xususiyat metodlarini biz odatdagi metodlar deb ataganimizdek chaqirishlari mumkin. Yagona farq shundaki, foydalanuvchi o'ziga xos traitni turlari bilan bir qatorda qamrab olishi kerak. Binary crate bizning <code>aggregator</code> kutubxonamiz cratesidan qanday foydalanishi mumkinligiga misol:</p>
<pre><code class="language-rust ignore">use aggregator::{Xulosa, Maqola};

fn main() {
    let maqola = Maqola {
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        mazmuni: String::from(
            &quot;Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim&quot;,
        ),
        javob_berish: false,
        repost: false,
    };

    println!(&quot;1 ta yangi xabar: {}&quot;, maqola.umumiy_xulosa());
}</code></pre>
<p>Bu kod <code>1 ta yangi xabar: ismoilovdev: Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim</code> chop etadi.</p>
<p><code>aggregator</code> cratesiga bog'liq bo'lgan boshqa cratelar ham <code>Xulosa</code> traitini o'z turlari bo'yicha <code>Xulosa</code>ni amalga oshirish uchun qamrab olishi mumkin. E'tiborga olish kerak bo'lgan cheklashlardan biri shundaki, biz trait yoki turning hech bo'lmaganda bittasi bizning cratemiz uchun mahalliy(local) bo'lsa, biz traitni turga qo'llashimiz mumkin. Misol uchun, biz <code>Maqola</code> kabi maxsus turdagi <code>Display</code> kabi standart kutubxona traitlarini <code>aggregator</code> crate funksiyamizning bir qismi sifatida amalga oshirishimiz mumkin, chunki <code>Maqola</code> turi <code>aggregator</code> cratemiz uchun mahalliydir. Shuningdek, biz  <code>Vec&lt;T&gt;</code> da <code>Xulosa</code>ni <code>aggregator</code> cratemizda ham qo‘llashimiz mumkin, chunki <code>Xulosa</code> traiti <code>aggregator</code> cratemiz uchun mahalliydir.</p>
<p>Ammo biz tashqi turlarga tashqi traitlarni amalga oshira olmaymiz. Masalan, biz <code>aggregator</code> cratemiz ichida <code>Vec&lt;T&gt;</code> da <code>Display</code> traitini amalga oshira olmaymiz, chunki <code>Display</code> va <code>Vec&lt;T&gt;</code> ikkalasi ham standart kutubxonada belgilangan va bizning <code>aggregator</code> cratemiz uchun mahalliy emas. Bu cheklash <em>kogerentlik(coherence)</em> deb nomlangan xususiyatning bir qismi va aniqrog'i <em>yetim qoidasi(orphan rule)</em>, chunki ota-ona turi mavjud emasligi sababli shunday nomlangan. Bu qoida boshqa odamlarning kodi sizning kodingizni buzmasligini ta'minlaydi va aksincha. Qoidalarsiz ikkita crate bir xil turdagi bir xil traitni amalga oshirishi mumkin edi va Rust qaysi dasturdan foydalanishni bilmaydi.</p>
<h3 id="standart-ilovalar"><a class="header" href="#standart-ilovalar">Standart ilovalar</a></h3>
<p>Ba'zan har bir turdagi barcha metodlarni amalga oshirishni talab qilish o'rniga, traitdagi ba'zi yoki barcha metodlar uchun standart xatti-harakatlarga ega bo'lish foydali bo'ladi.
Keyin, biz traitni ma'lum bir turga qo'llaganimizda, har bir metodning standart xatti-harakatlarini saqlab qolishimiz yoki bekor qilishimiz mumkin.</p>
<p>Roʻyxat 10-14da biz 10-12 ro'yxatda bo'lgani kabi faqat metod imzosini belgilash o'rniga <code>Xulosa</code> traitining <code>umumiy_xulosa</code> metodi uchun standart qatorni belgilaymiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Xulosa {
    fn umumiy_xulosa(&amp;self) -&gt; String {
        String::from(&quot;(Batafsil...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct YangiMaqola {
</span><span class="boring">    pub sarlavha: String,
</span><span class="boring">    pub manzil: String,
</span><span class="boring">    pub muallif: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for YangiMaqola {}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Roʻyxat 10-14: <code>Xulosa</code> traitini <code>umumiy_xulosa</code> metodini standart boʻyicha amalga oshirish bilan aniqlash</span></p>
<p><code>YangiMaqola</code> misollarini umumlashtirish uchun standart ilovadan foydalanish uchun biz bo'sh <code>impl</code> blokini <code>impl Xulosa for YangiMaqola {}</code> bilan belgilaymiz.</p>
<p>Biz <code>YangiMaqola</code>da to‘g‘ridan-to‘g‘ri <code>umumiy_xulosa</code> metodini endi aniqlamasak ham, biz standart bo‘yicha dasturni taqdim etdik va <code>YangiMaqola</code> <code>Xulosa</code> traitini amalga oshirishini belgilab oldik. Natijada, biz hali ham <code>YangiMaqola</code> misolida <code>umumiy_xulosa</code> metodini quyidagicha chaqirishimiz mumkin:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, YangiMaqola, Xulosa};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let maqola = YangiMaqola {
        sarlavha: String::from(&quot;Tesla yangi elektromobil ustida ishlayapti&quot;),
        manzil: String::from(&quot;USA&quot;),
        muallif: String::from(&quot;Elon Musk&quot;),
        mazmuni: String::from(
            &quot;Hozirgi kunda Tesla yangi innovatsion elektromobil\
             ustida ishlamoqda.&quot;,
        ),
    };

    println!(&quot;Yangi maqola mavjud! {}&quot;, maqola.umumiy_xulosa());
<span class="boring">}</span></code></pre>
<p>Bu kod <code>Yangi maqola mavjud! (Batafsil...)</code>ni chop etadi.</p>
<p>Standart dasturni yaratish bizdan 10-13 roʻyxatdagi <code>Maqola</code>dagi <code>Xulosa</code>ni amalga oshirish haqida biror narsani oʻzgartirishimizni talab qilmaydi. Buning sababi, standart dasturni bekor qilish sintaksisi standart dasturga ega bo'lmagan trait metodini amalga oshirish sintaksisi bilan bir xil.</p>
<p>Standart ilovalar bir xil traitga ega bo'lgan boshqa metodlarni chaqirishi mumkin, hatto bu boshqa metodlarda standart dastur bo'lmasa ham. Shunday qilib, trait juda ko'p foydali funksiyalarni taqdim etishi mumkin va amalga oshiruvchilardan faqat uning kichik qismini ko'rsatishni talab qiladi. Misol uchun, biz <code>Xulosa</code> traitini amalga oshirish zarur bo'lgan <code>muallif_haqida</code> metodiga ega bo'lish uchun belgilashimiz va keyin <code>muallif_haqida</code> metodini chaqiradigan standart amalga oshirishga ega bo'lgan <code>umumiy_xulosa</code> metodini belgilashimiz mumkin:</p>
<pre><code class="language-rust noplayground">pub trait Xulosa {
    fn muallif_haqida(&amp;self) -&gt; String;

    fn umumiy_xulosa(&amp;self) -&gt; String {
        format!(&quot;(Batafsil: {}...)&quot;, self.muallif_haqida())
    }
}
<span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn muallif_haqida(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.foydalanuvchi)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>Xulosa</code> ning ushbu versiyasidan foydalanish uchun biz faqat bir turdagi traitni amalga oshirganimizda <code>muallif_haqida</code> ni aniqlashimiz kerak:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn muallif_haqida(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Batafsil: {}...)&quot;, self.muallif_haqida())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Xulosa for Maqola {
    fn muallif_haqida(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.foydalanuvchi)
    }
}</code></pre>
<p><code>muallif_haqida</code> ni aniqlaganimizdan so'ng, biz <code>Maqola</code> structi misollarida <code>umumiy_xulosa</code> deb atashimiz mumkin va <code>umumiy_xulosa</code> standart bajarilishi biz taqdim etgan <code>muallif_haqida</code> ta'rifini chaqiradi. Biz <code>muallif_haqida</code> ni qo'llaganimiz sababli, <code>Xulosa</code> traiti bizga boshqa kod yozishni talab qilmasdan <code>umumiy_xulosa</code> metodining harakatini berdi.</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Xulosa, Maqola};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let maqola = Maqola {
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        mazmuni: String::from(
            &quot;Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim&quot;,
        ),
        javob_berish: false,
        repost: false,
    };

    println!(&quot;1 ta yangi xabar: {}&quot;, maqola.umumiy_xulosa());
<span class="boring">}</span></code></pre>
<p>Bu kod <code>1 ta yangi xabar: (Batafsil: @ismoilovdev...)</code> ni chop etadi.</p>
<p>Shuni esda tutingki, xuddi shu metodni bekor qilish orqali standart dasturni chaqirish mumkin emas.</p>
<h3 id="traitlar-parametr-sifatida"><a class="header" href="#traitlar-parametr-sifatida">Traitlar parametr sifatida</a></h3>
<p>Endi siz traitlarni qanday aniqlash va amalga oshirishni bilganingizdan so'ng, biz ko'plab turlarni qabul qiladigan funksiyalarni aniqlash uchun traitlardan qanday foydalanishni o'rganishimiz mumkin. Biz 10-13 roʻyxatdagi <code>YangiMaqola</code> va <code>Maqola</code> turlari uchun joriy qilingan <code>Xulosa</code> traitidan foydalanamiz, uning <code>element</code> parametri boʻyicha umumlashtirish metodlini chaqiradigan <code>xabar_berish</code> funksiyasini belgilaymiz, u <code>Xulosa</code> traitini amalga oshiradi. Buning uchun biz <code>impl Trait</code> sintaksisidan foydalanamiz, masalan:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct YangiMaqola {
</span><span class="boring">    pub sarlavha: String,
</span><span class="boring">    pub manzil: String,
</span><span class="boring">    pub muallif: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for YangiMaqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.sarlavha, self.muallif, self.manzil)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn xabar_berish(element: &amp;impl Xulosa) {
    println!(&quot;Tezkor xabarlar! {}&quot;, element.umumiy_xulosa());
}</code></pre>
<p><code>element</code> parametri uchun aniq tur o'rniga biz <code>impl</code> kalit so'zini va trait nomini belgilaymiz. Ushbu parametr belgilangan traitni amalga oshiradigan har qanday turni qabul qiladi. <code>xabar_berish</code> qismida biz <code>Xulosa</code> traitidan kelib chiqadigan <code>element</code> bo‘yicha har qanday metodlarni chaqirishimiz mumkin, masalan, <code>umumiy_xulosa</code>. Biz <code>xabar_berish</code> ga chaiqruv  qilishimiz va <code>YangiMaqola</code> yoki <code>Maqola</code> ning istalgan misolida o'tishimiz mumkin. Funksiyani <code>String</code> yoki <code>i32</code> kabi boshqa har qanday turdagi chaqiruvchi kod kompilyatsiya qilinmaydi, chunki bu turlar <code>Xulosa</code> ni amalga oshirmaydi.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="traitlarni-cheklash-sintaksisi"><a class="header" href="#traitlarni-cheklash-sintaksisi">Traitlarni cheklash sintaksisi</a></h4>
<p><code>impl Trait</code> sintaksisi oddiy holatlar uchun ishlaydi, lekin aslida <em>trait bound</em> deb nomlanuvchi uzunroq shakl uchun sintaksis shakaridir; bu shunday ko'rinadi:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish&lt;T: Xulosa&gt;(element: &amp;T) {
    println!(&quot;Tezkor xabarlar! {}&quot;, element.umumiy_xulosa());
}</code></pre>
<p>Ushbu uzunroq shakl oldingi bo'limdagi misolga teng, ammo batafsilroq. Trait chegaralarini ikki nuqta va ichki burchakli qavslardan keyin umumiy tur parametri e'lon qilingan holda joylashtiramiz.</p>
<p><code>impl Trait</code> sintaksisi qulay va oddiy holatlarda ixchamroq kodni yaratadi, to'liqroq traitlar bilan bog'langan sintaksisi esa boshqa holatlarda ko'proq murakkablikni ifodalashi mumkin. Misol uchun, bizda <code>Xulosa</code> ni amalga oshiradigan ikkita parametr bo'lishi mumkin. Buni <code>impl Trait</code> sintaksisi bilan bajarish quyidagicha ko'rinadi:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish(element1: &amp;impl Xulosa, element2: &amp;impl Xulosa) {</code></pre>
<p>Agar biz ushbu funksiya <code>element1</code> va <code>element2</code> turli xil turlarga ega bo'lishini istasak, <code>impl Trait</code> dan foydalanish maqsadga muvofiqdir (agar ikkala tur ham <code>Xulosa</code>ni qo'llasa). Agar biz ikkala parametrni bir xil turga ega bo'lishga majburlamoqchi bo'lsak, quyidagi kabi trait bounddan foydalanishimiz kerak:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish&lt;T: Xulosa&gt;(element1: &amp;T, element2: &amp;T) {</code></pre>
<p><code>element1</code> va <code>element2</code> parametrlarining turi sifatida belgilangan umumiy <code>T</code> turi funksiyani shunday cheklaydiki, <code>element1</code> va <code>element2</code> uchun argument sifatida berilgan qiymatning aniq turi bir xil bo`lishi kerak.</p>
<h4 id="-sintaksisi-bilan-bir-nechta-trait-chegaralarini-belgilash"><a class="header" href="#-sintaksisi-bilan-bir-nechta-trait-chegaralarini-belgilash"><code>+</code> sintaksisi bilan bir nechta trait chegaralarini belgilash</a></h4>
<p>Bundan tashqari, biz bir nechta traitlarni belgilashimiz mumkin. Aytaylik, biz <code>xabar_berish</code> funksiyasidan display formatlash hamda <code>element</code> bo‘yicha <code>umumiy_xulosa</code>dan foydalanishni xohladik: biz <code>xabar_berish</code> ta'rifida <code>element</code> <code>Display</code> va <code>Xulosa</code> ni ham amalga oshirishi kerakligini belgilaymiz. Buni <code>+</code> sintaksisi yordamida amalga oshirishimiz mumkin:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish(element: &amp;(impl Xulosa + Display)) {</code></pre>
<p><code>+</code> sintaksisi generik turdagi belgilar chegaralari bilan ham amal qiladi:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish&lt;T: Xulosa+ Display&gt;(element: &amp;T) {</code></pre>
<p>Belgilangan ikkita trait chegarasi bilan <code>xabar_berish</code> asosiy qismi <code>umumiy_xulosa</code> deb chaqirishi va <code>element</code>ni formatlash uchun <code>{}</code> dan foydalanishi mumkin.</p>
<h4 id="where-bandlari-bilan-aniqroq-trait-boundschegaralari"><a class="header" href="#where-bandlari-bilan-aniqroq-trait-boundschegaralari"><code>where</code> bandlari bilan aniqroq trait bounds(chegaralari)</a></h4>
<p>Haddan tashqari ko'p belgilar boundlaridan foydalanish o'zining salbiy tomonlariga ega. Har bir generikning o'ziga xos trait boundlari bor, shuning uchun bir nechta umumiy turdagi parametrlarga ega funksiyalar funksiya nomi va uning parametrlar ro'yxati o'rtasida ko'plab belgilar bilan bog'liq ma'lumotlarni o'z ichiga olishi mumkin, bu funksiya imzosini o'qishni qiyinlashtiradi. Shu sababli, Rust funksiya imzosidan keyin <code>where</code> bandida trait boundlarini belgilash uchun muqobil sintaksisga ega.</p>
<pre><code class="language-rust ignore">fn boshqa_funksiya&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>biz <code>where</code> bandidan foydalanishimiz mumkin, masalan:</p>
<pre><code class="language-rust ignore">fn boshqa_funksiya&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>Bu funksiya imzosi kamroq chalkash: funksiya nomi, parametrlar ro'yxati va qaytish turi bir-biriga yaqin bo'lib, ko'p trait boundlari bo'lmagan funksiyaga o'xshaydi.</p>
<h3 id="traitlarni-amalga-oshiradigan-returnqaytaruvchi-turlar"><a class="header" href="#traitlarni-amalga-oshiradigan-returnqaytaruvchi-turlar">Traitlarni amalga oshiradigan Return(qaytaruvchi) turlar</a></h3>
<p>Bu yerda ko'rsatilganidek, traitni amalga oshiradigan ba'zi turdagi qiymatni qaytarish(return) uchun <code>impl Trait</code> sintaksisini return holatida ham ishlatishimiz mumkin:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct YangiMaqola {
</span><span class="boring">    pub sarlavha: String,
</span><span class="boring">    pub manzil: String,
</span><span class="boring">    pub muallif: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for YangiMaqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.sarlavha, self.muallif, self.manzil)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn return_xulosa() -&gt; impl Xulosa {
    Maqola {
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        mazmuni: String::from(
            &quot;Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim&quot;,
        ),
        javob_berish: false,
        repost: false,
    }
}</code></pre>
<p>Qaytish(return) turi uchun <code>impl Xulosa</code> dan foydalanib, biz <code>return_xulosa</code> funksiyasi aniq turga nom bermasdan <code>Xulosa</code> traitini amalga oshiradigan ba'zi turlarni qaytarishini aniqlaymiz. Bunday holda, <code>return_xulosa</code> <code>Maqola</code> ni qaytaradi, lekin bu funksiyani chaqiruvchi kod buni bilishi shart emas.</p>
<p>Qaytish turini faqat u amalga oshiradigan traitga ko'ra belgilash qobiliyati, ayniqsa, biz 13-bobda ko'rib chiqiladigan closurelar va iteratorlar kontekstida foydalidir.  Closures va iteratorlar faqat kompilyator biladigan turlarni yoki belgilash uchun juda uzoq turlarni yaratadi. <code>impl Trait</code> sintaksisi sizga funksiya juda uzun turni yozishga hojat qoldirmasdan <code>Iterator</code> traitini amalga oshiradigan ba'zi turlarni qaytarishini qisqacha belgilash imkonini beradi.</p>
<p>Biroq, faqat bitta turni qaytarayotgan bo'lsangiz, <code>impl Trait</code> dan foydalanishingiz mumkin. Masalan, <code>YangiMaqola</code> yoki <code>Maqola</code>ni qaytaruvchi <code>impl Xulosa</code> sifatida ko‘rsatilgan qaytarish turiga ega bo‘lgan bu kod ishlamaydi:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p><code>YangiMaqola</code> yoki <code>Maqola</code>ni qaytarishga <code>impl Trait</code> sintaksisi kompilyatorda qanday amalga oshirilishi bilan bog‘liq cheklovlar tufayli ruxsat berilmaydi. Ushbu xatti-harakat bilan funksiyani qanday yozishni biz 17-bobning <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">&quot;Turli turdagi qiymatlarga ruxsat beruvchi trait ob'ektlaridan foydalanish&quot;</a><!--
ignore --> bo'limida ko'rib chiqamiz.</p>
<h3 id="metodlarni-shartli-ravishda-amalga-oshirish-uchun-trait-boundlardan-foydalanish"><a class="header" href="#metodlarni-shartli-ravishda-amalga-oshirish-uchun-trait-boundlardan-foydalanish">Metodlarni shartli ravishda amalga oshirish uchun Trait Boundlardan foydalanish</a></h3>
<p>Umumiy turdagi parametrlardan foydalanadigan <code>impl</code> bloki bilan trait bounddan foydalanib, biz belgilangan traitlarni amalga oshiradigan turlar uchun metodlarni shartli ravishda amalga oshirishimiz mumkin. Masalan, 10-15-ro'yxatdagi <code>Pair&lt;T&gt;</code> turi har doim yangi <code>Pair&lt;T&gt;</code> nusxasini qaytarish uchun <code>new</code> funksiyasini amalga oshiradi (5-bobning <a href="ch05-03-method-syntax.html#defining-methods">“Metodlarni aniqlash”</a><!-- ignore -->  boʻlimidan eslaylikki, <code>Self</code> bu <code>impl</code> bloki turiga tegishli turdagi taxallus(alias) boʻlib, bu holda <code>Pair&lt;T&gt;</code> boʻladi). Ammo keyingi <code>impl</code> blokida <code>Pair&lt;T&gt;</code> faqat <code>cmp_display</code> metodini qo'llaydi, uning ichki turi(inner type) <code>T</code> taqqoslash imkonini beruvchi <code>PartialOrd</code> traitini <em>va</em> chop etish imkonini beruvchi <code>Display</code> traittini amalga oshiradi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Eng katta a'zo x = {}&quot;, self.x);
        } else {
            println!(&quot;Eng katta a'zo y = {}&quot;, self.y);
        }
    }
}</code></pre>
<p><span class="caption">Ro'yxat 10-15: Trait boundga qarab generik tur bo'yicha shartli ravishda qo'llash metodlari</span></p>
<p>Biz shartli ravishda boshqa traitni amalga oshiradigan har qanday tur uchun traitni amalga oshirishimiz mumkin. Trait boundlarni qondiradigan har qanday turdagi tarittni amalga oshirish <em>blanket implementations</em> deb nomlanadi va Rust standart kutubxonasida keng qo'llaniladi. Masalan, standart kutubxona <code>Display</code> traitini amalga oshiradigan har qanday turdagi <code>ToString</code> traitini amalga oshiradi. Standart kutubxonadagi <code>impl</code> bloki ushbu kodga o'xshaydi:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Standart kutubxonada bu keng qamrovli dastur mavjud bo'lganligi sababli, biz <code>Display</code> traitini amalga oshiradigan har qanday turdagi <code>ToString</code> traiti bilan aniqlangan <code>to_string</code> metodini chaqirishimiz mumkin. Masalan, biz butun sonlarni mos keladigan <code>String</code> qiymatlariga shunday aylantirishimiz mumkin, chunki butun sonlar <code>Display</code>ni amalga oshiradi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Blanket implementationlari &quot;Implementors&quot; bo'limidagi trait uchun texnik hujjatlarda ko'rinadi.</p>
<p>Traitlar va trait boundlar takrorlanishni kamaytirish uchun generik turdagi parametrlardan foydalanadigan kod yozishga imkon beradi, shuningdek, generik turning o'ziga xos xatti-harakatlariga ega bo'lishini kompilyatorga ko'rsatishga imkon beradi. Keyin kompilyator trait bilan bog'langan ma'lumotlardan bizning kodimiz bilan qo'llaniladigan barcha aniq turlar to'g'ri xatti-harakatni ta'minlaydiganligini tekshirish uchun foydalanishi mumkin. Dinamik ravishda tuzilgan tillarda, agar biz metodni aniqlamagan turdagi metodni chaqirsak, runtimeda xatoga yo'l qo'yamiz. Ammo Rust bu xatolarni vaqtni kompilyatsiya qilish uchun ko'chiradi, shuning uchun biz kodimiz ishga tushgunga qadar muammolarni hal qilishga majbur bo'lamiz. Bundan tashqari, biz runtimeda xatti-harakatni tekshiradigan kod yozishimiz shart emas, chunki biz kompilyatsiya vaqtida allaqachon tekshirganmiz.
Bu generiklarning moslashuvchanligidan voz kechmasdan ishlashni yaxshilaydi.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
