<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Control Flow - Rust dasturlash tili</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust dasturlash tili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Muqaddima</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Kirish</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Ishni boshlash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> O'rnatish</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Taxmin qilish o'yinini dasturlash</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Umumiy dasturlash tushunchalari</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> O'zgaruvchilar va o'zgaruvchanlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Ma'lumotlar turlari</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funksiyalar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Izohlar</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html" class="active"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Ownershipni tushunish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership nima?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencelar va  Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slice turi</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Tegishli ma'lumotlarni tuzish uchun Structdan foydalanish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Structlarni aniqlash va yaratish</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Structs yordamida namunaviy dastur</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod sintaksisi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumlar va patternlarni moslashtirish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumni aniqlash</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Control Flow konstruksiyasi</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let bilan qisqacha Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> O'sib borayotgan loyihalarni Paketlar, Cratelar va Modullar bilan boshqarish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketlar va Cratelar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Qo'llanish doirasi va maxfiylikni nazorat qilish uchun modullarni aniqlash</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modul daraxtidagi elementga murojaat qilish yo'llari</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use kalit so'zi bilan yo'llarni qamrab olish</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modullarni turli fayllarga ajratish</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Umumiy to'plamlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectorlar bilan qiymatlar ro'yxatini saqlash</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 kodlangan matnni Stringlar bilan saqlash</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Mapda bog'langan qiymatlarga ega kalitlarni saqlash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Xatolar bilan ishlash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! bilan tuzatib bo'lmaydigan xatolar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result bilan tiklanadigan xatolar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! yoki panic! emas</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Umumiy turlar, traitlar va lifetime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generik ma'lumotlar turlari</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traitlar: umumiy xatti-harakatni aniqlash</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referencelarni lifetime bilan tekshirish</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Avtomatlashtirilgan testlarni yozish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testlarni qanday yozish kerak</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Sinovlar qanday o'tkazilishini nazorat qilish</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test tashkil etish</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O loyihasi: Buyruqlar qatori dasturini yaratish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Buyruqlar qatori argumentini qabul qilishs</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Faylni o'qish</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modullikni yaxshilash va xatolarni qayta ishlash uchun refactoring</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Sinovga asoslangan ishlab chiqish bilan kutubxonaning funksionalligini rivojlantirish</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Environment o'zgaruvchilari bilan ishlash</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Xato xabarlarini standart chiqish o'rniga standart xatoga yozish</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funksional til xususiyatlari: iteratorlar va closurelar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closurelar: Environmentni qamrab oladigan anonim funksiyalar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iteratorlar bilan bir qator elementlarga ishlov berish</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O loyihamizni takomillashtirish</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Ishlash samaradorligini solishtirish: Looplar va iteratorlar</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo va Crates.io haqida ko'proq</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Reliz profillari bilan structlarni moslashtirish</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crateni Crates.io-ga nashr qilish</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspacelar</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Binary fayllarni Crates.io'dan cargo install bilan o'rnatish</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Maxsus buyruqlar bilan Cargoni kengaytirish</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointerlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Heapdagi ma'lumotlarni ko'rsatish uchun Box&lt;T&gt; dan foydalanish</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Traitidan foydalangan holda oddiy referencelar kabi Smart Pointerlar bilan ishlash</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Traiti bilan tozalashda kodni ishga tushirish</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, reference hisoblangan Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; va ichki o'zgaruvchanlik namunasi</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Qo'rqmas parallellik</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodni bir vaqtning o'zida ishga tushirish uchun threadlardan foydalanish</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Threadlar orasidagi ma'lumotlarni uzatish uchun xabar uzatishdan(Message Passing) foydalanish</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync va Send traitlari bilan kengaytiriladigan parallellik</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustning ob'ektga yo'naltirilgan dasturlash xususiyatlari- OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Ob'ektga yo'naltirilgan tillarning xususiyatlari</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Har xil turdagi qiymatlarga ruxsat beruvchi trait ob'ektlaridan foydalanish</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ob'ektga yo'naltirilgan dizayn patternini implement qilish</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patternlar va Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Sintaksisi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Kengaytirilgan Xususiyatlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Xavfsiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Murakkab Traitlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Kengaytirilgan Turlar</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Kengaytirilgan funksiyalar va closurelar</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Yakuniy loyiha: Ko'p tarmoqli veb-serverni qurish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Yagona tarmoqli veb-serverni qurish</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Bizning yagona tarmoqli serverimizni ko'p tarmoqli serverga aylantirish</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Ajoyib o'chirish va tozalash</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ilova</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Kalit so'zlar</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatorlar va Symbollar</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Hosilaviy Traitlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Foydali Development Toollar</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Nashrlar</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitobning tarjimalari</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust qanday yasaladi va “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust dasturlash tili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-uz/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Shartning <code>true</code> yoki yo'qligiga qarab ba'zi kodlarni ishga tushirish va shart <code>true</code> bo'lganda ba'zi kodlarni qayta-qayta ishga tushirish qobiliyati ko'pchilik dasturlash tillarida asosiy building bloklari hisoblanadi. Rust kodining bajarilishini nazorat qilish imkonini beruvchi eng keng tarqalgan konstruksiyalar <code>if</code> expressionlari va looplaridir.</p>
<h3 id="if-ifodalari"><a class="header" href="#if-ifodalari"><code>if</code> ifodalari</a></h3>
<p><code>if</code> ifodasi shartlarga qarab kodingizni branchga ajratish imkonini beradi. Siz shartni taqdim etasiz va keyin shunday deb aytasiz: “Agar bu shart bajarilsa, ushbu kod blokini ishga tushiring. Agar shart bajarilmasa, ushbu kod blokini ishga tushirmang.&quot;</p>
<p><code>If</code> ifodasini oʻrganish uchun <em>loyihalar</em> jildingizda <em>branchlar</em> nomli yangi loyiha yarating. <em>src/main.rs</em> faylida quyidagilarni kiriting:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqam = 3;

    if raqam &lt; 5 {
        println!(&quot;shart true edi&quot;);
    } else {
        println!(&quot;shart true edi&quot;);
    }
}</code></pre></pre>
<p>Barcha <code>if</code> expressionlari <code>if</code> kalit so‘zidan boshlanadi, undan keyin shart keladi. Bunday holda, shart <code>raqam</code> o'zgaruvchisi 5 dan kichik qiymatga ega yoki yo'qligini tekshiradi. Agar shart <code>true</code> bo'lsa, biz kod blokini shartdan keyin darhol jingalak qavslar ichiga joylashtiramiz.
<code>if</code> expressionlaridagi shartlar bilan bog‘langan kod bloklari ba’zan <em>arms</em> deb ataladi, xuddi biz 2-bobning <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Tahminni maxfiy raqam bilan solishtirish”</a><!--ignore --> bo‘limida muhokama qilgan <code>match</code> expressionlaridagi qurollar kabi.</p>
<p>Ixtiyoriy ravishda, agar shart <code>false</code> deb baholansa, dasturga bajarilishi uchun muqobil kod blokini berish uchun biz tanlagan <code>else</code> expressionini ham kiritishimiz mumkin. Agar <code>else</code> ifodasini bermasangiz va shart <code>false</code> bo‘lsa, dastur shunchaki <code>if</code> blokini o‘tkazib yuboradi va kodning keyingi bitiga o‘tadi.</p>
<p>Ushbu kodni ishga tushirishga harakat qiling; quyidagi chiqishni ko'rishingiz kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branchlar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branchlar`
shart true edi
</code></pre>
<p>Keling, nima sodir bo'lishini ko'rish uchun <code>raqam</code> qiymatini shartni <code>false</code> qiladigan qiymatga o'zgartirib ko'raylik:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let raqam = 7;
<span class="boring">
</span><span class="boring">    if raqam &lt; 5 {
</span><span class="boring">        println!(&quot;shart true edi&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;shart false edi&quot;);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Dasturni qayta ishga tushiring va natijaga qarang:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
shart false edi
</code></pre>
<p>Shuni ham ta'kidlash kerakki, ushbu koddagi shart <code>bool</code> bo'lishi kerak. Agar shart <code>bool</code> bo'lmasa, biz xatoga yo'l qo'yamiz. Masalan, quyidagi kodni ishga tushirishga harakat qiling:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let raqam = 3;

    if raqam {
        println!(&quot;raqam uchta edi&quot;);
    }
}</code></pre>
<p><code>if</code> sharti bu safar <code>3</code> qiymatiga teng bo'ladi va Rust xato qiladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if raqam {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Xato shuni ko'rsatadiki, Rust <code>bool</code> kutgan, lekin integer(butun) son olgan. Ruby va JavaScript kabi tillardan farqli o'laroq, Rust boolean bo'lmagan turlarni boolean tilga o'zgartirishga avtomatik ravishda urinmaydi. Siz aniq bo'lishingiz va har doim <code>if</code> ni mantiqiy shart sifatida ko'rsatishingiz kerak. Agar biz <code>if</code> kod bloki faqat raqam <code>0</code> ga teng bo‘lmaganda ishlashini istasak, masalan, <code>if</code> ifodasini quyidagiga o‘zgartirishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqam = 3;

    if raqam != 0 {
        println!(&quot;raqam noldan boshqa narsa edi&quot;);
    }
}</code></pre></pre>
<p>Ushbu kodni ishga tushirish <code>raqam noldan boshqa narsa edi</code> chop etiladi.</p>
<h4 id="else-if-bilan-bir-nechta-shartlarni-boshqarish"><a class="header" href="#else-if-bilan-bir-nechta-shartlarni-boshqarish"><code>else if</code> bilan bir nechta shartlarni boshqarish</a></h4>
<p><code>if</code> va <code>else</code> ni <code>else if</code> ifodasida birlashtirib, bir nechta shartlardan foydalanishingiz mumkin.Misol uchun:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqam = 6;

    if raqam % 4 == 0 {
        println!(&quot;raqam 4 ga bo'linadi&quot;);
    } else if raqam % 3 == 0 {
        println!(&quot;raqam 3 ga bo'linadi&quot;);
    } else if raqam % 2 == 0 {
        println!(&quot;raqam 2 ga bo'linadi&quot;);
    } else {
        println!(&quot;raqam 4, 3 yoki 2 ga bo'linmaydi&quot;);
    }
}</code></pre></pre>
<p>Ushbu dasturda to'rtta yo'l bor. Uni ishga tushirgandan so'ng siz quyidagi chiqishni ko'rishingiz kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
raqam 3 ga bo'linadi
</code></pre>
<p>Ushbu dastur bajarilganda, u har bir <code>if</code> expressionni navbatma-navbat tekshiradi va shart <code>true</code> deb baholanadigan birinchi tanani bajaradi. E'tibor bering 6, 2 ga bo'linsa ham, biz <code>son 2 ga bo'linmaydi</code> chiqishini ko'rmayapmiz va <code>else</code> blokidagi <code>raqam 4, 3 yoki 2 ga bo'linmaydi</code> matnini ko'rmaymiz.Buning sababi, Rust faqat birinchi <code>true</code> shart uchun blokni bajaradi va bir marta topilsa, qolganlarini ham tekshirmaydi.
Juda ko'p <code>else if</code> expressionlaridan foydalanish kodingizni buzishi mumkin, shuning uchun sizda bir nechta bo'lsa, kodingizni qayta tahrirlashni xohlashingiz mumkin. 6-bobda bu holatlar uchun <code>match</code> deb nomlangan kuchli Rust tarmoqli konstruksiyasi tasvirlangan.</p>
<h4 id="let-statementida-if-dan-foydalanish"><a class="header" href="#let-statementida-if-dan-foydalanish"><code>let</code> statementida <code>if</code> dan foydalanish</a></h4>
<p><code>if</code> expression bo‘lganligi sababli, biz 3-2-listdagi kabi natijani o‘zgaruvchiga belgilash uchun <code>let</code> statementining o‘ng tomonida foydalanishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let shart = true;
    let raqam = if shart { 5 } else { 6 };

    println!(&quot;Raqamning qiymati: {raqam}&quot;);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-2: <code>if</code> expressioni natijasini o‘zgaruvchiga tayinlash</span></p>
<p><code>raqam</code> o'zgaruvchisi <code>if</code> expressioni natijasiga asoslangan qiymatga bog'lanadi. Nima sodir bo'lishini ko'rish uchun ushbu kodni ishga tushiring:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
Raqamning qiymati: 5
</code></pre>
<p>Esda tutingki, kod bloklari ulardagi oxirgi expressiongacha evaluate qilianadi va raqamlar o'zlari ham expressionlardir. Bu holda butun <code>if</code> expressionning qiymati qaysi kod bloki bajarilishiga bog'liq. Bu <code>if</code> ning har bir armidan result bo'lish potentsialiga ega bo'lgan qiymatlar bir xil turdagi bo'lishi kerakligini anglatadi; 3-2 ro'yxatda <code>if</code> va <code>else</code> armllarining natijalari <code>i32</code> butun sonlari edi. Agar turlar mos kelmasa(mismatched), quyidagi misolda bo'lgani kabi, biz xatoga duch kelamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let shart = true;

    let raqam = if shart { 5 } else { &quot;olti&quot; };

    println!(&quot;Raqamning qiymati: {raqam}&quot;);
}</code></pre>
<p>Ushbu kodni kompilyatsiya qilmoqchi bo'lganimizda, biz xatoga duch kelamiz. <code>if</code> va <code>else</code> armllari mos kelmaydigan qiymat turlariga ega va Rust muammoni dasturda qayerdan topish mumkinligini aniq ko'rsatadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let raqam = if shart { 5 } else { &quot;olti&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p><code>if</code> blokidagi expression butun songa, <code>else</code> blokidagi expression esa satrga baholanadi. Bu ishlamaydi, chunki oʻzgaruvchilar bitta turga ega boʻlishi kerak va Rust kompilyatsiya vaqtida <code>raqam</code> oʻzgaruvchisi qaysi turini aniq bilishi kerak. <code>raqam</code> turini bilish kompilyatorga ushbu tur biz <code>raqam</code> ishlatadigan hamma joyda yaroqliligini tekshirish imkonini beradi. Agar <code>raqam</code> turi faqat runtimeda aniqlangan bo'lsa, Rust buni qila olmaydi; kompilyator murakkabroq bo'lar edi va agar u har qanday o'zgaruvchi uchun bir nechta gipotetik turlarni kuzatib borishi kerak bo'lsa, kod haqida kamroq kafolatlar beradi.</p>
<h3 id="looplar-bilan-takrorlash"><a class="header" href="#looplar-bilan-takrorlash">Looplar bilan takrorlash</a></h3>
<p>Ko'pincha kod blokini bir necha marta bajarish foydali bo'ladi. Ushbu vazifani bajarish uchun Rust bir nechta <em>looplarni</em> taqdim etadi, ular sikl tanasi ichidagi kod orqali oxirigacha ishlaydi va keyin darhol boshida boshlanadi. Looplar bilan tajriba o'tkazish uchun keling, <em>looplar</em> deb nomlangan yangi loyiha yarataylik.</p>
<p>Rustda uch xil looplar mavjud: <code>loop</code>, <code>while</code> va <code>for</code>. Keling, har birini sinab ko'raylik.</p>
<h4 id="kodni-loop-bilan-takrorlash"><a class="header" href="#kodni-loop-bilan-takrorlash">Kodni <code>loop</code> bilan takrorlash</a></h4>
<p><code>loop</code> kalit so'zi Rustga kod blokini abadiy qayta-qayta bajarishni yoki uni to'xtatishni aniq aytmaguningizcha bajarishni aytadi.</p>
<p>Misol tariqasida, <em>looplar</em> jildingizdagi <em>src/main.rs</em> faylini quyidagicha o'zgartiring:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;yana!&quot;);
    }
}</code></pre>
<p>Ushbu dasturni ishga tushirganimizda, dasturni qo'lda to'xtatmagunimizcha, <code>yana!</code> so'zi doimiy ravishda chop etilishini ko'ramiz.Aksariyat terminallar uzluksiz siklda ishlab qolgan dasturni to'xtatish uchun <span class="keystroke">ctrl-c</span>  klaviatura yorliqlarini qo'llab-quvvatlaydi.
Sinab ko'ring:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/looplar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/looplar`
yana!
yana!
yana!
yana!
^Cyana!
</code></pre>
<p><code>^C</code> belgisi <span class="keystroke">ctrl-c</span> tugmalarini bosgan joyni bildiradi. Kod uzilish signalini qabul qilganda siklning qayerda bo'lganiga qarab, <code>^C</code> dan keyin chop etilgan <code>yana!</code> so'zini ko'rishingiz yoki ko'rmasligingiz mumkin.</p>
<p>Yaxshiyamki, Rust kod yordamida loopdan chiqish yo'lini ham taqdim etadi. Siz dasturga siklni bajarishni qachon to'xtatish kerakligini aytish uchun <code>break</code> kalit so'zini siklga qo'yishingiz mumkin. 
Eslatib o'tamiz, biz buni 2-bobning <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">”To'g'ri taxmindan keyin chiqish”</a><!-- ignore --> bo'limidagi taxminiy o'yinda, foydalanuvchi to'g'ri raqamni taxmin qilish orqali o'yinda g'alaba qozonganida dasturdan chiqish uchun qilganmiz.</p>
<p>Shuningdek, biz taxmin qilish o'yinida <code>continue</code> dan foydalandik, bu siklda dasturga siklning ushbu iteratsiyasida qolgan har qanday kodni o'tkazib yuborish va keyingi iteratsiyaga o'tishni aytadi.</p>
<h4 id="looplardan-qiymatlarni-qaytarishreturn"><a class="header" href="#looplardan-qiymatlarni-qaytarishreturn">Looplardan qiymatlarni qaytarish(return)</a></h4>
<p><code>loop</code> dan foydalanishdan biri bu ish bajarilmasligi mumkin bo'lgan operatsiyani qaytadan urinish, masalan, thread o'z ishini tugatganligini tekshirish. Bundan tashqari, ushbu operatsiya natijasini kodingizning qolgan qismiga sikldan o'tkazishingiz kerak bo'lishi mumkin. Buning uchun siklni toʻxtatish uchun foydalanadigan <code>break</code> ifodasidan keyin return qilinishi kerak boʻlgan qiymatni qoʻshishingiz mumkin; bu qiymat loopdan qaytariladi, shuning uchun uni bu yerda ko'rsatilganidek ishlatishingiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut hisoblagich = 0;

    let natija = loop {
        hisoblagich += 1;

        if hisoblagich == 10 {
            break hisoblagich * 2;
        }
    };

    println!(&quot;Natija: {natija}&quot;);
}</code></pre></pre>
<p>Loopdan oldin biz <code>hisoblagich</code> nomli o‘zgaruvchini e’lon qilamiz va uni <code>0</code> ga ishga tushiramiz. Keyin sikldan qaytarilgan qiymatni ushlab turish uchun <code>natija</code> nomli o'zgaruvchini e'lon qilamiz. Loopning har bir iteratsiyasida biz <code>hisoblagich</code> o‘zgaruvchisiga <code>1</code> qo‘shamiz va keyin <code>hisoblagich</code> 10 ga teng yoki yo‘qligini tekshiramiz. Bu bo'lganda, biz <code>hisoblagich * 2</code> qiymati bilan <code>break</code> kalit so'zidan foydalanamiz. Loopdan so'ng biz <code>natija</code> qiymatini belgilaydigan statementni tugatish uchun nuqta-verguldan foydalanamiz. Nihoyat, biz qiymatni <code>natija</code>da chop qilamiz, bu holda <code>20</code>.</p>
<h4 id="bir-nechta-looplar-orasidagi-farqni-ajratish-uchun-loop-labellari"><a class="header" href="#bir-nechta-looplar-orasidagi-farqni-ajratish-uchun-loop-labellari">Bir nechta looplar orasidagi farqni ajratish uchun loop labellari</a></h4>
<p>Agar sizda looplar ichida looplaringiz bo'lsa, o'sha nuqtada eng ichki loopga <code>break</code> va <code>continue</code> amallari qo'llaniladi. Siz ixtiyoriy ravishda siklda <em>loop label</em> belgilashingiz mumkin, undan so‘ng <code>break</code> yoki  <code>continue</code> bilan o‘sha kalit so‘zlar eng ichki loop o‘rniga belgilangan loopga qo‘llanilishini belgilashingiz mumkin. Loop labellari bitta tirnoqcha bilan boshlanishi kerak. Mana ikkita ichki loop bilan bir misol:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut hisob = 0;
    'hisoblash: loop {
        println!(&quot;hisob = {hisob}&quot;);
        let mut qolgan = 10;

        loop {
            println!(&quot;qolgan = {qolgan}&quot;);
            if qolgan == 9 {
                break;
            }
            if hisob == 2 {
                break 'hisoblash;
            }
            qolgan -= 1;
        }

        hisob += 1;
    }
    println!(&quot;Yakuniy hisob = {hisob}&quot;);
}</code></pre></pre>
<p>Tashqi loopda <code>'hisoblash</code> labeli bor va u 0 dan 2 gacha hisoblanadi.
Labelsiz ichki loop 10 dan 9 gacha hisoblanadi. Label ko'rsatilmagan birinchi <code>break</code> faqat ichki sikldan chiqadi. <code>break 'hisoblash;</code> statementi tashqi sikldan chiqadi. Keling kodni run qilib ko'ramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
hisob = 0
qolgan = 10
qolgan = 9
hisob = 1
qolgan = 10
qolgan = 9
hisob = 2
qolgan = 10
Yakuniy hisob = 2
</code></pre>
<h4 id="while-bilan-shartli-looplar"><a class="header" href="#while-bilan-shartli-looplar"><code>while</code> bilan shartli looplar</a></h4>
<p>Dastur ko'pincha loop ichidagi shartni evaluate qilishi kerak bo'ladi. Shart <code>true</code> bo'lsa-da, loop ishlaydi. Shart <code>true</code> bo'lishni to'xtatganda, dastur loopni to'xtatib, <code>break</code> ni chaqiradi. Bu kabi xatti-harakatlarni <code>loop</code>, <code>if</code>, <code>else</code> va <code>break</code> kombinatsiyasidan foydalanib amalga oshirish mumkin; Agar xohlasangiz, buni hozir dasturda sinab ko'rishingiz mumkin. Biroq, bu pattern shunchalik keng tarqalganki, Rustda buning uchun <code>while</code> sikli deb ataladigan o'rnatilgan til konstruktsiyasi mavjud. 3-3 ro'yxatda biz dasturni uch marta aylanish uchun <code>while</code> dan foydalanamiz, har safar sanab chiqamiz, so'ngra sikldan so'ng xabarni chop etamiz va chiqamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut raqam = 3;

    while raqam != 0 {
        println!(&quot;{raqam}!&quot;);

        raqam -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-3: Shart to'g'ri bo'lganda kodni ishga tushirish uchun <code>while</code> siklidan foydalanish</span></p>
<p>Bu konstruksiya <code>loop</code>, <code>if</code>, <code>else</code> va <code>break</code> dan foydalansangiz, zarur bo'ladigan ko'plab joylashtirishlarni yo'q qiladi va bu aniqroq bo'ladi. Shart <code>true</code> deb baholansa, kod ishlaydi; aks holda, u loopdan chiqadi.</p>
<h4 id="for-bilan-toplam-boylab-aylanish"><a class="header" href="#for-bilan-toplam-boylab-aylanish"><code>for</code> bilan to'plam bo'ylab aylanish</a></h4>
<p>Siz <code>while</code> konstruksiyasidan array kabi to‘plam elementlari ustidan aylanishni tanlashingiz mumkin. Masalan, 3-4 ro'yxatdagi sikl <code>a</code> arrayidagi har bir elementni chop etadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;qiymati: {}&quot;, a[index]);

        index += 1;
    }
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-4: <code>while</code> sikli yordamida to‘plamning har bir elementi bo‘ylab aylanish</span></p>
<p>Bu erda kod arraydagi elementlar orqali hisoblanadi. U <code>0</code> indeksidan boshlanadi va keyin arraydagi yakuniy indeksga yetguncha (ya'ni, <code>index &lt; 5</code> endi <code>true</code> bo`lmaganda) sikl davom etadi. Ushbu kodni ishga tushirish arraydagi har bir elementni chop etadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling looplar v0.1.0 (file:///projects/looplar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/looplar`
qiymati: 10
qiymati: 20
qiymati: 30
qiymati: 40
qiymati: 50
</code></pre>
<p>Barcha besh array qiymatlari kutilganidek terminalda paydo bo'ladi. Garchi <code>index</code> bir nuqtada <code>5</code> qiymatiga yetsa ham, arraydan oltinchi qiymatni olishga urinishdan oldin sikl ishlashni to‘xtatadi.</p>
<p>Biroq, bu yondashuv xatoga moyil; Agar indeks qiymati yoki test holati noto'g'ri bo'lsa, biz dasturni panic qo'yishimiz mumkin. Misol uchun, agar siz <code>a</code> arrayining ta'rifini to'rtta elementga o'zgartirsangiz, lekin shartni <code>while index &lt; 4</code> bo'lganda yangilashni unutgan bo'lsangiz, kod panic qo'zg'atadi. Bu ham sekin, chunki kompilyator sikl orqali har bir iteratsiyada indeks array chegaralarida ekanligini shartli tekshirish uchun runtime kodini qo‘shadi.</p>
<p>Aniqroq variant sifatida, siz <code>for</code> siklidan foydalanishingiz va to'plamdagi har bir element uchun ba'zi kodlarni bajarishingiz mumkin. <code>for</code> sikli 3-5-ro'yxatdagi kodga o'xshaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;qiymati: {element}&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-5: <code>for</code> `sikli yordamida to'plamning har bir elementi bo'ylab aylanish</span></p>
<p>Ushbu kodni ishga tushirganimizda, biz 3-4 ro'yxatdagi kabi natijani ko'ramiz. Eng muhimi, biz kodning xavfsizligini oshirdik va arrayning oxiridan tashqariga chiqish yoki yetarlicha uzoqqa bormaslik va ba'zi elementlarni yetishmayotganligi sababli paydo bo'lishi mumkin bo'lgan xatolar ehtimolini yo'q qildik.</p>
<p><code>for</code> siklidan foydalanib, agar siz 3-4 roʻyxatda qoʻllanilgan metodda boʻlgani kabi arraydagi qiymatlar sonini oʻzgartirsangiz, boshqa kodni oʻzgartirishni eslab qolishingiz shart emas.</p>
<p><code>for</code> looplarining xavfsizligi va ixchamligi ularni Rustda eng ko‘p ishlatiladigan loop konstruksiyasiga aylantiradi. 3-3 ro'yxatdagi <code>while</code> siklidan foydalanilgan ortga hisoblash misolida bo'lgani kabi, ma'lum bir necha marta kodni ishlatmoqchi bo'lgan vaziyatlarda ham ko'pchilik Rustaceanlar <code>for</code> siklidan foydalanadilar. Buning yo'li standart kutubxona tomonidan taqdim etilgan <code>Range</code> dan foydalanish bo'lib, bir raqamdan boshlanib, boshqa raqamdan oldin tugaydigan barcha raqamlarni ketma-ketlikda hosil qiladi.</p>
<p>Ortga hisoblash <code>for</code> sikli va biz hali u to‘g‘risida gapirmagan boshqa metod – <code>rev</code> yordamida diapazonni teskari tomonga o‘zgartirishga o‘xshaydi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for raqam in (1..4).rev() {
        println!(&quot;{raqam}!&quot;);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p>Bu kod biroz chiroyliroq, shunday emasmi?</p>
<h2 id="xulosa"><a class="header" href="#xulosa">Xulosa</a></h2>
<p>Siz erishdingiz! Bu juda katta bob bo'ldi: siz o'zgaruvchilar, skalyar va compound ma'lumotlar turlari, funksiyalar, izohlar, <code>if</code> expressionlari va sikllar haqida bilib oldingiz! Ushbu bobda muhokama qilingan tushunchalar bilan mashq qilish uchun quyidagilarni amalga oshirish uchun dasturlar yaratishga harakat qiling:</p>
<ul>
<li>Haroratni Farengeyt va Selsiy o'rtasida o'zgartiring.</li>
<li><em>n</em>ta Fibonachchi raqamini yarating.</li>
<li>Qo'shiqning takrorlanishidan foydalanib, “Rojdestvoning o'n ikki kuni“ Rojdestvo qo'shig'ining so'zlarini chop eting.</li>
</ul>
<p>Davom etishga tayyor bo'lganingizda, Rustda boshqa dasturlash tillarida odatda mavjud bo'lmagan ownership(egalik) tushunchasi haqida gaplashamiz.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-04-comments.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-04-comments.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
