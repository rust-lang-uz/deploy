<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust dasturlash tili</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust dasturlash tili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Muqaddima</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Kirish</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Ishni boshlash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> O'rnatish</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Taxmin qilish o'yinini dasturlash</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Umumiy dasturlash tushunchalari</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> O'zgaruvchilar va o'zgaruvchanlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Ma'lumotlar turlari</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funksiyalar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Izohlar</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Ownershipni tushunish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership nima?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referencelar va  Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slice turi</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Tegishli ma'lumotlarni tuzish uchun Structdan foydalanish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Structlarni aniqlash va yaratish</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Structs yordamida namunaviy dastur</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod sintaksisi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumlar va patternlarni moslashtirish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumni aniqlash</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Control Flow konstruksiyasi</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let bilan qisqacha Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> O'sib borayotgan loyihalarni Paketlar, Cratelar va Modullar bilan boshqarish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketlar va Cratelar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Qo'llanish doirasi va maxfiylikni nazorat qilish uchun modullarni aniqlash</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modul daraxtidagi elementga murojaat qilish yo'llari</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use kalit so'zi bilan yo'llarni qamrab olish</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modullarni turli fayllarga ajratish</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Umumiy to'plamlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectorlar bilan qiymatlar ro'yxatini saqlash</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 kodlangan matnni Stringlar bilan saqlash</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Mapda bog'langan qiymatlarga ega kalitlarni saqlash</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Xatolar bilan ishlash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! bilan tuzatib bo'lmaydigan xatolar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result bilan tiklanadigan xatolar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! yoki panic! emas</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Umumiy turlar, traitlar va lifetime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generik ma'lumotlar turlari</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traitlar: umumiy xatti-harakatni aniqlash</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referencelarni lifetime bilan tekshirish</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Avtomatlashtirilgan testlarni yozish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testlarni qanday yozish kerak</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Sinovlar qanday o'tkazilishini nazorat qilish</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test tashkil etish</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O loyihasi: Buyruqlar qatori dasturini yaratish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Buyruqlar qatori argumentini qabul qilishs</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Faylni o'qish</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modullikni yaxshilash va xatolarni qayta ishlash uchun refactoring</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Sinovga asoslangan ishlab chiqish bilan kutubxonaning funksionalligini rivojlantirish</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Environment o'zgaruvchilari bilan ishlash</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Xato xabarlarini standart chiqish o'rniga standart xatoga yozish</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funksional til xususiyatlari: iteratorlar va closurelar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closurelar: Environmentni qamrab oladigan anonim funksiyalar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iteratorlar bilan bir qator elementlarga ishlov berish</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O loyihamizni takomillashtirish</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Ishlash samaradorligini solishtirish: Looplar va iteratorlar</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo va Crates.io haqida ko'proq</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Reliz profillari bilan structlarni moslashtirish</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crateni Crates.io-ga nashr qilish</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspacelar</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Binary fayllarni Crates.io'dan cargo install bilan o'rnatish</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Maxsus buyruqlar bilan Cargoni kengaytirish</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointerlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Heapdagi ma'lumotlarni ko'rsatish uchun Box&lt;T&gt; dan foydalanish</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref Traitidan foydalangan holda oddiy referencelar kabi Smart Pointerlar bilan ishlash</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Traiti bilan tozalashda kodni ishga tushirish</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, reference hisoblangan Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; va ichki o'zgaruvchanlik namunasi</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Qo'rqmas parallellik</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodni bir vaqtning o'zida ishga tushirish uchun threadlardan foydalanish</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Threadlar orasidagi ma'lumotlarni uzatish uchun Message Passing(xabar uzatish)dan foydalanish</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync va Send traitlari bilan kengaytiriladigan parallellik</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustning ob'ektga yo'naltirilgan dasturlash xususiyatlari- OOP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Ob'ektga yo'naltirilgan tillarning xususiyatlari</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Har xil turdagi qiymatlarga ruxsat beruvchi trait ob'ektlaridan foydalanish</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ob'ektga yo'naltirilgan dizayn patternini implement qilish</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patternlar va Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Sintaksisi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Kengaytirilgan Xususiyatlar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Xavfsiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Murakkab Traitlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Kengaytirilgan Turlar</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Kengaytirilgan funksiyalar va closurelar</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Yakuniy loyiha: Ko'p tarmoqli veb-serverni qurish</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Yagona tarmoqli veb-serverni qurish</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Bizning yagona tarmoqli serverimizni ko'p tarmoqli serverga aylantirish</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Ajoyib o'chirish va tozalash</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Ilova</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Kalit so'zlar</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatorlar va Symbollar</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Hosilaviy Traitlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Foydali Development Toollar</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Nashrlar</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitobning tarjimalari</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust qanday yasaladi va ‚ÄúNightly Rust‚Äù</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust dasturlash tili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-uz/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-dasturlash-tili"><a class="header" href="#rust-dasturlash-tili">Rust dasturlash tili</a></h1>
<p><em>Steve Klabnik va Carol Nicholsning, Rust hamjamiyatining hissasi bilan</em></p>
<p>Kitobning ushbu versiyasi siz Rust 1.67.1 (2023-02-09-da chiqarilgan) yoki undan keyingi versiyasidan foydalanayotganingizni taxmin qiladi. Rustni o'rnatish yoki yangilash uchun 1-bobning <a href="ch01-01-installation.html">‚ÄùO'rnatish‚Äù bo'limiga</a><!-- ignore --> qarang.</p>
<p>HTML formati <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> saytida va oflayn rejimda <code>rustup</code> bilan qilingan Rust o'rnatishlari mavjud; ochish uchun <code>rustup docs --book</code> ni ishga tushiring.</p>
<p>Bir nechta hamjamiyat <a href="appendix-06-translation.html">tarjimalari</a> ham mavjud.</p>
<p>Ushbu kitob qog'oz va elektron <a href="https://nostarch.com/rust-programming-language-2nd-edition">kitob formatida No Starch Press</a> nashrida mavjud.</p>
<blockquote>
<p><strong>üö® Ko'proq interaktiv o'rganishni xohlaysizmi? Rust Bookning boshqa
versiyasini sinab ko ªring: viktorinalar, alohida chizilgan belgilashlar, vizualizatsiya
va boshqalar</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="muqaddima"><a class="header" href="#muqaddima">Muqaddima</a></h1>
<p>Bu har doim ham unchalik aniq bo'lmagan, lekin Rust dasturlash tili asosan imkoniyatlarni kengaytirishga qaratilgan: hozir qanday kod yozayotganingizdan qat'iy nazar, Rust sizga oldinga qaraganda kengroq domenlarda ishonch bilan dasturlash imkonini beradi.</p>
<p>Masalan, memory managementning low-leveldagi tafsilotlari, ma'lumotlarni taqdim etish va parallellik bilan shug'ullanadigan &quot;systems-leveldagi&quot; ishni olaylik. An'anaga ko'ra, dasturlashning bu sohasi sirli bo'lib ko'rinadi, unga faqat o'zining dahshatli tuzoqlaridan qochish uchun zarur yillarini o'rganishga bag'ishlagan tanlanganlargina foydalanishi mumkin. Va hatto buni amalda qo'llayotganlar ham, ularning kodi ekspluatatsiyalar, buzilishlar yoki korruptsiyaga ochiq bo'lmasligi uchun buni ehtiyotkorlik bilan bajaradilar.</p>
<p>Rust eski tuzoqlarni yo'q qilish va sizga yordam berish uchun do'stona, sayqallangan vositalar to'plamini taqdim etish orqali bu to'siqlarni yo'q qiladi. Low-leveldagi boshqaruvga ‚Äùpastga tushishi‚Äù kerak bo'lgan dasturchilar buni Rust bilan odatiy holga tushib qolish xavfi yoki xavfsizlik teshiklarisiz va o'zgaruvchan toolchainning nozik tomonlarini o'rganmasdan amalga oshirishlari mumkin. Yaxshisi, bu til sizni tabiiy ravishda tezlik va xotiradan foydalanish jihatidan samarali bo'lgan ishonchli kodga yo'naltirish uchun mo'ljallangan.</p>
<p>Low leveldagi kod bilan ishlayotgan dasturchilar o'zlarining bilimlarini oshirish uchun Rust-dan foydalanishlari mumkin. Masalan, Rust-da parallelizmni joriy qilish nisbatan low-riskli operatsiya: kompilyator siz uchun klassik xatolarni aniqlaydi. Va siz tasodifan nosozliklar yoki zaifliklarni kiritmasligingizga ishonch bilan kodingizdagi yanada tajovuzkor optimallashtirishlarni hal qilishingiz mumkin.</p>
<p>Ammo Rust low-leveldagi tizimlarni dasturlash bilan cheklanmaydi. Bu CLI ilovalari, veb-serverlar va boshqa ko'plab turdagi kodlarni yozishni juda yoqimli qilish uchun yetarlicha ifodali va samarador - siz ikkalasining oddiy misollarini keyinroq kitobda topasiz. Rust bilan ishlash sizga bir domendan boshqasiga o'tadigan ko'nikmalarni shakllantirish imkonini beradi; veb-ilovani yozish orqali Rustni o'rganishingiz mumkin, so'ngra Raspberry Pi-ni nishonga olish uchun xuddi shu ko'nikmalarni qo'llashingiz mumkin.</p>
<p>Ushbu kitob o'z foydalanuvchilarini kuchaytirish uchun Rust imkoniyatlarini to'liq qamrab oladi. Bu sizga nafaqat Rust haqidagi bilimingizni, balki umuman dasturchi sifatidagi ishonchingizni oshirishga yordam beradigan samimiy va qulay kitob. Shunday qilib, sho'ng'ing, o'rganishga tayyor bo'ling va Rust hamjamiyatiga xush kelibsiz!</p>
<p>‚Äî Nicholas Matsakis va Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kirish"><a class="header" href="#kirish">Kirish</a></h1>
<blockquote>
<p>Eslatma: Kitobning ushbu nashri <a href="https://nostarch.com/">No Starch Press</a>-dan bosma va elektron kitob formatida mavjud bo'lgan
<a href="https://nostarch.com/rust-programming-language-2nd-edition">Rust dasturlash tili</a> bilan bir xil.</p>
</blockquote>
<p><em>Rust dasturlash tili</em>ga xush kelibsiz, Rust haqida kirish kitobi.
Rust dasturlash tili tezroq va ishonchli dasturlarni yozishga yordam beradi.
Yuqori darajadagi samaradorlik va low-leveldagi boshqaruv ko'pincha dasturlash tilini loyihalashda bir-biriga zid keladi; Rust bu ziddiyatga qarshi turadi. Kuchli texnik imkoniyatlar va ishlab chiquvchilarning ajoyib tajribasini muvozanatlash orqali Rust sizga an'anaviy ravishda bunday nazorat bilan bog'liq bo'lgan barcha qiyinchiliklarsiz low-leveldagi tafsilotlarni (masalan, xotiradan foydalanish) boshqarish imkoniyatini beradi.</p>
<h2 id="rust-kim-uchun"><a class="header" href="#rust-kim-uchun">Rust kim uchun</a></h2>
<p>Rust turli sabablarga ko'ra ko'p odamlar uchun idealdir. Keling, eng muhim guruhlarning bir nechtasini ko'rib chiqaylik.</p>
<h3 id="dasturchilar-jamoalari"><a class="header" href="#dasturchilar-jamoalari">Dasturchilar jamoalari</a></h3>
<p>Rust turli darajadagi tizimlarni dasturlash bo'yicha bilimga ega bo'lgan yirik ishlab chiquvchilar guruhlari o'rtasida hamkorlik qilish uchun samarali vosita ekanligini isbotlamoqda. Low-leveldagi kod turli xil nozik xatolarga moyil bo'lib, ko'pchilik boshqa tillarda ularni faqat keng ko'lamli sinov va tajribali ishlab chiquvchilar tomonidan sinchkovlik bilan tekshirish orqali aniqlash mumkin.Rust-da kompilyator ushbu qiyin xatolar, jumladan, parallellik xatolari bilan kodni kompilyatsiya qilishni rad etib, darvozabon rolini o'ynaydi. Kompilyator bilan birga ishlash orqali jamoa xatolarni ta'qib qilishdan ko'ra, vaqtini dastur mantig'iga qaratishga sarflashi mumkin.</p>
<p>Rust shuningdek, tizim dasturlash dunyosiga zamonaviy ishlab chiquvchilar vositalarini olib keladi:</p>
<ul>
<li>Cargo  dependency menejeri va build toolni o'z ichiga oladi, Rust ekotizimida bog'liqliklarni qo'shish, kompilyatsiya qilish va boshqarishni qiyinchiliksiz va davomli qiladi.</li>
<li>Rustfmt formatlash vositasi ishlab chiquvchilar orasida barqaror kodlash uslubini ta'minlaydi.</li>
<li>Rust Language Server kodni to ªldirish va inline xato xabarlari uchun Integrated Development Environment (IDE) integratsiyasini quvvatlaydi.</li>
</ul>
<p>Rust ekotizimidagi ushbu va boshqa vositalardan foydalangan holda, ishlab chiquvchilar tizim darajasidagi kodni yozishda samarali bo'lishi mumkin.</p>
<h3 id="talabalar"><a class="header" href="#talabalar">Talabalar</a></h3>
<p>Rust talabalar va tizim tushunchalarini o'rganishga qiziquvchilar uchun. Rust-dan foydalanib, ko'p odamlar operatsion tizimlarni ishlab chiqish kabi mavzular haqida bilib oldilar. Jamiyat juda mehmondo'st va talabalar savollariga javob berishdan xursand. Ushbu kitob kabi sa'y-harakatlar orqali Rust guruhlari tizim tushunchalarini ko'proq odamlar, ayniqsa dasturlash uchun yangi bo'lganlar uchun qulayroq qilishni xohlashadi.</p>
<h3 id="kompaniyalar"><a class="header" href="#kompaniyalar">Kompaniyalar</a></h3>
<p>Yuzlab yirik va kichik kompaniyalar ishlab chiqarishda Rust-dan CLI dasturlar, veb-xizmatlar, DevOps toollari, embedded qurilmalar, audio va video tahlillari va transkodlar, kriptovalyutalar, bioinformatika, qidiruv tizimlari, Internet of Things ilovalari kabi turli vazifalar uchun foydalanadilar. , machine learning va hatto Firefox veb-brauzerining asosiy qismlari.</p>
<h3 id="open-source-dasturchilar"><a class="header" href="#open-source-dasturchilar">Open Source dasturchilar</a></h3>
<p>Rust Rust dasturlash tilini, hamjamiyatini, ishlab chiquvchilar vositalarini va kutubxonalarini yaratmoqchi bo'lgan odamlar uchundir. Rust tiliga o'z hissangizni qo'shishingizni istardik.</p>
<h3 id="tezlik-va-barqarorlikni-qadrlaydigan-odamlar"><a class="header" href="#tezlik-va-barqarorlikni-qadrlaydigan-odamlar">Tezlik va barqarorlikni qadrlaydigan odamlar</a></h3>
<p>Rust dasturlash tili tezlik va barqarorlikni xohlaydigan odamlar uchundir. Tezlik deganda biz Rust kodi qanchalik tez ishlashini va Rust sizga dasturlar yozish imkonini beradigan tezligini nazarda tutamiz. Rust kompilyatorining tekshiruvlari qo'shimcha funksiyalar va refaktoring orqali barqarorlikni ta'minlaydi. Bu ishlab chiquvchilar ko'pincha o'zgartirishdan qo'rqadigan ushbu tekshiruvlarsiz tillardagi mo'rt eski koddan farqli o'laroq. Nol xarajatli abstraktsiyalarga, qo'lda yozilgan kod kabi tezroq lower-leveldagi kodni kompilyatsiya qiladigan higher-leveldagi funktsiyalarga intilish orqali Rust xavfsiz kodni ham tezkor kod qilishga intiladi.</p>
<p>Rust tili boshqa ko'plab foydalanuvchilarni ham qo'llab-quvvatlashga umid qiladi; Bu yerda tilga olinganlar faqat eng katta manfaatdor tomonlardan biri hisoblanadi. Umuman olganda, Rustning eng katta ambitsiyalari xavfsizlik <em>va</em> unumdorlik, tezlik <em>va</em> samaradorlikni ta'minlash orqali dasturchilar o'nlab yillar davomida qabul qilgan kelishuvlarni yo'q qilishdir. Rust-ni sinab ko'ring va uning tanlovlari sizga mos keladimi yoki yo'qligini tekshiring.</p>
<h2 id="bu-kitob-kim-uchun"><a class="header" href="#bu-kitob-kim-uchun">Bu kitob kim uchun</a></h2>
<p>Ushbu kitobda siz boshqa dasturlash tilida kod yozgansiz deb taxmin qilinadi, lekin qaysi biri haqida hech qanday taxminlar yo'q. Biz materialni turli xil dasturlash tajribasiga ega bo'lganlar uchun keng foydalanishga harakat qildik. Biz dasturlash nima ekanligi yoki u haqida qanday fikr yuritish haqida gapirishga ko'p vaqt sarflamaymiz. Agar siz dasturlashda mutlaqo yangi bo'lsangiz, dasturlash bilan tanishishni ta'minlaydigan kitobni o'qisangiz yaxshi bo'lardi.</p>
<h2 id="ushbu-kitobdan-qanday-foydalanish-kerak"><a class="header" href="#ushbu-kitobdan-qanday-foydalanish-kerak">Ushbu kitobdan qanday foydalanish kerak</a></h2>
<p>Umuman olganda, bu kitob siz uni oldindan orqaga ketma-ket o'qiyotganingizni taxmin qiladi. Keyingi boblar oldingi boblardagi tushunchalarga asoslanadi va oldingi boblar ma'lum bir mavzu bo'yicha tafsilotlarni o'rganmasligi mumkin, lekin keyingi bobda mavzuni qayta ko'rib chiqadi.</p>
<p>Ushbu kitobda siz ikki xil bo'limni topasiz: kontseptsiya bo'limlari va loyiha bo'limlari. Kontseptsiya boblarida siz Rustning bir tomoni haqida bilib olasiz. Loyiha bo'limlarida biz hozirgacha o'rganganlaringizni qo'llagan holda kichik dasturlarni birgalikda tuzamiz. 2, 12 va 20-boblar loyiha boblari; qolganlari kontseptsiya boblari.</p>
<p>1-bobda Rustni qanday o'rnatish, &quot;Hello, world!&quot; dasturi va Cargo, Rust paket menejeri va build tooldan qanday foydalanishni ko'rib chiqamiz. 2-bob Rustda dastur yozish bo'yicha amaliy kirish bo'lib, siz raqamlarni taxmin qilish o'yinini tuzasiz. Bu yerda biz tushunchalarni yuqori darajada yoritamiz va keyingi boblarda qo'shimcha tafsilotlar beriladi. Agar siz darhol qo'llaringizni ifloslantirmoqchi bo'lsangiz, 2-bob buning uchun joy. 3-bobda boshqa dasturlash tillariga o ªxshash Rust funksiyalari yoritilgan va 4-bobda siz Rustning ownershp tizimi haqida bilib olasiz. Agar siz keyingisiga o‚Äòtishdan oldin har bir tafsilotni o‚Äòrganishni ma‚Äôqul ko‚Äòradigan, ayniqsa sinchkov o‚Äòquvchi bo‚Äòlsangiz, 2-bobni o‚Äòtkazib yuborib, to‚Äòg‚Äòridan-to‚Äòg‚Äòri 3-bobga o‚Äòtishingiz va loyiha ustida ishlashni hohlaganingizda 2-bobga qaytishingiz mumkin. siz o'rgangan tafsilotlar.</p>
<p>5-bobda structlar va metodlar muhokama qilinadi, 6-bob esa enumlar, <code>match</code> expressionlari va <code>if let</code> control flow konstruksiyasini qamrab oladi. Rust-da maxsus turlarni yaratish uchun struclar va enumlardan foydalanasiz.</p>
<p>7-bobda siz Rust modul tizimi va kodingizni va uning umumiy amaliy dasturlash interfeysini (API) tashkil qilish uchun maxfiylik qoidalari haqida bilib olasiz. 8-bobda standart kutubxona taqdim etadigan vektorlar, stringlar va hash maplar kabi umumiy yig'ish ma'lumotlar tuzilmalari muhokama qilinadi. 9-bob Rustning xatolarni hal qilish falsafasi va usullarini o'rganadi.</p>
<p>10-bob generiklar, traitlar va lifetimeni o'rganadi, bu sizga bir nechta turlarga tegishli kodni aniqlash imkoniyatini beradi. 11-bob sinovdan o'tadi, bu hatto Rustning xavfsizlik kafolatlari bilan ham dasturingiz mantig'ining to'g'riligini ta'minlash uchun zarurdir. 12-bobda biz fayllar ichidagi matnni qidiradigan <code>grep</code> buyruq qatori vositasidan o'zimizning funksiyalar to'plamini yaratamiz. Buning uchun biz oldingi boblarda muhokama qilgan ko'plab tushunchalardan foydalanamiz.</p>
<p>13-bob yopilishlar va iteratorlarni o'rganadi: Rustning funktsional dasturlash tillaridan kelib chiqadigan xususiyatlari. 14-bobda biz Cargolarni chuqurroq ko'rib chiqamiz va kutubxonalaringizni boshqalar bilan baham ko'rishning eng yaxshi amaliyotlari haqida gaplashamiz.
15-bobda standart kutubxona taqdim etadigan smart pointerlar va ularning funksionalligini ta'minlaydigan traitlar muhokama qilinadi.</p>
<p>16-bobda biz bir vaqtning o'zida dasturlashning turli modellarini ko'rib chiqamiz va Rust sizga bir nechta mavzularda qo'rqmasdan dasturlashda qanday yordam berishi haqida gaplashamiz.
17-bobda Rust idiomlari sizga tanish bo'lishi mumkin bo'lgan obyektga yo'naltirilgan(OOP) dasturlash tamoyillari bilan qanday taqqoslanishi ko'rib chiqiladi.</p>
<p>18-bobda Rust dasturlari bo'ylab g'oyalarni ifodalashning kuchli usullari bo'lgan patternlar va patternlarni moslashtirish haqida ma'lumot berilgan. 19-bobda ilg'or qiziqarli mavzular, jumladan xavfli Rust, makroslar va boshqa ko'p narsalar mavjud.</p>
<p>20-bobda biz low-leveldagi ko'p tarmoqli veb-serverni amalga oshiradigan loyihani yakunlaymiz!</p>
<p>Va nihoyat, ba'zi qo'shimchalarda til haqida foydali ma'lumotlar ko'proq mos yozuvlar formatida mavjud. A ilovasida Rustning kalit so'zlari, B ilovasida Rust operatorlari va belgilari, C ilovasi standart kutubxona tomonidan taqdim etilgan hosila traitlarini o'z ichiga oladi, D ilovasi ba'zi foydali ishlab chiqish vositalarini qamrab oladi va E ilovasida Rust nashrlari tushuntiriladi. F ilovasida siz kitobning tarjimalarini topishingiz mumkin, G ilovasida esa Rust qanday qilinganligi va  nightlyli Rust nima ekanligini ko'rib chiqamiz.</p>
<p>Ushbu kitobni o'qishning noto'g'ri usuli yo'q: agar siz oldinga o'tmoqchi bo'lsangiz, unga boring! Agar chalkashliklarga duch kelsangiz, avvalgi boblarga qaytishingiz kerak bo'lishi mumkin. Lekin siz uchun nima ish qilsa, shuni qiling.</p>
<p><span id="ferris"></span></p>
<p>Rustni o'rganish jarayonining muhim qismi kompilyator ko'rsatadigan xato xabarlarini o'qishni o'rganishdir: ular sizni ish kodiga yo'naltiradi.
Shunday qilib, biz kompilyator har bir vaziyatda sizga ko'rsatadigan xato xabari bilan birga kompilyatsiya qilinmaydigan ko'plab misollarni keltiramiz. Bilingki, agar siz tasodifiy misol kiritsangiz va ishlatsangiz, u kompilyatsiya qilinmasligi mumkin! Ishlamoqchi bo'lgan misol xato uchun mo'ljallanganligini bilish uchun atrofdagi matnni o'qiganingizga ishonch hosil qiling. Ferris, shuningdek, ishlash uchun mo'ljallanmagan kodni ajratishga yordam beradi:</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Ma'nosi</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/></td><td>Bu kod kompilyatsiya qilinmaydi!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>Bu kod panic!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>Ushbu kod kerakli xatti-harakatni keltirib chiqarmaydi.</td></tr>
</tbody></table>
</div>
<p>Aksariyat hollarda biz sizni kompilyatsiya qilinmagan har qanday kodning to'g'ri versiyasiga olib boramiz.</p>
<h2 id="manba-kodi"><a class="header" href="#manba-kodi">Manba kodi</a></h2>
<p>Ushbu kitob yaratilgan manba fayllarni <a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>da topish mumkin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ishni-boshlash"><a class="header" href="#ishni-boshlash">Ishni boshlash</a></h1>
<p>Rust sayohatingizni boshlaymiz! O'rganish uchun ko'p narsa bor, lekin har bir sayohat bir joydan boshlanadi. Ushbu bobda biz muhokama qilamiz:</p>
<ul>
<li>Rustni Linux, macOS va Windows-ga o'rnatish</li>
<li><code>Hello, world!</code> ni chop etuvchi dasturni yozish</li>
<li><code>cargo</code> dan foydalanib, Rust paketlar menejeri va build systemdan foydalanish</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ornatish"><a class="header" href="#ornatish">O'rnatish</a></h2>
<p>Birinchi qadam Rustni o'rnatishdir.Rustni Rust versiyalari va tegishli vositalarni boshqarish uchun buyruq qatori vositasi bo‚Äòlgan <code>rustup</code> orqali yuklab olamiz. Yuklab olish uchun sizga internet ulanishi kerak bo'ladi.</p>
<blockquote>
<p>Eslatma: Agar biron sababga ko'ra <code>rustup</code> dan foydalanmaslikni xohlasangiz, boshqa variantlar uchun
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Rustni o'rnatishning boshqa usullari</a> sahifasiga qarang.</p>
</blockquote>
<p>Quyidagi qadamlar Rust kompilyatorining so'nggi barqaror versiyasini o'rnatadi.
Rustning barqarorligi kafolati kitobdagi kompilyatsiya qilingan barcha misollar Rustning yangi versiyalari bilan kompilyatsiya qilishda davom etishini ta'minlaydi. Chiqish versiyalar orasida biroz farq qilishi mumkin, chunki Rust ko'pincha xato xabarlari va ogohlantirishlarni yaxshilaydi. Boshqacha qilib aytadigan bo'lsak, ushbu qadamlar yordamida o'rnatgan har qanday yangi, barqaror Rust versiyasi ushbu kitob mazmuni bilan kutilganidek ishlashi kerak.</p>
<blockquote>
<h3 id="buyruqlar-qatori-yozuvi"><a class="header" href="#buyruqlar-qatori-yozuvi">Buyruqlar qatori yozuvi</a></h3>
<p>Ushbu bobda va butun kitobda biz terminalda ishlatiladigan ba'zi buyruqlarni ko'rsatamiz.
Terminalga kiritishingiz kerak bo'lgan barcha qatorlar <code>$</code> bilan boshlanadi.
<code>$</code> belgisini kiritishingiz shart emas; bu har bir buyruqning boshlanishini ko'rsatish
uchun ko'rsatilgan buyruq qatori. <code>$</code> bilan boshlanmagan qatorlar odatda oldingi buyruqning
natijasini ko'rsatadi. Bundan tashqari, PowerShell-ga xos misollarda <code>$</code> emas, <code>&gt;</code> ishlatiladi.</p>
</blockquote>
<h3 id="linux-yoki-macos-ga--rustup-ornatish"><a class="header" href="#linux-yoki-macos-ga--rustup-ornatish">Linux yoki macOS-ga  <code>rustup</code> o'rnatish</a></h3>
<p>Agar siz Linux yoki macOS dan foydalansangiz, terminalni oching va quyidagi buyruqni kiriting:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Buyruq skriptni yuklab oladi va Rustning eng so'nggi barqaror versiyasini o'rnatadigan <code>rustup</code> vositasini o'rnatishni boshlaydi. Sizdan parol so'ralishi mumkin. O'rnatish muvaffaqiyatli bo'lsa, quyidagi qator paydo bo'ladi:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Shuningdek, sizga  <em>linker</em>, kerak bo'ladi, ya'ni Rust o'zining kompilyatsiya qilingan natijalarini bitta faylga birlashtirish uchun foydalanadigan dastur. Ehtimol,bu sizda allaqachon mavjud. Agar linker xatolarga duch kelsangiz, odatda linkerni o'z ichiga olgan C kompilyatorini o'rnatishingiz kerak. C kompilyatori ham foydalidir, chunki ba'zi umumiy Rust paketlari C kodiga bog'liq va C kompilyatoriga muhtoj bo'ladi.</p>
<p>MacOS-da siz C kompilyatorini ishga tushirish orqali olishingiz mumkin:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux foydalanuvchilari odatda distributiv texnik hujjatlariga muvofiq GCC yoki Clang o'rnatishlari kerak. Misol uchun, agar siz Ubuntu'dan foydalansangiz, <code>build-essential</code> paketini o'rnatishingiz mumkin.</p>
<h3 id="windows-ga-rustup-ornatish"><a class="header" href="#windows-ga-rustup-ornatish">Windows-ga <code>rustup</code> o'rnatish</a></h3>
<p>Windows tizimida <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> saytiga o'ting va Rustni o'rnatish bo'yicha ko'rsatmalarga amal qiling. O'rnatishning bir nuqtasida sizga Visual Studio 2013 yoki undan keyingi versiyalari uchun MSVC yaratish vositalari kerakligi haqida xabar keladi.</p>
<p>Build toolsini olish uchun <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2022</a> ni o'rnatishingiz kerak bo'ladi. Qaysi ish dasturlarini o'rnatish kerakligi so'ralganda, quyidagilarni  kiriting:</p>
<ul>
<li>‚ÄúDesktop Development with C++‚Äù</li>
<li>TWindows 10 yoki 11 SDK</li>
<li>Ingliz tili to'plami komponenti va siz tanlagan boshqa tillar to'plami</li>
</ul>
<p>Ushbu kitobning qolgan qismi <em>cmd.exe</em> va PowerShell da ishlaydigan buyruqlardan foydalanadi.
Agar aniq farqlar bo'lsa, qaysi birini ishlatishni tushuntiramiz.</p>
<h3 id="muammolarni-bartaraf-etish"><a class="header" href="#muammolarni-bartaraf-etish">Muammolarni bartaraf etish</a></h3>
<p>Rust to'g'ri o'rnatilganligini tekshirish uchun shellni oching va quyidagi qatorni kiriting:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Quyidagi formatda chiqarilgan so‚Äònggi barqaror versiya uchun versiya raqami, xesh va tasdiqlangan sanani ko‚Äòrishingiz kerak:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Agar siz ushbu ma'lumotni ko'rsangiz, Rustni muvaffaqiyatli o'rnatdingiz! Agar siz ushbu ma'lumotni ko'rmasangiz, Rust <code>%PATH%</code> tizim o'zgaruvchingizda quyidagi tarzda ekanligini tekshiring.</p>
<p>Windows CMD-da quyidagilardan foydalaning:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>PowerShell-da foydalaning:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>Linux va macOS-da quyidagilardan foydalaning:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>Agar hammasi to'g'ri bo'lsa va Rust hali ham ishlamasa, yordam olishingiz mumkin bo'lgan bir qancha joylar mavjud. Boshqa Rustaceanlar (biz o'zimizni chaqiradigan ahmoqona taxallus) bilan qanday bog'lanishni <a href="https://www.rust-lang.org/community">hamjamiyat sahifasida</a> bilib oling.</p>
<h3 id="yangilash-va-ochirish"><a class="header" href="#yangilash-va-ochirish">Yangilash va o'chirish</a></h3>
<p>Rust <code>rustup</code> orqali o'rnatilgandan so'ng, yangi chiqarilgan versiyaga yangilash oson. Shelldan quyidagi yangilash skriptini ishga tushiring:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Rust va  <code>rustup</code>-ni o'chirish uchun shelldan quyidagi o'chirish skriptini ishga tushiring:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="mahalliy-texnik-hujjatlar"><a class="header" href="#mahalliy-texnik-hujjatlar">Mahalliy texnik hujjatlar</a></h3>
<p>Rust-ning o'rnatilishi texnik hujjatlarning mahalliy nusxasini ham o'z ichiga oladi, shunda siz uni oflayn rejimda o'qishingiz mumkin. Brauzeringizda mahalliy texnik hujjatlarni ochish uchun <code>rustup doc</code> dasturini ishga tushiring.</p>
<p>Istalgan vaqtda standart kutubxona tomonidan tur yoki funksiya taqdim etilsa va siz u nima qilishini yoki undan qanday foydalanishni bilmasangiz, bilish uchun amaliy dasturlash interfeysi (API) texnik hujjatlaridan foydalaning!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>Endi siz Rustni o'rnatdingiz, hozir sizning birinchi Rust dasturingizni yozishning ayni vaqti.
Yangi dasturlash tilini o'rganishda <code>Hello, World!</code> matnini ekranga chop etuvchi kichik va sodda
dastur tuzish an'anaga aylangan, shunday ekan biz ham sinab ko'ramiz!</p>
<blockquote>
<p>Eslatma: Bu kitob terminal bilan ishlay olishning boshlang'ich ko'nikmalarini
talab qiladi. Rust sizning kod muxarriringiz foydalanadigan asboblaringiz va
kodingizni qayerda joylayishi bo'yicha talablar qo'ymaydi, shuning uchun agar siz
terminal o'rniga integratsiyalashgan ishlab chiqish muhitidan (IDE) foydalanishni afzal ko'rsangiz,
o'zingizning sevimli IDE-dan foydalaning. Ko'pgina IDElar endi ma'lum darajada
Rust-ni qo'llab-quvvatlaydi; tafsilotlar uchun IDE hujjatlarini tekshiring.
Rust jamoasi <code>rust-analyzer</code> orqali ajoyib IDE yordamini ta'minlashga e'tibor qaratdi.
Batafsil ma‚Äôlumot uchun <a href="appendix-04-useful-development-tools.html">D ilovasi</a><!-- ignore -->ni ko'zdan kechiring.</p>
</blockquote>
<h3 id="loyiha-jildini-yaratish"><a class="header" href="#loyiha-jildini-yaratish">Loyiha jildini yaratish</a></h3>
<p>Siz ishni Rust kodingizni joylaytirish uchun jild yaratishdan boshlaysiz.
Rust uchun sizning kodingiz qayerda joylashining ahamiyati yo'q, lekin biz
bu kitobdagi mashq va loyihalarni joylash uchun <em>projects</em> nomli jild yaratishingizni
maslahat beramiz.</p>
<p>Terminalni oching va <em>projects</em> jildini yaratish va uning ichidan ‚ÄúHello, world!‚Äù loyihasi
jildini yaratish uchun quyidagi buyruqlarni kiriting.</p>
<p>Linux, macOS va Windows Powershell uchun:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows CMD uchun:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="rust-dasturi-yozish-va-ishga-tushirish"><a class="header" href="#rust-dasturi-yozish-va-ishga-tushirish">Rust dasturi yozish va ishga tushirish.</a></h3>
<p>Endi, <em>main.rs</em> nomli yangi fayl yarating. Rust kodlar har doim <em>.rs</em> kengaytmasi
bilan tugaydi. Agar fayl nomida bir nechta so'zlardan foydalansangiz, ularni ajratish uchun pastki chiziqdan foydalanish shart. Masalan, <em>helloworld.rs</em> o'rniga <em>hello_world.rs</em> dan foydalaning.</p>
<p>Endi hozirgina yaratgan <em>main.rs</em> faylingizni kod muharririda oching.</p>
<p><span class="filename">Fayl nomi: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 1-1: <code>Hello, world!</code> ni chop etuvchi dastur</span></p>
<p>Faylni saqlang va Terminalda <em>~/projects/hello_world</em> jildiga qayting.
Linux yoki macOS da faylni kompilyatsiya qilish va ishga tushirish uchun quyidagi buyruqlarni kiriting:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>Windowsda <code>./main</code> ning o'rniga <code>.\main.exe</code> buyrug'ini kiriting:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Operatsion tizimingizdan qat'i nazar, terminalda <code>Hello, world!</code> qatori chop etilishi kerak.Agar siz ushbu chiqishni ko'rmasangiz, yordam olish usullari uchun O'rnatish bo'limining <a href="ch01-01-installation.html#troubleshooting">‚ÄùMuammolarni bartaraf etish‚Äù</a><!-- ignore --> bo'limiga qayting.</p>
<p>Agar <code>Hello, world!</code> chop etilgan bo'lsa, tabriklaymiz! Siz rasmiy ravishda Rust dasturini yozdingiz. Bu sizni Rust dasturchisiga aylantiradi - xush kelibsiz!</p>
<h3 id="rust-dasturining-tuzilishi"><a class="header" href="#rust-dasturining-tuzilishi">Rust dasturining tuzilishi.</a></h3>
<p>Keling &quot;Hello, world!&quot; dasturiga chuqurroq nazar solamiz. Boshqotirmaning 1-qismi:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}</code></pre></pre>
<p>Bu qatorlar <code>main</code> nomli funksiyani e'lon qiladi. <code>main</code> funksiyasi alohida: u har doim bajariladigan Rust dasturida ishlaydigan birinchi koddir. Bu yerda birinchi satr hech qanday parametrga ega bo ªlmagan va hech narsani qaytarmaydigan <code>main</code> funksiyasini e ºlon qiladi.
Agar parametrlar mavjud bo'lsa, ular <code>()</code> qavslar ichiga kiradi.</p>
<p>Funksiyasing tanasi <code>{}</code> bilan o'ralgan. Rust har bir funksiyalarda e'lon qilishda
<code>{}</code> dan foydalanishni talab qiladi.</p>
<blockquote>
<p>Eslatma: Agar siz Rust loyihalarda standart usulda kod yozmoqchi bo'lsangiz
kodingizni ma ºlum bir uslubda formatlash uchun <code>rustfmt</code> nomli avtomatik formatlash vositasidan
foydalanishingiz mumkin (batafsilroq <code>rustfmt</code> <a href="appendix-04-useful-development-tools.html">D ilovasi</a><!-- ignore --> -da)
Rust jamoasi ushbu vositani standart Rust distributiviga kiritdi,
chunki <code>rustc</code> kabi, u allaqachon kompyuteringizga o'rnatilgan bo'lishi kerak!</p>
</blockquote>
<p><code>main</code> funksiyaning tanasi quyidagi kodni o'z ichiga oladi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Shu bir qator kod shu kichik dasturdagi barcha ishni amalga oshiardi: u
matnni ekranga chop etadi.Bu yerda ahamiyat qaratish zarur bo'lgan
to'rtta muhim narsalar bor.</p>
<!-- Birinchidan, Rust stili 4ta bo'sh joydan iborat 1ta tabdan emas. -->
<p>Birinchidan, Rust style to'rtta bo'shliqdan iborat tab emas</p>
<p>Ikkinchidan, <code>println!</code> Rust makrosini chaqiradi. Agar u funktsiyani o'rniga chaqirgan bo'lsa, u <code>println</code> (<code>!</code> belgisiz) sifatida kiritiladi. Biz Rust makrolari haqida 19-bobda batafsilroq muhokama qilamiz.Hozircha siz shuni bilishingiz kerakki, <code>!</code> belgisidan foydalanish oddiy funksiya o‚Äòrniga makrosni chaqirayotganingizni anglatadi va makrolar har doim ham funksiyalar bilan bir xil qoidalarga amal qilmaydi.</p>
<p>Uchinchidan, siz <code>&quot;Hello, world!&quot;</code> qatorini ko'rasiz. Bu satrni argument sifatida <code>println!</code> ga uzatamiz va satr ekranga chop etiladi.</p>
<p>To'rtinchidan, satrni nuqtali vergul (<code>;</code>) bilan tugatamiz, bu esa bu ifoda tugaganligini va keyingisi boshlashga tayyorligini bildiradi. Rust kodining aksariyat satrlari nuqtali vergul bilan tugaydi.</p>
<h3 id="kompilyatsiya-va-ishga-tushirish-alohida-bosqichlardir"><a class="header" href="#kompilyatsiya-va-ishga-tushirish-alohida-bosqichlardir">Kompilyatsiya va ishga tushirish alohida bosqichlardir</a></h3>
<p>Siz yangi yaratilgan dasturni ishga tushirdingiz, shuning uchun jarayonning har bir bosqichini ko'rib chiqamiz.</p>
<p>Rust dasturini ishga tushirishdan oldin uni Rust kompilyatoridan foydalanib, <code>rustc</code> buyrug‚Äòini kiritib, unga manba faylingiz nomini quyidagi tarzda kiritishingiz kerak:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>Agar siz C yoki C++ bilan ishlagan bo'lsangiz, bu <code>gcc</code> yoki <code>clang</code> ga o'xshashligini sezasiz. Muvaffaqiyatli kompilyatsiyadan so'ng Rust binary bajariladigan faylni chiqaradi.</p>
<p>Linux, macOS va Windows-dagi PowerShell-da siz shelldagi <code>ls</code> buyrug'ini kiritish orqali bajariladigan faylni ko'rishingiz mumkin:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>Linux va macOS-da siz ikkita faylni ko'rasiz. Windows-dagi PowerShell bilan siz CMD-dan foydalangan holda ko'rgan uchta faylni ko'rasiz. Windows-da CMD bilan siz quyidagilarni kiritasiz:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B faqat fayl nomlarini ko'rsatishni aytadi =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Bu sizga <em>.rs</em> kengaytmali kod faylini, bajariluvchi faylni(Windowsda <code>main.exe</code>
boshqa barcha tizimlarda <code>main</code>), va Windowsdan foydalanayotganingizda, debugging 
ma'lumotlarini o'z ichida saqlovchi <em>.pdb</em> kengaytmali faylni ko'rsatadi.</p>
<p>Bu yerdan siz <em>main</em> yoki <em>main.exe</em> faylini ishga tushirasiz, masalan:</p>
<pre><code class="language-console">$ ./main # or .\Windows-da main.exe
</code></pre>
<p>Agar sizning <em>main.rs</em> faylingiz ‚ÄúHello, world!‚Äù dasturi bo'lsa, bu dastur
ekranga <code>Hello, world!</code> matnini chop etadi.</p>
<p>Agar siz Ruby, Python yoki JavaScript kabi dinamik tilni yaxshi bilsangiz, dasturni alohida bosqichlar sifatida kompilyatsiya qilish va ishga tushirishga odatlanmagan bo'lishingiz mumkin. Rust - bu oldindan tuzilgan kompilyatsiya tili, ya'ni siz dasturni kompilyatsiya qilishingiz va bajariladigan faylni boshqa birovga berishingiz mumkin va ular Rustni o'rnatmasdan ham uni ishga tushirishlari mumkin.Agar siz kimgadir <em>.rb</em>, <em>.py</em> yoki <em>.js</em> faylini bersangiz, ularda Ruby, Python yoki JavaScript ilovasi o ªrnatilgan bo ªlishi kerak (mos ravishda). Ammo bu tillarda dasturni kompilyatsiya qilish va ishga tushirish uchun faqat bitta buyruq kerak bo'ladi. Til dizaynida hamma narsa o'zaro kelishuvdir.</p>
<p>Oddiy dasturlar uchun <code>rustc</code> bilan kompilyatsiya qilish juda mos keladi, lekin loyihangiz o'sib borishi bilan siz barcha variantlarni boshqarishni va kodingizni almashishni osonlashtirishni xohlaysiz.
Endi, biz siz bilan haqiqiy Rust dasturlarini tuzishda qulaylik yaratuvchi
Cargo yordamchisi bilan tanishamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<p>Cargo - bu Rustning build tizimi va paketlar menejeri. Aksariyat Rustaceanlar o'zlarining Rust loyihalarini boshqarish uchun ushbu vositadan foydalanadilar, chunki Cargo siz uchun kodni yaratish, kodingizga bog'liq kutubxonalarni yuklab olish va ushbu kutubxonalarni yaratish kabi ko'plab vazifalarni bajaradi.(Biz sizning kodingizga kerak bo'lgan kutubxonalarni chaqiramiz
<em>dependencies</em>.)</p>
<p>Eng oddiy Rust dasturlari, biz hozirgacha yozganimiz kabi, hech qanday dependencylarga ega emas. Agar biz  ‚ÄúHello, world!‚Äù Cargo bilan loyiha bo'lsa, u faqat sizning kodingizni yaratish bilan shug'ullanadigan Cargo qismidan foydalanadi. Murakkab Rust dasturlarini yozganingizda, siz dependencylarni qo'shasiz va agar siz Cargo yordamida loyihani boshlasangiz, dependencylarni qo'shish osonroq bo'ladi.</p>
<p>Rust loyihalarining aksariyati Cargolardan foydalanganligi sababli, ushbu kitobning qolgan qismida siz ham Cargodan foydalanasiz deb taxmin qilinadi. <a href="ch01-01-installation.html#installation">O'rnatish</a><!-- ignore -->  bo'limida muhokama qilingan rasmiy o'rnatuvchilardan foydalansangiz, Cargo Rust bilan birga keladi. Agar siz Rust-ni boshqa vositalar orqali o'rnatgan bo'lsangiz, terminalingizga quyidagilarni kiritish orqali Cargo o'rnatilganligini tekshiring:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Agar siz versiya raqamini ko'rsangiz, sizda bor! Agar siz <code>command not found</code> kabi xatolikni ko'rsangiz, Cargoni qanday qilib alohida o'rnatish bo'yicha texnik hujjatlarni ko'rib chiqing.</p>
<h3 id="cargo-bilan-loyiha-yaratish"><a class="header" href="#cargo-bilan-loyiha-yaratish">Cargo bilan loyiha yaratish</a></h3>
<p>Keling, Cargo-dan foydalanib yangi loyiha yarataylik va u bizning asl ‚ÄúHello, world!‚Äù loyihadan qanday farq qilishini ko'rib chiqaylik. O'zingizning <em>projects</em> jildigiga (yoki kodingizni saqlashga qaror qilgan joyingizga) qayting. Keyin istalgan operatsion tizimda quyidagilarni bajaring:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Birinchi buyruq <em>hello_cargo</em> nomli yangi jild va loyihani yaratadi.
Biz loyihamizga <em>hello_cargo</em> deb nom berdik va Cargo o'z fayllarini xuddi shu nomdagi jildda yaratadi.</p>
<p><em>hello_cargo</em> jildiga o'ting va fayllar ro'yxatini ko'ring.Cargo biz uchun ikkita fayl va bitta jild yaratganini ko'rasiz: <em>Cargo.toml</em> fayli va ichida <em>main.rs</em> fayli bo'lgan <em>src</em> jildi.</p>
<p>Shuningdek, u <em>.gitignore</em> fayli bilan birga yangi Git repositoryni ishga tushirdi. Mavjud Git repositoryda <code>cargo new</code> ni ishga tushirsangiz, Git fayllari yaratilmaydi; <code>cargo new - vcs=git</code> yordamida bu xatti-harakatni bekor qilishingiz mumkin.</p>
<blockquote>
<p>Eslatma: Git keng tarqalgan versiya boshqaruv tizimidir. Siz <code>--vcs</code> buyrug ªi yordamida
<code>cargo new</code> ni boshqa versiyani boshqarish tizimidan foydalanishga yoki versiyani boshqarish
tizimisiz foydalanishga o ªzgartirishingiz mumkin. Mavjud variantlarni
ko'rish uchun <code>cargo new --help</code> ni ishga tushiring.</p>
</blockquote>
<p>Siz tanlagan matn muharririda <em>Cargo.toml</em>ni oching. U 1-2 ro'yxatdagi kodga o'xshash bo'lishi kerak.</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">Ro'yxat 1-2: <code>cargo new</code> tomonidan yaratilgan <em>Cargo.toml</em> tarkibi</span></p>
<p>Bu fayl <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> da (<em>Tom‚Äôs Obvious, Minimal
Language</em>) formati, bu Cargo konfiguratsiya formati.</p>
<p>Birinchi qator, <code>[package]</code>, bo'lim sarlavhasi bo'lib, quyidagi iboralar paketni sozlayotganligini bildiradi.Ushbu faylga qo'shimcha ma'lumot qo'shsak, biz boshqa bo'limlarni qo'shamiz.</p>
<p>Keyingi uchta qatorda Cargo dasturingizni kompilyatsiya qilish uchun kerak bo'lgan konfiguratsiya ma'lumotlarini o'rnatadi: Rustning nomi, versiyasi va foydalanish uchun nashri.
<a href="appendix-05-editions.html">E ilovasi</a><!-- ignore -->da <code>edition</code> kaliti haqida gaplashamiz.</p>
<p>Oxirgi qator, <code>[dependencies]</code>, loyihangizning har qanday dependencylarini ro'yxatlash uchun bo'limning boshlanishi. Rustda kod paketlari <em>crates</em> deb ataladi. Ushbu loyiha uchun bizga boshqa cratelar kerak bo'lmaydi, lekin biz 2-bobdagi birinchi loyihada bo'lamiz, shuning uchun biz ushbu dependencies bo'limidan foydalanamiz.</p>
<p>Endi <em>src/main.rs</em> oching va qarang:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Cargo ‚ÄúHello, world!‚Äù siz uchun dastur, xuddi biz Ro'yxat 1-1 da yozganimiz kabi! Hozircha, bizning loyihamiz va yaratilgan Cargo loyihasi o'rtasidagi farq shundaki, Cargo kodni <em>src</em> jildiga joylashtirgan va bizda yuqori jildda <em>Cargo.toml</em> konfiguratsiya fayli mavjud.</p>
<p>Cargo sizning manba fayllaringiz <em>src</em> jildida turishini kutadi. Yuqori darajadagi loyiha jildi faqat README fayllari, litsenziya ma ºlumotlari, konfiguratsiya fayllari va kodingizga aloqador bo ªlmagan boshqa narsalar uchun mo ªljallangan. Cargo-dan foydalanish loyihalaringizni tartibga solishga yordam beradi. Hamma narsaning o'rni bor va hamma narsa o'z o'rnida.</p>
<p>Agar siz ‚ÄúHello, world!‚Äù bilan qilganimizdek, Cargo-dan foydalanmaydigan loyihani boshlagan bo'lsangiz, uni Cargo-dan foydalanadigan loyihaga aylantirishingiz mumkin. Loyiha kodini <em>src</em> jildiga o'tkazing va tegishli <em>Cargo.toml</em> faylini yarating.</p>
<h3 id="cargo-loyihasini-qurish-va-ishga-tushirish"><a class="header" href="#cargo-loyihasini-qurish-va-ishga-tushirish">Cargo loyihasini qurish va ishga tushirish</a></h3>
<p>Keling, ‚ÄúHello, world!‚Äù ni qurish va ishga tushirishda nima farq qilishini ko'rib chiqaylik. Cargo bilan dasturni <em>hello_cargo</em> jildidan quyidagi buyruqni kiritish orqali loyihangizni build qiling:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Ushbu buyruq bajariladigan faylni joriy jildingizda emas, balki <em>target/debug/hello_cargo</em> da (yoki Windowsda <em>target\debug\hello_cargo.exe</em>)da  yaratadi. Odatiy tuzilish debug tuzilishi bo'lgani uchun Cargo binary faylni <em>debug</em> nomli jildga joylashtiradi. Ushbu buyruq bilan bajariladigan faylni ishga tushirishingiz mumkin:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # yoki .\target\debug\hello_cargo.exe Windowsda
Hello, world!
</code></pre>
<p>Agar hammasi yaxshi bo'lsa, <code>Hello, world!</code> terminalga chop etilishi kerak.<code>cargo build</code> ni birinchi marta ishga tushirish ham Cargoning yuqori darajadagi yangi faylni yaratishiga olib keladi: <em>Cargo.lock</em>. Ushbu fayl loyihangizdagi dependencylarning aniq versiyalarini kuzatib boradi. Ushbu loyihada dependencylar yo'q, shuning uchun faylda kod biroz kam. Siz hech qachon ushbu faylni qo'lda o'zgartirishingiz shart emas; Cargo uning tarkibini siz uchun boshqaradi.</p>
<p>Biz hozirgina <code>cargo build</code> orqali loyihasini build qildik va uni <code>./target/debug/hello_cargo</code> bilan ishga tushirdik, lekin kodni kompilyatsiya qilish uchun <code>cargo run</code> dan ham foydalanishimiz va natijada bajariladigan faylni bitta buyruqda ishga tushirishimiz mumkin:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p><code>cargo run</code> dan foydalanish <code>cargo build</code> ni ishga tushirishdan ko'ra qulayroqdir va keyin binary yo'lni to'liq ishlatadi, shuning uchun ko'pchilik ishlab chiquvchilar <code>cargo run</code> dan foydalanadilar.</p>
<p>E'tibor bering, bu safar biz <code>Hello_cargo</code> ni kompilyatsiya qilayotganini ko'rsatadigan natijani ko'rmadik. Cargo fayllar o'zgarmaganligini aniqladi, shuning uchun u qayta tiklanmadi, balki binary faylni ishga tushirdi. Agar siz manba kodingizni o'zgartirgan bo'lsangiz, Cargo loyihani ishga tushirishdan oldin uni qayta build qilgan bo'lar edi va siz ushbu natijani ko'rgan bo'lar edingiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo shuningdek, <code>cargo check</code> deb nomlangan buyruqni taqdim etadi. Bu buyruq kompilyatsiya qilish uchun kodingizni tezda tekshiradi, lekin bajariladigan fayl yaratmaydi:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Nima uchun bajariladigan faylni xohlamaysiz? Ko'pincha <code>cargo check</code> <code>cargo build</code>dan ko'ra tezroq bo'ladi,, chunki u bajariladigan faylni yaratish bosqichini o'tkazib yuboradi. Agar siz kod yozish paytida ishingizni doimiy ravishda tekshirayotgan bo'lsangiz, <code>cargo check</code> dan foydalanish loyihangiz hali ham kompilyatsiya qilinayotganligini bildirish jarayonini tezlashtiradi! Shunday qilib, ko'plab Rustaceanlar vaqti-vaqti bilan <code>cargo check</code> ni amalga oshiradilar, chunki ular o'z dasturlarini kompilyatsiya qilishiga ishonch hosil qilish uchun yozadilar. Keyin ular bajariladigan fayldan foydalanishga tayyor bo'lgach, <code>cargo build</code> ni ishga tushiradilar.</p>
<p>Cargo haqida shu paytgacha o'rganganlarimizni takrorlaymiz:</p>
<ul>
<li>Biz <code>cargo new</code> yordamida loyiha yaratamiz.</li>
<li><code>cargo build</code> yordamida loyihani build qilishimiz mumkin.</li>
<li>Biz <code>cargo run</code> yordamida bir bosqichda loyiha build qilishimiz va ishga tushirishimiz mumkin.</li>
<li><code>cargo check</code> yordamida xatolarni tekshirish uchun binary  ishlab chiqarmasdan loyihani build qilishimiz mumkin.</li>
<li>Build natijasini bizning kodimiz bilan bir xil jildda saqlash o'rniga, Cargo uni <em>target/debug</em> jildida saqlaydi.</li>
</ul>
<p>Cargo-dan foydalanishning qo'shimcha afzalligi shundaki, qaysi operatsion tizimda ishlayotganingizdan qat'i nazar, buyruqlar bir xil bo'ladi. Shunday qilib, biz endi Linux va MacOS uchun Windows-ga nisbatan maxsus ko'rsatmalar bermaymiz.</p>
<h3 id="loyihani-reliz-qilish"><a class="header" href="#loyihani-reliz-qilish">Loyihani Reliz qilish</a></h3>
<p>Loyihangiz nihoyat relizga tayyor bo'lgach, uni optimallashtirish bilan kompilyatsiya qilish uchun <code>cargo build --release</code> dan foydalanishingiz mumkin. Ushbu buyruq <em>target/debug</em> o'rniga <em>target/release</em> da bajariladigan fayl yaratadi. Optimizatsiya Rust kodingizni tezroq ishga tushiradi, lekin bu kompilyatsiya vaqtini uzaytiradi. Shuning uchun ikkita turli profil mavjud: biri tez va tez-tez qayta tiklamoqchi bo'lganingizda ishlab chiqish uchun, ikkinchisi esa oxirgi dasturni yaratish uchun siz foydalanuvchiga qayta tiklanmaydigan va mkon qadar tez ishlaydigan oxirgi dastur. Agar siz kodingizning ishlash vaqtini solishtirmoqchi bo'lsangiz, <code>cargo build --release</code> dasturini ishga tushiring va <em>target/release</em> da bajariladigan fayl bilan taqqoslang.</p>
<h3 id="konventsiya-sifatida-cargo"><a class="header" href="#konventsiya-sifatida-cargo">Konventsiya sifatida Cargo</a></h3>
<p>Oddiy loyihalar bilan Cargo <code>rustc</code> dan foydalanishdan ko'ra unchalik katta foyda keltirmaydi, ammo dasturlaringiz yanada murakkablashgani sayin u o'z qiymatini isbotlaydi.
Dasturlar bir nechta fayllarga ko'payib rivojlanganda yoki ularga dependency kerak bo'lsa, Cargo-ga buildni muvofiqlashtirishga ruxsat berish ancha oson bo'ladi.</p>
<p><code>hello_cargo</code> loyihasi oddiy bo'lsa ham, u endi Rust karyerangizning qolgan qismida foydalanadigan haqiqiy asboblarning ko'p qismini ishlatadi. Haqiqatan ham, mavjud loyihalar ustida ishlash uchun siz Git yordamida kodni tekshirish, ushbu loyiha jildiga o ªzgartirish va build qilish uchun quyidagi buyruqlardan foydalanishingiz mumkin:</p>
<pre><code class="language-console">$ git clone github.com/birorta-loyiha
$ cd birorta-loyiha
$ cargo build
</code></pre>
<p>Cargo haqida ko'proq ma'lumot olish uchun uning <a href="https://doc.rust-lang.org/cargo/">texnik hujjatlarini</a> tekshiring.</p>
<h2 id="xulosa"><a class="header" href="#xulosa">Xulosa</a></h2>
<p>Siz allaqachon Rust sayohatingizni ajoyib boshladingiz! Ushbu bobda siz quyidagilarni o'rgandingiz:</p>
<ul>
<li>Rust-ning so'nggi barqaror versiyasini <code>rustup</code> yordamida o'rnatish</li>
<li>Rustning yangi versiyasiga yangilash</li>
<li>Mahalliy o'rnatilgan texnik hujjatlarni ochish</li>
<li>‚ÄúHello, world!‚Äù deb yozing va ishga tushiring. to'g'ridan-to'g'ri <code>rustc</code> dan foydalangan holda dastur</li>
<li>Cargo konventsiyalaridan foydalangan holda yangi loyiha yaratish va ishga tushirish</li>
</ul>
<p>Bu Rust kodini o'qish va yozishga odatlanish uchun yanada muhimroq dastur yaratish uchun ajoyib vaqt. Shunday qilib, 2-bobda biz taxminiy o'yin dasturini tuzamiz.
Agar siz Rust-da umumiy dasturlash tushunchalari qanday ishlashini o'rganishni afzal ko'rsangiz, 3-bobga qarang va keyin 2-bobga qayting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="taxmin-qilish-oyinini-dasturlash"><a class="header" href="#taxmin-qilish-oyinini-dasturlash">Taxmin qilish o'yinini dasturlash</a></h1>
<p>Keling, birgalikda amaliy loyiha orqali Rustga o'taylik! Ushbu bob sizni bir nechta umumiy Rust tushunchalari bilan tanishtirib, ulardan haqiqiy dasturda qanday foydalanishni ko'rsatib beradi.  Siz <code>let</code>, <code>match</code>, metodlari, bog'langan funksiyalar, external cratelardan foydalanish va boshqalar haqida bilib olasiz! Keyingi boblarda biz ushbu fikrlarni batafsilroq ko'rib chiqamiz. Ushbu bobda siz faqat asoslarni mashq qilasiz.</p>
<p>Biz klassik boshlang'ich dasturlash muammosini amalga oshiramiz: taxmin qilish o'yini. Bu qanday ishlaydi: dastur 1 dan 100 gacha tasodifiy butun son hosil qiladi. Keyin u o'yinchini taxmin qilishni taklif qiladi.Tahmin kiritilgandan so'ng, dastur taxmin kichik yoki katta ekanligini ko'rsatadi. Agar taxmin to'g'ri bo'lsa, o'yin tabrik xabarini chop etadi va chiqadi.</p>
<h2 id="yangi-loyiha-yaratish"><a class="header" href="#yangi-loyiha-yaratish">Yangi loyiha yaratish</a></h2>
<p>Yangi loyihani o'rnatish uchun 1-bobda yaratgan <em>projects</em> jildiga o'ting va Cargo-dan foydalanib yangi loyiha yarating, masalan:</p>
<pre><code class="language-console">$ cargo new taxminiy_raqam
$ cd taxminiy_raqam
</code></pre>
<p>Birinchi <code>cargo new</code> buyrug'i birinchi argument sifatida loyiha nomini (<code>taxminiy_raqam</code>)ni oladi. Ikkinchi buyruq yangi loyiha jildiga kiradi.</p>
<p>Yaratilgan <em>Cargo.toml</em> fayliga qarang:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;taxminiy_raqam&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>1-bobda ko'rganingizdek, <code>cargo new</code> siz uchun ‚ÄúHello, world!‚Äù so'zini chop etadigan dastur yaratadi. <em>src/main.rs</em> faylini tekshiring:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<p>Keling, ushbu &quot;Hello, world!&quot; dasturni yarating va <code>cargo run</code> buyrug'i yordamida ishga tushiring :</p>
<pre><code class="language-console">$ cargo run
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/taxminiy_raqam`
Hello, world!
</code></pre>
<p><code>run</code> buyrug‚Äòi loyihani tezda takrorlash kerak bo‚Äòlganda foydali bo‚Äòladi, biz bu o‚Äòyinda qilganimizdek, keyingisiga o‚Äòtishdan oldin har bir iteratsiyani tezda sinab ko‚Äòramiz.</p>
<p><em>src/main.rs</em> faylini qayta oching. Siz ushbu fayldagi barcha kodlarni yozasiz.</p>
<h2 id="taxmin-qilish-oyiniga-ishlov-berish"><a class="header" href="#taxmin-qilish-oyiniga-ishlov-berish">Taxmin qilish o'yiniga ishlov berish</a></h2>
<p>Taxmin qilish o'yini dasturining birinchi qismi foydalanuvchi kiritishini so'raydi, ushbu kiritishni qayta ishlaydi va kirish kutilgan shaklda ekanligini tekshiradi. Boshlash uchun biz o'yinchiga taxmin kiritishga ruxsat beramiz. 2-1 ro'yxatdagi kodni <em>src/main.rs</em> ichiga kiriting.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Raqamni topish o'yini!&quot;);

    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);

    let mut taxmin = String::new();

    io::stdin()
        .read_line(&amp;mut taxmin)
        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);

    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
}</code></pre>
<p><span class="caption">Ro'yxat 2-1: Foydalanuvchi tomonidan taxmin qilinadigan va uni chop etadigan kod</span></p>
<p>Ushbu kod juda ko'p ma'lumotlarni o'z ichiga oladi, shuning uchun uni satrga o'tkazamiz. Foydalanuvchi kiritishini olish va natijani chiqish sifatida chop etish uchun biz <code>io</code> input/output kutubxonasini qamrab olishimiz kerak. <code>io</code> kutubxonasi <code>std</code> deb nomlanuvchi standart kutubxonadan keladi:</p>
<pre><code class="language-rust ignore">use std::io;</code></pre>
<p>Odatda, Rust standart kutubxonada belgilangan elementlar to'plamiga ega bo'lib, u har bir dastur doirasiga kiradi. Ushbu to'plam <em>prelude</em> deb ataladi va siz undagi hamma narsani <a href="../std/prelude/index.html">standart kutubxona texnik hujjatlarida</a> ko'rishingiz mumkin.</p>
<p>Agar siz foydalanmoqchi bo'lgan tur preludeda bo'lmasa, siz ushbu turni <code>use</code> iborasi bilan aniq kiritishingiz kerak. <code>std::io</code> kutubxonasidan foydalanish sizga bir qator foydali xususiyatlarni, jumladan, foydalanuvchi kiritishini qabul qilish imkoniyatini beradi.</p>
<p>1-bobda ko'rganingizdek, <code>main</code> funksiya dasturga kirish nuqtasidir:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">}</span></code></pre>
<p><code>fn</code> sintaksisi yangi funktsiyani e'lon qiladi; Qavslar, <code>()</code>, hech qanday parametr yo'qligini bildiradi; va jingalak qavs, <code>{</code>, funksiyaning asosiy qismini boshlaydi.</p>
<p>1-bobda ham bilib olganingizdek, <code>println!</code> bu ekranga satrni chop etuvchi makros:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Raqamni topish o'yini!&quot;);

    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
<span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Ushbu kod o'yin nima ekanligini ko'rsatuvchi va foydalanuvchidan ma'lumot so'rashni chop etadi.</p>
<h3 id="ozgaruvchilar-bilan-qiymatlarni-saqlash"><a class="header" href="#ozgaruvchilar-bilan-qiymatlarni-saqlash">O'zgaruvchilar bilan qiymatlarni saqlash</a></h3>
<p>Keyinchalik, foydalanuvchi ma'lumotlarini saqlash uchun <em>o'zgaruvchi</em> yaratamiz, masalan:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span>    let mut taxmin = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Endi dastur qiziqarli bo'lib bormoqda! Bu kichik satrda juda ko'p narsa bor. O'zgaruvchini yaratish uchun <code>let</code> iborasidan foydalanamiz. Mana yana bir misol:</p>
<pre><code class="language-rust ignore">let olmalar = 5;</code></pre>
<p>Bu qator <code>olmalar</code> nomli yangi o‚Äòzgaruvchini yaratadi va uni 5 qiymatiga bog‚Äòlaydi. Rustda o'zgaruvchilar standard bo'yicha o'zgarmasdir, ya'ni o'zgaruvchiga qiymat berganimizdan keyin qiymat o'zgarmaydi.Biz ushbu kontseptsiyani 3-bobdagi <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">‚ÄùO'zgaruvchilar va O'zgaruvchanlik‚Äù</a><!-- ignore --> bo'limida batafsil muhokama qilamiz. O ªzgaruvchini o ªzgaruvchan qilish uchun o ªzgaruvchi nomidan oldin <code>mut</code> qo ªshamiz:</p>
<pre><code class="language-rust ignore">let olmalar = 5; // o'zgarmas
let mut bananlar = 5; // o'zgaruvchan</code></pre>
<blockquote>
<p>Eslatma: <code>//</code> sintaksisi satr oxirigacha davom etadigan izohni
boshlaydi. Rust izohlarda hamma narsani e'tiborsiz qoldiradi.
Izohlarni <a href="ch03-04-comments.html">3-bobda</a><!-- ignore --> batafsilroq muhokama qilamiz.</p>
</blockquote>
<p>Taxmin qilish o'yin dasturiga qaytsak, endi bilasizki, <code>let mut taxmin</code> <code>taxmin</code> nomli o'zgaruvchan o'zgaruvchini kiritadi. Teng belgisi (<code>=</code>) Rustga biz hozir biror narsani o ªzgaruvchiga bog ªlamoqchi ekanligimizni bildiradi. Tenglik belgisining o'ng tomonida <code>taxmin</code> bog'langan qiymat joylashgan bo'lib, u <code>String::new</code> funksiyasini chaqirish natijasidir, bu <code>String</code>ning yangi nusxasini qaytaradi.
<a href="../std/string/struct.String.html">String</a><!-- ignore --> standart kutubxona tomonidan taqdim etilgan string turi bo'lib, u rivojlantirib boriladigan, UTF-8 kodlangan matn bitidir.</p>
<p><code>::new</code> qatoridagi <code>::</code> sintaksisi <code>new</code> <code>String</code> tipidagi bog'langan funksiya ekanligini bildiradi. <em>Assosiatsiyalangan funksiya</em> bu funksiya
turida amalga oshiriladi, bu holda <code>String</code>. Ushbu <code>new</code> funksiya yangi, bo'sh qatorni yaratadi. Siz ko'p turdagi <code>new</code> funksiyani topasiz, chunki u qandaydir yangi qiymatni yaratadigan funksiyaning umumiy nomi.</p>
<p>To'liq <code>let mut taxmin = String::new();</code> qatori hozirda <code>String</code> ning yangi, bo'sh nusxasiga bog'langan o'zgaruvchan o'zgaruvchini yaratadi.</p>
<h3 id="foydalanuvchi-malumotlarini-qabul-qilish"><a class="header" href="#foydalanuvchi-malumotlarini-qabul-qilish">Foydalanuvchi ma'lumotlarini qabul qilish</a></h3>
<p>Eslatib o'tamiz, biz dasturning birinchi qatoriga <code>use std::io;</code> bilan standart kutubxonadan input/output funksiyasini kiritgan edik. Endi biz <code>io</code> modulidan <code>stdin</code> funksiyasini chaqiramiz, bu bizga foydalanuvchi kiritishini boshqarish imkonini beradi:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut taxmin)
<span class="boring">        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Agar biz dasturning boshida <code>use std::io;</code> bilan <code>io</code> kutubxonasini import qilmagan bo'lsak, biz ushbu funktsiya chaqiruvini <code>std::io::stdin</code> sifatida yozish orqali funksiyadan foydalanishimiz xam mumkin. <code>stdin</code> funksiyasi <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore --> misolini qaytaradi, bu sizning terminalingiz uchun standart kirish uchun asosni ifodalovchi tur.</p>
<p>Keyinchalik, <code>.read_line(&amp;mut taxmin)</code> qatori foydalanuvchidan ma'lumot olish uchun standart kiritish nuqtasidagi <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--ignore --> metodini chaqiradi.
Shuningdek, foydalanuvchi kiritgan ma ºlumotlarni qaysi qatorda saqlash kerakligini aytish uchun <code>read_line</code> ga argument sifatida <code>&amp;mut taxmin</code> ni o ªtkazamiz. <code>read_line</code> ning to ªliq vazifasi foydalanuvchi nima yozganidan qat ºiy nazar standart kiritishga olish va uni satrga qo ªshishdir (uning mazmunini qayta yozmasdan), shuning uchun biz bu qatorni argument sifatida beramiz. String argumenti o'zgaruvchan bo'lishi kerak, shuning uchun metod string tarkibini o'zgartirishi mumkin.</p>
<p><code>&amp;</code> bu argument reference(havola) ekanligini bildiradi, bu sizga kodingizning bir nechta qismlariga ushbu ma'lumotni xotiraga bir necha marta nusxalash kerak bo'lmasdan bitta ma'lumotga kirish imkonini beradi. Referencelar murakkab xususiyat bo'lib, Rustning asosiy afzalliklaridan biri havolalardan foydalanish qanchalik xavfsiz va oson ekanligidir. Ushbu dasturni tugatish uchun ko'p bilimlrga ega bo'lishingiz shart emas. Hozircha siz bilishingiz kerak bo'lgan narsa shundaki, o'zgaruvchilar singari, havolalar ham standard bo'yicha o'zgarmasdir. Demak, uni o ªzgaruvchan qilish uchun <code>&amp;taxmin</code> o ªrniga <code>&amp;mut taxmin</code> yozish kerak. (4-bobda havolalar ko'proq va yaxshiroq tushuntiriladi)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="potensial-nosozlikni-result-turi-bilan-hal-qilish"><a class="header" href="#potensial-nosozlikni-result-turi-bilan-hal-qilish">Potensial nosozlikni <code>Result</code> turi bilan hal qilish</a></h3>
<p>Biz hali ham ushbu kod qatori ustida ishlayapmiz. Biz hozir matnning uchinchi qatorini muhokama qilmoqdamiz, lekin u hali ham bitta mantiqiy kod qatorining bir qismi ekanligini unutmang. Keyingi qism bu metod:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span>        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">}</span></code></pre>
<p>Biz ushbu kodni quyidagicha yozishimiz mumkin edi:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut taxmin).expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);</code></pre>
<p>Biroq, bitta uzun qatorni o'qish qiyin, shuning uchun uni bo'lish yaxshidir. <code>.method_name()</code> sintaksisi bilan metodni chaqirganda uzun qatorlarni ajratishga yordam berish uchun yangi qator va boshqa bo'shliqlarni kiritish ko'pincha oqilona. Endi bu kod nima qilishini muhokama qilaylik.</p>
<p>Yuqorida aytib o'tilganidek, <code>read_line</code> foydalanuvchi kiritgan narsani biz unga o'tkazadigan qatorga qo'yadi, lekin u <code>Result</code> qiymatini ham qaytaradi. <a href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> - ko'pincha <em>enum</em> deb ataladigan <a href="ch06-00-enums.html"><em>enumeration</em></a><!-- ignore -->, bu bir nechta mumkin bo'lgan holatlardan birida bo'lishi mumkin bo'lgan tur. Har bir mumkin bo'lgan holatni <em>variant</em> deb ataymiz.</p>
<p><a href="ch06-00-enums.html">6-bobda</a><!-- ignore --> enumlar batafsilroq yoritiladi. Ushbu <code>Result</code> turlarining maqsadi xatolarni qayta ishlash ma'lumotlarini kodlashdir.</p>
<p><code>Result</code> variantlari <code>Ok</code> va <code>Err</code>. <code>Ok</code> varianti operatsiya muvaffaqiyatli bo'lganligini bildiradi va <code>Ok</code> ichida muvaffaqiyatli yaratilgan qiymat.
<code>Err</code> varianti operatsiya bajarilmaganligini bildiradi va <code>Err</code> operatsiya qanday yoki nima uchun bajarilmagani haqida ma ºlumotni o ªz ichiga oladi.</p>
<p><code>Result</code> turidagi qiymatlar, har qanday turdagi qiymatlar kabi, ularda aniqlangan metodlarga ega. <code>Result</code> misolida siz murojat qilishingiz mumkin bo'lgan <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> metodi</a><!-- ignore --> mavjud. Agar <code>Result</code> ning ushbu namunasi <code>Err</code> qiymati bo'lsa, <code>expect</code> dasturning ishlamay qolishiga olib keladi va <code>expect</code> ga argument sifatida siz uzatgan xabarni ko'rsatadi. Agar <code>read_line</code> metodi <code>Err</code>ni qaytarsa, bu asosiy operatsion tizimdan kelgan xato natijasi bo'lishi mumkin.</p>
<p>Agar <code>Result</code>ning ushbu namunasi <code>Ok</code> qiymati bo‚Äòlsa, <code>expect</code> <code>Ok</code> ushlab turgan qaytarish qiymatini oladi va siz undan foydalanishingiz uchun aynan shu qiymatni sizga qaytaradi.
Bunday holda, bu qiymat foydalanuvchi kiritishidagi baytlar soni.</p>
<p>Agar siz <code>expect</code> ga murojat qilmasangiz, dastur kompilyatsiya qilinadi, lekin siz ogohlantirish olasiz:</p>
<pre><code class="language-console">$ cargo build
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut taxmin);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default

warning: `taxminiy_raqam` (bin &quot;taxminiy_raqam&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust <code>read_line</code> dan qaytarilgan <code>Result</code> qiymatini ishlatmaganligingiz haqida ogohlantiradi, bu dastur mumkin bo'lgan xatoni hal qilmaganligini ko'rsatadi.</p>
<p>Ogohlantirishni yo'qotishning to'g'ri yo'li aslida xatolarni qayta ishlash kodini yozishdir, ammo bizning holatlarimizda muammo yuzaga kelganda biz ushbu dasturni ishdan chiqarishni xohlaymiz, shuning uchun biz <code>expect</code> dan foydalanishimiz mumkin. Xatolarni tiklash haqida [9-bobda]recover]<!-- ignore --> bilib olasiz.</p>
<h3 id="qiymatlarni-println--bilan-chop-etish"><a class="header" href="#qiymatlarni-println--bilan-chop-etish">Qiymatlarni <code>println!</code>  bilan chop etish</a></h3>
<p>Yopuvchi jingalak qavsdan tashqari, kodda hozirgacha muhokama qilinadigan yana bitta satr mavjud:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span>    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
<span class="boring">}</span></code></pre>
<p>Ushbu satr foydalanuvchi kiritishini o'z ichiga olgan qatorni chop etadi. <code>{}</code> jingalak qavslar to'plami o'rnini egallaydi: <code>{}</code> qiymatini joyida ushlab turadigan qisqichbaqa qisqichlari deb tasavvur qiling. O'zgaruvchining qiymatini chop etishda o'zgaruvchi nomi jingalak qavslar ichiga kirishi mumkin. Ifodani baholash natijasini chop etishda format satriga bo'sh jingalak qavslarni joylashtiring, so'ngra har bir bo'sh jingalak qavs o'rnini egallagan holda bir xil tartibda chop etish uchun vergul bilan ajratilgan iboralar ro'yxati bilan format qatoriga amal qiling. O‚Äòzgaruvchini va ifoda natijasini <code>println!</code> ga bitta chaqiruvda chop etish quyidagicha ko‚Äòrinadi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} va y + 2 = {}&quot;, y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Bu kod <code>x = 5 va y + 2 = 12</code> ni chop etadi.</p>
<h3 id="birinchi-qismni-sinovdan-otkazish"><a class="header" href="#birinchi-qismni-sinovdan-otkazish">Birinchi qismni sinovdan o'tkazish</a></h3>
<p>Keling, taxmin qilish o'yinining birinchi qismini sinab ko'raylik. Uni <code>cargo run</code> yordamida ishga tushiring:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/taxminiy_raqam`
Raqamni topish o'yini!
Iltimos, taxminingizni kiriting.
6
Sizni taxminingiz: 6
</code></pre>
<p>Shu nuqtada, o'yinning birinchi qismi tugadi: biz klaviaturadan ma'lumotlarni olamiz va keyin uni chop etamiz.</p>
<h2 id="yashirin-raqam-yaratish"><a class="header" href="#yashirin-raqam-yaratish">Yashirin raqam yaratish</a></h2>
<p>Keyinchalik, foydalanuvchi taxmin qilishga harakat qiladigan maxfiy raqamni yaratishimiz kerak. Yashirin raqam har safar boshqacha bo'lishi kerak, shuning uchun o'yinni bir necha marta o'ynash qiziqarli bo'ladi. O'yin juda qiyin bo'lmasligi uchun biz 1 dan 100 gacha bo'lgan tasodifiy raqamdan foydalanamiz. Rust hali o'zining standart kutubxonasida tasodifiy raqamlar funksiyasini o'z ichiga olmaydi. Biroq, Rust jamoasi ushbu funksiyaga <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>i taqdim etadi.</p>
<h3 id="koproq-funksionallikka-ega-bolish-uchun-cratedan-foydalanish"><a class="header" href="#koproq-funksionallikka-ega-bolish-uchun-cratedan-foydalanish">Ko'proq funksionallikka ega bo'lish uchun Cratedan foydalanish</a></h3>
<p>Esda tutingki, crate Rust manba kodi fayllari to'plamidir. Biz qurayotgan loyiha <em>binary crate</em> bo'lib, u bajariladigan. <code>rand</code> crate boshqa dasturlarda foydalanish uchun mo ªljallangan va mustaqil ravishda bajarib bo ªlmaydigan kodni o ªz ichiga olgan <em>library crate</em>.</p>
<p>Cargoning tashqi cratelarni muvofiqlashtirishi bu erda Cargp haqiqatan ham ishlaydi. <code>rand</code> dan foydalanadigan kodni yozishdan oldin, biz <em>Cargo.toml</em> faylini <code>rand</code> cratesini dependency sifatida qo‚Äòshish uchun o‚Äòzgartirishimiz kerak. Hozir o‚Äòsha faylni oching va Cargo siz uchun yaratgan<code>[dependencies]</code> bo‚Äòlimi sarlavhasi ostiga quyidagi qatorni qo‚Äòshing.<code>rand</code> ni aynan bizda bo ªlganidek, ushbu versiya raqami bilan belgilaganingizga ishonch hosil qiling, aks holda ushbu qo ªllanmadagi kod misollari ishlamasligi mumkin:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p><em>Cargo.toml</em> faylida sarlavhadan keyingi hamma narsa boshqa bo'lim boshlanmaguncha davom etadigan bo'limning bir qismidir. <code>[dependencies]</code> da siz Cargo loyihangiz qaysi tashqi cratelarga bog'liqligini va bu cratelarning qaysi versiyalari kerakligini aytasiz. Bunday holda, biz <code>rand</code> crateni <code>0.8.5</code> semantik versiya spetsifikatsiyasi bilan belgilaymiz. Cargo versiya raqamlarini yozish uchun standart bo'lgan <a href="http://semver.org">Semantic Versioning</a><!-- ignore -->ni (ba'zan <em>SemVer</em> deb ataladi) tushunadi. <code>0.8.5</code> spetsifikatsiyasi aslida <code>^0.8.5</code> ning qisqartmasi bo ªlib, kamida 0.8.5, lekin 0.9.0 dan past bo ªlgan har qanday versiyani bildiradi.</p>
<p>Cargo ushbu versiyalarni 0.8.5 versiyasiga mos keladigan umumiy API-larga ega deb hisoblaydi va bu spetsifikatsiya sizga ushbu bobdagi kod bilan tuziladigan so‚Äònggi patch versiyasini olishingizni kafolatlaydi. 0.9.0 yoki undan kattaroq versiyalar quyidagi misollar ishlatadigan API bilan bir xil bo'lishi kafolatlanmaydi.</p>
<p>Endi, hech qanday kodni o'zgartirmasdan, 2-2 ro'yxatda ko'rsatilganidek, loyihani build qilaylik.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Ro'yxat 2-2: rand cratesini dependency sifatida qo'shgandan so'ng <code>cargo build</code> dan olingan natija</span></p>
<p>Siz turli xil versiya raqamlarini (lekin ularning barchasi SemVer tufayli kod bilan mos keladi!) va turli xil satrlarni (operatsion tizimga qarab) ko'rishingiz mumkin va satrlar boshqa tartibda bo'lishi mumkin.</p>
<p>Biz tashqi dependency qo'shganimizda, Cargo <a href="https://crates.io/">Crates.io</a> ma'lumotlarining nusxasi bo'lgan  <em>registry</em> dan dependency uchun zarur bo'lgan barcha narsalarning so'nggi versiyalarini oladi.Crates.io - bu Rust ekotizimidagi odamlar o'zlarining ochiq manbali Rust loyihalarini boshqalar foydalanishi uchun joylashtiradigan joy.</p>
<p>registrni yangilagandan so'ng, Cargo  <code>[dependencies]</code>  bo'limini tekshiradi va ro'yxatda hali yuklab olinmagan cratelarni yuklab oladi. Bu holatda, garchi biz faqat <code>rand</code> ni dependency sifatida ko'rsatgan bo'lsak-da, Cargo <code>rand</code> ishlashga bog'liq bo'lgan boshqa cratelarni ham oldi. Cratelarni yuklab olgandan so'ng, Rust ularni kompilyatsiya qiladi va keyin mavjud bo'lgan dependency bilan loyihani tuzadi.</p>
<p>Agar siz hech qanday o'zgartirishlarsiz darhol <code>cargo build</code> ni qayta ishga tushirsangiz, <code>Finished</code> qatoridan boshqa hech qanday natija olmaysiz. Cargo allaqachon dependencylarni yuklab olganini va kompilyatsiya qilganini biladi va siz <em>Cargo.toml</em> faylida ular haqida hech narsani o'zgartirmagansiz. Cargo, shuningdek, kodingiz haqida hech narsani o'zgartirmaganligingizni biladi, shuning uchun u ham uni qayta kompilyatsiya qilmaydi. Hech narsa qilmasdan, u shunchaki chiqib ketadi.</p>
<p>Agar siz <em>src/main.rs</em> faylini ochsangiz, ahamiyatsiz o'zgarishlarni amalga oshirsangiz va keyin uni saqlab va qayta build qilsangiz, siz faqat ikkita chiqish qatorini ko'rasiz:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Bu satrlar shuni ko'rsatadiki, Cargo faqat <em>src/main.rs</em> fayliga kichik o'zgartirishingiz bilan buildni yangilaydi. Sizning dependencylaringiz o'zgarmadi, shuning uchun Cargo allaqachon yuklab olingan va ular uchun tuzilgan narsadan qayta foydalanishi mumkinligini biladi..</p>
<h4 id="cargolock-fayli-bilan-qayta-tiklanadigan-tuzilmalarni-taminlash"><a class="header" href="#cargolock-fayli-bilan-qayta-tiklanadigan-tuzilmalarni-taminlash"><em>Cargo.lock</em> fayli bilan qayta tiklanadigan tuzilmalarni ta'minlash</a></h4>
<p>Cargoda siz yoki boshqa birov kodingizni har safar yaratganingizda bir xil artefaktni qayta tiklashingiz mumkinligini ta'minlaydigan mexanizm mavjud: Siz aksini ko'rsatmaguningizcha, cargo faqat siz ko'rsatgan dependency versiyalaridan foydalanadi. Masalan, kelasi hafta <code>rand</code> cratening 0.8.6 versiyasi chiqadi va bu versiyada muhim xatoliklar tuzatilgan, lekin u sizning kodingizni buzadigan regressiyani ham o‚Äòz ichiga oladi. Buni hal qilish uchun Rust birinchi marta  <code>cargo build</code> dasturini ishga tushirganingizda <em>Cargo.lock</em> faylini yaratadi, shuning uchun biz endi bu <em>guessing_game</em> jildida mavjud.</p>
<p>Loyihani birinchi marta yaratganingizda, Cargo mezonlarga mos keladigan dependencylarning barcha versiyalarini aniqlaydi va keyin ularni <em>Cargo.lock</em> fayliga yozadi. Keyingi loyihangizni yaratganingizda, Cargo <em>Cargo.lock</em> fayli mavjudligini ko'radi va versiyalarni qayta aniqlash uchun barcha ishlarni bajarishdan ko'ra, u erda ko'rsatilgan versiyalardan foydalanadi. Bu sizga avtomatik ravishda takrorlanadigan tuzilishga ega bo'lish imkonini beradi. Boshqacha qilib aytganda, <em>Cargo.lock</em> fayli tufayli loyihangiz aniq yangilanmaguningizcha 0.8.5 da qoladi.
<em>Cargo.lock</em> fayli qayta tiklanadigan tuzilmalar uchun muhim bo'lgani uchun u ko'pincha loyihangizdagi kodning qolgan qismi bilan manba nazoratida tekshiriladi.</p>
<h4 id="yangi-versiyani-olish-uchun-crateni-yangilash"><a class="header" href="#yangi-versiyani-olish-uchun-crateni-yangilash">Yangi versiyani olish uchun Crateni yangilash</a></h4>
<p>Crateni yangilamoqchi bo'lsangiz, Cargo <code>update</code> buyrug'ini beradi, bu buyruq <em>Cargo.lock</em> faylini e'tiborsiz qoldiradi va <em>Cargo.toml</em> dagi texnik xususiyatlaringizga mos keladigan barcha so'nggi versiyalarni aniqlaydi. Keyin Cargo ushbu versiyalarni <em>Cargo.lock</em> fayliga yozadi. Aks holda, standart bo'yicha, Cargo faqat 0.8.5 dan katta va 0.9.0 dan kichik versiyalarni qidiradi. Agar <code>rand</code> cratesi ikkita yangi 0.8.6 va 0.9.0 versiyalarini chiqargan bo'lsa, <code>cargo update</code> ni ishga tushirgan bo'lsangiz, quyidagilarni ko'rasiz:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo 0.9.0 versiyasiga e'tibor bermaydi. Bu vaqtda siz <em>Cargo.lock</em> faylingizda o ªzgarishlarni ham sezasiz, bunda siz hozir foydalanayotgan <code>rand</code>  cratesi versiyasi 0.8.6. <code>rand</code> 0.9.0 versiyasidan yoki 0.9.<em>x</em> seriyasining istalgan versiyasidan foydalanish uchun <em>Cargo.toml</em> faylini quyidagi ko ªrinishda yangilashingiz kerak bo ªladi:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>Keyingi safar <code>cargo build</code>ni ishga tushirganingizda, Cargo mavjud cratelar reestrini yangilaydi va siz ko‚Äòrsatgan yangi versiyaga muvofiq <code>rand</code> talablaringizni qayta baholaydi.</p>
<p><a href="http://doc.crates.io">Cargo</a><!-- ignore --> va uning <a href="http://doc.crates.io/crates-io.html">ekotizimlari</a><!-- ignore --> haqida ko'p gapirish mumkin, biz ularni 14-bobda muhokama qilamiz, ammo hozircha bilishingiz kerak bo'lgan narsa shu. Cargo kutubxonalarni qayta ishlatishni juda osonlashtiradi, shuning uchun Rustaceans bir nechta paketlardan yig'ilgan kichikroq loyihalarni yozishga qodir.</p>
<h3 id="tasodifiy-raqamni-yaratish"><a class="header" href="#tasodifiy-raqamni-yaratish">Tasodifiy raqamni yaratish</a></h3>
<p>Keling, taxmin qilish uchun raqam yaratishda <code>rand</code> dan foydalanishni boshlaylik. Keyingi qadam 2-3 ro'yxatda ko'rsatilganidek <em>src/main.rs</em> ni yangilashdir.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Raqamni topish o'yini!&quot;);

    let yashirin_raqam = rand::rng().random_range(1..=100);

    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);

    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);

    let mut taxmin = String::new();

    io::stdin()
        .read_line(&amp;mut taxmin)
        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);

    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
}</code></pre>
<p><span class="caption">Ro'yxat 2-3: Tasodifiy raqam yaratish uchun kod qo'shiladi</span></p>
<p>Avval <code>use rand::Rng;</code> qatorini qo'shamiz. <code>Rng</code> traiti tasodifiy sonlar generatorlari qo'llaydigan metodlarni belgilaydi va biz ushbu usullardan foydalanishimiz uchun bu trait mos bo'lishi kerak. 10-bobda traitlar batafsil yoritiladi.</p>
<p>Keyin o'rtada ikkita qator qo'shamiz. Birinchi qatorda biz <code>rand::thread_rng</code> funksiyasini chaqiramiz, bu bizga biz foydalanmoqchi bo'lgan tasodifiy sonlar generatorini beradi: joriy bajarilish oqimi uchun mahalliy bo'lgan va operatsion tizim tomonidan ekilgan. Keyin tasodifiy sonlar generatorida <code>gen_range</code> metodini chaqiramiz. Bu metod biz <code>use rand::Rng;</code>  iborasi bilan qamrab olgan <code>Rng</code> traiti bilan aniqlanadi. <code>gen_range</code> metodi argument sifatida diapazon ifodasini oladi va diapazonda tasodifiy son hosil qiladi. Biz bu yerda foydalanayotgan diapazon ifodasi turi <code>start..=end</code>  shaklini oladi va pastki va yuqori chegaralarni qamrab oladi, shuning uchun biz 1 va 100 oralig‚Äòidagi raqamni so‚Äòrash uchun <code>1..=100</code> ni belgilashimiz kerak. .</p>
<blockquote>
<p>Eslatma: Siz faqat qaysi traitlardan foydalanishni va qaysi metodlar va funktsiyalarni
cratedan chaqirishni bila olmaysiz, shuning uchun har bir crateda foydalanish bo'yicha
ko'rsatmalar mavjud. Cargo-ning yana bir qulay xususiyati shundaki, <code>cargo doc --open</code> buyrug'ini
ishga tushirish sizning barcha dependencylar tomonidan taqdim etilgan texnik hujjatlarni
mahalliy sifatida tuzadi va uni brauzeringizda ochadi. Agar siz <code>rand</code> cratedagi boshqa
funksiyalarga qiziqsangiz, masalan, <code>cargo doc --open</code> ni ishga tushiring va chap tomondagi
yon paneldagi <code>rand</code> tugmasini bosing.</p>
</blockquote>
<p>Ikkinchi yangi qator maxfiy raqamni chop etadi. Bu dasturni ishlab chiqishda uni sinab ko'rishimiz uchun foydalidir, lekin biz uni oxirgi versiyadan o'chirib tashlaymiz. Agar dastur boshlanishi bilanoq javobni chop etsa, bu unchalik o'yin emas!</p>
<p>Dasturni bir necha marta ishga tushirishga harakat qiling:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/taxminiy_raqam`
Raqamni topish o'yini!
Yashirin raqam: 7
Iltimos, taxminingizni kiriting.
4
Siznig taxminingiz: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/taxminiy_raqam`
Raqamni topish o'yini!
Yashirin raqam: 83
Iltimos, taxminingizni kiriting.
5
Siznig taxminingiz: 5
</code></pre>
<p>Siz turli xil tasodifiy raqamlarni olishingiz kerak va ularning barchasi 1 dan 100 gacha raqamlar bo'lishi kerak. Ajoyib ish!</p>
<h2 id="taxminni-maxfiy-raqam-bilan-solishtirish"><a class="header" href="#taxminni-maxfiy-raqam-bilan-solishtirish">Taxminni maxfiy raqam bilan solishtirish</a></h2>
<p>Endi bizda foydalanuvchi kiritishi va tasodifiy raqam bor, biz ularni solishtirishimiz mumkin. Ushbu qadam 2-4 ro'yxatda ko'rsatilgan. E'tibor bering, bu kod hozircha kompilatsiya bo'lmaydi, biz tushuntiramiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span>
    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);

    match taxmin.cmp(&amp;yashirin_raqam) {
        Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
        Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
        Ordering::Equal =&gt; println!(&quot;Siz yutdingiz!&quot;),
    }
}</code></pre>
<p><span class="caption">Ro'yxat 2-4: Ikki raqamni solishtirishning mumkin bo'lgan qaytish qiymatlarini boshqarish</span></p>
<p>Avval biz standart kutubxonadan <code>std::cmp::Ording</code> deb nomlangan turni olib keladigan yana bir <code>use</code> iborasini qo'shamiz. <code>Ordering</code> turi boshqa raqam bo ªlib, <code>Less</code>, <code>Greater</code> va <code>Equal</code> variantlariga ega. Bu ikkita qiymatni solishtirganda mumkin bo'lgan uchta natijadir.</p>
<p>Keyin pastki qismida <code>Ordering</code> turidan foydalanadigan beshta yangi qator qo'shamiz. <code>cmp</code> metodi ikkita qiymatni solishtiradi va uni solishtirish mumkin bo'lgan har qanday narsani chaqirish mumkin. Siz solishtirmoqchi bo'lgan narsaga reference kerak: bu yerda <code>taxmin</code> bilan <code>yashirin_raqam</code> solishtiriladi. Keyin u biz <code>use</code>  iborasi bilan qamrab olgan <code>Ordering</code>  raqamining variantini qaytaradi. Biz <code>taxmin</code> va <code>yashirin_raqam</code> qiymatlari bilan <code>cmp</code> ga murojatdan <code>Ordering</code> ning qaysi varianti qaytarilganiga qarab, keyin nima qilish kerakligini hal qilish uchun <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> ifodasidan foydalanamiz.</p>
<p><code>Match</code> ifodasi <em>arms</em> dan tuzilgan. Arm mos keladigan <em>pattern</em> va agar <code>match</code> ga berilgan qiymat armning patterniga mos kelsa, bajarilishi kerak bo'lgan koddan iborat. Rust <code>match</code> ga berilgan qiymatni oladi va har bir armning patternini o'z navbatida ko'rib chiqadi. Patternlar va <code>match</code> konstruksiyasi Rust-ning kuchli xususiyatlari hisoblanadi: ular sizning kodingiz duch kelishi mumkin bo'lgan turli vaziyatlarni ifodalash imkonini beradi va ularning barchasini boshqarishingizga ishonch hosil qiladi. Bu xususiyatlar mos ravishda 6-bobda va 18-bobda batafsil yoritiladi.</p>
<p>Keling, bu yerda ishlatadigan <code>match</code> iborasi bilan bir misolni ko'rib chiqaylik. Aytaylik, foydalanuvchi 50 ni taxmin qilgan va bu safar tasodifiy yaratilgan maxfiy raqam 38 ni tashkil qiladi.</p>
<p>Kod 50 ni 38 ga solishtirganda, <code>cmp</code> metodi <code>Ordering::Greater</code> ni qaytaradi, chunki 50 38 dan katta. <code>match</code> ifodasi <code>Ordering::Greater</code> qiymatini oladi va har bir armning patternini tekshirishni boshlaydi. U birinchi armning <code>Ordering::Less</code> patternini ko ªrib chiqadi va <code>Ordering::Greater</code> qiymati <code>Ordering::Less</code> qiymatiga mos kelmasligini ko ªradi, shuning uchun u armdagi kodga e ºtibor bermaydi va keyingi armga o ªtadi. Keyingi armning namunasi <code>Ordering::Greater</code> bo ªlib, <code>Ordering::Greater</code> bilan <em>does</em> match  keladi! O ªsha armdagi bog ªlangan kod ishga tushadi va ekranga <code>Raqam katta!</code> deb chop etiladi. <code>match</code> iborasi birinchi muvaffaqiyatli o'yindan keyin tugaydi, shuning uchun bu senariydagi oxirgi armni ko'rib chiqmaydi.</p>
<p>Biroq, 2-4 ro'yxatdagi kod hali kompilyatsiya qilinmaydi. Keling, sinab ko'raylik:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match taxmin.cmp(&amp;yashirin_raqam) {
   |                 --- ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |                 |
   |                 arguments to this function are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: associated function defined here
  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/cmp.rs:783:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `taxminiy_raqame` due to previous error
</code></pre>
<p>Xatoning asosi <em>mos kelmaydigan turlar</em> mavjudligini bildiradi. Rust kuchli, statik turdagi tizimga ega. Biroq, u ham turdagi inference ega. Biz <code>let mut taxmin = String::new()</code> deb yozganimizda, Rust <code>taxmin</code> <code>String</code> bo'lishi kerak degan xulosaga keldi va bizni turni yozishga majburlamadi. Boshqa tomondan, <code>yashirin_raqam</code> raqam turidir. Rust raqamlarining bir nechta turlari 1 dan 100 gacha qiymatga ega bo'lishi mumkin: <code>i32</code>, 32 bitli raqam; <code>u32</code>, unsigned 32-bitli raqam; <code>i64</code>, 64-bitli raqam; boshqalar kabi. Agar boshqacha ko ªrsatilmagan bo ªlsa, Rust standart bo ªyicha <code>i32</code> ga o ªrnatiladi, bu <code>yashirin_raqam</code> turiga, agar siz Rustning boshqa raqamli turini chiqarishiga olib keladigan turdagi ma ºlumotlarni boshqa joyga qo ªshmasangiz. Xatoning sababi shundaki, Rust string va raqam turini taqqoslay olmaydi.</p>
<p>Oxir-oqibat, biz dastur tomonidan kiritilgan <code>String</code> ni haqiqiy son turiga aylantirmoqchimiz, shuning uchun uni raqamli raqam bilan yashirin raqam bilan solishtirishimiz mumkin.Buni <code>main</code> funksiya tanasiga ushbu qatorni qo'shish orqali qilamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut taxmin = String::new();

    io::stdin()
        .read_line(&amp;mut taxmin)
        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);

    let taxmin: u32 = taxmin.trim().parse().expect(&quot;Iltimos, raqam yozing!&quot;);

    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);

    match taxmin.cmp(&amp;yashirin_raqam) {
        Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
        Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
        Ordering::Equal =&gt; println!(&quot;Siz yutdingiz!&quot;),
    }
<span class="boring">}</span></code></pre>
<p>Satr</p>
<pre><code class="language-rust ignore">let taxmin: u32 = taxmin.trim().parse().expect(&quot;Iltimos, raqam yozing!&quot;);</code></pre>
<p>Biz <code>taxmin</code> nomli o'zgaruvchini yaratamiz. Ammo shoshilmang, dasturda allaqachon <code>taxmin</code> nomli o'zgaruvchi mavjud emasmi? Bu shunday, lekin foydali Rust bizga <code>taxmin</code> ning oldingi qiymatini yangisi bilan ergashtirish imkonini beradi. <em>Shadowing</em> bizga ikkita noyob o ªzgaruvchini yaratish o ªrniga, <code>taxmin</code> o ªzgaruvchi nomidan qayta foydalanish imkonini beradi, masalan, <code>taxmin_str</code> va <code>taxmin</code>. Biz buni <a href="ch03-01-variables-and-mutability.html#shadowing">3-bobda</a><!-- ignore --> batafsil ko'rib chiqamiz, ammo hozircha shuni bilingki, bu xususiyat ko'pincha qiymatni bir turdan boshqa turga aylantirmoqchi bo'lganingizda ishlatiladi.</p>
<p>Biz bu yangi o'zgaruvchini <code>taxmin.trim().parse()</code> ifodasiga bog'laymiz. Ifodadagi <code>taxmin</code> matni qator sifatida kiritilgan asl <code>taxmin</code> o'zgaruvchisiga ishora qiladi. <code>String</code> misolidagi <code>trim</code> metodi boshida va oxiridagi har qanday bo‚Äòshliqni yo‚Äòq qiladi, bu qatorni faqat raqamli ma‚Äôlumotlarni o‚Äòz ichiga olishi mumkin bo‚Äòlgan <code>u32</code> bilan solishtirishimiz uchun buni qilishimiz kerak. Foydalanuvchi <code>read_line</code> ni to'ldirish uchun <span class="keystroke">enter</span>tugmasini bosib, ularni kiritishi kerak
satrga yangi satr belgisini qo'shadigan taxmin. Masalan, agar foydalanuvchi <span class="keystroke">5</span> raqamini kiritsa va va <span class="keystroke">enter</span> tugmasini bossa <code>taxmin</code> shunday ko'rinadi: <code>5\n</code>.
<code>\n</code> ‚Äúyangi qator‚Äùni bildiradi. (Windows tizimida <span class="keystroke">enter</span> tugmasini bosish natijasida carriage qaytariladi va yangi qator <code>\r\n</code> chiqadi.)
<code>trim</code> metodi <code>\n</code> yoki <code>\r\n</code>ni yo'q qiladi, natijada atigi <code>5</code> bo`ladi.</p>
<p>Satrlardagi <a href="../std/primitive.str.html#method.parse"><code>parse</code> metodi</a><!-- ignore --> qatorni boshqa turga aylantiradi.
Bu yerda biz uni stringdan raqamga aylantirish uchun foydalanamiz. Biz Rustga <code>let taxmin: u32</code> yordamida kerakli raqam turini aytishimiz kerak. <code>taxmin</code> dan keyin ikki nuqta (<code>:</code>) Rustga o'zgaruvchining turiga izoh berishimizni aytadi. Rust bir nechta o'rnatilgan raqam turlariga ega; Bu yerda ko ªrilgan <code>u32</code> unsigned, 32-bitli butun son.
Bu kichik ijobiy raqam uchun yaxshi standart tanlovdir. Boshqa raqamlar turlari haqida <a href="ch03-02-data-types.html#integer-types">3-bobda</a><!-- ignore --> bilib olasiz.</p>
<p>Bundan tashqari, ushbu misol dasturidagi <code>u32</code> annotation va <code>yashirin_raqam</code> bilan taqqoslash Rust <code>yashirin_raqam</code> ham <code>u32</code> bo'lishi kerak degan xulosaga keladi. Shunday qilib, endi taqqoslash bir xil turdagi ikkita qiymat o'rtasida bo'ladi!</p>
<p><code>parse</code> metodii faqat mantiqiy ravishda raqamlarga aylantirilishi mumkin bo'lgan belgilarda ishlaydi va shuning uchun osongina xatolarga olib kelishi mumkin. Agar, masalan, satrda <code>Aüëç%</code> bo'lsa, uni raqamga aylantirishning hech qanday metodi bo'lmaydi. Muvaffaqiyatsiz bo'lishi mumkinligi sababli, <code>parse</code> metodii <code>read_line</code> metodi kabi <code>Result</code> turini qaytaradi (oldingi [&quot;<code>Result</code> bilan potentsial muvaffaqiyatsizlikni ko'rib chiqish&quot;] bo'limida muhokama qilingan)(#handling-potential-failure-with-result)<!-- ignore-->). Biz ushbu <code>Result</code> ga yana <code>expect</code> metodini qo'llash orqali xuddi shunday munosabatda bo'lamiz. Agar <code>parse</code> qatordan raqam yarata olmagani uchun <code>Err</code> <code>Result</code> variantini qaytarsa, <code>expect</code> chaqiruvi o‚Äòyinni buzadi va biz bergan xabarni chop etadi.
Agar <code>parse</code> qatorni raqamga muvaffaqiyatli aylantira olsa, u <code>Result</code>ning <code>Ok</code> variantini qaytaradi va <code>expect</code> biz xohlagan raqamni <code>Ok</code> qiymatidan qaytaradi.</p>
<p>Endi dasturni ishga tushiramiz:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/taxminiy_raqam`
Raqamni topish o'yini!
Yashirin raqam: 58
Iltimos, taxminingizni kiriting.
  76
Sizning taxminingiz: 76
Raqam katta!
</code></pre>
<p>Yaxshi! Tahmindan oldin bo'shliqlar qo'shilgan bo'lsa ham, dastur foydalanuvchi 76 ni taxmin qilganini aniqladi. Har xil turdagi kirishlar bilan turli xatti-harakatlarni tekshirish uchun dasturni bir necha marta ishga tushiring: raqamni to'g'ri taxmin qiling, katta raqamni taxmin qiling va kichik raqamni taxmin qiling.</p>
<p>Hozir bizda o'yinning ko'p qismi ishlayapti, lekin foydalanuvchi faqat bitta taxmin qila oladi. Keling, buni loop qo'shish orqali o'zgartiraylik!</p>
<h2 id="loop-bilan-bir-nechta-taxminlarga-ruxsat-berish"><a class="header" href="#loop-bilan-bir-nechta-taxminlarga-ruxsat-berish">Loop bilan bir nechta taxminlarga ruxsat berish</a></h2>
<p><code>loop</code> kalit so'zi cheksiz tsiklni yaratadi. Biz foydalanuvchilarga raqamni taxmin qilishda ko'proq imkoniyat berish uchun tsikl qo'shamiz:
<span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);

    loop {
        println!(&quot;Iltimos, taxminingizni kiriting.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut taxmin)
</span><span class="boring">            .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span><span class="boring">        let taxmin: u32 = taxmin.trim().parse().expect(&quot;Iltimos, raqam yozing!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">
</span>        match taxmin.cmp(&amp;yashirin_raqam) {
            Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
            Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
            Ordering::Equal =&gt; println!(&quot;Siz yutdingiz!&quot;),
        }
    }
}</code></pre>
<p>Ko'rib turganingizdek, biz hamma narsani taxminiy kiritish so'rovidan boshlab tsiklga o'tkazdik. Ilova ichidagi satrlarni har birida yana to'rtta bo'sh joydan o'tkazganingizga ishonch hosil qiling va dasturni qayta ishga tushiring. Dastur endi boshqa bir taxminni abadiy yani har doim so'raydi, bu aslida yangi muammoni keltirib chiqaradi. Foydalanuvchi chiqa olmaydiganga o'xshaydi!</p>
<p>Foydalanuvchi har doim <span class="keystroke">ctrl-c</span> klaviatura yorlig'i yordamida dasturni to'xtatishi mumkin. Ammo bu to'yib bo'lmaydigan yirtqich hayvondan qochishning yana bir yo'li bor, <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">‚ÄúTaxminni maxfiy raqam bilan solishtirish‚Äú</a><!--ignore -->: mavzusidagi <code>parse</code> muhokamasida aytib o'tilganidek, agar foydalanuvchi raqam bo'lmagan javobni kiritsa, dastur buziladi. Bu yerda ko'rsatilganidek, foydalanuvchiga chiqishga ruxsat berish uchun undan foydalanishimiz mumkin</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/taxminiy_raqam`
Raqamni topish o'yini!
Yashirin raqam: 59
Iltimos, taxminingizni kiriting.
45
Sizning taxminingiz: 45
Raqam Kichik!
Iltimos, taxminingizni kiriting.
60
Sizning taxminingiz: 60
Raqam katta!
Iltimos, taxminingizni kiriting.
59
Sizning taxminingiz: 59
Siz yutdingiz!
Iltimos, taxminingizni kiriting.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>quit</code> deb yozsangiz, o‚Äòyin tugaydi, lekin siz ko‚Äòrganingizdek, boshqa raqam bo‚Äòlmagan ma‚Äôlumotlarni kiritish ham shunday bo‚Äòladi. Bu, eng kamida, suboptimaldir; Biz to'g'ri raqam taxmin qilinganda ham o'yin to'xtashini xohlaymiz.</p>
<h3 id="togri-taxmindan-keyin-chiqish"><a class="header" href="#togri-taxmindan-keyin-chiqish">To'g'ri taxmindan keyin chiqish</a></h3>
<p>Keling, foydalanuvchi g'alaba qozonganida <code>break</code> iborasini qo'shish orqali o'yinni to'xtatish uchun dasturlashtiramiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut taxmin)
</span><span class="boring">            .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span><span class="boring">        let taxmin: u32 = taxmin.trim().parse().expect(&quot;Iltimos, raqam yozing!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">
</span>        // --snip--

        match taxmin.cmp(&amp;yashirin_raqam) {
            Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
            Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Siz yutdingiz!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p><code>Siz yutdingiz!</code> so‚Äòng <code>break</code> qatorini qo‚Äòshish foydalanuvchi maxfiy raqamni to‚Äòg‚Äòri taxmin qilganda dasturni tsikldan chiqadi. Loopdan chiqish dasturdan chiqishni ham anglatadi, chunki sikl <code>main</code> ning oxirgi qismidir.</p>
<h3 id="notogri-kiritish"><a class="header" href="#notogri-kiritish">Noto'g'ri kiritish</a></h3>
<p>O'yinning xatti-harakatlarini yanada yaxshilash uchun, foydalanuvchi raqamlardan boshqa belgilar kiritganda dasturni ishdan chiqargandan ko'ra, foydalanuvchi taxmin qilishni davom ettirishi uchun o'yinni raqam bo'lmagan belgilarga e'tibor bermaslikka harakat qildiraylik. Buni 2-5 ro ªyxatda ko ªrsatilganidek, <code>taxmin</code> satrdan <code>u32</code> ga aylantirilgan qatorni o ªzgartirish orqali amalga oshirishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut taxmin = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut taxmin)
            .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);

        let taxmin: u32 = match taxmin.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Sizning taxminingiz: {taxmin}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match taxmin.cmp(&amp;yashirin_raqam) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Siz yutdingiz!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 2-5: Raqamsiz taxminga e'tibor bermaslik va dasturni ishdan chiqarish o'rniga boshqa taxminni so'rash</span></p>
<p>Xato ustida ishlamay qolishdan xatoni hal qilishga o‚Äòtish uchun biz <code>expect</code> chaqiruvidan <code>match</code> ifodasiga o‚Äòtamiz. Esda tutingki, <code>parse</code> <code>Result</code> turini qaytaradi, <code>Result</code> esa <code>Ok</code> va <code>Err</code> variantlariga ega bo'lgan raqamdir. Biz bu yerda <code>cmp</code> metodining <code>Ordering</code> natijasi bilan bo‚Äòlgani kabi <code>match</code> ifodasidan foydalanmoqdamiz.</p>
<p>Agar <code>parse</code> qatorni raqamga muvaffaqiyatli aylantira olsa, natijada olingan raqamni o'z ichiga olgan <code>Ok</code> qiymatini qaytaradi. Bu <code>Ok</code> qiymati birinchi armning patterniga mos keladi va <code>match</code> ifodasi <code>parse</code> ishlab chiqarilgan va <code>Ok</code> qiymatiga qo'ygan <code>num</code> qiymatini qaytaradi. Bu raqam biz yaratayotgan yangi <code>taxmin</code>  o'zgaruvchisida biz xohlagan joyda tugaydi</p>
<p>Agar <code>parse</code> satrni raqamga aylantira olmasa xato haqida qo'shimcha ma'lumotni o'z ichiga olgan <code>Err</code> qiymatini qaytaradi. <code>Err</code> qiymati birinchi <code>match</code> bo‚Äòlimidagi <code>Ok(num)</code> patterniga mos kelmaydi, lekin ikkinchi armdagi <code>Err(_)</code> patterniga mos keladi. Pastki chiziq, <code>_</code>, diqqatga sazovor qiymatdir; bu misolda biz barcha <code>Err</code> qiymatlariga, ular ichida qanday ma'lumotlar bo'lishidan qat'iy nazar, mos kelmoqchimiz deymiz. Shunday qilib, dastur ikkinchi armning <code>continue</code> kodini bajaradi, bu dasturga <code>loop</code> ning keyingi iteratsiyasiga o'tishni va boshqa taxminni so'rashni aytadi. Shunday qilib, dastur <code>parse</code> duch kelishi mumkin bo'lgan barcha xatolarga e'tibor bermaydi!</p>
<p>Endi dasturdagi hamma narsa kutilganidek ishlashi kerak. Keling, sinab ko'raylik:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling taxminiy_raqam v0.1.0 (file:///projects/taxminiy_raqam)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/taxminiy_raqam`
Raqamni topish o'yini!
Yashirin raqam: 61
Iltimos, taxminingizni kiriting.
10
Sizning taxminingiz: 10
Raqam Kichik!
Iltimos, taxminingizni kiriting.
99
Sizning taxminingiz: 99
Raqam katta!
Iltimos, taxminingizni kiriting.
foo
Iltimos, taxminingizni kiriting.
61
Sizning taxminingiz: 61
Siz yutdingiz!
</code></pre>
<p>Ajoyib! Bitta kichik so'nggi tweak bilan biz taxmin qilish o'yinini tugatamiz. Eslatib o'tamiz, dastur hali ham maxfiy raqamni chop etmoqda. Bu sinov uchun yaxshi ishladi, lekin o'yinni buzadi. Maxfiy raqamni chiqaradigan <code>println!</code>ni o'chirib tashlaymiz. 2-6 ro'yxat yakuniy kodni ko'rishingiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Raqamni topish o'yini!&quot;);

    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Iltimos, taxminingizni kiriting.&quot;);

        let mut taxmin = String::new();

        io::stdin()
            .read_line(&amp;mut taxmin)
            .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);

        let taxmin: u32 = match taxmin.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Sizning taxminingiz: {taxmin}&quot;);

        match taxmin.cmp(&amp;yashirin_raqam) {
            Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
            Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Siz yutdingiz!&quot;);
                break;
            }
        }
    }
}</code></pre>
<p><span class="caption">Ro'yxat 2-6: To'liq taxmin qilish o'yin kodini</span></p>
<p>Shu nuqtada, siz taxmin qilish o'yinini muvaffaqiyatli yaratdingiz. Tabriklaymiz!</p>
<h2 id="xulosa-1"><a class="header" href="#xulosa-1">Xulosa</a></h2>
<p>Ushbu loyiha sizni Rustning ko'plab yangi tushunchalari bilan tanishtirishning amaliy usuli bo'ldi: <code>let</code>, <code>match</code>, funktsiyalar, tashqi cratelardan foydalanish va boshqalar. Keyingi bir necha boblarda siz ushbu tushunchalar haqida batafsilroq bilib olasiz. 3-bob ko'pchilik dasturlash tillarida mavjud bo'lgan o'zgaruvchilar, ma'lumotlar turlari va funktsiyalari kabi tushunchalarni qamrab oladi va ulardan Rustda qanday foydalanishni ko'rsatadi. 4-bobda Rust tilini boshqa tillardan ajratib turadigan egalik huquqi o‚Äòrganiladi. 5-bobda tuzilmalar va metodlar sintaksisi muhokama qilinadi va 6-bobda enumlar qanday ishlashi tushuntiriladi.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="umumiy-dasturlash-tushunchalari"><a class="header" href="#umumiy-dasturlash-tushunchalari">Umumiy dasturlash tushunchalari</a></h1>
<p>Ushbu bob deyarli barcha dasturlash tillarida paydo bo'ladigan tushunchalarni va ular Rustda qanday ishlashini o'z ichiga oladi. Ko'pgina dasturlash tillari o'rtasida juda ko'p umumiylik mavjud. Ushbu bobda keltirilgan tushunchalarning hech biri Rustga xos emas, lekin biz ularni Rust kontekstida ko'rib chiqamiz va ushbu tushunchalardan foydalanish bo'yicha konventsiyalarni tushuntiramiz.</p>
<p>Xususan, siz o'zgaruvchilar, asosiy turlar, funktsiyalar, izohlar va control flow haqida bilib olasiz. Ushbu asoslar har bir Rust dasturida bo'ladi va ularni erta o'rganish sizga boshlash uchun kuchli asos bo'ladi.</p>
<blockquote>
<h4 id="kalit-sozlar"><a class="header" href="#kalit-sozlar">Kalit so'zlar</a></h4>
<p>Rust dasturlash tilida boshqa tillardagi kabi faqat til tomonidan foydalanish uchun ajratilgan
<em>kalit so'zlar</em> to'plami mavjud. Shuni yodda tutingki, siz ushbu so'zlarni 
o'zgaruvchilar yoki funksiyalar nomi sifatida ishlata olmaysiz. Kalit so'zlarning aksariyati
maxsus ma'noga ega va siz ulardan Rust dasturlarida turli vazifalarni bajarish
uchun foydalanasiz; ba'zilarida ular bilan bog'liq bo'lgan joriy funksionallik
yo'q, lekin kelajakda Rustga qo'shilishi mumkin bo'lgan funksiyalar uchun ajratilgan.
Kalit so'zlar ro'yxatini <a href="appendix-01-keywords.html">A ilovasida</a><!-- ignore -->. topishingiz mumkin.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ozgaruvchilar-va-ozgaruvchanlik"><a class="header" href="#ozgaruvchilar-va-ozgaruvchanlik">O'zgaruvchilar va o'zgaruvchanlik</a></h2>
<p><a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">‚ÄùO'zgaruvchilar bilan qiymatlarni saqlash‚Äù</a><!-- ignore --> bo'limida aytib o'tilganidek, standart bo'yicha o'zgaruvchilar o'zgarmasdir.Rust sizga o'z kodingizni Rust taqdim etgan xavfsizlik va qulay parallellikdan foydalanadigan tarzda yozish uchun beradigan ko'plab qulayliklardan biridir. Biroq, siz hali ham o'zgaruvchilaringizni o'zgaruvchan qilish imkoniyatiga egasiz.
Keling, Rust sizni qanday qilib va nima uchun o'zgarmaslikni afzal ko'rishga undashini va nega ba'zan siz undan voz kechishingiz mumkinligini bilib olaylik.</p>
<p>Agar o'zgaruvchi o'zgarmas bo'lsa, qiymat nomga bog'langandan keyin siz bu qiymatni o'zgartira olmaysiz. Buni ko'rsatish uchun <code>cargo new variables</code> yordamida <em>projects</em> jildingizda <em>variables</em> nomli yangi loyihani yarating.</p>
<p>Keyin, yangi <em>variables</em> jildida <em>src/main.rs</em> ni oching va uning kodini quyidagi kod bilan almashtiring. Bu kod hozircha kompilyatsiya qilinmaydi, biz avval o'zgarmaslik xatosini ko'rib chiqamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;x qiymati: {x}&quot;);
    x = 6;
    println!(&quot;x qiymati: {x}&quot;);
}</code></pre>
<p>Kodni saqlang va dasturni <code>cargo run</code> yordamida ishga tushiring. Ushbu chiqishda ko'rsatilganidek, o'zgarmaslik xatosi haqida xato xabarini olishingiz kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;x qiymati: {x}&quot;);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Ushbu misol kompilyator sizning dasturlaringizdagi xatolarni topishga qanday yordam berishini ko'rsatadi.
Kompilyatordagi xatolar sizni asabiylashtirishi mumkin, lekin aslida ular sizning dasturingiz hali siz xohlagan narsani xavfsiz bajarmayotganligini anglatadi; ular sizning yaxshi dasturchi emasligingizni bildirmaydi! Tajribali Rustaceanlar hali ham kompilyator xatolariga duch kelishadi.</p>
<p>Siz o ªzgarmas <code>x</code> o ªzgaruvchisiga ikkinchi qiymatni belgilashga harakat qilganingiz uchun ````x` o ªzgaruvchisiga ikki marta tayinlab bo ªlmaydi``` xato xabarini oldingiz.</p>
<p>O'zgarmas deb belgilangan qiymatni o'zgartirishga urinayotganda kompilyatsiya vaqtida xatolarga duch kelishimiz muhim, chunki bu holat xatolarga olib kelishi mumkin.Agar bizning kodimizning bir qismi qiymat hech qachon o'zgarmasligi haqidagi faraz asosida ishlayotgan bo'lsa va kodimizning boshqa qismi bu qiymatni o'zgartirsa, kodning birinchi qismi uni bajarish uchun mo'ljallangan narsani qilmasligi mumkin. Bunday xatoning sababini aniqlash qiyin bo'lishi mumkin, ayniqsa kodning ikkinchi qismi faqat <em>ba'zan</em> qiymatini o'zgartirganda. Rust kompilyatori qiymat o'zgarmasligini bildirganingizda, u haqiqatan ham o'zgarmasligini kafolatlaydi, shuning uchun uni o'zingiz kuzatib borishingiz shart emas. Shunday qilib, kodingizni tushunish osonroq.</p>
<p>Ammo o'zgaruvchanlik juda foydali bo'lishi mumkin va kodni yozishni qulayroq qilishi mumkin.
Garchi o ªzgaruvchilar standart bo ªyicha o ªzgarmas bo ªlsa-da, <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">2-bobda</a><!-- ignore --> bo ªlgani kabi o ªzgaruvchi nomi oldiga <code>mut</code> qo ªshish orqali ularni o ªzgaruvchan qilish mumkin. <code>mut</code> qo'shilishi, shuningdek, kodning boshqa qismlari ushbu o'zgaruvchining qiymatini o'zgartirishini ko'rsatib, kelajakdagi kod o'quvchilariga niyatni bildiradi.</p>
<p>Masalan, <em>src/main.rs</em> ni quyidagiga o'zgartiramiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;x qiymati: {x}&quot;);
    x = 6;
    println!(&quot;x qiymati: {x}&quot;);
}</code></pre></pre>
<p>Dasturni hozir ishga tushirganimizda, biz quyidagilarni olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
x qiymati: 5
x qiymati: 6
</code></pre>
<p><code>mut</code> ishlatilganda <code>x</code> ga bog‚Äòlangan qiymatni <code>5</code> dan <code>6</code> ga o‚Äòzgartirishga ruxsat beriladi. Oxir oqibat, o'zgaruvchanlikni qo'llash yoki qilmaslikni hal qilish sizga bog'liq va bu vaziyatda eng aniq deb o'ylagan narsangizga bog'liq.</p>
<h3 id="konstantalar"><a class="header" href="#konstantalar">Konstantalar</a></h3>
<p>O'zgarmas o'zgaruvchilar singari, <em>konstantalar</em> nomga bog'langan va o'zgarishi mumkin bo'lmagan qiymatlardir, lekin konstantalar va o'zgaruvchilar o'rtasida bir nechta farqlar mavjud.</p>
<p>Birinchidan, <code>mut</code> dan konstantalar bilan foydalanishga ruxsat berilmagan. Konstantalar standart bo'yicha shunchaki o'zgarmas emas - ular har doim o'zgarmasdir.Siz konstantalarni <code>let</code> kalit so'zi o'rniga <code>const</code> kalit so'zidan foydalanib e'lon qilasiz va qiymat turiga <em>annotatsiya qilinishi kerak</em>. Biz turlar va izohlarni keyingi <a href="ch03-02-data-types.html#data-types">&quot;Ma'lumotlar turlari&quot;</a><!-- ignore --> bo'limida ko'rib chiqamiz, shuning uchun hozir tafsilotlar haqida qayg'urmang. Bilingki, siz har doim turga annotate qo'yishingiz kerak.</p>
<p>Konstantalar har qanday miqyosda, shu jumladan global miqyosda e'lon qilinishi mumkin, bu ularni kodning ko'p qismlari bilishi kerak bo'lgan qiymatlar uchun foydali qiladi.</p>
<p>Oxirgi farq shundaki, konstantalar faqat ish vaqtida hisoblanishi mumkin bo'lgan qiymatning natijasi emas, balki faqat konstanta ifodaga o'rnatilishi mumkin.</p>
<p>Mana konstanta deklaratsiyaga misol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SONIYADA_UCH_SOAT: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>Konstanta nomi <code>SONIYADA_UCH_SOAT</code> va uning qiymati 60 ni (bir daqiqadagi soniyalar soni) 60 ga (bir soatdagi daqiqalar soni) 3 ga (biz hisoblamoqchi bo'lgan soatlar soni) ko'paytirish natijasiga o'rnatiladi. Rustning konstantalar uchun nomlash konventsiyasi so'zlar orasida barcha bosh harflarni pastki chiziq bilan ishlatishdir. Kompilyator kompilyatsiya vaqtida cheklangan operatsiyalar to'plamini baholashga qodir, bu bizga ushbu qiymatni 10,800 qiymatiga o'rnatmasdan, tushunish va tekshirish osonroq bo'lgan tarzda yozishni tanlash imkonini beradi.
Konstantalarni e'lon qilishda qanday operatsiyalardan foydalanish mumkinligi haqida qo'shimcha ma'lumot olish
<a href="../reference/const_eval.html">Rust Referencening konstantalar bo'limiga qarang</a></p>
<p>Konstantalar dastur ishlayotgan butun vaqt davomida, ular e'lon qilingan doirada amal qiladi. Bu xususiyat dasturning bir nechta qismlari bilishi kerak bo'lgan, masalan, o'yinning har qanday o'yinchisi olishi mumkin bo'lgan maksimal ball soni yoki yorug'lik tezligi kabi, ilova domeningizdagi qiymatlar uchun foydali konstantalarni qiladi.</p>
<p>Dasturingiz davomida ishlatiladigan qattiq kodlangan qiymatlarni konstantalar sifatida nomlash ushbu qiymatning ma'nosini kodning kelajakdagi maintainerlariga yetkazishda foydalidir. Bu, shuningdek, kodingizda faqat bitta joyga ega bo'lishga yordam beradi, agar kelajakda qattiq kodlangan qiymat yangilanishi kerak bo'lsa, o'zgartirishingiz kerak bo'ladi.</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p><a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">2-bobdagi Taxmin qilish o ªyini</a><!-- ignore --> bo ªyicha qo ªllanmada ko ªrganingizdek, oldingi o ªzgaruvchi bilan bir xil nomli yangi o ªzgaruvchini e ºlon qilishingiz mumkin.Rustaceanlarning aytishicha, birinchi o'zgaruvchi ikkinchi o'zgaruvchi tomonidan <em>shadow qilingan</em> ya'ni ikkinchi o'zgaruvchi o'zgaruvchi nomidan foydalanganda kompilyator ko'radigan narsadir.
Darhaqiqat, ikkinchi o'zgaruvchi birinchisiga shadow qilib, o'zgaruvchi nomidan har qanday foydalanishni uning o'zi shadowli bo'lmaguncha yoki doirasi tugaguncha oladi.
Biz bir xil o ªzgaruvchining nomidan foydalanib, <code>let</code> kalit so ªzidan foydalanishni quyidagi tarzda takrorlash orqali o ªzgaruvchini shadow qilishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;x ning ichki doiradagi qiymati: {x}&quot;);
    }

    println!(&quot;x qiymati: {x}&quot;);
}</code></pre></pre>
<p>Bu dastur avval <code>x</code> ni <code>5</code> qiymatiga bog'laydi. Keyin u <code>let x =</code> ni takrorlab, asl qiymatni olib, <code>1</code> qo'shish orqali yangi <code>x</code> o'zgaruvchisini yaratadi, shunda <code>x</code> qiymati <code>6</code> bo'ladi. Keyin, jingalak qavslar bilan yaratilgan ichki doirada uchinchi <code>let</code> iborasi ham <code>x</code> ga shadow qiladi va yangi o'zgaruvchini yaratadi va oldingi qiymatni <code>2</code> ga ko'paytirib, <code>x</code> ga <code>12</code> qiymatini beradi.
Bu doira tugagach, ichki shadow tugaydi va <code>x</code> <code>6</code> ga qaytadi.
Ushbu dasturni ishga tushirganimizda, u quyidagilarni chiqaradi:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
x ning ichki doiradagi qiymati: 12
x qiymati: 6
</code></pre>
<p>Shadowing o‚Äòzgaruvchini <code>mut</code> deb belgilashdan farq qiladi, chunki <code>let</code> kalit so‚Äòzidan foydalanmasdan tasodifan ushbu o‚Äòzgaruvchiga qayta tayinlashga harakat qilsak, kompilyatsiya vaqtida xatolikka yo‚Äòl qo‚Äòyamiz. <code>let</code> dan foydalanib, biz qiymat bo'yicha bir nechta o'zgarishlarni amalga oshirishimiz mumkin, lekin bu o'zgarishlar tugagandan so'ng o'zgaruvchi o'zgarmas bo'lishi mumkin.</p>
<p><code>Mut</code> va shadow o'rtasidagi boshqa farq shundaki, biz <code>let</code> kalit so'zini qayta ishlatganimizda yangi o'zgaruvchini samarali yaratayotganimiz sababli, qiymat turini o`zgartirishimiz mumkin, lekin bir xil nomni qayta ishlatishimiz ham mumkin. Misol uchun, bizning dasturimiz foydalanuvchidan bo'sh joy belgilarini kiritish orqali ba'zi matnlar orasida qancha bo'sh joy bo'lishini ko'rsatishni so'raydi va biz ushbu kiritishni raqam sifatida saqlamoqchimiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let joylar = &quot;   &quot;;
    let joylar = joylar.len();
<span class="boring">}</span></code></pre></pre>
<p>Birinchi <code>joylar</code> o'zgaruvchisi satr turi, ikkinchi <code>joylar</code> o'zgaruvchisi esa raqam turi. Shadowing shu tariqa bizni turli nomlar bilan chiqishdan saqlaydi, masalan, <code>joylar_str</code> va <code>joylar_num</code>; Buning o'rniga biz oddiyroq <code>joylar</code> nomini qayta ishlatishimiz mumkin. Biroq, bu erda ko'rsatilganidek, buning uchun <code>mut</code> dan foydalanmoqchi bo'lsak, kompilyatsiya vaqtida xatoga duch kelamiz:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut joylar = &quot;   &quot;;
    joylar = joylar.len();
<span class="boring">}</span></code></pre>
<p>Xato bizga o'zgaruvchining turini mutatsiyaga o'tkazishga ruxsat yo'qligini aytadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut joylar = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     joylar = joylar.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Endi biz o'zgaruvchilar qanday ishlashini o'rganib chiqdik, keling, ular bo'lishi mumkin bo'lgan ko'proq ma'lumotlar turlarini ko'rib chiqaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="malumotlar-turlari"><a class="header" href="#malumotlar-turlari">Ma'lumotlar turlari</a></h2>
<p>Rust-dagi har bir qiymat ma'lum bir <em>ma'lumot turiga</em> tegishli bo'lib, Rustga qanday ma'lumotlar ko'rsatilayotganligini bildiradi, shuning uchun u ushbu ma'lumotlar bilan qanday ishlashni biladi. Biz ikkita ma'lumotlar turini ko'rib chiqamiz: skalyar va birikma.</p>
<p>Esda tutingki, Rust <em>statik tarzda yozilgan</em> tildir, ya'ni kompilyatsiya vaqtida barcha o'zgaruvchilarning turlarini bilishi kerak. Kompilyator odatda qiymat va uni qanday ishlatishimiz asosida biz qaysi turdan foydalanmoqchi ekanligimiz haqida xulosa chiqarishi mumkin.
Ko‚Äòp turlar mumkin bo‚Äòlgan hollarda, masalan, 2-bobdagi <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">‚ÄúTahminni maxfiy raqam bilan solishtirish‚Äù</a><!-- ignore --> bo‚Äòlimidagi <code>parse</code> yordamida <code>String</code>ni raqamli turga o‚Äòzgartirganimizda, quyidagi turdagi izohni qo‚Äòshishimiz kerak:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let taxmin: u32 = &quot;42&quot;.parse().expect(&quot;Raqam emas!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Oldingi kodda ko'rsatilgan <code>: u32</code> turidagi izohni qo'shmasak, Rust quyidagi xatoni ko'rsatadi, ya'ni kompilyator bizdan qaysi turdan foydalanishni xohlayotganimizni bilish uchun qo'shimcha ma'lumotga muhtoj:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let taxmin = &quot;42&quot;.parse().expect(&quot;Raqam emas!&quot;);
  |         ^^^^^
  |
help: consider giving `taxmin` an explicit type
  |
2 |     let taxmin: _ = &quot;42&quot;.parse().expect(&quot;Raqam emas!&quot;);
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>Boshqa ma'lumotlar turlari uchun turli turdagi izohlarni ko'rasiz.</p>
<h3 id="skalyar-turlar"><a class="header" href="#skalyar-turlar">Skalyar Turlar</a></h3>
<p><em>Skalyar</em> turi bitta qiymatni ifodalaydi. Rust to'rtta asosiy skalyar turga ega: integerlar, floating-point number, boolean va belgilar. Siz ularni boshqa dasturlash tillaridan bilishingiz mumkin. Keling, ularning Rustda qanday ishlashini ko'rib chiqaylik.</p>
<h4 id="integer-turlari"><a class="header" href="#integer-turlari">Integer Turlari</a></h4>
<p><em>Integer</em> kasr komponenti bo‚Äòlmagan sondir. Biz 2-bobda <code>u32</code> tipidagi bitta <em>integer</em> sonni ishlatdik. Ushbu turdagi deklaratsiya u bilan bog'langan qiymat 32 bit bo'sh joyni egallagan belgisiz butun son bo'lishi kerakligini bildiradi (Signed integer sonlar <code>u</code> o'rniga <code>i</code> bilan boshlanadi). 3-1-jadvalda Rust-da o'rnatilgan integer son turlari ko'rsatilgan. Integer son qiymatining turini e'lon qilish uchun biz ushbu variantlardan foydalanishimiz mumkin.</p>
<p><span class="caption">3-1-jadval: Rustdagi Integer sonlar turlari</span></p>
<div class="table-wrapper"><table><thead><tr><th>Uzunlik</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>Signedlar kichkina <code>i</code> harfi bilan boshlanadi, Unsigned esa kichik <code>u</code> harfi bilan boshlanadi.</p>
<p>Har bir variant signed yoki unsigned bo'lishi mumkin va aniq o'lchamga ega.
<em>Signed</em> va <em>Unsigned</em> raqam manfiy bo ªlishi mumkinmi yoki yo ªqligini anglatadi, boshqacha qilib aytganda, raqam u bilan birga belgiga ega bo ªlishi (signed) bo ªlishi kerakmi yoki u faqat ijobiy bo'ladimi va shuning uchun belgisiz (unsigned) ifodalanishi mumkinmi. Bu raqamlarni qog'ozga yozishga o'xshaydi: belgi muhim bo'lsa, raqam ortiqcha yoki minus belgisi bilan ko'rsatiladi; ammo, agar raqamni ijobiy deb hisoblash xavfsiz bo'lsa, u hech qanday belgisiz ko'rsatiladi.
Signed raqamlar <a href="https://en.wikipedia.org/wiki/Two%27s_complement">ikkita to'ldiruvchi</a><!-- ignore--> ko'rinish yordamida saqlanadi.</p>
<p>Har bir signed variant -(2<sup>n - 1</sup>) dan 2<sup>n -
1</sup> -1 gacha bo'lgan raqamlarni saqlashi mumkin, bu erda <em>n</em> variant foydalanadigan bitlar soni.
Shunday qilib, <code>i8</code> -(2<sup>7</sup>) dan 2<sup>7</sup> - 1, gacha bo'lgan raqamlarni saqlashi mumkin, bu tengdir -128 dan 127 gacha.
Unsigned variantlar 0 dan 2<sup>n</sup> - 1 gacha raqamlarni saqlashi mumkin, shuning uchun <code>u8</code> 0 dan 2<sup>8</sup> - 1 gacha bo'lgan raqamlarni saqlashi mumkin, bu 0 dan 255 gacha.</p>
<p>Bundan tashqari, <code>isize</code> va <code>usize</code> turlari dasturingiz ishlayotgan kompyuterning arxitekturasiga bog'liq bo'lib, u jadvalda ‚Äúarch‚Äù sifatida ko'rsatilgan: agar siz 64 bitli arxitekturada bo'lsangiz 64 bit va 32 bitli arxitekturada bo'lsangiz 32 bit.</p>
<p>Integer sonlarni 3-2-jadvalda ko'rsatilgan istalgan shaklda yozishingiz mumkin. E'tibor bering, bir nechta raqamli turlar bo'lishi mumkin bo'lgan son harflari turni belgilash uchun <code>57u8</code> kabi tur qo'shimchasiga ruxsat beradi. Raqamni o'qishni osonlashtirish uchun <code>_</code> dan raqamli harflar ham foydalanishi mumkin, masalan, <code>1_000</code>, siz <code>1000</code> ni ko'rsatganingizdek bir xil qiymatga ega bo'ladi.</p>
<p><span class="caption">3-2-jadval: Rustdagi Integer literallar</span></p>
<div class="table-wrapper"><table><thead><tr><th>Raqamli harflar</th><th>Misol</th></tr></thead><tbody>
<tr><td>O'nlik</td><td><code>98_222</code></td></tr>
<tr><td>O'n oltilik</td><td><code>0xff</code></td></tr>
<tr><td>Sakkizlik</td><td><code>0o77</code></td></tr>
<tr><td>Ikkilik</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Bayt (faqat &quot;u8&quot;)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Xo'sh, qaysi turdagi integer sonni ishlatishni qanday bilasiz? Agar ishonchingiz komil bo'lmasa, Rustning standart sozlamalari odatda boshlash uchun yaxshi joylardir: integer son turlari standart bo'yicha <code>i32</code> dir. <code>isize</code> yoki <code>usize</code> dan foydalanadigan asosiy holat to'plamning bir turini indekslashdir.</p>
<blockquote>
<h5 id="integer-overflow"><a class="header" href="#integer-overflow">Integer Overflow</a></h5>
<p>Aytaylik, sizda 0 dan 255 gacha bo'lgan qiymatlarni ushlab turadigan <code>u8</code> tipidagi o'zgaruvchi bor.
Agar siz o'zgaruvchini ushbu diapazondan tashqaridagi qiymatga o'zgartirishga harakat qilsangiz,
masalan, 256, <em>integer overflow</em> sodir bo'ladi, bu ikki xatti-harakatdan biriga olib kelishi mumkin.
Debug mode rejimida kompilyatsiya qilayotganingizda, Rust butun sonlarning to'lib ketishini
tekshirishni o'z ichiga oladi, bu esa dasturni ishga tushirish vaqtida <em>panic</em> chiqaradi. Rust
dastur xato bilan chiqqanda <em>panicking</em> atamasini ishlatadi; Biz panic haqida 9-bobdagi
<a href="ch09-01-unrecoverable-errors-with-panic.html">‚Äú<code>panic</code> bilan tuzatib bo'lmaydigan xatolar‚Äù</a><!-- ignore -->
bo'limda batafsil ko'rib chiqamiz</p>
<p><code>--release</code> buyrug'i bilan reliz rejimida kompilyatsiya qilayotganingizda, Rust
panic keltirib chiqaradigan butun sonlarni tekshirishni <em>o'z ichiga olmaydi</em>.
overflow occur sodir bo'ladi Rust <em>ikkitasini to'ldiruvchi wrapni</em> bajaradi. Qisqa qilib
aytganda, turdagi maksimal qiymatdan kattaroq qiymatlar, tur ushlab turishi mumkin bo'lgan minimal
qiymatlargacha &quot;wrap&quot; ni tashkil qiladi. <code>u8</code> holatida 256 qiymati 0 ga, 257 qiymati
1 ga aylanadi va hokazo. Dastur panic qo'ymaydi, lekin o'zgaruvchi
siz kutgan qiymatga ega bo'lmaydi. Butun sonlarni wrapga tayanish
xato hisoblanadi. Owerflow ehtimolini aniq ko'rib chiqish uchun siz prime sonlar uchun
standart kutubxona tomonidan taqdim etilgan ushbu metodlar oilalaridan foydalanishingiz mumkin:</p>
<ul>
<li>Barcha modelarni <code>wrapping_*</code> metodlari bilan o ªrash, masalan, <code>wrapping_add</code>.</li>
<li>Agar <code>checked_*</code> metodlari owerflow bo ªlsa, <code>None</code> qiymatini qaytaring.</li>
<li>Qiymat va boolean qiymatni qaytaring, bu <code>overflowing_*</code> metodlari
bilan overflow bo'lganini ko'rsatadi.</li>
<li>Qiymatning minimal yoki maksimal qiymatlarida <code>saturating_*</code>
metodllari bilan saturate bo'lgan.</li>
</ul>
</blockquote>
<h4 id="floating-point-turlari"><a class="header" href="#floating-point-turlari">Floating-Point Turlari</a></h4>
<p>Rust shuningdek <em>floating-point raqamlar</em> uchun ikkita primitive turga ega, ular kasrli raqamlardir.
Rust-ning floating-point turlari <code>f32</code> va <code>f64</code> bo'lib, ular mos ravishda 32 bit va 64 bit o'lchamga ega.
Standart tur <code>f64</code> dir, chunki zamonaviy protsessorlarda u <code>f32</code> bilan bir xil tezlikda, lekin aniqroq bo'lishga qodir.
Barcha floating-point turlari signeddir.</p>
<p>Bu yerda harakatdagi floating-point raqamlarni ko'rsatadigan misol:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Floating-point raqamlari IEEE-754 standartiga muvofiq taqdim etiladi. <code>f32</code> turi bitta aniqlikdagi floatdir va <code>f64</code> ikki tomonlama aniqlikka ega.</p>
<h4 id="raqamli-operatsiyalar"><a class="header" href="#raqamli-operatsiyalar">Raqamli operatsiyalar</a></h4>
<p>Rust barcha turdagi raqamlar uchun kutilgan asosiy matematik operatsiyalarni qo'llab-quvvatlaydi: qo'shish, ayirish, ko'paytirish, bo'lish va qoldiq. Butun sonni bo'lish noldan eng yaqin butun songa qisqaradi. Quyidagi kod <code>let</code> iborasida har bir raqamli operatsiyadan qanday foydalanishni ko'rsatadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // qo'shish
    let qoshish = 5 + 10;

    // ayirish
    let ayrish = 95.5 - 4.3;

    // ko'paytirish
    let kopaytirish = 4 * 30;

    // bo'lish
    let bolish = 56.7 / 32.2;
    let manfiy = -5 / 3; // Natijalar -1

    // qoldiq
    let qoldiq = 43 % 5;
}</code></pre></pre>
<p>Ushbu bayonotlardagi har bir ifoda matematik operatordan foydalanadi va bitta qiymatga baholanadi, keyin esa o'zgaruvchiga bog'lanadi. <a href="appendix-02-operators.html">B ilovasi</a><!-- ignore --> da
Rust taqdim etgan barcha operatorlar ro'yxati mavjud.</p>
<h4 id="boolean-turi"><a class="header" href="#boolean-turi">Boolean turi</a></h4>
<p>Ko'pgina boshqa dasturlash tillarida bo'lgani kabi, Rust-da ham Boolean turi ikkita mumkin bo'lgan qiymatga ega: <code>true</code> va <code>false</code>. Boolean hajmi bir baytga teng.
Rustdagi boolean turi <code>bool</code> yordamida belgilanadi. Misol uchun:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // aniq turdagi izoh bilan
}</code></pre></pre>
<p>Boolean qiymatlardan foydalanishning asosiy metodi shartlardir, masalan, <code>if</code> ifodasidir. Rustda <code>if</code> iboralari qanday ishlashini <a href="ch03-05-control-flow.html#control-flow">‚ÄúControl Flow‚Äù</a><!-- ignore --> bo‚Äòlimida ko‚Äòrib chiqamiz.</p>
<h4 id="belgilarcharacter-turi"><a class="header" href="#belgilarcharacter-turi">Belgilar(Character) turi</a></h4>
<p>Rustning <code>char</code> turi tilning eng primitive alifbo turidir. Mana <code>char</code> qiymatlarini e'lon qilishning ba`zi misollari:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = '‚Ñ§'; // aniq turdagi izoh bilan
    let yurak_kozli_mushuk = 'üòª';
}</code></pre></pre>
<p>E'tibor bering, biz qo'sh tirnoq ishlatadigan satr harflaridan farqli o'laroq, <code>char</code> harflarini bitta tirnoq bilan belgilaymiz. Rustning <code>char</code> turi to'rt bayt o'lchamga ega va Unicode Scalar qiymatini ifodalaydi, ya'ni u ASCIIdan ko'ra ko'proq narsani anglatishi mumkin.
Urg'uli harflar; Xitoy, yapon va koreys belgilar; emoji; va nol kenglikdagi bo ªshliqlar Rust-dagi barcha haqiqiy <code>char</code> qiymatlaridir. Unicode Scalar qiymatlari <code>U+0000</code>dan <code>U+D7FF</code>gacha va <code>U+E000</code>dan <code>U+10FFFF</code>gacha.
Biroq, ‚Äúcharacter‚Äù aslida Unicode-da tushuncha emas, shuning uchun ‚Äúcharacter‚Äù nima ekanligi haqidagi Rustdagi <code>char</code> bilan mos kelmasligi mumkin. Biz ushbu mavzuni 8-bobdagi <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">‚ÄúUTF-8 kodlangan matnni satrlar bilan saqlash‚Äù</a><!-- ignore --> bo'limida batafsil muhokama qilamiz.</p>
<h3 id="murakkab-turlar"><a class="header" href="#murakkab-turlar">Murakkab turlar</a></h3>
<p><em>Murakkab turlar</em> bir nechta qiymatlarni bir turga to'plashi mumkin.Rust ikkita primitive birikma turiga ega: tuplelar va arraylar.</p>
<h4 id="tuple-turi"><a class="header" href="#tuple-turi">Tuple turi</a></h4>
<p><em>tuple</em> - bu turli xil turlarga ega bo'lgan bir qator qiymatlarni bitta qo'shma turga birlashtirishning umumiy metodi.Tuplelar belgilangan uzunlikka ega: bir marta e'lon qilingandan so'ng, ular o'sishi yoki kichrayishi mumkin emas.</p>
<p>Qavslar ichida vergul bilan ajratilgan qiymatlar ro'yxatini yozish orqali tuple yaratamiz. Tupledagi har bir pozitsiya o'z turiga ega va tupledagi turli qiymatlarning turlari bir xil bo'lishi shart emas. Ushbu misolda biz ixtiyoriy turdagi izohlarni qo'shdik:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p><code>tup</code> o'zgaruvchisi butun tuplega bog'lanadi, chunki tuple bitta birikma element hisoblanadi. Tupledan individual qiymatlarni olish uchun biz tuple qiymatini buzish uchun pattern moslashuvidan foydalanishimiz mumkin, masalan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;y qiymati: {y}&quot;);
}</code></pre></pre>
<p>Bu dastur avval tuple yaratadi va uni <code>tup</code> o'zgaruvchisiga bog'laydi.Keyin u <code>tup</code>ni olish va uni uchta alohida o‚Äòzgaruvchiga, <code>x</code>, <code>y</code> va <code>z</code> ga aylantirish uchun <code>let</code> bilan pattern ishlatadi. Bu  <em>destruktura</em> deb ataladi, chunki u bitta tupleni uch qismga ajratadi. Nihoyat, dastur <code>y</code> qiymatini chop etadi, bu <code>6,4</code>.</p>
<p>Shuningdek, biz to'g'ridan-to'g'ri nuqta (<code>.</code>) va undan keyin kirishni xohlagan qiymat indeksidan foydalanib, tuple elementiga kirishimiz mumkin. Misol uchun:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let besh_yuz = x.0;

    let olti_butun_tort= x.1;

    let bir = x.2;
}</code></pre></pre>
<p>Bu dastur <code>x</code> tuplesini yaratadi va so'ngra o'z indekslari yordamida tuplening har bir elementiga kiradi. Ko'pgina dasturlash tillarida bo'lgani kabi, tupledagi birinchi indeks 0 ga teng.</p>
<p>Hech qanday qiymatsiz tuple maxsus nomga, <em>unit</em> ega. Bu qiymat va unga mos keladigan tur <code>()</code> yoziladi va bo'sh qiymat yoki bo'sh qaytish turini ifodalaydi. Ifodalar, agar ular boshqa qiymatni qaytarmasa, bilvosita birlik qiymatini qaytaradi.</p>
<h4 id="array-turi"><a class="header" href="#array-turi">Array Turi</a></h4>
<p>Bir nechta qiymatlar to'plamiga ega bo'lishning yana bir usuli <em>array</em>dir. Tupledan farqli o'laroq, arrayning har bir elementi bir xil turdagi bo'lishi kerak. Ba'zi boshqa tillardagi arraylardan farqli o'laroq, Rustdagi arraylar belgilangan uzunlikka ega.</p>
<p>Biz arraydagi qiymatlarni kvadrat qavslar ichida vergul bilan ajratilgan ro'yxat sifatida yozamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Arraylar ma ºlumotlaringizni to ªplamga emas, balki stekga ajratishni istasangiz foydali bo ªladi (biz <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">4-bobda</a><!-- ignore -->) stek va to ªplam haqida ko ªproq gaplashamiz yoki sizda har doim ma ºlum miqdordagi elementlar mavjudligini ta ºminlashni istasangiz).
Array vektor turi kabi moslashuvchan emas. <em>Vektor</em> standart kutubxona tomonidan taqdim etilgan o'xshash to'plam turi bo'lib, uning hajmini o'stirish yoki kichraytirishi mumkin. Agar array yoki vektordan foydalanishga ishonchingiz komil bo'lmasa, vektordan foydalanishingiz mumkin.
<a href="ch08-01-vectors.html">8-bobda</a><!-- ignore --> vektorlar batafsilroq muhokama qilinadi.</p>
<p>Biroq, agar elementlar sonini o'zgartirish kerak bo'lmasligini bilsangiz, arraylar foydaliroq bo'ladi. Misol uchun, agar siz dasturda oy nomlaridan foydalansangiz, vektordan ko'ra massivdan foydalanar edingiz, chunki u har doim 12 ta elementdan iborat bo'lishini bilasiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let oylar = [&quot;Yanvar&quot;, &quot;Fevral&quot;, &quot;Mart&quot;, &quot;Aprel&quot;, &quot;May&quot;, &quot;Iyun&quot;, &quot;Iyul&quot;,
              &quot;Avgust&quot;, &quot;Setabr&quot;, &quot;Oktabr&quot;, &quot;Noyabr&quot;, &quot;Dekabr&quot;];
<span class="boring">}</span></code></pre></pre>
<p>Siz har bir element turi, nuqta-vergul va arraydagi elementlar soni bilan kvadrat qavslar yordamida array turini yozasiz, masalan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Bu erda <code>i32</code> har bir elementning turi. Nuqtali verguldan keyin <code>5</code> raqami array beshta elementdan iboratligini bildiradi.</p>
<p>Bundan tashqari, har bir element uchun bir xil qiymatni o'z ichiga olgan arrayni boshlang'ich qiymatdan keyin nuqta-vergul qo'yib, so'ngra bu yerda ko'rsatilgandek kvadrat qavs ichida array uzunligini belgilash orqali ishga tushirishingiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p><code>a</code> nomli array dastlab <code>3</code> qiymatiga o'rnatiladigan <code>5</code> elementni o'z ichiga oladi. Bu <code>let a = [3, 3, 3, 3, 3];</code> yozish bilan bir xil, ammo qisqaroq tarzda.</p>
<h5 id="array-elementlariga-kirish"><a class="header" href="#array-elementlariga-kirish">Array elementlariga kirish</a></h5>
<p>Array - bu stekda taqsimlanishi mumkin bo'lgan ma'lum, qat'iy o'lchamdagi xotiraning bitta bo'lagi. Siz indekslash yordamida array elementlariga kirishingiz mumkin, masalan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let birinchi = a[0];
    let ikkinchi = a[1];
}</code></pre></pre>
<p>Bu misolda <code>birinchi</code> deb nomlangan o‚Äòzgaruvchi <code>1</code> qiymatini oladi, chunki bu arraydagi <code>[0]</code> indeksidagi qiymatdir. <code>ikkinchi</code> deb nomlangan ozgaruvchi arraydagi <code>[1]</code> indeksidan <code>2</code> qiymatini oladi.</p>
<h5 id="yaroqsiz-array-elementlariga-kirish"><a class="header" href="#yaroqsiz-array-elementlariga-kirish">Yaroqsiz Array elementlariga kirish</a></h5>
<p>Keling, array oxiridan o‚Äòtgan array elementiga kirishga harakat qilsangiz nima bo‚Äòlishini ko‚Äòrib chiqamiz. Aytaylik, foydalanuvchidan array indeksini olish uchun 2-bobdagi taxminiy o‚Äòyinga o‚Äòxshash ushbu kodni ishlatasiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Iltimos, array indeksini kiriting.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Kiritilgan indeks raqam emas&quot;);

    let element = a[index];

    println!(&quot;{index} indeksidagi elementning qiymati: {element}&quot;);
}</code></pre>
<p>Ushbu kod muvaffaqiyatli kompilyatsiya qilinadi.Agar siz ushbu kodni <code>cargo run</code> yordamida ishga tushirsangiz va <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> yoki <code>4</code> kiritsangiz, dastur arraydagi ushbu indeksdagi mos qiymatni chop etadi. Buning o'rniga array oxiridan o'tgan raqamni kiritsangiz, masalan, <code>10</code>, siz shunday chiqishni ko'rasiz:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Dastur indekslash operatsiyasida yaroqsiz qiymatdan foydalanish nuqtasida <em>runtime</em> xatosiga olib keldi. Dastur xato xabari bilan chiqdi va yakuniy <code>println!</code> bayonotini bajarmadi. Indekslash yordamida elementga kirishga harakat qilganingizda, Rust siz ko'rsatgan indeks array uzunligidan kamroq ekanligini tekshiradi. Agar indeks uzunlikdan kattaroq yoki unga teng bo'lsa, Rust panic chiqaradi. Bu tekshirish runtimeda amalga oshirilishi kerak, ayniqsa bu holatda, chunki kompilyator foydalanuvchi kodni keyinroq ishga tushirganda qanday qiymat kiritishini bila olmaydi.</p>
<p>Bu Rustning xotira xavfsizligi tamoyillarining amaldagi namunasidir. Ko'pgina low-leveldagi tillarda bunday tekshirish amalga oshirilmaydi va noto'g'ri indeksni taqdim etganingizda, yaroqsiz xotiraga kirish mumkin. Rust xotiraga kirishga ruxsat berish va davom ettirish o'rniga darhol chiqish orqali sizni bunday xatolardan himoya qiladi. 9-bobda Rust-ning xatolarini qanday hal qilish va siz panic qo'ymaydigan va yaroqsiz xotiraga kirishga ruxsat bermaydigan o'qilishi mumkin bo'lgan xavfsiz kodni qanday yozishingiz mumkinligi muhokama qilinadi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="funksiyalar"><a class="header" href="#funksiyalar">Funksiyalar</a></h2>
<p>Funksiyalar Rust kodida keng tarqalgan. Siz allaqachon tildagi eng muhim funksiyalardan birini ko'rgansiz: ko'plab dasturlarning kirish nuqtasi bo'lgan <code>main</code> funksiya. Siz yangi funksiyalarni e'lon qilish imkonini beruvchi <code>fn</code> kalit so'zini ham ko'rdingiz.</p>
<p>Rust kodi funksiya va o ªzgaruvchilar nomlari uchun an ºanaviy uslub sifatida <em>snake case</em> dan foydalanadi, unda barcha harflar kichik va alohida so ªzlarning tagiga chiziladi.
Mana, misol funksiya ta'rifini o'z ichiga olgan dastur:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    boshqa_funksiya();
}

fn boshqa_funksiya() {
    println!(&quot;Boshqa funksiya.&quot;);
}</code></pre></pre>
<p>Rust-da funksiyani <code>fn</code> so'ng funksiya nomi va qavslar to'plamini kiritish orqali aniqlaymiz. Jingalak qavslar kompilyatorga funksiya tanasi qayerda boshlanishi va tugashini bildiradi.</p>
<p>Biz belgilagan har qanday funksiyani uning nomidan keyin qavslar to'plamini kiritish orqali chaqirishimiz mumkin. Dasturda <code>boshqa_funksiya</code> ni aniqlanganligi sababli uni <code>main</code> funksiya ichidan chaqirish mumkin. E'tibor bering, biz <code>boshqa_funksiya</code> ni manba kodidagi <code>main</code> funksiyadan keyin belgilaganmiz; uni avval ham belgilashimiz mumkin edi. Rust sizning funksiyalaringizni qayerda belgilashingizning ahamiyati yo'q, faqat ular so'rov yuboruvchi tomonidan ko'rinadigan doirada aniqlangan.</p>
<p>Keling, funksiyalarni ko'proq o'rganish uchun <em>funksiyalar</em> nomli yangi binary loyihani boshlaylik. <code>boshqa_funksiya</code> misolini <em>src/main.rs</em> ga joylashtiring va uni ishga tushiring.Quyidagi chiqishni ko'rishingiz kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Boshqa funksiya.
</code></pre>
<p>Qatorlar <code>main</code> funksiyada paydo bo'ladigan tartibda bajariladi.
Avvaliga &quot;Hello, world!&quot; xabar chop etiladi, keyin <code>boshqa_funksiya</code> chaqiriladi va uning xabari chop etiladi.</p>
<h3 id="parametrlar"><a class="header" href="#parametrlar">Parametrlar</a></h3>
<p>Biz funksiyalarni <em>parametrlari</em> bo'lishi uchun belgilashimiz mumkin, ular funksiya imzosining bir qismi bo'lgan maxsus o'zgaruvchilardir. Agar funksiya parametrlarga ega bo'lsa, siz unga ushbu parametrlar uchun aniq qiymatlarni berishingiz mumkin. Texnik jihatdan aniq qiymatlar <em>argumentlar</em> deb ataladi, ammo tasodifiy suhbatda odamlar funksiya ta ºrifidagi o ªzgaruvchilar yoki funksiyani chaqirganingizda qabul qilingan aniq qiymatlar uchun <em>parametr</em> va <em>argument</em> so ªzlarini bir-birining o ªrniga ishlatishga moyildirlar.</p>
<p><code>boshqa_funksiya</code> ning ushbu versiyasida biz parametr qo'shamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    boshqa_funksiya(5);
}

fn boshqa_funksiya(x: i32) {
    println!(&quot;x qiymati: {x}&quot;);
}</code></pre></pre>
<p>Ushbu dasturni ishga tushirishga harakat qiling; quyidagi chiqishni olishingiz kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
x qiymati: 5
</code></pre>
<p><code>boshqa_funksiya</code> deklaratsiyasi <code>x</code> nomli bitta parametrga ega. <code>x</code> turi <code>i32</code> sifatida belgilangan. Biz <code>5</code>ni <code>boshqa_funksiya</code>ga o‚Äòtkazganimizda, <code>println!</code> makros <code>5</code> ni <code>x</code>ni o‚Äòz ichiga olgan jingalak qavslar juftligi format satrida joylashgan joyga qo‚Äòyadi.</p>
<p>Funksiya signaturelarda siz har bir parametr turini e'lon qilishingiz kerak. Bu Rust dizaynidagi ataylab qabul qilingan qaror: funksiya ta ºriflarida turdagi izohlarni talab qilish kompilyatorga qaysi turni nazarda tutayotganingizni tushunish uchun ularni kodning boshqa joylarida ishlatishingizga deyarli hech qachon ehtiyoj sezmasligini anglatadi. Kompilyator, shuningdek, funksiya qanday turlarni kutayotganini bilsa, yanada foydali xato xabarlarini berishi mumkin.</p>
<p>Bir nechta parametrlarni belgilashda parametr deklaratsiyasini vergul bilan ajrating, masalan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    belgilangan_vaqt(5, 'h');
}

fn belgilangan_vaqt(value: i32, unit_label: char) {
    println!(&quot;Belgilangan Vaqt: {value}{unit_label}&quot;);
}</code></pre></pre>
<p>Ushbu misol ikkita parametrli <code>belgilangan_vaqt</code> nomli funksiyani yaratadi. Birinchi parametr <code>value</code> deb nomlangan va <code>i32</code> dir. Ikkinchisi <code>unit_label</code> deb nomlanadi va <code>char</code> turidir. Keyin funksiya <code>value</code> va ``unit_label` ni o‚Äòz ichiga olgan matnni chop etadi.</p>
<p>Keling, ushbu kodni ishga tushirishga harakat qilaylik. Hozirda <em>funksiyalar</em> loyihangizning <em>src/main.rs</em> faylidagi dasturni oldingi misol bilan almashtiring va uni <code>cargo run</code> yordamida ishga tushiring:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
Belgilangan Vaqt: 5h
</code></pre>
<p>Biz funksiyani <code>value</code> qiymati sifatida <code>5</code> va <code>unit_label</code> qiymati sifatida <code>'h'</code> deb ataganimiz sababli, dastur chiqishi ushbu qiymatlarni o`z ichiga oladi.</p>
<h3 id="statementlar-va--expressionlar"><a class="header" href="#statementlar-va--expressionlar">Statementlar va  Expressionlar</a></h3>
<p>Funksiya qismlari ixtiyoriy ravishda statement bilan tugaydigan bir qator expressionlardan iborat. Hozircha biz ko'rib chiqqan funksiyalar yakuniy expressionni o'z ichiga olmagan, lekin siz expressionni statementning bir qismi sifatida ko'rdingiz. Rust expressionga asoslangan til bo'lganligi sababli, bu tushunish uchun muhim farqdir. Boshqa tillar bir xil farqlarga ega emas, shuning uchun keling, qanday statementlar va expressionlar ekanligini va ularning farqlari funksiyalar tanasiga qanday ta'sir qilishini ko'rib chiqaylik.</p>
<ul>
<li><strong>Statementlar</strong> ba'zi amallarni bajaradigan va qiymat qaytarmaydigan ko'rsatmalardir.</li>
<li><strong>Expressionlar</strong> qiymatga baholanadi. Keling, ba'zi misollarni ko'rib chiqaylik.</li>
</ul>
<p>Biz allaqachon statementlar va expressionlarni ishlatganmiz. O'zgaruvchini yaratish va unga <code>let</code> kalit so'zi bilan qiymat berish - bu statement. 3-1 ro'yxatda <code>let y = 6;</code> - bu statement.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-1: Bitta statementni o'z ichiga olgan <code>main</code> funksiya deklaratsiyasi</span></p>
<p>Funksiya definitionlari ham statementlardir; oldingi misol o'z-o'zidan bir statementdir.</p>
<p>Statementlar qiymatlarni qaytarmaydi. Shuning uchun siz boshqa o'zgaruvchiga <code>let</code> iborasini tayinlay olmaysiz, chunki quyidagi kod bunga harakat qiladi; siz xatoga duch kelasiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>Ushbu dasturni ishga tushirganingizda, sizda paydo bo'ladigan xato quyidagicha ko'rinadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^

error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are unstable
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 3 previous errors; 1 warning emitted
</code></pre>
<p><code>let y = 6</code> statementi qiymat qaytarmaydi, shuning uchun <code>x</code> bog'lanishi uchun hech narsa yo'q. Bu boshqa tillarda sodir bo'ladigan narsadan farq qiladi, masalan, C va Ruby, bu yerda assignment assignmentning qiymatini qaytaradi. Bu tillarda siz <code>x = y = 6</code> yozishingiz mumkin va <code>x</code> va <code>y</code> ham <code>6</code> qiymatiga ega; Rustda bunday emas.</p>
<p>Expressionlar qiymatga baholanadi va siz Rust-da yozadigan kodning qolgan qismini tashkil qiladi. <code>5 + 6</code> kabi matematik amalni ko'rib chiqing, bu <code>11</code> qiymatini beruvchi expressiondir. Expressionlar statementlarning bir qismi bo'lishi mumkin: 3-1 ro'yxatdagi <code>let y = 6;</code> ifodasidagi <code>6</code>, <code>6</code> qiymatini beruvchi expressiondir. Funksiyani chaqirish expressiondir. Makroni chaqirish expressiondir. Jingalak qavslar bilan yaratilgan yangi qamrov bloki expressiondir, masalan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;y qiymati: {y}&quot;);
}</code></pre></pre>
<p>Bu expression:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>blok bo'lib, bu holda <code>4</code> ga evaluate bo'ladi. Bu qiymat <code>let</code> statementining bir qismi sifatida <code>y</code> ga bog'lanadi. E'tibor bering, &quot;<code>x + 1</code> qatorining oxirida nuqta-vergul yo'q, bu siz ko'rgan ko'pgina qatorlardan farqli o'laroq. Expressionlar yakuniy nuqtali vergullarni o'z ichiga olmaydi. Ifodaning oxiriga nuqtali vergul qo'shsangiz, uni statementga aylantirasiz va u keyinchalik qiymatni qaytarmaydi. Keyingi funksiyani qaytarish qiymatlari va expressionlarini o'rganayotganda buni yodda tuting.</p>
<h3 id="return-qiymatlari-bilan-funksiyalar"><a class="header" href="#return-qiymatlari-bilan-funksiyalar">Return qiymatlari bilan funksiyalar</a></h3>
<p>Funksiyalar qiymatlarni ularni chaqiradigan kodga return qaytarishi mumkin. Return qiymatlarini nomlamaymiz, lekin ularning turini o'qdan keyin e'lon qilishimiz kerak (<code>-&gt;</code>). Rustda funksiyaning return qiymati funksiya tanasi blokidagi yakuniy ifodaning qiymati bilan sinonimdir. Siz <code>return</code> kalit so'zidan foydalanib va qiymatni belgilash orqali funksiyadan erta qaytishingiz mumkin, lekin ko'pchilik funksiyalar oxirgi expressionni bevosita qaytaradi. Mana qiymatni return qiladigan funksiyaga misol:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn besh() -&gt; i32 {
    5
}

fn main() {
    let x = besh();

    println!(&quot;x qiymati: {x}&quot;);
}</code></pre></pre>
<p><code>besh</code> funksiyasida funksiya chaqiruvlari, makroslar va hatto <code>let</code> iboralari ham yo‚Äòq ‚Äì faqat <code>5</code> raqamining o‚Äòzi. Bu Rust-da juda to'g'ri funksiya. Funksiyaning return turi ham <code>-&gt; i32</code> sifatida ko'rsatilganligini unutmang.Ushbu kodni ishga tushirishga harakat qiling; chiqish quyidagicha ko'rinishi kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
x qiymati: 5
</code></pre>
<p><code>besh</code> dagi <code>5</code> funksiyaning return qiymatidir, shuning uchun return turi <code>i32</code>dir. Keling, buni batafsilroq ko'rib chiqaylik. Ikkita muhim bit mavjud: birinchidan, <code>let x = besh();</code> qatori biz o'zgaruvchini ishga tushirish uchun funksiyaning return qiymatidan foydalanayotganimizni ko'rsatadi. Chunki <code>besh</code> funksiyasi <code>5</code>ni qaytaradi, bu qator quyidagi bilan bir xil:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Ikkinchidan, <code>besh</code> funksiyasi hech qanday parametrga ega emas va return qiladigan qiymat turini belgilaydi, lekin funksiyaning tanasi nuqta-vergulsiz yolg‚Äòiz <code>5</code> bo‚Äòladi, chunki bu biz qiymatini qaytarmoqchi bo‚Äòlgan ifodadir.</p>
<p>Keling, yana bir misolni ko'rib chiqaylik:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = qoshilgan_bir(5);

    println!(&quot;x qiymati: {x}&quot;);
}

fn qoshilgan_bir(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>Ushbu kodni ishga tushirish <code>x qiymati: 6</code> ni chop etadi. Ammo, agar biz <code>x + 1</code> bo'lgan satr oxiriga nuqta-vergul qo'ysak, uni expressiondan statementga o'zgartirsak, xatoga yo'l qo'yamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = qoshilgan_bir(5);

    println!(&quot;x qiymati: {x}&quot;);
}

fn qoshilgan_bir(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>Ushbu kodni kompilyatsiya qilish quyidagi kabi xatoga olib keladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn qoshilgan_bir(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<p>Asosiy xato xabari, <code>mismatched types</code>(mos kelmaydigan turlar) ushbu kod bilan bog'liq asosiy muammoni ochib beradi. <code>qoshilgan_bir</code> funksiyasining ta ºrifida aytilishicha, u <code>i32</code> ni qaytaradi, lekin statementlar birlik turi bo ªlgan <code>()</code> bilan expression bo'lgan qiymatga evaluate bo'lmaydi. Shuning uchun, hech narsa return qilinmaydi, bu funksiya definitioniga zid keladi va xatolikka olib keladi. Ushbu chiqishda Rust bu muammoni tuzatishga yordam beradigan xabarni taqdim etadi: u nuqta-vergulni olib tashlashni taklif qiladi, bu xatoni tuzatadi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="izohlar"><a class="header" href="#izohlar">Izohlar</a></h2>
<p>Barcha dasturchilar o'z kodlarini tushunishni osonlashtirishga harakat qilishadi, lekin ba'zida qo'shimcha tushuntirish kerak. Bunday hollarda dasturchilar o'zlarining manba kodlarida <em>izohlar</em> qoldiradilar, ularni kompilyator e'tiborsiz qoldiradi, ammo manba kodini o'qiyotgan odamlar uchun foydali bo'lishi mumkin.</p>
<p>Mana oddiy izoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}</span></code></pre></pre>
<p>Rustda idiomatik izoh uslubi izohni ikki qiyshiq chiziq bilan boshlaydi va izoh satr oxirigacha davom etadi. Bitta satrdan tashqariga chiqadigan izohlar uchun har bir satrga <code>//</code> qo'shishingiz kerak bo'ladi, masalan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shunday qilib, biz bu erda murakkab ish qilyapmiz,
// bizga bir nechta izohlar kerak bo'ladi! Vou! Umid qilamanki,
// bu izoh nima bo'layotganini tushuntiradi.
<span class="boring">}</span></code></pre></pre>
<p>Izohlar, shuningdek, kodni o'z ichiga olgan qatorlar oxirida joylashtirilishi mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let omadli_raqam = 7; // Bugun o'zimni omadli his qilyapman
}</code></pre></pre>
<p>Ammo siz ularni ushbu formatda ko'proq ko'rasiz, izohli kod ustidagi alohida satrda izoh bilan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Bugun o'zimni omadli his qilyapman
    let omadli_raqam = 7;
}</code></pre></pre>
<p>Rustda yana bir turdagi izohlar, hujjatlar izohlari mavjud, biz ularni 14-bobning <a href="ch14-02-publishing-to-crates-io.html">‚ÄúCrates.io-ga crateni nashr qilish‚Äú</a><!-- ignore --> bo'limida muhokama qilamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Shartning <code>true</code> yoki yo'qligiga qarab ba'zi kodlarni ishga tushirish va shart <code>true</code> bo'lganda ba'zi kodlarni qayta-qayta ishga tushirish qobiliyati ko'pchilik dasturlash tillarida asosiy building bloklari hisoblanadi. Rust kodining bajarilishini nazorat qilish imkonini beruvchi eng keng tarqalgan konstruksiyalar <code>if</code> expressionlari va looplaridir.</p>
<h3 id="if-ifodalari"><a class="header" href="#if-ifodalari"><code>if</code> ifodalari</a></h3>
<p><code>if</code> ifodasi shartlarga qarab kodingizni branchga ajratish imkonini beradi. Siz shartni taqdim etasiz va keyin shunday deb aytasiz: ‚ÄúAgar bu shart bajarilsa, ushbu kod blokini ishga tushiring. Agar shart bajarilmasa, ushbu kod blokini ishga tushirmang.&quot;</p>
<p><code>If</code> ifodasini o ªrganish uchun <em>loyihalar</em> jildingizda <em>branchlar</em> nomli yangi loyiha yarating. <em>src/main.rs</em> faylida quyidagilarni kiriting:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqam = 3;

    if raqam &lt; 5 {
        println!(&quot;shart true edi&quot;);
    } else {
        println!(&quot;shart true edi&quot;);
    }
}</code></pre></pre>
<p>Barcha <code>if</code> expressionlari <code>if</code> kalit so‚Äòzidan boshlanadi, undan keyin shart keladi. Bunday holda, shart <code>raqam</code> o'zgaruvchisi 5 dan kichik qiymatga ega yoki yo'qligini tekshiradi. Agar shart <code>true</code> bo'lsa, biz kod blokini shartdan keyin darhol jingalak qavslar ichiga joylashtiramiz.
<code>if</code> expressionlaridagi shartlar bilan bog‚Äòlangan kod bloklari ba‚Äôzan <em>arms</em> deb ataladi, xuddi biz 2-bobning <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">‚ÄúTahminni maxfiy raqam bilan solishtirish‚Äù</a><!--ignore --> bo‚Äòlimida muhokama qilgan <code>match</code> expressionlaridagi qurollar kabi.</p>
<p>Ixtiyoriy ravishda, agar shart <code>false</code> deb baholansa, dasturga bajarilishi uchun muqobil kod blokini berish uchun biz tanlagan <code>else</code> expressionini ham kiritishimiz mumkin. Agar <code>else</code> ifodasini bermasangiz va shart <code>false</code> bo‚Äòlsa, dastur shunchaki <code>if</code> blokini o‚Äòtkazib yuboradi va kodning keyingi bitiga o‚Äòtadi.</p>
<p>Ushbu kodni ishga tushirishga harakat qiling; quyidagi chiqishni ko'rishingiz kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branchlar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branchlar`
shart true edi
</code></pre>
<p>Keling, nima sodir bo'lishini ko'rish uchun <code>raqam</code> qiymatini shartni <code>false</code> qiladigan qiymatga o'zgartirib ko'raylik:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let raqam = 7;
<span class="boring">
</span><span class="boring">    if raqam &lt; 5 {
</span><span class="boring">        println!(&quot;shart true edi&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;shart false edi&quot;);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Dasturni qayta ishga tushiring va natijaga qarang:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
shart false edi
</code></pre>
<p>Shuni ham ta'kidlash kerakki, ushbu koddagi shart <code>bool</code> bo'lishi kerak. Agar shart <code>bool</code> bo'lmasa, biz xatoga yo'l qo'yamiz. Masalan, quyidagi kodni ishga tushirishga harakat qiling:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let raqam = 3;

    if raqam {
        println!(&quot;raqam uchta edi&quot;);
    }
}</code></pre>
<p><code>if</code> sharti bu safar <code>3</code> qiymatiga teng bo'ladi va Rust xato qiladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if raqam {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Xato shuni ko'rsatadiki, Rust <code>bool</code> kutgan, lekin integer(butun) son olgan. Ruby va JavaScript kabi tillardan farqli o'laroq, Rust boolean bo'lmagan turlarni boolean tilga o'zgartirishga avtomatik ravishda urinmaydi. Siz aniq bo'lishingiz va har doim <code>if</code> ni mantiqiy shart sifatida ko'rsatishingiz kerak. Agar biz <code>if</code> kod bloki faqat raqam <code>0</code> ga teng bo‚Äòlmaganda ishlashini istasak, masalan, <code>if</code> ifodasini quyidagiga o‚Äòzgartirishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqam = 3;

    if raqam != 0 {
        println!(&quot;raqam noldan boshqa narsa edi&quot;);
    }
}</code></pre></pre>
<p>Ushbu kodni ishga tushirish <code>raqam noldan boshqa narsa edi</code> chop etiladi.</p>
<h4 id="else-if-bilan-bir-nechta-shartlarni-boshqarish"><a class="header" href="#else-if-bilan-bir-nechta-shartlarni-boshqarish"><code>else if</code> bilan bir nechta shartlarni boshqarish</a></h4>
<p><code>if</code> va <code>else</code> ni <code>else if</code> ifodasida birlashtirib, bir nechta shartlardan foydalanishingiz mumkin.Misol uchun:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqam = 6;

    if raqam % 4 == 0 {
        println!(&quot;raqam 4 ga bo'linadi&quot;);
    } else if raqam % 3 == 0 {
        println!(&quot;raqam 3 ga bo'linadi&quot;);
    } else if raqam % 2 == 0 {
        println!(&quot;raqam 2 ga bo'linadi&quot;);
    } else {
        println!(&quot;raqam 4, 3 yoki 2 ga bo'linmaydi&quot;);
    }
}</code></pre></pre>
<p>Ushbu dasturda to'rtta yo'l bor. Uni ishga tushirgandan so'ng siz quyidagi chiqishni ko'rishingiz kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
raqam 3 ga bo'linadi
</code></pre>
<p>Ushbu dastur bajarilganda, u har bir <code>if</code> expressionni navbatma-navbat tekshiradi va shart <code>true</code> deb baholanadigan birinchi tanani bajaradi. E'tibor bering 6, 2 ga bo'linsa ham, biz <code>son 2 ga bo'linmaydi</code> chiqishini ko'rmayapmiz va <code>else</code> blokidagi <code>raqam 4, 3 yoki 2 ga bo'linmaydi</code> matnini ko'rmaymiz.Buning sababi, Rust faqat birinchi <code>true</code> shart uchun blokni bajaradi va bir marta topilsa, qolganlarini ham tekshirmaydi.
Juda ko'p <code>else if</code> expressionlaridan foydalanish kodingizni buzishi mumkin, shuning uchun sizda bir nechta bo'lsa, kodingizni qayta tahrirlashni xohlashingiz mumkin. 6-bobda bu holatlar uchun <code>match</code> deb nomlangan kuchli Rust tarmoqli konstruksiyasi tasvirlangan.</p>
<h4 id="let-statementida-if-dan-foydalanish"><a class="header" href="#let-statementida-if-dan-foydalanish"><code>let</code> statementida <code>if</code> dan foydalanish</a></h4>
<p><code>if</code> expression bo‚Äòlganligi sababli, biz 3-2-listdagi kabi natijani o‚Äòzgaruvchiga belgilash uchun <code>let</code> statementining o‚Äòng tomonida foydalanishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let shart = true;
    let raqam = if shart { 5 } else { 6 };

    println!(&quot;Raqamning qiymati: {raqam}&quot;);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-2: <code>if</code> expressioni natijasini o‚Äòzgaruvchiga tayinlash</span></p>
<p><code>raqam</code> o'zgaruvchisi <code>if</code> expressioni natijasiga asoslangan qiymatga bog'lanadi. Nima sodir bo'lishini ko'rish uchun ushbu kodni ishga tushiring:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
Raqamning qiymati: 5
</code></pre>
<p>Esda tutingki, kod bloklari ulardagi oxirgi expressiongacha evaluate qilianadi va raqamlar o'zlari ham expressionlardir. Bu holda butun <code>if</code> expressionning qiymati qaysi kod bloki bajarilishiga bog'liq. Bu <code>if</code> ning har bir armidan result bo'lish potentsialiga ega bo'lgan qiymatlar bir xil turdagi bo'lishi kerakligini anglatadi; 3-2 ro'yxatda <code>if</code> va <code>else</code> armllarining natijalari <code>i32</code> butun sonlari edi. Agar turlar mos kelmasa(mismatched), quyidagi misolda bo'lgani kabi, biz xatoga duch kelamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let shart = true;

    let raqam = if shart { 5 } else { &quot;olti&quot; };

    println!(&quot;Raqamning qiymati: {raqam}&quot;);
}</code></pre>
<p>Ushbu kodni kompilyatsiya qilmoqchi bo'lganimizda, biz xatoga duch kelamiz. <code>if</code> va <code>else</code> armllari mos kelmaydigan qiymat turlariga ega va Rust muammoni dasturda qayerdan topish mumkinligini aniq ko'rsatadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let raqam = if shart { 5 } else { &quot;olti&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p><code>if</code> blokidagi expression butun songa, <code>else</code> blokidagi expression esa satrga baholanadi. Bu ishlamaydi, chunki o ªzgaruvchilar bitta turga ega bo ªlishi kerak va Rust kompilyatsiya vaqtida <code>raqam</code> o ªzgaruvchisi qaysi turini aniq bilishi kerak. <code>raqam</code> turini bilish kompilyatorga ushbu tur biz <code>raqam</code> ishlatadigan hamma joyda yaroqliligini tekshirish imkonini beradi. Agar <code>raqam</code> turi faqat runtimeda aniqlangan bo'lsa, Rust buni qila olmaydi; kompilyator murakkabroq bo'lar edi va agar u har qanday o'zgaruvchi uchun bir nechta gipotetik turlarni kuzatib borishi kerak bo'lsa, kod haqida kamroq kafolatlar beradi.</p>
<h3 id="looplar-bilan-takrorlash"><a class="header" href="#looplar-bilan-takrorlash">Looplar bilan takrorlash</a></h3>
<p>Ko'pincha kod blokini bir necha marta bajarish foydali bo'ladi. Ushbu vazifani bajarish uchun Rust bir nechta <em>looplarni</em> taqdim etadi, ular sikl tanasi ichidagi kod orqali oxirigacha ishlaydi va keyin darhol boshida boshlanadi. Looplar bilan tajriba o'tkazish uchun keling, <em>looplar</em> deb nomlangan yangi loyiha yarataylik.</p>
<p>Rustda uch xil looplar mavjud: <code>loop</code>, <code>while</code> va <code>for</code>. Keling, har birini sinab ko'raylik.</p>
<h4 id="kodni-loop-bilan-takrorlash"><a class="header" href="#kodni-loop-bilan-takrorlash">Kodni <code>loop</code> bilan takrorlash</a></h4>
<p><code>loop</code> kalit so'zi Rustga kod blokini abadiy qayta-qayta bajarishni yoki uni to'xtatishni aniq aytmaguningizcha bajarishni aytadi.</p>
<p>Misol tariqasida, <em>looplar</em> jildingizdagi <em>src/main.rs</em> faylini quyidagicha o'zgartiring:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;yana!&quot;);
    }
}</code></pre>
<p>Ushbu dasturni ishga tushirganimizda, dasturni qo'lda to'xtatmagunimizcha, <code>yana!</code> so'zi doimiy ravishda chop etilishini ko'ramiz.Aksariyat terminallar uzluksiz siklda ishlab qolgan dasturni to'xtatish uchun <span class="keystroke">ctrl-c</span>  klaviatura yorliqlarini qo'llab-quvvatlaydi.
Sinab ko'ring:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/looplar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/looplar`
yana!
yana!
yana!
yana!
^Cyana!
</code></pre>
<p><code>^C</code> belgisi <span class="keystroke">ctrl-c</span> tugmalarini bosgan joyni bildiradi. Kod uzilish signalini qabul qilganda siklning qayerda bo'lganiga qarab, <code>^C</code> dan keyin chop etilgan <code>yana!</code> so'zini ko'rishingiz yoki ko'rmasligingiz mumkin.</p>
<p>Yaxshiyamki, Rust kod yordamida loopdan chiqish yo'lini ham taqdim etadi. Siz dasturga siklni bajarishni qachon to'xtatish kerakligini aytish uchun <code>break</code> kalit so'zini siklga qo'yishingiz mumkin. 
Eslatib o'tamiz, biz buni 2-bobning <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">‚ÄùTo'g'ri taxmindan keyin chiqish‚Äù</a><!-- ignore --> bo'limidagi taxminiy o'yinda, foydalanuvchi to'g'ri raqamni taxmin qilish orqali o'yinda g'alaba qozonganida dasturdan chiqish uchun qilganmiz.</p>
<p>Shuningdek, biz taxmin qilish o'yinida <code>continue</code> dan foydalandik, bu siklda dasturga siklning ushbu iteratsiyasida qolgan har qanday kodni o'tkazib yuborish va keyingi iteratsiyaga o'tishni aytadi.</p>
<h4 id="looplardan-qiymatlarni-qaytarishreturn"><a class="header" href="#looplardan-qiymatlarni-qaytarishreturn">Looplardan qiymatlarni qaytarish(return)</a></h4>
<p><code>loop</code> dan foydalanishdan biri bu ish bajarilmasligi mumkin bo'lgan operatsiyani qaytadan urinish, masalan, thread o'z ishini tugatganligini tekshirish. Bundan tashqari, ushbu operatsiya natijasini kodingizning qolgan qismiga sikldan o'tkazishingiz kerak bo'lishi mumkin. Buning uchun siklni to ªxtatish uchun foydalanadigan <code>break</code> ifodasidan keyin return qilinishi kerak bo ªlgan qiymatni qo ªshishingiz mumkin; bu qiymat loopdan qaytariladi, shuning uchun uni bu yerda ko'rsatilganidek ishlatishingiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut hisoblagich = 0;

    let natija = loop {
        hisoblagich += 1;

        if hisoblagich == 10 {
            break hisoblagich * 2;
        }
    };

    println!(&quot;Natija: {natija}&quot;);
}</code></pre></pre>
<p>Loopdan oldin biz <code>hisoblagich</code> nomli o‚Äòzgaruvchini e‚Äôlon qilamiz va uni <code>0</code> ga ishga tushiramiz. Keyin sikldan qaytarilgan qiymatni ushlab turish uchun <code>natija</code> nomli o'zgaruvchini e'lon qilamiz. Loopning har bir iteratsiyasida biz <code>hisoblagich</code> o‚Äòzgaruvchisiga <code>1</code> qo‚Äòshamiz va keyin <code>hisoblagich</code> 10 ga teng yoki yo‚Äòqligini tekshiramiz. Bu bo'lganda, biz <code>hisoblagich * 2</code> qiymati bilan <code>break</code> kalit so'zidan foydalanamiz. Loopdan so'ng biz <code>natija</code> qiymatini belgilaydigan statementni tugatish uchun nuqta-verguldan foydalanamiz. Nihoyat, biz qiymatni <code>natija</code>da chop qilamiz, bu holda <code>20</code>.</p>
<h4 id="bir-nechta-looplar-orasidagi-farqni-ajratish-uchun-loop-labellari"><a class="header" href="#bir-nechta-looplar-orasidagi-farqni-ajratish-uchun-loop-labellari">Bir nechta looplar orasidagi farqni ajratish uchun loop labellari</a></h4>
<p>Agar sizda looplar ichida looplaringiz bo'lsa, o'sha nuqtada eng ichki loopga <code>break</code> va <code>continue</code> amallari qo'llaniladi. Siz ixtiyoriy ravishda siklda <em>loop label</em> belgilashingiz mumkin, undan so‚Äòng <code>break</code> yoki  <code>continue</code> bilan o‚Äòsha kalit so‚Äòzlar eng ichki loop o‚Äòrniga belgilangan loopga qo‚Äòllanilishini belgilashingiz mumkin. Loop labellari bitta tirnoqcha bilan boshlanishi kerak. Mana ikkita ichki loop bilan bir misol:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut hisob = 0;
    'hisoblash: loop {
        println!(&quot;hisob = {hisob}&quot;);
        let mut qolgan = 10;

        loop {
            println!(&quot;qolgan = {qolgan}&quot;);
            if qolgan == 9 {
                break;
            }
            if hisob == 2 {
                break 'hisoblash;
            }
            qolgan -= 1;
        }

        hisob += 1;
    }
    println!(&quot;Yakuniy hisob = {hisob}&quot;);
}</code></pre></pre>
<p>Tashqi loopda <code>'hisoblash</code> labeli bor va u 0 dan 2 gacha hisoblanadi.
Labelsiz ichki loop 10 dan 9 gacha hisoblanadi. Label ko'rsatilmagan birinchi <code>break</code> faqat ichki sikldan chiqadi. <code>break 'hisoblash;</code> statementi tashqi sikldan chiqadi. Keling kodni run qilib ko'ramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
hisob = 0
qolgan = 10
qolgan = 9
hisob = 1
qolgan = 10
qolgan = 9
hisob = 2
qolgan = 10
Yakuniy hisob = 2
</code></pre>
<h4 id="while-bilan-shartli-looplar"><a class="header" href="#while-bilan-shartli-looplar"><code>while</code> bilan shartli looplar</a></h4>
<p>Dastur ko'pincha loop ichidagi shartni evaluate qilishi kerak bo'ladi. Shart <code>true</code> bo'lsa-da, loop ishlaydi. Shart <code>true</code> bo'lishni to'xtatganda, dastur loopni to'xtatib, <code>break</code> ni chaqiradi. Bu kabi xatti-harakatlarni <code>loop</code>, <code>if</code>, <code>else</code> va <code>break</code> kombinatsiyasidan foydalanib amalga oshirish mumkin; Agar xohlasangiz, buni hozir dasturda sinab ko'rishingiz mumkin. Biroq, bu pattern shunchalik keng tarqalganki, Rustda buning uchun <code>while</code> sikli deb ataladigan o'rnatilgan til konstruktsiyasi mavjud. 3-3 ro'yxatda biz dasturni uch marta aylanish uchun <code>while</code> dan foydalanamiz, har safar sanab chiqamiz, so'ngra sikldan so'ng xabarni chop etamiz va chiqamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut raqam = 3;

    while raqam != 0 {
        println!(&quot;{raqam}!&quot;);

        raqam -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-3: Shart to'g'ri bo'lganda kodni ishga tushirish uchun <code>while</code> siklidan foydalanish</span></p>
<p>Bu konstruksiya <code>loop</code>, <code>if</code>, <code>else</code> va <code>break</code> dan foydalansangiz, zarur bo'ladigan ko'plab joylashtirishlarni yo'q qiladi va bu aniqroq bo'ladi. Shart <code>true</code> deb baholansa, kod ishlaydi; aks holda, u loopdan chiqadi.</p>
<h4 id="for-bilan-toplam-boylab-aylanish"><a class="header" href="#for-bilan-toplam-boylab-aylanish"><code>for</code> bilan to'plam bo'ylab aylanish</a></h4>
<p>Siz <code>while</code> konstruksiyasidan array kabi to‚Äòplam elementlari ustidan aylanishni tanlashingiz mumkin. Masalan, 3-4 ro'yxatdagi sikl <code>a</code> arrayidagi har bir elementni chop etadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;qiymati: {}&quot;, a[index]);

        index += 1;
    }
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-4: <code>while</code> sikli yordamida to‚Äòplamning har bir elementi bo‚Äòylab aylanish</span></p>
<p>Bu erda kod arraydagi elementlar orqali hisoblanadi. U <code>0</code> indeksidan boshlanadi va keyin arraydagi yakuniy indeksga yetguncha (ya'ni, <code>index &lt; 5</code> endi <code>true</code> bo`lmaganda) sikl davom etadi. Ushbu kodni ishga tushirish arraydagi har bir elementni chop etadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling looplar v0.1.0 (file:///projects/looplar)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/looplar`
qiymati: 10
qiymati: 20
qiymati: 30
qiymati: 40
qiymati: 50
</code></pre>
<p>Barcha besh array qiymatlari kutilganidek terminalda paydo bo'ladi. Garchi <code>index</code> bir nuqtada <code>5</code> qiymatiga yetsa ham, arraydan oltinchi qiymatni olishga urinishdan oldin sikl ishlashni to‚Äòxtatadi.</p>
<p>Biroq, bu yondashuv xatoga moyil; Agar indeks qiymati yoki test holati noto'g'ri bo'lsa, biz dasturni panic qo'yishimiz mumkin. Misol uchun, agar siz <code>a</code> arrayining ta'rifini to'rtta elementga o'zgartirsangiz, lekin shartni <code>while index &lt; 4</code> bo'lganda yangilashni unutgan bo'lsangiz, kod panic qo'zg'atadi. Bu ham sekin, chunki kompilyator sikl orqali har bir iteratsiyada indeks array chegaralarida ekanligini shartli tekshirish uchun runtime kodini qo‚Äòshadi.</p>
<p>Aniqroq variant sifatida, siz <code>for</code> siklidan foydalanishingiz va to'plamdagi har bir element uchun ba'zi kodlarni bajarishingiz mumkin. <code>for</code> sikli 3-5-ro'yxatdagi kodga o'xshaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;qiymati: {element}&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Ro'yxat 3-5: <code>for</code> `sikli yordamida to'plamning har bir elementi bo'ylab aylanish</span></p>
<p>Ushbu kodni ishga tushirganimizda, biz 3-4 ro'yxatdagi kabi natijani ko'ramiz. Eng muhimi, biz kodning xavfsizligini oshirdik va arrayning oxiridan tashqariga chiqish yoki yetarlicha uzoqqa bormaslik va ba'zi elementlarni yetishmayotganligi sababli paydo bo'lishi mumkin bo'lgan xatolar ehtimolini yo'q qildik.</p>
<p><code>for</code> siklidan foydalanib, agar siz 3-4 ro ªyxatda qo ªllanilgan metodda bo ªlgani kabi arraydagi qiymatlar sonini o ªzgartirsangiz, boshqa kodni o ªzgartirishni eslab qolishingiz shart emas.</p>
<p><code>for</code> looplarining xavfsizligi va ixchamligi ularni Rustda eng ko‚Äòp ishlatiladigan loop konstruksiyasiga aylantiradi. 3-3 ro'yxatdagi <code>while</code> siklidan foydalanilgan ortga hisoblash misolida bo'lgani kabi, ma'lum bir necha marta kodni ishlatmoqchi bo'lgan vaziyatlarda ham ko'pchilik Rustaceanlar <code>for</code> siklidan foydalanadilar. Buning yo'li standart kutubxona tomonidan taqdim etilgan <code>Range</code> dan foydalanish bo'lib, bir raqamdan boshlanib, boshqa raqamdan oldin tugaydigan barcha raqamlarni ketma-ketlikda hosil qiladi.</p>
<p>Ortga hisoblash <code>for</code> sikli va biz hali u to‚Äòg‚Äòrisida gapirmagan boshqa metod ‚Äì <code>rev</code> yordamida diapazonni teskari tomonga o‚Äòzgartirishga o‚Äòxshaydi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for raqam in (1..4).rev() {
        println!(&quot;{raqam}!&quot;);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}</code></pre></pre>
<p>Bu kod biroz chiroyliroq, shunday emasmi?</p>
<h2 id="xulosa-2"><a class="header" href="#xulosa-2">Xulosa</a></h2>
<p>Siz erishdingiz! Bu juda katta bob bo'ldi: siz o'zgaruvchilar, skalyar va compound ma'lumotlar turlari, funksiyalar, izohlar, <code>if</code> expressionlari va sikllar haqida bilib oldingiz! Ushbu bobda muhokama qilingan tushunchalar bilan mashq qilish uchun quyidagilarni amalga oshirish uchun dasturlar yaratishga harakat qiling:</p>
<ul>
<li>Haroratni Farengeyt va Selsiy o'rtasida o'zgartiring.</li>
<li><em>n</em>ta Fibonachchi raqamini yarating.</li>
<li>Qo'shiqning takrorlanishidan foydalanib, ‚ÄúRojdestvoning o'n ikki kuni‚Äú Rojdestvo qo'shig'ining so'zlarini chop eting.</li>
</ul>
<p>Davom etishga tayyor bo'lganingizda, Rustda boshqa dasturlash tillarida odatda mavjud bo'lmagan ownership(egalik) tushunchasi haqida gaplashamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownershipni-tushunish-egalik"><a class="header" href="#ownershipni-tushunish-egalik">Ownershipni tushunish (Egalik)</a></h1>
<p>Ownership Rustning eng noyob xususiyati bo'lib, tilning qolgan qismiga chuqur ta'sir ko'rsatadi. Bu Rust-ga garbage collectorga muhtoj bo'lmasdan xotira xavfsizligini kafolatlash imkonini beradi, shuning uchun ownership  qanday ishlashini tushunish muhimdir. Ushbu bobda biz ownership huquqi, shuningdek, bir nechta tegishli xususiyatlar haqida gapiramiz: borrowing, slices va Rust ma'lumotlarni xotirada qanday joylashtirishi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ownership-nima"><a class="header" href="#ownership-nima">Ownership Nima?</a></h2>
<p><em>Ownership</em>(Egalik) bu Rust dasturi xotirani qanday boshqarishini boshqaradigan qoidalar to'plami.
Barcha dasturlar ishlayotgan vaqtda kompyuter xotirasidan qanday foydalanishini boshqarishi kerak.
Ba'zi tillarda axlat yig'ish(garbage collection) mavjud bo'lib, ular dastur ishlayotgan paytda ishlatilmaydigan xotirani muntazam ravishda qidiradi; boshqa tillarda dasturchi xotirani aniq ajratishi va bo'shatishi kerak. Rust uchinchi yondashuvdan foydalanadi: xotira kompilyator tekshiradigan qoidalar to'plamiga ownership tizimi orqali boshqariladi. Agar biron bir qoidalar buzilgan bo'lsa, dastur kompilatsiya qilinmaydi. Ownership xususiyatlarining hech biri dasturingiz ishlayotgan vaqtda sekinlashtirmaydi.</p>
<p>Ownership ko'plab dasturchilar uchun yangi tushuncha bo'lganligi sababli, unga ko'nikish uchun biroz vaqt kerak bo'ladi. Yaxshi xabar shundaki, siz Rust va ownership tizimi qoidalari bilan qanchalik tajribali bo'lsangiz, xavfsiz va samarali kodni tabiiy ravishda ishlab chiqish osonroq bo'ladi. Unda davom etamiz!</p>
<p>Ownershipni tushunganingizda, Rustni noyob qiladigan xususiyatlarni tushunish uchun mustahkam asosga ega bo'lasiz. Ushbu bobda, siz juda keng tarqalgan ma'lumotlar tuzilishiga qaratilgan ba'zi misollarni orqali  ownershipni ishlashini o'rganasiz: string.</p>
<blockquote>
<h3 id="stack-va-heap"><a class="header" href="#stack-va-heap">Stack va Heap</a></h3>
<p>Ko'pgina dasturlash tillari stack va heap haqida tez-tez o'ylashingizni talab qilmaydi.
Ammo Rust kabi tizim dasturlash tilida qiymat stackda yoki heapda bo'ladimi,
til o'zini qanday tutishiga ta'sir qiladi va nima uchun siz ma'lum qarorlar
qabul qilishingiz kerak. Ownershipning qismlari stack va heapga nisbatan keyinchalik
ushbu bobda tasvirlanadi, shuning uchun bu yerda tayyorgarlik jarayonida qisqacha 
tushuntirish berilgan.</p>
<p>Stack ham, heap ham runtimeda foydalanish uchun kodingiz uchun mavjud bo'lgan 
xotira qismlaridir, lekin ular turli yo'llar bilan tuzilgan. Stack qiymatlarni
ularni olgan tartibda saqlaydi va qiymatlarni teskari tartibda o'chiradi
Bu <em>oxirgi kelgan, birinchi chiqqan</em> deb ataladi. Plitalar stackini o'ylab
ko'ring: ko'proq plastinka qo'shsangiz, ularni qoziqning ustiga qo'yasiz va plastinka
kerak bo'lganda, siz yuqoridan birini olib qo'yasiz. Plitalarni o'rtadan yoki pastdan
qo'shish yoki olib tashlash ham ishlamaydi! Ma'lumotlarni qo'shish <em>stackga qo'shish</em>,
ma'lumotlarni olib tashlash esa <em>stackdan o'chirish</em> deb ataladi. Stackda saqlangan
barcha ma'lumotlar ma'lum, qat'iy belgilangan hajmga ega bo'lishi kerak. Kompilyatsiya vaqtida
noma'lum o'lchamli yoki o'zgarishi mumkin bo'lgan o'lchamdagi ma'lumotlar esa heapda
saqlanishi kerak.</p>
<p>heap kamroq tartibga solingan: ma'lumotlarni heapga qo'yganingizda, ma'lum miqdorda
bo'sh joy talab qilasiz. Xotira ajratuvchisi(memory allocator) heapda yetarlicha katta bo'lgan bo'sh joyni
topadi, uni ishlatilayotgan deb belgilaydi va o'sha joyning manzili bo'lgan
<em>pointerni</em> ni qaytaradi. Bu jarayon <em>heap allocating</em> deb ataladi va ba'zan
faqat <em>allocating</em> deb qisqartiriladi (qiymatlarni stackga qo'shish ajratish
hisoblanmaydi). Heapga pointer ma'lum, qat'iy o'lcham bo'lgani uchun siz
pointerni stackda saqlashingiz mumkin, lekin yaroqli ma'lumotlarni
olishni istasangiz, pointergaga amal qilishingiz kerak. Restoranda o'tirganingizni
o'ylab ko'ring. Kirish paytida siz guruhingizdagi odamlar sonini bildirasiz
va uy egasi hammaga mos keladigan bo'sh stol topadi va sizni u yerga olib boradi.
Agar guruhingizdagi kimdir kechikib kelsa, sizni topish uchun qayerda o'tirganingizni
so'rashi mumkin.</p>
<p>stackga qo'shish heapda allocating qilishdan tezroq bo'ladi, chunki allacator hech
qachon yangi ma'lumotlarni saqlash uchun joy izlamasligi kerak; bu joy har doim
stackning yuqori qismida joylashgan. Nisbatan, heapda bo'sh joy ajratish ko'proq
mehnat talab qiladi, chunki allacator avval ma'lumotlarni saqlash uchun yetarlicha
katta joy topishi va keyingi allocatinga tayyorgarlik ko'rish uchun buxgalteriya
hisobini amalga oshirishi kerak.</p>
<p>Heapdagi ma'lumotlarga kirish stackdagi ma'lumotlarga kirishdan ko'ra sekinroq, chunki u yerga 
borish uchun pointerga amal qilishingiz kerak. Zamonaviy protsessorlar xotirada
kamroq o'tishsa, tezroq ishlaydi. O'xshashlikni davom ettirib, ko'plab jadvallardan
buyurtmalarni qabul qiladigan restoran serverini ko'rib chiqing. Keyingi stolga o'tishdan oldin
barcha buyurtmalarni bitta stolda olish eng samarali hisoblanadi. A jadvalidan
buyurtma olish, keyin B jadvalidan buyurtma olish, keyin yana A dan va yana B dan bitta
buyurtma olish ancha sekinroq jarayon bo'ladi. Xuddi shu qoidaga ko'ra,
protsessor uzoqroqda emas (u heapda bo'lishi mumkin) emas, balki boshqa
ma'lumotlarga yaqin (stackdagi kabi) ma'lumotlarda ishlasa, o'z ishini yaxshiroq
bajarishi mumkin.</p>
<p>Sizning kodingiz funksiyani chaqirganda, funksiyaga o'tgan qiymatlar (shu jumladan, potentsial,
heapdagi ma'lumotlarga pointerlar) va funksiyaning mahalliy o'zgaruvchilari
stackga qo'shiladi. Funktsiya tugagach, bu qiymatlar stackdan chiqariladi.</p>
<p>Kodning qaysi qismlari heapda qaysi ma'lumotlardan foydalanayotganini kuzatib borish,
heapdagi takroriy ma'lumotlar miqdorini minimallashtirish va bo'sh joy qolmasligi uchun
heapdagi foydalanilmagan ma'lumotlarni tozalash - bularning barchasi ownership hal qiladigan 
muammolardir. Ownershipni tushunganingizdan so'ng, stack va heap haqida tez-tez
o'ylashingiz shart emas, lekin ownership qilishning asosiy maqsadi heap
ma'lumotlarni boshqarish ekanligini bilish uning nima uchun shunday ishlashini
tushuntirishga yordam beradi.</p>
</blockquote>
<h3 id="ownership-qoidalari"><a class="header" href="#ownership-qoidalari">Ownership qoidalari</a></h3>
<p>Birinchidan, ownership qoidalarini ko'rib chiqaylik.Biz ularni ko'rsatadigan misollar bilan ishlashda ushbu qoidalarni yodda tuting:</p>
<ul>
<li>Rust-dagi har bir qiymat <em>owner</em>ga ega.</li>
<li>Bir vaqtning o'zida faqat bitta owneri bo'lishi mumkin.</li>
<li>Owneri amaldan tashqariga chiqsa, qiymat o'chiriladi.</li>
</ul>
<h3 id="ozgaruvchan-scope"><a class="header" href="#ozgaruvchan-scope">O'zgaruvchan Scope</a></h3>
<p>Endi biz Rustning asosiy sintaksisidan o‚Äòtganimiz uchun, biz barcha <code>fn main() {</code> kodini misollarga kiritmaymiz, shuning uchun agar kuzatib boradigan bo‚Äòlsangiz, quyidagi misollarni <code>main</code> funksiyasiga qo‚Äòlda kiritganingizga ishonch hosil qiling. Natijada, bizning misollarimiz biroz ixchamroq bo'ladi, bu bizga boilerplate kodiga emas, balki haqiqiy tafsilotlarga e'tibor berishga imkon beradi.</p>
<p>Ownershipning birinchi misoli sifatida biz ba'zi o'zgaruvchilarning <em>scope</em>ni ko'rib chiqamiz. Scope - dastur doirasidagi element amal qiladigan diapazon. Quyidagi o'zgaruvchini oling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;salom&quot;;
<span class="boring">}</span></code></pre></pre>
<p><code>s</code> o'zgaruvchisi satr literaliga ishora qiladi, bu yerda satr qiymati dasturimiz matniga qattiq kodlangan. O'zgaruvchi e'lon qilingan paytdan boshlab joriy <em>scopning</em> oxirigacha amal qiladi. 4-1 ro'yxatida <code>s</code> o'zgaruvchisi qayerda to'g'ri bo'lishini izohlovchi izohlar bilan dastur ko'rsatilgan.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s bu erda haqiqiy emas, u hali e'lon qilinmagan
        let s = &quot;salom&quot;;   // s shu nuqtadan boshlab amal qiladi

        // s bilan ish bajaring
    }                      // bu scope endi tugadi va s endi haqiqiy emas
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 4-1: O'zgaruvchi va uning amal qiladigan doirasi</span></p>
<p>Boshqacha qilib aytganda, bu yerda ikkita muhim nuqta bor:</p>
<ul>
<li>Qachonki <code>s</code> <em>scopega</em> kirsa, u amal qiladi.</li>
<li>U scopedan tashqariga <em>chiqmaguncha</em> amal qiladi.</li>
</ul>
<p>Ushbu nuqtada, scopelar va o'zgaruvchilarning yaroqliligi o'rtasidagi munosabatlar boshqa dasturlash tillaridagiga o'xshaydi. Endi biz <code>String</code> turini joriy qilish orqali ushbu tushunchaga asoslanamiz.</p>
<h3 id="string-turi"><a class="header" href="#string-turi"><code>String</code> turi</a></h3>
<p>Ownership qoidalarini tasvirlash uchun bizga 3-bobning <a href="ch03-02-data-types.html#data-types">‚ÄùMa'lumotlar turlari‚Äù</a><!-- ignore -->
bo'limida ko'rib chiqilganlarga qaraganda murakkabroq ma'lumotlar turi kerak. Oldin ko'rib chiqilgan turlar ma'lum o'lchamga ega bo'lib, ular stackda saqlanishi va qo'llanilish doirasi tugagach, stackdan o'chirilishi mumkin va agar kodning boshqa qismi foydalanishi kerak bo'lsa yangi, mustaqil misol yaratish uchun tez va ahamiyatsiz nusxa ko'chirilishi mumkin kodning boshqa qismi bir xil qiymatni boshqa doirada ishlatishi kerak. Ammo biz heapda saqlangan ma'lumotlarni ko'rib chiqmoqchimiz va Rust bu ma'lumotlarni qachon tozalashni bilishini o'rganmoqchimiz va <code>String</code> turi ajoyib misoldir.</p>
<p>Biz <code>String</code> ning ownership bilan bog'liq qismlariga e'tibor qaratamiz. Ushbu jihatlar standart kutubxona tomonidan taqdim etilganmi yoki siz yaratganmi, boshqa murakkab ma'lumotlar turlariga ham tegishli.
Biz <a href="ch08-02-strings.html">8-bobda</a><!-- ignore --> <code>String</code>ni chuqurroq muhokama qilamiz.</p>
<p>Biz allaqachon string literallarini ko'rdik, bu yerda string qiymati bizning dasturimizga qattiq kodlangan. String literallari qulay, ammo ular biz matndan foydalanmoqchi bo'lgan har qanday vaziyatga mos kelmaydi. Buning sabablaridan biri shundaki, ular o'zgarmasdir. Yana bir narsa shundaki, biz kodni yozganimizda har bir satr qiymatini bilish mumkin emas: masalan, agar biz foydalanuvchi ma'lumotlarini olib, uni saqlamoqchi bo'lsak-chi? Bunday holatlar uchun Rust ikkinchi string turiga ega, <code>String</code>. Bu tur heapda ajratilgan ma'lumotlarni boshqaradi va shuning uchun kompilyatsiya vaqtida bizga noma'lum bo'lgan matn miqdorini saqlashi mumkin. Siz <code>from</code> funksiyasidan foydalanib satr literalidan <code>String</code> yaratishingiz mumkin, masalan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;salom&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Ikki nuqtali <code>::</code> operatori bizga <code>string_from</code> kabi qandaydir nomdan foydalanish o'rniga <code>String</code> turi ostida ushbu <code>from</code> funksiyasini nom maydoniga qo`yish imkonini beradi.
Biz ushbu sintaksisni 5-bobning <a href="ch05-03-method-syntax.html#method-syntax">‚ÄùMetod sintaksisi‚Äù</a><!-- ignore --> bo'limida ko'proq muhokama qilamiz va 7-bobdagi <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄùModul treedagi elementga murojaat qilish yo'llari‚Äù</a><!-- ignore --> da modullar bilan nomlar oralig'i haqida gapiramiz.</p>
<p>Ushbu turdagi <em>string</em> mutatsiyaga uchragan bo'lishi mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;salom&quot;);

    s.push_str(&quot;, dunyo!&quot;); // push_str() satrga literal qo'shadi

    println!(&quot;{}&quot;, s); // Bu ‚Äúsalom, dunyo!‚Äù deb chop etiladi
<span class="boring">}</span></code></pre></pre>
<p>Xo'sh, bu yerda qanday farq bor? Nima uchun <code>String</code> ni mutatsiyaga solish mumkin, lekin harflarni o'zgartirish mumkin emas? Farqi bu ikki turning xotira bilan qanday munosabatda bo'lishida.</p>
<h3 id="xotira-va-taqsimlashallocation"><a class="header" href="#xotira-va-taqsimlashallocation">Xotira va Taqsimlash(Allocation)</a></h3>
<p>String literalida biz kompilyatsiya vaqtida tarkibni bilamiz, shuning uchun matn to'g'ridan-to'g'ri yakuniy bajariladigan faylga qattiq kodlangan.Shuning uchun string literallari tez va samarali. Ammo bu xususiyatlar faqat satr literalining o'zgarmasligidan kelib chiqadi. Afsuski, kompilyatsiya vaqtida hajmi noma'lum bo'lgan va dasturni ishga tushirishda hajmi o'zgarishi mumkin bo'lgan har bir matn bo'lagi uchun biz binary faylga bir bo'lak xotira qo'ya olmaymiz.</p>
<p><code>String</code> turida o'zgaruvchan, o'sib boradigan matn qismini qo'llab-quvvatlash uchun tarkibni saqlash uchun kompilyatsiya vaqtida noma'lum bo'lgan xotira hajmini yig'ishda ajratishimiz kerak. Buning ma'nosi:</p>
<ul>
<li>Xotira runtimeda xotira allactoridan so'ralishi kerak.</li>
<li><code>String</code> bilan ishlashni tugatgandan so'ng, bizga ushbu xotirani allacatoriga qaytarish usuli kerak.</li>
</ul>
<p>Bu birinchi qism biz tomonimizdan amalga oshiriladi: biz <code>String::from</code> deb chaqirganimizda, uni implementi kerakli xotirani talab qiladi. Bu dasturlash tillarida deyarli universaldir.</p>
<p>Biroq, ikkinchi qism boshqacha. <em>Garbage Collector (GC)</em> bo'lgan tillarda GC endi ishlatilmayotgan xotirani kuzatib boradi va tozalaydi va bu haqda o'ylashimiz shart emas. Ko'pgina tillarda GC bo'lmaganda, xotiradan qachon foydalanilmayotganini aniqlash va uni aniq bo'shatish uchun kodni chaqirish, xuddi biz so'raganimizdek, bizning burchimizdir. Buni to'g'ri bajarish tarixan qiyin dasturlash muammosi bo'lgan. Agar unutsak, xotirani behuda sarflaymiz. Agar biz buni juda erta qilsak, bizda noto'g'ri o'zgaruvchi bo'ladi. Agar buni ikki marta qilsak, bu ham xato. Aynan bitta <code>allocate</code>ni bitta <code>bo'sh</code> bilan birlashtirishimiz kerak.</p>
<p>Rust boshqa yo'lni egallaydi: unga ega bo'lgan o'zgaruvchi amaldan tashqariga chiqqandan so'ng xotira avtomatik ravishda qaytariladi. Bu yerda 4-1 ro ªyxatdagi misolimiz satr harfi o ªrniga <code>String</code> yordamida berilgan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;salom&quot;); // s shu nuqtadan boshlab amal qiladi

        // s bilan ish bajaring
    }                                  // bu scope endi tugadi va s yo'q
                                       // uzoqroq amal qiladi
<span class="boring">}</span></code></pre></pre>
<p>Biz <code>String</code> kerak bo'lgan xotirani ajratuvchiga qaytarishimiz mumkin bo'lgan tabiiy nuqta bor: <code>s</code> scopedan chiqib ketganda. O'zgaruvchi scopedan chiqib ketganda, Rust biz uchun maxsus funksiyani chaqiradi.Ushbu funktsiya <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore --> deb ataladi va u yerda <code>String</code> muallifi xotirani qaytarish uchun kodni qo'yishi mumkin. Rust yopilgan jingalak qavsda avtomatik ravishda <code>drop</code> ni chaqiradi.</p>
<blockquote>
<p>Eslatma: C++ da, elementning ishlash muddati oxirida resurslarni taqsimlashning bunday sxemasi ba'zan
<em>Resource Acquisition Is Initialization (RAII)</em>(Resurslarni yig'ish - ishga tushirish (RAII) deb ataladi.
Agar siz RAII patternlaridan foydalangan bo'lsangiz, Rust-dagi <code>drop</code>
funksiyasi sizga tanish bo'ladi.</p>
</blockquote>
<p>Ushbu pattern Rust kodini yozish usuliga chuqur ta'sir qiladi. Bu hozir oddiy bo'lib tuyulishi mumkin, ammo biz bir nechta o'zgaruvchilar biz yig'ilgan ma'lumotlardan foydalanishni xohlayotganimizda, murakkabroq holatlarda kodning harakati kutilmagan bo'lishi mumkin. Keling, ushbu vaziyatlarning ba'zilarini ko'rib chiqaylik.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="move-bilan-ozaro-tasir-qiluvchi-ozgaruvchilar-va-malumotlar"><a class="header" href="#move-bilan-ozaro-tasir-qiluvchi-ozgaruvchilar-va-malumotlar">Move bilan o'zaro ta'sir qiluvchi o'zgaruvchilar va ma'lumotlar</a></h4>
<p>Rustda bir nechta o'zgaruvchilar bir xil ma'lumotlar bilan turli yo'llar bilan o'zaro ta'sir qilishi mumkin.
4-2 ro'yxatda integer sondan foydalanish misolini ko'rib chiqaylik.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">4-2 ro ªyxat: <code>x</code> o ªzgaruvchisining butun qiymatini <code>y</code> ga belgilash</span></p>
<p>Bu nima qilayotganini taxmin qilishimiz mumkin: <code>5</code> qiymatini <code>x</code> ga bog‚Äòlang; keyin <code>x</code> dagi qiymatdan nusxa oling va uni <code>y</code> ga bog'lang. Endi bizda ikkita o'zgaruvchi bor, <code>x</code> va <code>y</code> va ikkalasi ham <code>5</code> ga teng. Bu haqiqatan ham sodir bo'lmoqda, chunki butun sonlar ma'lum, qat'iy o'lchamga ega oddiy qiymatlardir va bu ikkita <code>5</code> qiymat stackga qo'shiladi.</p>
<p>Endi <code>String</code> versiyasini ko'rib chiqamiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;salom&quot;);
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Bu juda o'xshash ko'rinadi, shuning uchun biz uning ishlash metodi bir xil bo'ladi deb taxmin qilishimiz mumkin: ya'ni ikkinchi qator <code>s1</code> qiymatining nusxasini yaratadi va uni <code>s2</code> bilan bog'laydi. Ammo bu sodir bo'ladigan narsa emas.</p>
<p>Qopqoq ostidagi <code>String</code> bilan nima sodir bo'layotganini ko'rish uchun 4-1-rasmga qarang. <code>String</code> chap tomonda ko'rsatilgan uchta qismdan iborat: satr tarkibini saqlaydigan xotiraga ko'rsatgich, uzunlik(len) va sig'im(capacity).
Ushbu ma'lumotlar guruhi stackda saqlanadi. O'ng tomonda tarkibni saqlaydigan heap xotira joylashgan.</p>
<p><img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.png" class="center"
style="width: 50%;" /></p>
<p><span class="caption">4-1-rasm: <code>s1</code> ga bog‚Äòlangan <code>salom</code> qiymatiga ega <code>String</code> xotirasidagi tasvir</span></p>
<p>Uzunlik - <code>String</code> mazmuni hozirda qancha xotira, baytlarda foydalanayotganligi. Sig'im(capacity) - bu <code>String</code> allacatordan olgan xotiraning umumiy hajmi, baytlarda. Uzunlik va si'gimlar o'rtasidagi farq muhim, ammo bu kontekstda emas, shuning uchun hozircha si'gimlarni e'tiborsiz qoldirish yaxshi.</p>
<p><code>s1</code> ni <code>s2</code> ga belgilaganimizda, <code>String</code> ma'lumotlari nusxalanadi, ya'ni biz stackdagi pointer, uzunlik va sig`imdan nusxa olamiz. Biz pointer(ko'rsatkich) ko'rsatgan to'plamdagi ma'lumotlarni ko'chirmaymiz. Boshqacha qilib aytganda, ma'lumotlarning xotirada ko'rinishi 4-2-rasmga o'xshaydi.</p>
<p><img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap."
src="img/trpl04-02.png" class="center" style="width: 50%;" /></p>
<p><span class="caption">4-2-rasm: <code>s1</code> pointeri, uzunligi va sig ªimi nusxasiga ega <code>s2</code> o ªzgaruvchisi xotirasida ko ªrsatilishi</span></p>
<p>Tasvir 4-3-rasmga <em>o'xshamaydi</em>, agar Rust o'rniga heap ma'lumotlarni ko'chirsa, xotira qanday ko'rinishga ega bo'lardi. Agar Rust buni amalga oshirgan bo'lsa, <code>s2 = s1</code> operatsiyasi, agar heapdagi ma'lumotlar katta bo'lsa, runtimening ishlashi nuqtai nazaridan juda qimmat bo'lishi mumkin.</p>
<p><img alt="Four tables: two tables representing the stack data for s1 and s2,
and each points to its own copy of string data on the heap."
src="img/trpl04-03.png" class="center" style="width: 50%;" /></p>
<p><span class="caption">4-3-rasm: Rust heap ma'lumotlarni ham nusxalagan bo'lsa, <code>s2 = s1</code> nima qilishi mumkin bo'lgan yana bir imkoniyat</span></p>
<p>Avvalroq biz aytgan edikki, o‚Äòzgaruvchi qo‚Äòllanish doirasidan chiqib ketganda, Rust avtomatik ravishda <code>drop</code> funksiyasini chaqiradi va bu o‚Äòzgaruvchi uchun heap xotirani tozalaydi. Ammo 4-2-rasmda ikkala ma'lumot pointeri bir xil joyga ishora qiladi. Bu muammo: <code>s2</code> va <code>s1</code> scopedan chiqib ketganda, ikkalasi ham bir xil xotirani bo'shatishga harakat qiladi. Bu <em>double free</em>(ikki marta bo'sh)xato sifatida tanilgan va biz avval aytib o'tgan xotira xavfsizligi xatolaridan biridir. Xotirani ikki marta bo'shatish xotira buzilishiga olib kelishi mumkin, bu esa xavfsizlik zaifliklariga olib kelishi mumkin.</p>
<p>Xotira xavfsizligini ta'minlash uchun <code>let s2 = s1;</code> qatoridan keyin Rust <code>s1</code> ni endi yaroqsiz deb hisoblaydi. Shuning uchun, <code>s1</code> qo'llanilgandan tashqariga chiqqanda Rust hech narsani bo'shatishi shart emas. <code>s2</code> yaratilgandan keyin <code>s1</code> dan foydalanmoqchi bo'lganingizda nima sodir bo`lishini tekshiring; u ishlamaydi:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;salom&quot;);
    let s2 = s1;

    println!(&quot;{}, dunyo!&quot;, s1);
<span class="boring">}</span></code></pre>
<p>Siz shunday xatoga yo'l qo'yasiz, chunki Rust bekor qilingan havoladan foydalanishga to'sqinlik qiladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;salom&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, dunyo!&quot;, s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Agar siz boshqa tillar bilan ishlashda <em>shallow copy</em> va <em>deep copy</em> so‚Äòzlarini eshitgan bo‚Äòlsangiz, pointerni nusxalash tushunchasi, ma'lumotlardan nusxa ko'chirmasdan uzunligi va sig'imi olish, ehtimol shallow copy kabi eshitiladi. Ammo Rust birinchi o'zgaruvchini ham bekor qilganligi sababli, shallow copy deb nomlanish o'rniga u <em>move</em>(ko'chirish) deb nomlanadi. Bu misolda <code>s1</code> <code>s2</code> ga <em>ko'chirilgan</em> deb aytamiz. Shunday qilib, aslida nima sodir bo'lishi 4-4-rasmda ko'rsatilgan.</p>
<p><img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap.
Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to
access the heap data." src="img/trpl04-04.png" class="center" style="width:
50%;" /></p>
<p><span class="caption">4-4-rasm: <code>s1</code> dan keyin xotiradagi ko`rinish bekor qilingan</span></p>
<p>Bu bizning muammomizni hal qiladi! Faqatgina <code>s2</code> amal qilganda, u scopedan tashqariga chiqsa, u faqat xotirani bo'shatadi va biz tugatdik.</p>
<p>Bundan tashqari, dizayn tanlovi ham mavjud: Rust hech qachon avtomatik ravishda ma'lumotlaringizning &quot;deep copyni&quot; yaratmaydi. Shuning uchun, har qanday <em>avtomatik</em> nusxa ko'chirish runtimening ishlashi nuqtai nazaridan arzon deb taxmin qilish mumkin.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="clone-bilan-ozaro-tasir-qiluvchi-ozgaruvchilar-va-malumotlar"><a class="header" href="#clone-bilan-ozaro-tasir-qiluvchi-ozgaruvchilar-va-malumotlar">Clone bilan o'zaro ta'sir qiluvchi o'zgaruvchilar va ma'lumotlar</a></h4>
<p>Agar biz faqat stack ma'lumotlarini emas, balki <code>String</code> ning heap ma'lumotlarini deeply copyni istasak, <code>clone</code> deb nomlangan umumiy metoddan foydalanishimiz mumkin. Metod sintaksisini 5-bobda muhokama qilamiz, lekin metodlar ko‚Äòp dasturlash tillarida umumiy xususiyat bo‚Äòlgani uchun siz ularni avval ko‚Äòrgan bo‚Äòlsangiz kerak.</p>
<p>Mana amaldagi <code>clone</code> metodiga misol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;salom&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}</span></code></pre></pre>
<p>Bu juda yaxshi ishlaydi va 4-3-rasmda ko'rsatilgan xatti-harakatni aniq ishlab chiqaradi, bu yerda heap ma'lumotlar nusxalanadi.</p>
<p><code>clone</code> ga murojatni ko'rsangiz, ba'zi bir ixtiyoriy kod bajarilayotganini va bu kod qimmat bo'lishi mumkinligini bilasiz. Bu boshqa narsa sodir bo'layotganining vizual ko'rsatkichidir.</p>
<h4 id="faqat-stack-malumotlari-nusxalash"><a class="header" href="#faqat-stack-malumotlari-nusxalash">Faqat stack ma'lumotlari: nusxalash</a></h4>
<p>Biz hali gapirmagan yana bir narsa bor. Integer sonlardan foydalanadigan ushbu kod - bir qismi 4-2 ro'yxatda ko'rsatilgan - ishlaydi va amal qiladi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}</span></code></pre></pre>
<p>Ammo bu kod biz bilib olgan narsaga zid ko'rinadi: bizda <code>clone</code> uchun murojat yo'q, lekin <code>x</code> hali ham amal qiladi va <code>y</code> ga o'tkazilmagan.</p>
<p>Sababi, kompilyatsiya vaqtida ma'lum o'lchamga ega bo'lgan integer sonlar kabi turlar to'liq stackda saqlanadi, shuning uchun haqiqiy qiymatlarning nusxalari tezda tayyorlanadi. Bu shuni anglatadiki, biz <code>y</code> o'zgaruvchisini yaratganimizdan keyin <code>x</code> ning haqiqiy bo'lishiga to'sqinlik qilish uchun hech qanday sabab yo'q. Boshqacha qilib aytadigan bo'lsak, bu yerda deep va shallow nusxa ko'chirish o'rtasida farq yo'q, shuning uchun <code>clone</code> ni chaqirish odatdagi shallow copydan farq qilmaydi va biz uni tark etishimiz mumkin.</p>
<p>Rust <code>Copy</code> traiti deb nomlangan maxsus annotationga ega bo'lib, uni butun sonlar kabi stackda saqlanadigan turlarga joylashtirishimiz mumkin (biz <a href="ch10-02-traits.html">10-bobda</a><!-- ignore --> traitlar haqida ko'proq gaplashamiz). Agar tur  <code>Copy</code> traitini amalga oshirsa, undan foydalanadigan o‚Äòzgaruvchilar harakatlanmaydi, aksincha, ahamiyatsiz tarzda ko‚Äòchiriladi, bu esa boshqa o‚Äòzgaruvchiga tayinlangandan keyin ham amal qiladi.</p>
<p>Rust turi yoki uning biron bir qismi <code>Drop</code> traitini qo‚Äòllagan bo‚Äòlsa, <code>Copy</code> bilan turga annotation qo‚Äòyishimizga ruxsat bermaydi. Qiymat doirasidan chiqib ketganda turga maxsus biror narsa kerak bo'lsa va biz ushbu turga <code>Copy</code> annotationni qo'shsak, biz kompilyatsiya vaqtida xatolikni olamiz. Traitni amalga oshirish uchun turingizga <code>Copy</code> annotationni qanday qo‚Äòshish haqida bilish uchun C ilovasidagi <a href="appendix-03-derivable-traits.html">‚ÄúDerivable Traitlar‚Äù</a><!-- ignore -->ga qarang.</p>
<p>Xo'sh, <code>Copy</code> traitini qaysi turlar amalga oshiradi? Ishonch hosil qilish uchun berilgan tur uchun texnik hujjatlarni tekshirishingiz mumkin, lekin umumiy qoida sifatida har qanday oddiy skalyar qiymatlar guruhi <code>Copy</code> ni amalga oshirishi mumkin va ajratishni talab qiladigan yoki biron bir manba shakli bo‚Äòlgan hech narsa <code>Copy</code> ni amalga oshira olmaydi. <code>Copy</code> ni amalga oshiradigan ba'zi turlar:</p>
<ul>
<li><code>u32</code> kabi barcha integer turlari.</li>
<li>Boolean turi, <code>bool</code>, <code>true</code> va <code>false</code> qiymatlari bilan.</li>
<li>Barcha floating-point turlari, masalan, <code>f64</code>.</li>
<li>Belgi turi, <code>char</code>.</li>
<li>Tuplelar, agar ular faqat <code>Copy</code> ni ham implement qiladigan turlarni o'z ichiga olsa. Masalan, <code>(i32, i32)</code> <code>Copy</code> ni implement qiladi, lekin <code>(i32, String)</code> bajarmaydi.</li>
</ul>
<h3 id="ownership-va-funksiyalar"><a class="header" href="#ownership-va-funksiyalar">Ownership va Funksiyalar</a></h3>
<p>Funksiyaga qiymat berish mexanikasi o'zgaruvchiga qiymat berish mexanikasiga o'xshaydi. O'zgaruvchini funksiyaga o'tkazish, xuddi assignment kabi ko'chiriladi yoki nusxalanadi. 4-3 ro'yxatda o'zgaruvchilarning qayerga kirishi va tashqariga chiqishini ko'rsatadigan ba'zi izohlar bilan misol mavjud.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;salom&quot;);  // s scopega kiradi

    ownershiplik_qiladi(s);             // s qiymati funksiyaga o'tadi ...
                                    // ... va shuning uchun bu yerda endi amal qilmaydi

    let x = 5;                      // x scopega kiradi

    nusxasini_yaratadi(x);                  // x funksiyaga o'tadi,
                                    // lekin i32 nusxa ko'chirish, shuning uchun tinch qo'yish yaxshidir
                                    // keyin x dan foydalaning

} // Bu erda x scopedan chiqib ketadi, keyin s. Lekin s qiymati ko'chirilganligi sababli, hech
  // qanday maxsus narsa sodir bo'lmaydi.

fn ownershiplik_qiladi(some_string: String) { // some_string scopega kiradi
    println!(&quot;{}&quot;, some_string);
} // Bu yerda some_string scopedan chiqib ketadi va `drop` deb ataladi. Qo'llab-quvvatlovchi
  // xotira bo'shatiladi.

fn nusxasini_yaratadi(some_integer: i32) { // some_integer scopega kiradi
    println!(&quot;{}&quot;, some_integer);
} // Bu erda some_integer scopedan tashqariga chiqadi. Hech qanday maxsus narsa bo'lmaydi.</code></pre></pre>
<p><span class="caption">Ro'yxat 4-3: ownership va scope izohlangan funksiyalar</span></p>
<p>Agar biz <code>ownershiplik_qiladi</code> chaqiruvidan keyin <code>s</code> dan foydalanmoqchi bo'lsak, Rust kompilyatsiya vaqtida xatolikka yo'l qo'yadi. Ushbu statik tekshiruvlar bizni xatolardan himoya qiladi. <code>s</code> va <code>x</code> dan foydalanadigan <code>main</code> ga kod qo‚Äòshib ko‚Äòring va ulardan qayerda foydalanishingiz mumkinligini va ownership qoidalari bunga xalaqit beradigan joyni ko‚Äòring.</p>
<h3 id="return-qiymatlari-va-scope"><a class="header" href="#return-qiymatlari-va-scope">Return qiymatlari va Scope</a></h3>
<p>Return qilingan qiymatlar ownershipni ham o'tkazishi mumkin. 4-4 ro'yxatda 4-3 ro'yxatdagi kabi izohlar bilan ba'zi qiymatlarni qaytaradigan funksiya misoli ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = egalik_beradi();         // egalik_beradi o'zining return qiymatini
                                        // s1 ga o'tkazadi

    let s2 = String::from(&quot;salom&quot;);     // s2 scopega kiradi

    let s3 = oladi_va_qaytaradi(s2);  // s2 oladi_va_qaytaradi ichiga 
                                        // ko'chiriladi, u ham o'zining return
                                        // qiymatini s3 ga o'tkazadi
} // Bu erda s3 scopedan chiqib ketadi va o'chiriladi. s2 ko'chirildi, shuning uchun
  // hech narsa sodir bo'lmaydi. s1 scopedan chiqib ketadi va o'chiriladi.

fn egalik_beradi() -&gt; String {             // egalik_beradi o'zining return
                                             // qiymatini uni chaqiradigan
                                             // funksiyaga o'tkazadi

    let some_string = String::from(&quot;rust&quot;); // some_string scopea kiradi

    some_string                              // some_string return qilinadi va
                                             // chaqiruv funksiyasiga 
                                             // o'tadi
}

// Bu funksiya Stringni oladi va bittasini qaytaradi
fn oladi_va_qaytaradi(a_string: String) -&gt; String { // a_string scopega 
                                                      // kiradi

    a_string  // a_string qaytariladi va chaqiruv funksiyasiga o'tadi
}</code></pre></pre>
<p><span class="caption">Ro'yxat 4-4: Return ownershipni o'tkazish
qiymatlar</span></p>
<p>O'zgaruvchiga ownership har safar bir xil patternga amal qiladi: boshqa o'zgaruvchiga qiymat berish uni ko'chiradi. Heapdagi ma ºlumotlarni o ªz ichiga olgan o ªzgaruvchi scopedan tashqariga chiqsa, agar ma ºlumotlarga ownership boshqa o ªzgaruvchiga o ªtkazilmagan bo ªlsa, qiymat <code>drop</code> orqali tozalanadi.</p>
<p>Bu ishlayotganda, ownership va keyin har bir funksiyaga ownershipini qaytarish biroz zerikarli. Agar funksiyaga qiymatdan foydalanishiga ruxsat bermoqchi bo'lsak, lekin ownershiplik qilmasak nima bo'ladi? Bu juda zerikarli, agar biz uni qayta ishlatmoqchi bo'lsak, biz kiritgan har qanday narsa, shuningdek, biz qaytarishni xohlashimiz mumkin bo'lgan funktsiya tanasidan kelib chiqadigan har qanday ma'lumotlarga qo'shimcha ravishda qaytarib berilishi kerak.</p>
<p>Rust 4-5 ro'yxatda ko'rsatilganidek, tuple yordamida bir nechta qiymatlarni return qilish imkon beradi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;salom&quot;);

    let (s2, len) = uzunlikni_hisoblash(s1);

    println!(&quot;'{}' uzunligi {}.&quot;, s2, len);
}

fn uzunlikni_hisoblash(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() string uzunligini qaytaradi

    (s, length)
}</code></pre></pre>
<p><span class="caption">Ro'yxat 4-5: Parametrlarga ownershipni qaytarish</span></p>
<p>Ammo bu umumiy bo'lishi kerak bo'lgan kontseptsiya uchun juda ko'p funksiya va juda ko'p ish. Yaxshiyamki, Rustda qiymatni ownershipni o'tkazmasdan ishlatish xususiyati mavjud, uni <em>reference</em> deb atashadi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reference-va-borrowing"><a class="header" href="#reference-va-borrowing">Reference va Borrowing</a></h2>
<p>Ro'yxat 4-5dagi tuple kodi bilan bog'liq muammo shundaki, biz <code>String</code> ni chaqiruvchi funksiyaga qaytarishimiz kerak, shunda biz <code>uzunlikni_hisoblash</code> ga chaqiruvdan keyin ham <code>String</code> dan foydalanishimiz mumkin, chunki <code>String</code> <code>uzunlikni_hisoblash</code> ga ko'chirildi. Buning o'rniga biz <code>String</code> qiymatiga reference(havola) berishimiz mumkin.</p>
<p><em>Reference</em> pointerga o'xshaydi, chunki u biz ushbu manzilda saqlangan ma'lumotlarga kirish uchun amal qilishimiz mumkin bo'lgan manzildir; bu ma'lumotlar boshqa o'zgaruvchilarga tegishli.
Pointerdan farqli o'laroq, reference ma'lumotnomaning amal qilish muddati davomida ma'lum turdagi yaroqli qiymatni ko'rsatishi kafolatlanadi.</p>
<p>Qiymatga egalik qilish o'rniga parametr sifatida obyektga referencega ega bo'lgan <code>uzunlikni_hisoblash</code> funksiyasini qanday aniqlash va ishlatishingiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;salom&quot;);

    let len = uzunlikni_hisoblash(&amp;s1);

    println!(&quot;'{}' uzunligi {}.&quot;, s1, len);
}

fn uzunlikni_hisoblash(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>Birinchidan, o'zgaruvchilar deklaratsiyasidagi barcha tuple kodi va funksiyani qaytarish qiymati yo'qolganiga e'tibor bering. Ikkinchidan, <code>&amp;s1</code> ni <code>uzunlikni_hisoblash</code> ga o'tkazamiz va uning definitionida biz <code>String</code> emas, <code>&amp;String</code>ni olamiz. Ushbu ampersandlar <em>reference</em> ni ifodalaydi va ular sizga biron bir qiymatga ownershiplik qilmasdan murojaat qilish imkonini beradi. 4-5-rasmda ushbu tushuncha tasvirlangan.</p>
<p><img alt="Three tables: the table for s contains only a pointer to the table
for s1. The table for s1 contains the stack data for s1 and points to the
string data on the heap." src="img/trpl04-05.jpg" class="center" /></p>
<p><span class="caption">4-5-rasm: <code>&amp;String s</code> chizmasi <code>String s1</code>ga ishora qiladi</span></p>
<blockquote>
<p>Eslatma: <code>&amp;</code> yordamida reference qilishning teskarisi <em>dereferencing</em> bo'lib,
u <code>*</code> dereference operatori yordamida amalga oshiriladi. Biz 8-bobda dereference
operatoridan ba ºzi foydalanishni ko ªrib chiqamiz va 15-bobda dereference tafsilotlarini 
muhokama qilamiz.</p>
</blockquote>
<p>Keling, bu yerda funksiya chaqiruvini batafsil ko'rib chiqaylik:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;salom&quot;);

    let len = uzunlikni_hisoblash(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;'{}' uzunligi {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn uzunlikni_hisoblash(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p><code>&amp;s1</code> sintaksisi bizga <code>s1</code> qiymatiga <em>refers</em> qiluvchi, lekin unga tegishli bo`lmagan reference yaratish imkonini beradi. Unga egalik qilmaganligi sababli, reference foydalanishni to'xtatganda, u ko'rsatgan qiymat o'chirilmaydi.</p>
<p>Xuddi shunday, funksiya imzosi <code>s</code> parametrining turi reference ekanligini ko'rsatish uchun <code>&amp;</code> dan foydalanadi. Keling, ba'zi tushuntirish izohlarini qo'shamiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;salom&quot;);
</span><span class="boring">
</span><span class="boring">    let len = uzunlikni_hisoblash(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;'{}' uzunligi {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn uzunlikni_hisoblash(s: &amp;String) -&gt; usize { // s - Stringga reference(havola)
    s.len()
} // Bu yerda s scopedan chiqib ketadi. Lekin u nazarda tutgan itemga ownership qilmagani
  // uchun u tashlanmaydi.</code></pre></pre>
<p><code>s</code> o'zgaruvchisi amal qiladigan doirasi har qanday funksiya parametrining qamrovi bilan bir xil bo'ladi, lekin <code>s</code> foydalanishni to'xtatganda reference  ko'rsatilgan qiymat o'chirilmaydi, chunki <code>s</code> ownershipga ega emas. Funksiya referencelarni yaroqli qiymatlar o'rniga parametr sifatida ko'rsatsa, biz ownershipni qaytarish uchun qiymatlarni qaytarishimiz shart emas, chunki bizda hech qachon ownership bo'lmagan.</p>
<p>Malumot yaratish harakatini <em>borrowing</em>(qarz olish) deb ataymiz. Haqiqiy hayotda bo'lgani kabi, agar biror kishi biror narsaga ega bo'lsa, siz undan qarz olishingiz mumkin. Ishingiz tugagach, uni qaytarib berishingiz kerak. Siz unga egalik qilmaysiz.</p>
<p>Xo'sh, agar biz borrowing qilgan narsani o'zgartirishga harakat qilsak nima bo'ladi? 4-6 ro'yxatdagi kodni sinab ko'ring. Spoiler ogohlantirish: bu ishlamaydi!</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;salom&quot;);

    almashtirish(&amp;s);
}

fn almashtirish(some_string: &amp;String) {
    some_string.push_str(&quot;, rust&quot;);
}</code></pre>
<p><span class="caption">Ro'yxat 4-6: Borrow qilingan qiymatni o'zgartirishga urinish</span></p>
<p>Mana xato:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn almashtirish(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(&quot;, rust&quot;);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>O'zgaruvchilar standart bo'yicha o'zgarmas bo'lganidek, referencelar ham shunday. Bizga reference biror narsani o'zgartirishga ruxsat berilmagan.</p>
<h3 id="ozgaruvchan-referencelar"><a class="header" href="#ozgaruvchan-referencelar">O'zgaruvchan Referencelar</a></h3>
<p>Biz 4-6 ro'yxatdagi kodni tuzatishimiz mumkin, buning o'rniga <code>o'zgaruvchan reference</code>dan foydalanadigan bir nechta kichik sozlashlar bilan borrow qilingan qiymatni o'zgartirishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;salom&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, dunyo&quot;);
}</code></pre></pre>
<p>Avval <code>s</code> ni <code>mut</code> qilib o'zgartiramiz. Keyin biz <code>&amp;mut s</code> bilan o'zgaruvchan reference yaratamiz, bu yerda biz <code>change</code> funksiyasini chaqiramiz va <code>some_string: &amp;mut String</code> bilan o'zgaruvchan referencei qabul qilish uchun funksiya signatureni yangilaymiz. Bu <code>change</code> funksiyasi olingan qiymatni o'zgartirishini aniq ko'rsatadi.</p>
<p>O'zgaruvchan referencelar bitta katta cheklovga ega: agar sizda qiymatga o'zgaruvchan reference bo'lsa, sizda bu qiymatga boshqa referencelar bo'lishi mumkin emas. <code>s</code> ga ikkita o'zgaruvchan reference yaratishga urinayotgan ushbu kod muvaffaqiyatsiz bo'ladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;salom&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}</span></code></pre>
<p>Mana xato:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Bu xatolik bu kodning yaroqsiz ekanligini bildiradi, chunki biz bir vaqtning o'zida bir necha marta o'zgaruvchan <code>s</code> ni borrow qila ololmaymiz. Birinchi o'zgaruvchan borrow <code>r1</code> da bo'lib, u <code>println!</code> da ishlatilgunga qadar davom etishi kerak, lekin bu o'zgaruvchan referenceni yaratish va undan foydalanish o'rtasida, biz <code>r2</code> da <code>r1</code> bilan bir xil ma'lumotlarni olgan boshqa o`zgaruvchan reference yaratishga harakat qildik.</p>
<p>Bir vaqtning o'zida bir xil ma'lumotlarga bir nechta o'zgaruvchan referencelarni oldini oluvchi cheklov mutatsiyaga imkon beradi, lekin juda nazorat ostida. Bu yangi Rustaceanlar bilan kurashadigan narsa, chunki aksariyat tillar xohlagan vaqtda mutatsiyaga o'tishga imkon beradi. Ushbu cheklovning afzalligi shundaki, Rust kompilyatsiya vaqtida data raceni oldini oladi. <em>Data race</em> poyga holatiga o'xshaydi va bu uchta xatti-harakatlar sodir bo'lganda sodir bo'ladi:</p>
<ul>
<li>Ikki yoki undan ortiq pointerlar bir vaqtning o'zida bir xil ma'lumotlarga kirishadi.</li>
<li>Pointerlardan kamida bittasi ma'lumotlarga yozish uchun ishlatiladi.</li>
<li>Ma'lumotlarga kirishni sinxronlashtirish uchun hech qanday mexanizm ishlatilmaydi.</li>
</ul>
<p>Data race aniqlanmagan xatti-harakatlarga olib keladi va ularni runtimeda kuzatib borishga harakat qilayotganingizda tashxis qo'yish va tuzatish qiyin bo'lishi mumkin; Rust data racelari bilan kodni kompilyatsiya qilishni rad etish orqali bu muammoni oldini oladi!</p>
<p>Har doimgidek, biz <em>bir vaqtning o'zida</em> emas, balki bir nechta o'zgaruvchan referencelarga ruxsat beruvchi yangi scope yaratish uchun jingalak qavslardan foydalanishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;salom&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 bu yerda scopedan chiqib ketadi, shuning uchun biz hech 
    //qanday muammosiz yangi reference qilishimiz mumkin.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>Rust o'zgaruvchan va o'zgarmas referencelarni birlashtirish uchun shunga o'xshash qoidani qo'llaydi.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;salom&quot;);

    let r1 = &amp;s; // muammo yo'q
    let r2 = &amp;s; // muammo yo'q
    let r3 = &amp;mut s; // KATTA MUAMMO

    println!(&quot;{}, {}, va {}&quot;, r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>Mana xato:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // muammo yo'q
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // muammo yo'q
6 |     let r3 = &amp;mut s; // KATTA MUAMMO
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, va {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Voy! Bizda <em>shuningdek</em> o'zgaruvchan referencelar bo'lishi mumkin emas, bizda bir xil qiymatga o'zgarmas reference mavjud.</p>
<p>O'zgarmas reference foydalanuvchilari qiymat birdaniga ularning ostidan o'zgarishini kutishmaydi! Biroq, bir nechta o'zgarmas referencelarga ruxsat beriladi, chunki faqat ma'lumotlarni o'qiyotgan hech kim boshqa hech kimning ma'lumotni o'qishiga ta'sir qilish qobiliyatiga ega emas.</p>
<p>E'tibor bering, referencening ko'lami u kiritilgan joydan boshlanadi va oxirgi ishlatilgan vaqtgacha davom etadi. Masalan, ushbu kod kompilyatsiya qilinadi, chunki o'zgarmas referencelarning oxirgi ishlatilishi, <code>println!</code>, o'zgaruvchan reference kiritilishidan oldin sodir bo'ladi:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;salom&quot;);

    let r1 = &amp;s; // muammo yo'q
    let r2 = &amp;s; // muammo yo'q
    println!(&quot;{} va {}&quot;, r1, r2);
    // r1 va r2 o'zgaruvchilari bu nuqtadan keyin ishlatilmaydi

    let r3 = &amp;mut s; // muammo yo'q
    println!(&quot;{}&quot;, r3);
<span class="boring">}</span></code></pre></pre>
<p><code>r1</code> va <code>r2</code> o'zgarmas referencelar doirasi <code>println</code> dan keyin tugaydi! ular oxirgi marta ishlatiladigan joy, ya'ni o'zgaruvchan referencelar <code>r3</code> yaratilishidan oldin. Ushbu doiralar bir-biriga mos kelmaydi, shuning uchun bu kodga ruxsat beriladi: kompilyator reference doirasi tugashidan bir nuqtada endi foydalanilmayotganini aytishi mumkin.</p>
<p>Borrowingdagi xatolar ba'zida asabiylashsa ham, Rust kompilyatori potentsial xatoni erta (runtimeda emas, balki kompilyatsiya vaqtida) ko'rsatib beradi va muammo qayerda ekanligini aniq ko'rsatadi. Keyin nima uchun ma'lumotlaringiz siz o'ylagandek emasligini kuzatishingiz shart emas.</p>
<h3 id="dangling-referencelar"><a class="header" href="#dangling-referencelar">Dangling Referencelar</a></h3>
<p>Pointerlari bo'lgan tillarda, <em>dangling pointer</em>ni - xotiradagi boshqa birovga berilgan bo'lishi mumkin bo'lgan joyga reference qiluvchi pointerni - bu xotiraga pointerni saqlab qolgan holda, xotirani biroz bo'shatish orqali yaratish oson. Rust-da, aksincha, kompilyator referencelar hech qachon dangling referencelar bo'lmasligini kafolatlaydi: agar sizda ba'zi ma'lumotlarga reference bo'lsa, kompilyator ma'lumotlarga referencedan oldin ma'lumotlar doirasi tashqariga chiqmasligini ta'minlaydi.</p>
<p>Keling, Rust ularni kompilyatsiya vaqtida xatosi bilan qanday oldini olishini ko'rish uchun dangling reference yaratishga harakat qilaylik:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let dangle_reference = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;salom&quot;);

    &amp;s
}</code></pre>
<p>Mana xato:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Ushbu xato xabari biz hali ko'rib chiqmagan xususiyatga ishora qiladi: lifetime. Biz 10-bobda lifetime batafsil muhokama qilamiz. Ammo, agar siz lifetime haqidagi qismlarga e'tibor bermasangiz, xabarda ushbu kod nima uchun muammo ekanligining kaliti mavjud:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Keling, <code>dangle</code> kodimizning har bir bosqichida nima sodir bo'layotganini batafsil ko'rib chiqaylik:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let dangle_reference = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle Stringga referencei qaytaradi

    let s = String::from(&quot;salom&quot;); // s - yangi String

    &amp;s // biz Stringga referenceni return qilamiz, s
} // Bu yerda s scopedan chiqib ketadi va drop qilinadi. Uning xotirasi yo'qoladi.
  // Xavf!</code></pre>
<p><code>s</code> <code>dangle</code> ichida yaratilganligi sababli, <code>dangle</code> kodi tugagach, <code>s</code> ajratiladi. Ammo biz unga referenceni qaytarishga harakat qildik. Bu shuni anglatadiki, bu reference yaroqsiz <code>String</code>ga ishora qiladi. Bu yaxshi emas! Rust bizga buni qilishga ruxsat bermaydi.</p>
<p>Bu yerda yechim to'g'ridan-to'g'ri <code>String</code> ni return qilishdir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = dangle_yoq();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle_yoq() -&gt; String {
    let s = String::from(&quot;salom&quot;);

    s
}</code></pre></pre>
<p>Bu hech qanday muammosiz ishlaydi. Ownership boshqa joyga ko'chiriladi va hech narsa ajratilmaydi.</p>
<h3 id="reference-qoidalari"><a class="header" href="#reference-qoidalari">Reference Qoidalari</a></h3>
<p>Keling, referencelar haqida nimalarni muhokama qilganimizni takrorlaymiz:</p>
<ul>
<li>Istalgan vaqtda siz <em>yoki</em> bitta o ªzgaruvchan referencega <em>yoki</em> istalgan miqdordagi o ªzgarmas referencelarga ega bo ªlishingiz mumkin.</li>
<li>Referencelar har doim yaroqli bo'lishi kerak.</li>
</ul>
<p>Keyinchalik, biz boshqa turdagi referenceni ko'rib chiqamiz: slicelar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="slice-turi"><a class="header" href="#slice-turi">Slice turi</a></h2>
<p><em>Slicelar</em> butun to'plamga emas, balki to'plamdagi elementlarning qo'shni ketma-ketligiga murojaat qilish imkonini beradi. Slice bir xil referencedir, shuning uchun u ownershipga ega emas.</p>
<p>Bu yerda kichik dasturlash muammosi: bo'shliqlar bilan ajratilgan so'zlar qatorini oladigan va shu qatorda topilgan birinchi so'zni qaytaradigan funksiya yozing.
Agar funksiya satrda bo'sh joy topmasa, butun satr bitta so'zdan iborat bo'lishi kerak, shuning uchun butun satr qaytarilishi kerak.</p>
<p>Keling, slicelar hal qiladigan muammoni tushunish uchun ushbu funksiyaning imzosini slicelardan foydalanmasdan qanday yozishni ko'rib chiqaylik:</p>
<pre><code class="language-rust ignore">fn birinchi_soz(s: &amp;String) -&gt; ?</code></pre>
<p><code>birinchi_soz</code> funksiyasi parametr sifatida <code>&amp;String</code> ga ega. Biz ownershiplik qilishni xohlamaymiz, shuning uchun bu yaxshi. Ammo biz nimani return qilishimiz kerak? Bizda satrning <em>qismi</em> haqida gapirishning metodi yo'q. Biroq, biz bo'sh joy bilan ko'rsatilgan so'z oxiri indeksini qaytarishimiz mumkin. 4-7 ro'yxatda ko'rsatilganidek, buni sinab ko'raylik.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn birinchi_soz(s: &amp;String) -&gt; usize {
    let bayt = s.as_bytes();

    for (i, &amp;item) in bayt.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 4-7: <code>String</code> parametriga bayt indeks qiymatini qaytaradigan <code>birinchi_soz</code> funksiyasi</span></p>
<p>Biz <code>String</code> elementini element bo'yicha ko'rib chiqishimiz va qiymat bo'sh joy yoki yo'qligini tekshirishimiz kerakligi sababli, <code>as_bytes</code> metodi yordamida <code>String</code>ni baytlar arrayiga aylantiramiz.</p>
<pre><code class="language-rust ignore"><span class="boring">fn birinchi_soz(s: &amp;String) -&gt; usize {
</span>    let bayt = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bayt.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Keyinchalik, <code>iter</code> metodi yordamida baytlar arrayida iterator yaratamiz:</p>
<pre><code class="language-rust ignore"><span class="boring">fn birinchi_soz(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bayt = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bayt.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Biz iteratorlarni <a href="ch13-02-iterators.html">13-bobda</a><!-- ignore --> batafsilroq muhokama qilamiz.
Hozircha bilingki, <code>iter</code> to‚Äòplamdagi har bir elementni return qiladigan va <code>enumerate</code> <code>iter</code> natijasini o‚Äòrab, har bir elementni tuplening bir qismi sifatida return qiladigan metoddir. <code>enumerate</code> dan qaytarilgan tuplening birinchi elementi indeks, ikkinchi element esa elementga referencedir.
Bu indeksni o'zimiz hisoblashdan ko'ra biroz qulayroqdir.</p>
<p><code>enumerate</code> metodi tupleni qaytarganligi sababli, biz ushbu tupleni destructure qilish uchun patternlardan foydalanishimiz mumkin. Biz <a href="ch06-02-match.html#patterns-that-bind-to-values">6-bobda</a><!-- ignore --> patternlarni ko'proq muhokama qilamiz. <code>for</code> siklida biz tupledagi indeks uchun <code>i</code> va bitta bayt uchun <code>&amp;element</code> ga ega bo‚Äòlgan patternni belgilaymiz.
Biz <code>.iter().enumerate()</code> dan elementga referenceni olganimiz uchun biz patternda <code>&amp;</code> dan foydalanamiz.</p>
<p><code>for</code> sikli ichida biz bayt literal sintaksisidan foydalanib, bo'sh joyni ifodalovchi baytni qidiramiz. Agar bo'sh joy topsak, biz pozitsiyani return qilamiz.
Aks holda, <code>s.len()</code> yordamida satr uzunligini qaytaramiz.</p>
<pre><code class="language-rust ignore"><span class="boring">fn birinchi_soz(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bayt = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bayt.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Endi bizda satrdagi birinchi so'zning oxirgi indeksini aniqlashning metodi bor, ammo muammo bor. Biz <code>usize</code> ni o'z-o'zidan qaytarmoqdamiz, lekin bu <code>&amp;String</code> kontekstida faqat meaningful raqam. Boshqacha qilib aytadigan bo'lsak, bu <code>String</code> dan alohida qiymat bo'lganligi sababli, uning kelajakda ham amal qilishiga kafolat yo'q. Ro'yxat 4-8da 4-7 ro'yxatdagi <code>birinchi_soz</code> funksiyasidan foydalanadigan dasturni ko'rib chiqing.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn birinchi_soz(s: &amp;String) -&gt; usize {
</span><span class="boring">    let baytlar = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in baytlar.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let soz = birinchi_soz(&amp;s); // soz 5 qiymatini oladi

    s.clear(); // bu Stringni bo'shatib, uni &quot;&quot; ga tenglashtiradi

    // soz hali ham bu erda 5 qiymatiga ega, ammo biz 5 qiymatini meaningfull ishlatishimiz
    // mumkin bo'lgan boshqa qator yo'q. soz endi mutlaqo yaroqsiz!
}</code></pre></pre>
<p><span class="caption">Ro'yxat 4-8: <code>birinchi_soz</code> funksiyasini chaqirish natijasida olingan natijani saqlash va keyin <code>String</code> tarkibini o'zgartirish</span></p>
<p>Bu dastur hech qanday xatosiz kompilyatsiya qiladi va agar biz <code>s.clear()</code> ga murojat qilgandan keyin <code>soz</code> ishlatgan bo'lsak ham shunday bo'lardi. Chunki <code>soz</code> <code>s</code> holatiga umuman bog‚Äòlanmagan, <code>soz</code> hali ham <code>5</code> qiymatini o‚Äòz ichiga oladi. Birinchi so‚Äòzni chiqarish uchun biz ushbu <code>5</code> qiymatini <code>s</code> o‚Äòzgaruvchisi bilan ishlatishimiz mumkin, ammo bu xato bo‚Äòlishi mumkin, chunki <code>soz</code>da <code>5</code> ni saqlaganimizdan so‚Äòng <code>s</code> tarkibi o‚Äòzgargan.</p>
<p><code>soz</code> da indeksning <code>s</code> dagi ma'lumotlar bilan muvofiqligi yo‚Äòqolishidan xavotir olish juda zerikarli va xatoga yo‚Äòl qo‚Äòyishga moyil! Agar biz <code>ikkinchi_soz</code> funksiyasini yozsak, bu indekslarni boshqarish yanada mo'rt bo'ladi. Uning signaturesi quyidagicha ko'rinishi kerak:</p>
<pre><code class="language-rust ignore">fn ikkinchi_soz(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Endi biz boshlang'ich va tugash indeksini kuzatmoqdamiz va bizda ma'lum bir holatdagi ma'lumotlardan hisoblangan, ammo bu holatga umuman bog'liq bo'lmagan ko'proq qiymatlar mavjud. Bizda bir-biriga bog'liq bo'lmagan uchta o'zgaruvchi mavjud bo'lib, ular sinxronlashtirilishi kerak.</p>
<p>Yaxshiyamki, Rust bu muammoni hal qildi: string slicelar.</p>
<h3 id="string-slicelar"><a class="header" href="#string-slicelar">String Slicelar</a></h3>
<p><em>string slice</em> <code>String</code> qismiga reference bo ªlib, u quyidagicha ko ªrinadi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;salom duno&quot;);

    let salom = &amp;s[0..5];
    let dunyo = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>Butun <code>String</code>ga reference o ªrniga <code>salom</code> qo ªshimcha <code>[0..5]</code> bitida ko ªrsatilgan <code>String</code> qismiga referencedir. Biz <code>[starting_index..ending_index]</code> ni belgilash orqali qavslar ichidagi diapazondan foydalangan holda slicelarni yaratamiz, bu yerda <code>starting_index</code> bo'limdagi birinchi pozitsiyadir va <code>ending_index</code> slicedagi oxirgi pozitsiyadan bittaga ko'p. Ichkarida, slice ma'lumotlar tuzilmasi <code>ending_index</code> minus <code>starting_index</code> ga mos keladigan boshlang'ich pozitsiyasini va slice uzunligini saqlaydi. Demak, <code>let dunyo = &amp;s[6..11];</code> holatida dunyo so'zi <code>s</code> ning 6 indeksidagi baytga ko‚Äòrsatgichni o‚Äòz ichiga olgan bo‚Äòlak bo‚Äòlib, uzunligi 5 ga teng bo‚Äòladi.</p>
<p>4-6-rasmda bu diagrammada ko'rsatilgan.</p>
<p><img alt="Three tables: a table representing the stack data of s, which points
to the byte at index 0 in a table of the string data &quot;hello world&quot; on
the heap. The third table rep-resents the stack data of the slice world, which
has a length value of 5 and points to byte 6 of the heap data table."
src="img/trpl04-06.png" class="center" style="width: 50%;" /></p>
<p><span class="caption">4-6-rasm: <code>String</code>ning bir qismiga referal qiluvchi String slice</span></p>
<p>Rustning <code>..</code> diapazoni sintaksisi bilan, agar siz 0 indeksidan boshlamoqchi bo'lsangiz, qiymatni ikki davr oldidan tushirishingiz mumkin. Boshqacha qilib aytganda, ular tengdir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;salom&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>Xuddi shu qoidaga ko'ra, agar sizning slicesingiz <code>String</code> ning oxirgi baytini o'z ichiga olgan bo'lsa, siz keyingi raqamni qo'yishingiz mumkin. Bu shuni anglatadiki, ular tengdir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;salom&quot;);

let uzunlik = s.len();

let slice = &amp;s[3..uzunlik];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>Shuningdek, butun satrning bir qismini olish uchun ikkala qiymatni ham tashlab qo'yishingiz mumkin. Shunday qilib, ular teng:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;salom&quot;);

let uzunlik = s.len();

let slice = &amp;s[0..uzunlik];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Eslatma: String diapazoni indekslari yaroqli UTF-8 belgilar chegaralarida
bo'lishi kerak. Agar siz ko'p baytli belgi o'rtasida string slice yaratishga
harakat qilsangiz, dasturingiz xato bilan chiqadi. String slicelarini kiritish uchun
biz faqat ushbu bo'limda ASCII ni qabul qilamiz; UTF-8 bilan ishlash bo'yicha batafsilroq
muhokama 8-bobning <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">‚ÄùUTF-8 kodlangan matnni satrlar bilan saqlash‚Äù</a><!-- ignore -->
bo'limida keltirilgan.</p>
</blockquote>
<p>Ushbu ma'lumotlarning barchasini hisobga olgan holda, sliceni qaytarish uchun <code>birinchi_soz</code> ni qayta yozamiz. ‚ÄúString slice‚Äùni bildiruvchi tur <code>&amp;str</code> sifatida yoziladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn birinchi_soz(s: &amp;String) -&gt; &amp;str {
    let baytlar = s.as_bytes();

    for (i, &amp;item) in baytlar.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Biz so'z oxiri indeksini 4-7 ro'yxatdagi kabi bo'shliqning birinchi marta paydo bo'lishini qidirib olamiz. Bo'shliqni topganimizda, satrning boshi va bo'sh joy indeksidan boshlang'ich va yakuniy indekslar sifatida foydalanib, satr bo'lagini qaytaramiz.</p>
<p>Endi biz <code>birinchi_soz</code> ni chaqirganimizda, biz asosiy ma'lumotlarga bog'langan bitta qiymatni olamiz. Qiymat slicening boshlang'ich nuqtasiga va bo'limdagi elementlar soniga referencedan iborat.</p>
<p>Sliceni return qilish <code>ikkinchi_soz</code> funksiyasi uchun ham ishlaydi:</p>
<pre><code class="language-rust ignore">fn ikkinchi_soz(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Endi bizda oddiy API mavjud, uni buzish ancha qiyin, chunki kompilyator <code>String</code> ga referencelar haqiqiyligini ta'minlaydi. 4-8 ro'yxatdagi dasturdagi xatoni eslaysizmi, biz indeksni birinchi so'zning oxirigacha olib, keyin qatorni o'chirib tashlaganimizda, indeksimiz yaroqsiz edi? Bu kod mantiqan noto'g'ri edi, lekin darhol xatoliklarni ko'rsatmadi. Agar biz birinchi so'z indeksini bo'shatilgan qator bilan ishlatishga harakat qilsak, muammolar keyinroq paydo bo'ladi. Slicelar bu xatoni imkonsiz qiladi va kodimiz bilan bog'liq muammo borligini bizga tezroq bildiradi. <code>birinchi_soz</code> slice versiyasidan foydalanish kompilyatsiya vaqtida xatolikka olib keladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn birinchi_soz(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let baytlar = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in baytlar.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;salom dunyo&quot;);

    let soz = birinchi_soz(&amp;s);

    s.clear(); // error!

    println!(&quot;birinchi so'z: {}&quot;, soz);
}</code></pre>
<p>Mana kompilyator xatosi:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let soz = birinchi_soz(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!(&quot;birinchi so'z: {}&quot;, soz);
   |                                   ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Borrowing qoidalarini eslang, agar bizda biror narsaga o'zgarmas reference bo'lsa, biz o'zgaruvchan referenceni ham qabul qila olmaymiz. Chunki <code>clear</code> <code>String</code>ni qisqartirishi kerak, u o'zgaruvchan referenceni olishi kerak. <code>clear</code> chaqiruvidan keyingi <code>println!</code> <code>soz</code> dagi referencedan foydalanadi, shuning uchun o‚Äòzgarmas reference shu nuqtada faol bo‚Äòlishi kerak. Rust bir vaqtning o'zida <code>clear</code> va <code>soz</code> dagi o'zgarmas referenceni bir vaqtning o'zida mavjud bo'lishiga yo'l qo'ymaydi va kompilyatsiya bajarilmaydi. Rust nafaqat API-dan foydalanishni osonlashtirdi, balki kompilyatsiya vaqtidagi xatolarning butun sinfini ham yo'q qildi!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="string-literallar-slice-sifatida"><a class="header" href="#string-literallar-slice-sifatida">String literallar Slice sifatida</a></h4>
<p>Eslatib o'tamiz, biz binary tizimda saqlanadigan string literallari haqida gapirgan edik. Endi biz slicelar haqida bilganimizdan so'ng, biz string literallarini to'g'ri tushunishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Bu erda <code>s</code> turi <code>&amp;str</code>: bu binary faylning o'ziga xos nuqtasiga ishora qiluvchi slice. Shu sababli ham string literallari o'zgarmasdir; <code>&amp;str</code> - o'zgarmas reference.</p>
<h4 id="parametrlar-sifatida-string-slicelar"><a class="header" href="#parametrlar-sifatida-string-slicelar">Parametrlar sifatida String Slicelar</a></h4>
<p>Siz literal va <code>String</code> qiymatlarini olish mumkinligini bilish bizni <code>birinchi_soz</code>ni yana bir takomillashtirishga olib keladi va bu uning signaturesi:</p>
<pre><code class="language-rust ignore">fn birinchi_soz(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Tajribali Rustacean buni o'rniga 4-9 ro'yxatda ko'rsatilgan signatureni yozadi, chunki bu bizga <code>&amp;String</code> qiymatlari va <code>&amp;str</code> qiymatlarida bir xil funksiyadan foydalanishga imkon beradi.</p>
<pre><code class="language-rust ignore">fn birinchi_soz(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let baytlar = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in baytlar.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mening_stringim = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `birinchi_soz` `String` ning qisman yoki to'liq slicelarida ishlaydi
</span><span class="boring">    let soz = birinchi_soz(&amp;mening_stringim[0..6]);
</span><span class="boring">    let soz = birinchi_soz(&amp;mening_stringim[..]);
</span><span class="boring">    // `birinchi_soz`, shuningdek, `String` ning butun slicelariga ekvivalent bo`lgan
</span><span class="boring">    // `String`-ga referencelar ustida ham ishlaydi.
</span><span class="boring">    let soz = birinchi_soz(&amp;mening_stringim);
</span><span class="boring">
</span><span class="boring">    let mening_literal_stringim = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `birinchi_soz` qisman yoki to'liq bo'lgan string literallari slicelarida ishlaydi
</span><span class="boring">    let soz = birinchi_soz(&amp;mening_literal_stringim [0..6]);
</span><span class="boring">    let soz = birinchi_soz(&amp;mening_literal_stringim [..]);
</span><span class="boring">
</span><span class="boring">    // String literallari  allaqachon string slicelari bo'lganligi sababli,
</span><span class="boring">    // bu slice sintaksisisiz ham ishlaydi!
</span><span class="boring">    let soz = birinchi_soz(mening_literal_stringim );
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 4-9: <code>birinchi_soz</code> funksiyasini <code>s</code> parametri turi uchun string slicedan foydalanish orqali yaxshilash</span></p>
<p>Agar bizda string slice bo'lsa, biz uni to'g'ridan-to'g'ri o'tkazishimiz mumkin. Agar bizda <code>String</code> bo'lsa, biz <code>String</code> slicesini yoki <code>String</code> ga referenceni o'tkazishimiz mumkin. Ushbu moslashuvchanlik <em>deref coercionlari</em> dan foydalanadi, bu xususiyatni biz 15-bobning <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">‚ÄúFunktsiyalar va metodlar bilan Implicit Deref Coercionlari‚Äù</a><!--ignore-->  da ko‚Äòrib chiqamiz.</p>
<p><code>String</code> ga reference o‚Äòrniga string sliceni olish funksiyasini belgilash bizning API‚Äôni hech qanday funksionallikni yo‚Äòqotmasdan umumiyroq va foydali qiladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn birinchi_soz(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let baytlar = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in baytlar.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mening_stringim = String::from(&quot;hello world&quot;);

    // `birinchi_soz` `String` ning qisman yoki to'liq slicelarida ishlaydi
    let soz = birinchi_soz(&amp;mening_stringim[0..6]);
    let soz = birinchi_soz(&amp;mening_stringim[..]);
    // `birinchi_soz`, shuningdek, `String` ning butun slicelariga ekvivalent bo`lgan
    // `String`-ga referencelar ustida ham ishlaydi.
    let soz = birinchi_soz(&amp;mening_stringim);

    let mening_literal_stringim = &quot;hello world&quot;;

    // `birinchi_soz` qisman yoki to'liq bo'lgan string literallari slicelarida ishlaydi
    let soz = birinchi_soz(&amp;mening_literal_stringim [0..6]);
    let soz = birinchi_soz(&amp;mening_literal_stringim [..]);

    // String literallari  allaqachon string slicelari bo'lganligi sababli,
    // bu slice sintaksisisiz ham ishlaydi!
    let soz = birinchi_soz(mening_literal_stringim );
}</code></pre></pre>
<h3 id="boshqa-slicelar"><a class="header" href="#boshqa-slicelar">Boshqa Slicelar</a></h3>
<p>String slicelari, siz tasavvur qilganingizdek, stringlarga xosdir. Ammo yana umumiy slice turi ham bor. Ushbu arrayni ko'rib chiqing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>Xuddi biz satrning bir qismiga murojaat qilishni xohlaganimizdek, arrayning bir qismiga murojaat qilishni xohlashimiz mumkin. Biz shunday qilamiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>Ushbu slice <code>&amp;[i32]</code> turiga ega. U birinchi element va uzunlikka referenceni saqlash orqali string slicelari kabi ishlaydi. Siz boshqa barcha turdagi to'plamlar uchun bunday slicedan foydalanasiz. 8-bobda vektorlar haqida gapirganda, biz ushbu to'plamlarni batafsil muhokama qilamiz.</p>
<h2 id="xulosa-3"><a class="header" href="#xulosa-3">Xulosa</a></h2>
<p>Ownership, borrowing va slicelar tushunchalari kompilyatsiya vaqtida Rust dasturlarida xotira xavfsizligini ta'minlaydi. Rust tili sizga boshqa tizim dasturlash tillari kabi xotiradan foydalanishni boshqarish imkonini beradi, lekin egasi amal qilish doirasidan chiqib ketganda ma ºlumotlar egasi avtomatik ravishda ushbu ma ºlumotlarni tozalaydi, bu boshqaruvni olish uchun qo ªshimcha kod yozish va debug qilish shart emasligini anglatadi.</p>
<p>Ownership Rustning boshqa ko'plab qismlari qanday ishlashiga ta'sir qiladi, shuning uchun biz bu tushunchalar haqida kitobning qolgan qismida batafsilroq gaplashamiz. Keling, 5-bobga o'tamiz va ma'lumotlar bo'laklarini <code>struct</code>da birga guruhlashni ko'rib chiqamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tegishli-malumotlarni-tuzish-uchun-structlardan-foydalanish"><a class="header" href="#tegishli-malumotlarni-tuzish-uchun-structlardan-foydalanish">Tegishli ma'lumotlarni tuzish uchun Structlardan foydalanish</a></h1>
<p><code>struct</code> - foydalanuvchi tomonidan belgilangan ma'lumotlar turi bo'lib, u sizga mantiqiy va mantiqiy guruhni tashkil etuvchi bir nechta tegishli qiymatlarni nomlash va to'plash imkonini beradi. Agar siz obyektga yo'naltirilgan til bilan tanish bo'lsangiz, <em>struct</em> obyektning ma'lumotlar atributlariga o'xshaydi. Ushbu bobda biz tuplelarni structlar bilan solishtiramiz va o'zingiz bilgan narsalarga asoslaymiz va qachon structlar ma'lumotlarni guruhlashning eng yaxshi usuli ekanligini ko'rsatamiz.</p>
<p>Biz structlarni qanday aniqlash va yaratishni ko'rsatamiz. Struct turi bilan bog'liq xatti-harakatni belgilash uchun bog'langan funksiyalarni, ayniqsa <em>method</em>lar deb ataladigan bog'langan funksiyalarni qanday aniqlashni muhokama qilamiz. Structlar va enumlar (6-bobda muhokama qilingan) dastur domenida yangi turlarni yaratish uchun building block hisoblanadi. Ular sizga Rustning kompilyatsiya vaqti turini tekshirish imkoniyatlaridan to'liq foydalanish imkonini beradi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="structlarni-aniqlash-va-yaratish"><a class="header" href="#structlarni-aniqlash-va-yaratish">Structlarni aniqlash va yaratish</a></h2>
<p>Structlar <a href="ch03-02-data-types.html#the-tuple-type">‚ÄúTuple turi‚Äú</a><!-- ignore --> bo'limida muhokama qilingan tuplelarga o'xshaydi, chunki ikkalasi ham bir-biriga bog'liq bo'lgan bir nechta qiymatlarga ega.
Tuplelar singari, structning qismlari ham har xil turdagi bo'lishi mumkin. Tuplelardan farqli o'laroq, structda siz har bir ma'lumot qismini nomlaysiz, shunda qiymatlar nimani anglatishini tushunasiz. Ushbu nomlarni qo'shish structlar tuplelardan ko'ra moslashuvchanroq ekanligini anglatadi: misol qiymatlarini belgilash yoki ularga kirish uchun ma'lumotlar tartibiga ishonishingiz shart emas.</p>
<p>Structni aniqlash uchun biz <code>struct</code> kalit so`zini kiritamiz va butun tuzilishga nom beramiz. Struct nomi birgalikda guruhlangan ma'lumotlar bo'laklarining ahamiyatini tavsiflashi kerak. Keyin, jingalak qavslar ichida biz <em>maydonlar</em> deb ataydigan ma'lumotlar qismlarining nomlari va turlarini aniqlaymiz. Masalan, 5-1 ro'yxati foydalanuvchi hisobi haqidagi ma'lumotlarni saqlaydigan structni ko'rsatadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Foydalanuvchi {
    faollik: bool,
    foydalanuvchi: String,
    email: String,
    kirish_hisobi: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 5-1: <code>Foydalanuvchi</code> structi ta'rifi</span></p>
<p>Struct aniqlangandan so'ng, tegishli ma'lumotlar turiga ega bo'lgan har bir maydonga ma'lum bir qiymat berish orqali uni yaratish mumkin. Biz structning nomini ko'rsatish orqali misol yaratamiz va keyin <em>kalit: qiymat</em>(key: value) juftlarini o'z ichiga olgan jingalak qavslarni qo'shamiz, bu erda kalitlar maydonlarning nomlari va qiymatlar biz o'sha maydonlarda saqlamoqchi bo'lgan ma'lumotlardir.Biz maydonlarni structda e'lon qilgan tartibda ko'rsatishimiz shart emas. Boshqacha qilib aytganda, structning ta'rifi tur uchun umumiy shablonga o'xshaydi va misollar tur qiymatlarini yaratish uchun ushbu shablonni ma'lum ma'lumotlar bilan to'ldiradi. Misol uchun, biz 5-2 ro'yxatda ko'rsatilganidek, ma'lum bir foydalanuvchini e'lon qilishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Foydalanuvchi {
</span><span class="boring">    faollik: bool,
</span><span class="boring">    foydalanuvchi: String,
</span><span class="boring">    email: String,
</span><span class="boring">    kirish_hisobi: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let foydalanuvchi1 = Foydalanuvchi {
        faollik: true,
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        email: String::from(&quot;ismoilovdev@example.com&quot;),
        kirish_hisobi: 1,
    };
}</code></pre></pre>
<p><span class="caption">Ro'yxat 5-2: <code>Foydalanuvchi</code> nusxasini yaratish
structi</span></p>
<p>Structdan ma'lum bir qiymat olish uchun biz nuqta belgilaridan foydalanamiz. Masalan, ushbu foydalanuvchining elektron pochta manziliga kirish uchun biz <code>foydalanuvchi1.email</code> dan foydalanamiz. Agar misol o'zgaruvchan bo'lsa, biz nuqta belgisi yordamida qiymatni o'zgartirishimiz va ma'lum bir maydonga belgilashimiz mumkin. 5-3 ro'yxatda o'zgaruvchan <code>Foydalanuvchi</code> misolining <code>email</code> maydonidagi qiymatni qanday o'zgartirish mumkinligi ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Foydalanuvchi {
</span><span class="boring">    faollik: bool,
</span><span class="boring">    foydalanuvchi: String,
</span><span class="boring">    email: String,
</span><span class="boring">    kirish_hisobi: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let foydalanuvchi1 = Foydalanuvchi {
        faollik: true,
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        email: String::from(&quot;ismoilovdev@example.com&quot;),
        kirish_hisobi: 1,
    };

    foydalanuvchi1.email = String::from(&quot;asilbek@example.com&quot;);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 5-3: <code>Foydalanuvchi</code> misolining <code>email</code> maydonidagi qiymatni o'zgartirish</span></p>
<p>E'tibor bering, butun misol o'zgaruvchan bo'lishi kerak; Rust bizga faqat ma'lum maydonlarni o'zgaruvchan deb belgilashga ruxsat bermaydi. Har qanday ifodada bo'lgani kabi, biz ushbu yangi misolni bilvosita qaytarish uchun funksiya tanasidagi oxirgi ifoda sifatida structning yangi nusxasini qurishimiz mumkin.</p>
<p>5-4 ro ªyxatda berilgan email va foydalanuvchi nomi bilan <code>Foydalanuvchi</code> misolini qaytaruvchi <code>foydalanuvchi_yaratish</code> funksiyasi ko ªrsatilgan. <code>faollik</code> maydoni <code>true</code> qiymatini, <code>kirish_hisobi</code> esa <code>1</code> qiymatini oladi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Foydalanuvchi {
</span><span class="boring">    faollik: bool,
</span><span class="boring">    foydalanuvchi: String,
</span><span class="boring">    email: String,
</span><span class="boring">    kirish_hisobi: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn foydalanuvchi_yaratish(email: String, foydalanuvchi: String) -&gt; Foydalanuvchi {
    Foydalanuvchi {
        faollik: true,
        foydalanuvchi: foydalanuvchi,
        email: email,
        kirish_hisobi: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let foydalanuvchi1 = foydalanuvchi_yaratish(
</span><span class="boring">        String::from(&quot;ismoilovdev@example.com&quot;),
</span><span class="boring">        String::from(&quot;ismoilovdev&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 5-4: <code>foydalanuvchi_yaratish</code> funksiyasi email va foydalanuvchi nomini oladi va <code>Foydalanuvchi</code> misolini qaytaradi</span></p>
<p>Funksiya parametrlarini struct maydonlari bilan bir xil nom bilan nomlash mantiqan to‚Äòg‚Äòri keladi, lekin <code>email</code> va <code>foydalanuvchi</code> maydon nomlari va o‚Äòzgaruvchilarini takrorlash biroz zerikarli. Agar structda ko'proq maydonlar bo'lsa, har bir nomni takrorlash yanada zerikarli bo'ladi. Yaxshiyamki, qulay Shorthand bor!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="field-init-shorthandan-foydalanish"><a class="header" href="#field-init-shorthandan-foydalanish">Field Init Shorthandan foydalanish</a></h3>
<p>Parametr nomlari va struct maydonlarining nomlari 5-4 ro'yxatda aynan bir xil bo'lgani uchun, <code>foydalanuvchi_yaratish</code>ni qayta yozish uchun <em>init shorthand</em> sintaksisidan foydalanishimiz mumkin, shuning uchun u xuddi shunday ishlaydi, lekin <code>foydalanuvchi</code> va <code>email</code>ni takrorlamaydi, 5-5 ro'yxatda ko'rsatilganidek.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Foydalanuvchi {
</span><span class="boring">    faollik: bool,
</span><span class="boring">    foydalanuvchi: String,
</span><span class="boring">    email: String,
</span><span class="boring">    kirish_hisobi: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn foydalanuvchi_yaratish(email: String, foydalanuvchi: String) -&gt; Foydalanuvchi {
    Foydalanuvchi {
        faollik: true,
        foydalanuvchi,
        email,
        kirish_hisobi: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let foydalanuvchi1 = foydalanuvchi_yaratish(
</span><span class="boring">        String::from(&quot;ismoilovdev@example.com&quot;),
</span><span class="boring">        String::from(&quot;ismoilovdev&quot;),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 5-5: <code>foydalanuvchi</code> va <code>email</code> parametrlari struct maydonlari bilan bir xil nomga ega bo ªlgani uchun init shorthanddan foydalanadigan <code>foydalanuvchi_yaratish</code> funksiyasi</span></p>
<p>Bu yerda biz <code>Foydalanuvchi</code> structining yangi nusxasini yaratmoqdamiz, unda <code>email</code> deb nomlangan maydon mavjud. Biz <code>email</code> maydonining qiymatini <code>foydalanuvchi_yaratish</code> funksiyasining <code>email</code> parametridagi qiymatga o‚Äòrnatmoqchimiz. <code>email</code> maydoni va <code>email</code> parametri bir xil nomga ega bo'lgani uchun biz <code>email: email</code> emas, balki <code>email</code> yozishimiz kerak.</p>
<h3 id="structni-update-sintaksisidan-foydalanib-boshqa-tuzilma-nusxasidan-tuzilma-namunasini-yaratish"><a class="header" href="#structni-update-sintaksisidan-foydalanib-boshqa-tuzilma-nusxasidan-tuzilma-namunasini-yaratish">Structni update sintaksisidan foydalanib, boshqa tuzilma nusxasidan tuzilma namunasini yaratish</a></h3>
<p>Ko'pincha boshqa namunadagi qiymatlarning ko'pini o'z ichiga olgan, lekin ularning ba'zilarini o'zgartiradigan structning yangi nusxasini yaratish foydali bo'ladi. Buni <em>struct update sintaksisi</em> yordamida amalga oshirishingiz mumkin.</p>
<p>Birinchidan, 5-6 ro'yxatda biz yangilanish sintaksisisiz muntazam ravishda <code>foydalanuvchi2</code> da yangi <code>Foydalanuvchi</code> misolini qanday yaratishni ko'rsatamiz. Biz <code>email</code> uchun yangi qiymat o‚Äòrnatdik, lekin aks holda 5-2 ro‚Äòyxatda yaratgan <code>foydalanuvchi1</code> qiymatidan foydalanamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Foydalanuvchi {
</span><span class="boring">    faollik: bool,
</span><span class="boring">    foydalanuvchi: String,
</span><span class="boring">    email: String,
</span><span class="boring">    kirish_hisobi: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let foydalanuvchi1 = Foydalanuvchi {
</span><span class="boring">        email: String::from(&quot;ismoilovdev@example.com&quot;),
</span><span class="boring">        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
</span><span class="boring">        faollik: true,
</span><span class="boring">        kirish_hisobi: 1,
</span><span class="boring">    };
</span>
    let foydalanuvchi2 = Foydalanuvchi {
        faollik: foydalanuvchi1.faollik,
        foydalanuvchi: foydalanuvchi1.foydalanuvchi,
        email: String::from(&quot;asilbek@example.com&quot;),
        kirish_hisobi: foydalanuvchi1.kirish_hisobi,
    };
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 5-6: foydalanuvchi1 qiymatlaridan biri yordamida yangi <code>Foydalanuvchi</code> namunasini yaratish</span></p>
<p>Strukturani yangilash sintaksisidan foydalanib, biz 5-7 ro'yxatda ko'rsatilganidek, kamroq kod bilan bir xil effektga erishishimiz mumkin. <code>..</code> sintaksisi qolgan maydonlar aniq o'rnatilganligini va belgilangan namunadagi qiymatlarga ega bo'lishi kerakligini ko'rsatadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Foydalanuvchi {
</span><span class="boring">    faollik: bool,
</span><span class="boring">    foydalanuvchi: String,
</span><span class="boring">    email: String,
</span><span class="boring">    kirish_hisobi: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let foydalanuvchi1 = Foydalanuvchi {
</span><span class="boring">        email: String::from(&quot;ismoilovdev@example.com&quot;),
</span><span class="boring">        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
</span><span class="boring">        faollik: true,
</span><span class="boring">        kirish_hisobi: 1,
</span><span class="boring">    };
</span>
    let foydalanuvchi2 = Foydalanuvchi {
        email: String::from(&quot;asilbek@example.com&quot;),
        ..foydalanuvchi1
    };
}</code></pre></pre>
<p><span class="caption">Ro'yxat 5-7: <code>Foydalanuvchi</code> misoli uchun yangi <code>email</code> qiymatini o'rnatish, lekin <code>foydalanuvchi1</code> dagi qolgan qiymatlardan foydalanish uchun structni yangilash sintaksisidan foydalanish</span></p>
<p>5-7 ro ªyxatdagi kod <code>foydalanuvchi2</code> da <code>email</code> uchun boshqa qiymatga ega, lekin <code>foydalanuvchi1</code> dan <code>foydalanuvchi</code>, <code>faollik</code> va <code>kirish_hisobi</code> maydonlari uchun bir xil qiymatlarga ega bo ªlgan misol yaratadi. <code>..foydalanuvchi1</code> qolgan maydonlar o‚Äòz qiymatlarini <code>foydalanuvchi1</code> dagi tegishli maydonlardan olishi kerakligini ko‚Äòrsatish uchun oxirgi o‚Äòrinda turishi kerak, lekin biz istalgan tartibda xohlagancha ko'p maydonlar uchun qiymatlarni belgilashni tanlashimiz mumkin, strukturaning ta'rifidagi maydonlar tartibidan qat'i nazar.</p>
<p>E'tibor bering, strukturani yangilash sintaksisi topshiriq kabi <code>=</code> dan foydalanadi; Buning sababi, biz <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">‚ÄùO'zgaruvchilar va ma'lumotlarni ko'chirish bilan o'zaro ta'sir qilish‚Äù</a><!-- ignore --> bo'limida ko'rganimizdek, u ma'lumotlarni harakatlantiradi. Ushbu misolda biz <code>foydalanuvchi2</code> ni yaratganimizdan keyin <code>foydalanuvchi1</code> dan bir butun sifatida foydalana olmaymiz, chunki <code>foydalanuvchi1</code>ning <code>foydalanuvchi</code> maydonidagi <code>String</code> <code>foydalanuvchi2</code> ga ko ªchirilgan. Agar biz <code>foydalanuvchi2</code> ga <code>email</code> va <code>foydalanuvchi</code> uchun yangi <code>String</code> qiymatlarini bergan bo‚Äòlsak va shuning uchun <code>foydalanuvchi1</code>dan faqat <code>faollik</code> va <code>kirish_hisobi</code> qiymatlarini ishlatgan bo‚Äòlsak, keyin <code>foydalanuvchi1</code> <code>foydalanuvchi2</code> yaratilgandan keyin ham amal qiladi. <code>faollik</code> va <code>kirish_hisobi</code> turlari nusxa ko'chirish xususiyatini amalga oshiradigan turlardir, shuning uchun biz <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">‚ÄùStek ma'lumotlari: Nusxalash‚Äù</a><!-- ignore --> bo'limida muhokama qilgan xatti-harakatlar qo'llaniladi.</p>
<h3 id="har-xil-turlarni-yaratish-uchun-nomli-maydonlarsiz-tuplelardan-foydalanish"><a class="header" href="#har-xil-turlarni-yaratish-uchun-nomli-maydonlarsiz-tuplelardan-foydalanish">Har xil turlarni yaratish uchun nomli maydonlarsiz tuplelardan foydalanish</a></h3>
<p>Rust shuningdek, <em>tuple struct</em>lar deb ataladigan tuplelarga o'xshash structlarni qo'llab-quvvatlaydi.
Tuple structlari struct nomi taqdim etadigan qo'shimcha ma'noga ega, ammo ularning maydonlari bilan bog'langan nomlari yo'q; aksincha, ular faqat maydonlarning turlariga ega. Tuple structlari butun tuplega nom berish va tupleni boshqa tuplelardan farqli turga aylantirish zarur bo‚Äòlganda foydali bo‚Äòladi va har bir maydonni oddiy structdagi kabi nomlashda batafsil yoki ortiqcha bo‚Äòladi.</p>
<p>Tuple structini aniqlash uchun <code>struct</code> kalit so‚Äòzi va struct nomidan keyin tupledagi turlardan boshlang. Masalan, bu yerda biz <code>Rang</code> va <code>Nuqta</code> nomli ikkita tuple structini aniqlaymiz va foydalanamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rang(i32, i32, i32);
struct Nuqta(i32, i32, i32);

fn main() {
    let qora = Rang(0, 0, 0);
    let kelib_chiqishi = Nuqta(0, 0, 0);
}</code></pre></pre>
<p>Esda tutingki, <code>qora</code> va <code>kelib_chiqishi</code> qiymatlari har xil turdagi, chunki ular turli xil tuple structlarining namunalaridir. Structdagi maydonlar bir xil turlarga ega bo'lishi mumkin bo'lsa ham, siz belgilagan har bir struct o'z turiga ega. Masalan, <code>Rang</code> turidagi parametrni qabul qiladigan funksiya, har ikkala tur ham uchta <code>i32</code> qiymatidan iborat bo‚Äòlsa ham, <code>Nuqta</code>ni argument sifatida qabul qila olmaydi. Aks holda, tuple structi namunalari tupelarga o'xshaydi, chunki siz ularni alohida qismlarga ajratishingiz mumkin va individual qiymatga kirish uchun <code>.</code> va keyin indeksdan foydalanishingiz mumkin.</p>
<h3 id="hech-qanday-maydonsiz-unit-kabi-structlar"><a class="header" href="#hech-qanday-maydonsiz-unit-kabi-structlar">Hech qanday maydonsiz unit kabi structlar</a></h3>
<p>Shuningdek, siz hech qanday maydonga ega bo'lmagan structlarni belgilashingiz mumkin! Ular <em>unita o'xshash structlar</em> deb ataladi, chunki ular biz <a href="ch03-02-data-types.html#the-tuple-type">‚ÄùTuple turi‚Äù</a><!-- ignore --> bo'limida aytib o'tgan unit turiga <code>()</code> o'xshash harakat qiladilar. Unitga o'xshash structlar qaysidir turdagi traitni qo'llash kerak bo'lganda foydali bo'lishi mumkin, ammo sizda turning o'zida saqlash uchun ma'lumotlaringiz yo'q. Traitlarni 10-bobda muhokama qilamiz. Mana <code>AlwaysEqual</code> nomli unit structini e‚Äôlon qilish va instantsiyalash misoli:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<p><code>AlwaysEqual</code> ni aniqlash uchun biz <code>struct</code> kalit so'zidan, kerakli nomdan va keyin nuqta-verguldan foydalanamiz. Jingalak qavslar yoki qavslar kerak emas! Shunda biz <code>subject</code> o'zgaruvchisida <code>AlwaysEqual</code> misolini xuddi shunday tarzda olishimiz mumkin: biz belgilagan nomdan foydalanib, hech qanday jingalak qavs yoki qavslarsiz. Tasavvur qiling-a, keyinchalik biz ushbu turdagi xatti-harakatlarni shunday amalga oshiramizki, <code>AlwaysEqual</code> ning har bir nusxasi har doim boshqa turdagi har bir misolga teng bo'ladi, ehtimol sinov uchun ma'lum natijaga ega bo'lishi mumkin. Ushbu xatti-harakatni amalga oshirish uchun bizga hech qanday ma'lumot kerak emas! Traitlarni qanday aniqlash va ularni har qanday turdagi, shu jumladan unitga o'xshash structlarda amalga oshirishni 10-bobda ko'rasiz.</p>
<blockquote>
<h3 id="strukturaviy-malumotlarga-ownershiplik-qilish"><a class="header" href="#strukturaviy-malumotlarga-ownershiplik-qilish">Strukturaviy ma'lumotlarga ownershiplik qilish</a></h3>
<p>5-1 ro ªyxatdagi <code>Foydalanuvchi</code> structi ta ºrifida biz <code>&amp;str</code> string slice turidan
ko ªra tegishli <code>String</code> turidan foydalandik. Bu ataylab qilingan tanlov, chunki
biz ushbu structning har bir nusxasi uning barcha ma ºlumotlariga ega bo ªlishini
va bu ma ºlumotlar butun struct amalda bo ªlgunga qadar amal qilishini istaymiz.</p>
<p>Structlar boshqa narsaga tegishli ma ºlumotlarga referencelarni saqlashi ham mumkin,
ammo buning uchun biz 10-bobda muhokama qiladigan Rust xususiyatidan  <em>lifetimelar</em>
foydalanishni talab qiladi. Lifetime struct tomonidan reference qilingan ma'lumotlar
struct mavjud bo'lgunga qadar amal qilishini ta'minlaydi. Aytaylik, siz ma'lumotnomani
lifetimeni ko'rsatmasdan structda saqlashga harakat qildingiz, quyidagi kabi; bu ishlamaydi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct Foydalanuvchi {
    faollik: bool,
    foydalanuvchi: &amp;str,
    email: &amp;str,
    kirish_hisobi: u64,
}

fn main() {
    let foydalanuvchi1 = Foydalanuvchi {
        faollik: true,
        foydalanuvchi: &quot;ismoilovdev&quot;,
        email: &quot;ismoilovdev@example.com&quot;,
        kirish_hisobi: 1,
    };
}</code></pre>
<p>Kompilyator referencelarning lifetimeni aniqlash zarurati haqida shikoyat qiladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     foydalanuvchi: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct Foydalanuvchi&lt;'a&gt; {
2 |     faollik: bool,
3 ~     foydalanuvchi: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct Foydalanuvchi&lt;'a&gt; {
2 |     faollik: bool,
3 |     foydalanuvchi: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>10-bobda biz ushbu xatolarni qanday tuzatishni muhokama qilamiz, shunda siz
referencelarni structlarda saqlashingiz mumkin, ammo hozircha biz bu kabi
xatolarni <code>&amp;str</code> kabi referencelar o ªrniga <code>String</code> kabi tegishli turlardan foydalanib tuzatamiz.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="structlar-yordamida-namunaviy-dastur"><a class="header" href="#structlar-yordamida-namunaviy-dastur">Structlar yordamida namunaviy dastur</a></h2>
<p>Structlarni qachon ishlatishimiz mumkinligini tushunish uchun to'rtburchakning maydonini hisoblaydigan dastur yozaylik. Biz bitta o'zgaruvchilardan foydalanishni boshlaymiz, so'ngra uning o'rniga structlardan foydalanmagunimizcha dasturni qayta yaxshilab boramiz.</p>
<p>Keling, cargo bilan <em>kvadratlar</em> deb nomlangan yangi binary loyihani yarataylik, u piksellarda ko'rsatilgan to'rtburchakning kengligi va balandligini oladi va to'rtburchakning maydonini hisoblaydi. 5-8 ro'yxatda loyihaning <em>src/main.rs</em> faylida nima qilishimiz kerakligini aniq bajarishga imkon beradigan bitta qisqa kod ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let kenglik1 = 30;
    let balandlik1 = 50;

    println!(
        &quot;To'rtburchakning maydoni {} kvadrat piksel.&quot;,
        area(kenglik1, balandlik1)
    );
}

fn area(kenglik: u32, balandlik: u32) -&gt; u32 {
    kenglik * balandlik
}</code></pre></pre>
<p><span class="caption">Ro'yxat 5-8: Alohida kenglik va balandlik o'zgaruvchilari bilan belgilangan to'rtburchaklar maydonini hisoblash</span></p>
<p>Endi ushbu dasturni <code>cargo run</code> yordamida ishga tushiring:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
To'rtburchakning maydoni 1500 kvadrat piksel.
</code></pre>
<p>Ushbu kod har bir o'lcham bilan <code>area</code> funksiyasini chaqirish orqali to'rtburchakning maydonini aniqlashga muvaffaq bo'ladi, ammo biz ushbu kodni aniq va o'qilishi uchun ko'proq narsani qilishimiz mumkin.</p>
<p>Ushbu kod bilan bog'liq muammo <code>area</code> signaturesida aniq ko'rinadi:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let kenglik1 = 30;
</span><span class="boring">    let balandlik1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;To'rtburchakning maydoni {} kvadrat piksel.&quot;,
</span><span class="boring">        area(kenglik1, balandlik1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(kenglik: u32, balandlik: u32) -&gt; u32 {
<span class="boring">    kenglik * balandlik
</span><span class="boring">}</span></code></pre>
<p><code>area</code> funksiyasi bitta to'rtburchakning maydonini hisoblashi kerak, lekin biz yozgan funksiya ikkita parametrga ega va bizning dasturimizning hech bir joyida parametrlar o'zaro bog'liqligi aniq emas. Kenglik va balandlikni birgalikda guruhlash yanada o'qilishi va boshqarilishi oson bo'lishi mumkin edi.3-bobning <a href="ch03-02-data-types.html#the-tuple-type">‚ÄùTuple Turi‚Äù</a><!-- ignore --> bo'limida biz buni amalga oshirishning bir usulini, ya'ni tuplelardan foydalanishni muhokama qildik.</p>
<h3 id="tuplelar-yordamida-refaktoring"><a class="header" href="#tuplelar-yordamida-refaktoring">Tuplelar yordamida Refaktoring</a></h3>
<p>5-9 ro'yxatda tuplelardan foydalanadigan dasturimizning boshqa versiyasi ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let kvadrat1 = (30, 50);

    println!(
        &quot;To'rtburchakning maydoni {} kvadrat pikselga teng.&quot;,
        area(kvadrat1)
    );
}

fn area(olchamlari: (u32, u32)) -&gt; u32 {
    olchamlari.0 * olchamlari.1
}</code></pre></pre>
<p><span class="caption">Ro'yxat 5-9: To'rtburchakning kengligi va balandligini tuple yordamida aniqlash</span></p>
<p>Bir tomondan, bu dastur yaxshiroq. Tuplar bizga biroz struct qo'shishga imkon beradi va biz hozir faqat bitta argumentni keltiramiz. Ammo boshqa yo'l bilan, bu versiya unchalik aniq emas: tuplelar o'z elementlarini nomlamaydi, shuning uchun biz hisob-kitobimizni kamroq aniq qilib, tuple qismlariga indeks qilishimiz kerak.</p>
<p>Kenglik va balandlikni aralashtirish maydonni hisoblash uchun muhim emas, lekin agar biz ekranda to'rtburchak chizmoqchi bo'lsak, bu muhim bo'ladi! Shuni yodda tutishimiz kerakki, <code>kenglik</code> indeks <code>0</code> da, <code>balandlik</code> esa <code>1</code> indeksda. Agar kimdir bizning kodimizdan foydalansa, buni tushunish va yodda tutish qiyinroq bo'ladi. Kodimizda ma'lumotlarimizning ma'nosini yetkazmaganimiz sababli, endi xatolarni kiritish osonroq.</p>
<h3 id="struktuctlar-bilan-refaktoring-koproq-mano-qoshish"><a class="header" href="#struktuctlar-bilan-refaktoring-koproq-mano-qoshish">Struktuctlar bilan Refaktoring: ko'proq ma'no qo'shish</a></h3>
<p>Biz ma'lumotlarni etiketlash orqali ma'no qo'shish uchun structlardan foydalanamiz. Biz foydalanayotgan tupleni 5-10 ro'yxatda ko'rsatilganidek, butun nomi bilan bir qatorda qismlar nomlari bilan tuzilishga aylantirishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Kvadrat {
    kenglik: u32,
    balandlik: u32,
}

fn main() {
    let kvadrat1 = Kvadrat {
        kenglik: 30,
        balandlik: 50,
    };

    println!(
        &quot;To'rtburchakning maydoni {} kvadrat pikselga teng.&quot;,
        area(&amp;kvadrat1)
    );
}

fn area(kvadrat: &amp;Kvadrat) -&gt; u32 {
    kvadrat.kenglik * kvadrat.balandlik
}</code></pre></pre>
<p><span class="caption">Ro'yxat 5-10: <code>Kvadrat</code> strukturasini aniqlash</span></p>
<p>Bu yerda biz structni aniqladik va uni <code>Kvadrat</code> deb nomladik. Jingalak qavslar ichida biz maydonlarni <code>kenglik</code> va <code>balandlik</code> sifatida belgiladik, ularning ikkalasi ham <code>u32</code> turiga ega. Keyin, <code>main</code> da biz <code>Kvadrat</code> ning ma'lum bir misolini yaratdik, uning kengligi <code>30</code> va balandligi <code>50</code>.</p>
<p>Bizning <code>area</code> funksiyamiz endi biz <code>kvadrat</code> deb nomlagan bitta parametr bilan aniqlanadi, uning turi <code>Kvadrat</code> structi misolining o‚Äòzgarmas borrowidir. 4-bobda aytib o'tilganidek, biz unga ownershiplik qilishdan ko'ra, structi borrow qilishni xohlaymiz. Shunday qilib, <code>main</code> o'z ownershipini saqlab qoladi va <code>kvadrat1</code> dan foydalanishni davom ettirishi mumkin, shuning uchun biz funktsiya signaturesida <code>&amp;</code> dan foydalanamiz va biz funksiyani chaqiramiz.</p>
<p><code>area</code> funksiyasi <code>Kvadrat</code> misolining <code>kenglik</code> va <code>balandlik</code>  maydonlariga kiradi (esda tutingki, borrow qilingan struct misolining maydonlariga kirish maydon qiymatlarini ko'chirmaydi, shuning uchun siz ko'pincha structlarning borrowlarini ko'rasiz). Endi <code>area</code> funksiyasi signaturesi biz nimani nazarda tutayotganimizni aniq aytadi: <code>Kvadrat</code> maydonini uning <code>kenglik</code> va <code>balandlik</code> maydonlaridan foydalanib hisoblang. Bu kenglik va balandlik bir-biri bilan bog'liqligini bildiradi va <code>0</code> va <code>1</code> qator indeks qiymatlarini ishlatishdan ko'ra, qiymatlarga tavsiflovchi nomlar beradi. Bu aniqlik uchun g'alaba.</p>
<h3 id="olingan-traitlar-bilan-foydali-funksionallikni-qoshish"><a class="header" href="#olingan-traitlar-bilan-foydali-funksionallikni-qoshish">Olingan Traitlar bilan foydali funksionallikni qo'shish</a></h3>
<p>Dasturimizni debug qilish va uning barcha maydonlari uchun qiymatlarni ko'rish paytida <code>Kvadrat</code> misolini chop etish foydali bo'lar edi. 5-11 ro'yxatda biz avvalgi boblarda foydalanganimizdek <a href="../std/macro.println.html"><code>println!</code> makrosidan</a><!-- ignore --> foydalanishga harakat qiladi. Biroq, bu ishlamaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Kvadrat {
    kenglik: u32,
    balandlik: u32,
}
fn main() {
    let kvadrat1 = Kvadrat {
        kenglik: 30,
        balandlik: 50,
    };

    println!(&quot;kvadrat1 - {}&quot;, kvadrat1);
}</code></pre>
<p><span class="caption">Ro'yxat 5-11: <code>Kvadrat</code>ni chop etishga urinish
misoli</span></p>
<p>Ushbu kodni kompilyatsiya qilishda, biz ushbu asosiy xabar bilan xatoga duch kelamiz:</p>
<pre><code class="language-text">error[E0277]: `Kvadrat` doesn't implement `std::fmt::Display`
</code></pre>
<p><code>println!</code> makrosi ko'plab formatlash turlarini amalga oshirishi mumkin va standart bo'yicha jingalak qavslar <code>println!</code>ga <code>Display</code> deb nomlanuvchi formatlashdan foydalanishni bildiradi: to'g'ridan-to'g'ri oxirgi foydalanuvchi iste'moli uchun mo'ljallangan chiqish. Biz hozirgacha ko'rgan primitiv turlar standart bo'yicha <code>Display</code> ni qo'llaydi, chunki foydalanuvchiga <code>1</code> yoki boshqa primitiv turni ko'rsatishning faqat bitta usuli bor. Lekin structlar bilan <code>println!</code> ning chiqishni formatlash metodi unchalik aniq emas, chunki ko ªproq ko ªrsatish imkoniyatlari mavjud: vergul qo ªyishni xohlaysizmi yoki yo ªqmi? Jingalak qavslarni chop qilmoqchimisiz? Barcha maydonlar ko'rsatilishi kerakmi? Ushbu noaniqlik tufayli Rust biz xohlagan narsani taxmin qilishga urinmaydi va structlarda <code>println!</code> va <code>{}</code> to'ldiruvchisi bilan foydalanish uchun <code>Display</code> ning taqdim etilgan ilovasi yo'q.</p>
<p>Agar xatolarni o'qishda davom etsak, biz ushbu foydali eslatmani topamiz:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Kvadrat`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Keling, sinab ko'raylik! <code>println!</code> macro chaqiruvi endi <code>println!(&quot;kvadrat1 bu {}&quot;, kvadrat1);</code> kabi ko'rinadi. <code>:?</code> spetsifikatsiyasini jingalak qavslar ichiga qo'yish <code>println!</code> biz <code>Debug</code> deb nomlangan chiqish formatidan foydalanmoqchi ekanligimizni bildiradi. <code>Debug</code> traiti bizga sturctni ishlab chiquvchilar uchun foydali bo'lgan tarzda chop etish imkonini beradi, shuning uchun biz kodimizni tuzatish paytida uning qiymatini ko'rishimiz mumkin.</p>
<p>Keling, ushbu o'zgarishlar bilan kodni kompilyatsiya qilaylik. Ehh! Biz hali ham xatoni olamiz:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Ammo yana, kompilyator bizga foydali eslatma beradi:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust debug ma'lumotlarini chop etish funksiyasini o'z ichiga oladi, lekin biz ushbu funksiyani structimiz uchun mavjud qilish uchun ochiqdan-ochiq rozi bo'lishimiz kerak.
Buni amalga oshirish uchun 5-12 ro'yxatda ko'rsatilganidek, struct ta'rifidan oldin <code>#[derive(Debug)]</code> tashqi atributini qo'shamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Kvadrat {
    kenglik: u32,
    balandlik: u32,
}
fn main() {
    let kvadrat1 = Kvadrat {
        kenglik: 30,
        balandlik: 50,
    };

    println!(&quot;kvadrat1 - {:?}&quot;, kvadrat1);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 5-12: <code>Debug</code> traitini olish uchun atribut qo‚Äòshish va debug formatlash yordamida <code>Kvadrat</code> misolini chop etish</span></p>
<p>Endi dasturni ishga tushirganimizda, biz hech qanday xatolikka yo'l qo'ymaymiz va biz quyidagi natijani ko'ramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
kvadrat1 - Kvadrat { kenglik: 30, balandlik: 50 }
</code></pre>
<p>Yaxshi! Bu eng yaxshi natija emas, lekin u ushbu misol uchun barcha maydonlarning qiymatlarini ko'rsatadi, bu disk raskadrovka paytida albatta yordam beradi. Kattaroq structlarga ega bo'lsak, o'qishni biroz osonlashtiradigan chiqishga ega bo'lish foydalidir; bunday hollarda <code>println!</code> qatoridagi <code>{:?}</code> o'rniga <code>{:#?}</code> dan foydalanishimiz mumkin. Ushbu misolda <code>{:#?}</code> uslubidan foydalanish quyidagi natijalarni beradi:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
kvadrat1 - Kvadrat {
    kenglik: 30,
    balandlik: 50
}
</code></pre>
<p><code>Debug</code> formati yordamida qiymatni chop etishning yana bir usuli <a href="../std/macro.dbg.html"><code>dbg!</code> macro</a><!-- ignore --> Ifodaga egalik qiluvchi macro (mos referencelar oladigan println! dan farqli o'laroq) o'sha <code>dbg!</code> qayerda fayl va satr raqamini chop etadi! macro murojati sizning kodingizda ushbu ifodaning natijaviy qiymati bilan birga sodir bo'ladi va qiymatga egalik huquqini qaytaradi.</p>
<blockquote>
<p>Eslatma: <code>dbg!</code> makrosini chaqirish standart chiqish konsoli stremiga
(<code>stdout</code>) chop qiluvchi <code>println!</code>dan farqli ravishda standart xato
konsoli stremiga (<code>stderr</code>) chop etadi. Biz 12-bobdagi <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">‚ÄùXato xabarlarini standart
chiqish o‚Äòrniga standart xatoga yozish‚Äù</a><!-- ignore --> bo‚Äòlimida <code>stderr</code> va <code>stdout</code> haqida ko‚Äòproq
gaplashamiz.</p>
</blockquote>
<p>Mana bizni <code>kenglik</code> maydoniga tayinlanadigan qiymat, shuningdek <code>kvadrat1</code>dagi butun structning qiymati qiziqtiradigan misol:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Kvadrat {
    kenglik: u32,
    balandlik: u32,
}
fn main() {
    let masshtab = 2;
    let kvadrat1 = Kvadrat {
        kenglik: dbg!(30 * masshtab),
        balandlik: 50,
    };

    dbg!(&amp;kvadrat1);
}</code></pre></pre>
<p>Biz <code>30 * masshtab</code> iborasi atrofida <code>dbg!</code> qo'yishimiz mumkin va <code>dbg!</code> ifoda qiymatiga egalik huquqini qaytargani uchun, <code>kenglik</code> maydoni bizda <code>dbg!</code> chaqiruvi bo'lmagani kabi bir xil qiymatga ega bo'ladi. Biz <code>dbg!</code> <code>kvadrat1</code>ga egalik qilishini istamaymiz, shuning uchun keyingi chaqiruvda <code>kvadrat1</code> ga referencedan foydalanamiz.
Ushbu misolning natijasi quyidagicha ko'rinadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * masshtab = 60
[src/main.rs:14] &amp;kvadrat1 = Kvadrat {
    kenglik: 30,
    balandlik: 50
}
</code></pre>
<p>Biz birinchi debuggingda <em>src/main.rs</em> ning 10-qatoridan kelganini ko'rishimiz mumkin, bu erda biz <em>30 * masshtab</em> ifodani debugging qilamiz va uning natijaviy qiymati <code>60</code> (butun sonlar uchun <code>Debug</code> formati faqat ularning qiymatini chop etish uchun ishlatiladi). <em>src/main.rs</em> ning 14-qatoridagi <code>dbg!</code> chaqiruvi <code>&amp;kvadrat1</code> qiymatini chiqaradi, bu <code>Kvadrat</code> structidir. Ushbu chiqishda <code>Kvadrat</code> turidagi chiroyli <code>Debug</code> formatlash qo'llaniladi. <code>dbg!</code> makrosi sizning kodingiz nima qilayotganini aniqlashga harakat qilayotganingizda juda foydali bo'lishi mumkin!</p>
<p>Rust <code>Debug</code> traitiga qo‚Äòshimcha ravishda <code>derive</code> atributi bilan foydalanishimiz uchun bir qancha taritlarni taqdim etdi, ular bizning odatiy turlarimizga foydali xatti-harakatlar qo‚Äòshishi mumkin.Ushbu traitlar va ularning xatti-harakatlari <a href="appendix-03-derivable-traits.html">C ilovasida</a><!-- ignore --> keltirilgan. Biz 10-bobda ushbu traittlarni odatiy xatti-harakatlar bilan qanday implement qilishni, shuningdek, o'z traitlaringizni qanday yaratishni ko'rib chiqamiz.Bundan tashqari, 'derive' dan boshqa ko'plab atributlar mavjud; qo'shimcha ma'lumot olish uchun <a href="../reference/attributes.html">Rust Referencening &quot;Atributlar&quot; bo'limiga</a> qarang.</p>
<p>Bizning <code>area</code> funksiyamiz juda aniq: u faqat to'rtburchaklar maydonini hisoblaydi. Ushbu xatti-harakatni <code>Kvadrat</code> structimiz bilan yaqinroq bog'lash foydali bo'ladi, chunki u boshqa turlar bilan ishlamaydi. Keling, ushbu kodni qanday qilib qayta ishlashni davom ettirishimiz mumkinligini ko'rib chiqaylik, bu <code>area</code> funksiyasini <code>Kvadrat</code> turida aniqlangan <code>area</code> <em>metod</em> ga aylantiradi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="metod-sintaksisi"><a class="header" href="#metod-sintaksisi">Metod Sintaksisi</a></h2>
<p><em>Metodlar</em> funksiyalarga o ªxshaydi: biz ularni <code>fn</code> kalit so ªzi va nomi bilan e ºlon qilamiz, ular parametrlari va qaytish qiymatiga ega bo ªlishi mumkin va ular boshqa joydan metod chaqirilganda ishga tushadigan kodni o ªz ichiga oladi. Funktsiyalardan farqli o'laroq, metodlar struct (yoki biz mos ravishda <a href="ch06-00-enums.html">6-bob</a><!-- ignore --> va <a href="ch17-02-trait-objects.html">17-bobda</a><!-- ignore --> ko'rib chiqiladigan enum yoki trait obyekti) kontekstida aniqlanadi va ularning birinchi parametri har doim <code>self</code> dir metod chaqirilayotgan structning namunasini ifodalaydi.</p>
<h3 id="metodlarni-aniqlash"><a class="header" href="#metodlarni-aniqlash">Metodlarni aniqlash</a></h3>
<p>Parametr sifatida <code>Kvadrat</code> misoliga ega bo‚Äòlgan <code>area</code> funksiyasini o‚Äòzgartiramiz va uning o‚Äòrniga 5-13 ro‚Äòyxatda ko'rsatilganidek, <code>Kvadrat</code> structida belgilangan <code>area</code> metodini yaratamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Kvadrat {
    kenglik: u32,
    balandlik: u32,
}

impl Kvadrat {
    fn area(&amp;self) -&gt; u32 {
        self.kenglik * self.balandlik
    }
}

fn main() {
    let kvadrat1 = Kvadrat {
        kenglik: 30,
        balandlik: 50,
    };

    println!(
        &quot;To'rtburchakning maydoni {} kvadrat pikselga teng.&quot;,
        kvadrat1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Ro'yxat 5-13: <code>Kvadrat</code> structida <code>area</code> metodini aniqlash</span></p>
<p><code>Kvadrat</code> kontekstida funksiyani aniqlash uchun <code>Kvadrat</code> uchun <code>impl</code> (implementation) blokini ishga tushiramiz. Ushbu <code>impl</code> blokidagi hamma narsa <code>Kvadrat</code> turi bilan bog'lanadi. Keyin biz  <code>area</code> funksiyasini <code>impl</code> jingalak qavslar ichida harakatlantiramiz va birinchi (va bu holda, faqat) parametrni signatureda va tananing hamma joyida <code>self</code> o‚Äòzgartiramiz. <code>main</code> da, biz <code>area</code> funksiyasini chaqirib, argument sifatida <code>kvadrat1</code> ni topshirgan bo‚Äòlsak, o‚Äòrniga <code>Kvadrat</code> misolida <code>area</code> metodini chaqirish uchun <em>metod sintaksisi</em> dan foydalanishimiz mumkin. Metod sintaksisi misoldan keyin keladi: biz nuqta qo'shamiz, undan keyin metod nomi, qavslar va har qanday argumentlar qo'shiladi.</p>
<p><code>area</code> uchun signatureda <code>kvadrat: &amp;Kvadrat</code> o‚Äòrniga <code>&amp;self</code> dan foydalanamiz. <code>&amp;self</code> aslida  <code>self: &amp;Self</code> ning qisqartmasi. <code>impl</code> blokida <code>Self</code> turi <code>impl</code> bloki uchun bo'lgan turdagi taxallusdir. Metodlar birinchi parametri uchun <code>Self</code> turidagi <code>self</code> deb nomlangan parametrga ega bo'lishi kerak, shuning uchun Rust birinchi parametr joyida faqat <code>self</code> nomi bilan qisqartirish imkonini beradi.
Esda tutingki, biz hali ham <code>kvadrat: &amp;Kvadrat</code> da qilganimizdek, bu metod <code>Self</code> misolini olishini ko ªrsatish uchun <code>Self</code> stenografiyasi oldida <code>&amp;</code> dan foydalanishimiz kerak. Boshqa har qanday parametr singari, metodlar <code>self</code> egallashi, o'zgarmas <code>self</code> borrow qilishi mumkin, xuddi biz bu yerda qilganimizdek yoki o'zgaruvchan <code>self</code>ni borrow qilishi mumkin.</p>
<p>Biz bu yerda funksiya versiyasida <code>&amp;Kvadrat</code> dan foydalanganimiz uchun xuddi shu sababga ko‚Äòra <code>&amp;self</code> tanladik: biz ownershiplik qilishni istamaymiz va faqat structdagi ma‚Äôlumotlarni o‚Äòqishni istaymiz, unga yozishni emas. Agar biz ushbu metodning bir qismi sifatida chaqirgan misolni o'zgartirmoqchi bo'lsak, birinchi parametr sifatida <code>&amp;mut self</code> dan foydalanamiz. Birinchi parametr sifatida faqat <code>self</code>ni ishlatib, misolga ownershiplik qiladigan metod kamdan-kam uchraydi; bu metod odatda <code>self</code>ni boshqa narsaga aylantirganda va siz murojat qiluvchiga transformatsiyadan keyin asl nusxadan foydalanishiga yo'l qo'ymaslikni istasangiz ishlatiladi.</p>
<p>Funktsiyalar o'rniga metodlardan foydalanishning asosiy sababi, har bir metod signaturesida <code>self</code>turini takrorlashning hojati bo'lmagan metod sintaksisidan tashqari, kodni tashkil qilishdir. Biz kelajakdagi kod foydalanuvchilarini biz taqdim etayotgan kutubxonaning turli joylarida <code>Kvadrat</code> imkoniyatlarini izlashga majburlashdan ko‚Äòra, biz tur namunasi bilan qila oladigan barcha narsalarni bitta <code>impl</code> blokiga joylashtirdik.</p>
<p>E'tibor bering, biz metodga structning maydonlaridan biri bilan bir xil nom berishni tanlashimiz mumkin. Misol uchun, biz <code>Kvadrat</code> da <code>kenglik</code> deb nomlangan metodni belgilashimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Kvadrat {
</span><span class="boring">    kenglik: u32,
</span><span class="boring">    balandlik: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Kvadrat {
    fn kenglik(&amp;self) -&gt; bool {
        self.kenglik &gt; 0
    }
}

fn main() {
    let kvadrat1 = Kvadrat {
        kenglik: 30,
        balandlik: 50,
    };

    if kvadrat1.kenglik() {
        println!(&quot;To'rtburchakning kengligi nolga teng bo'lmagan; bu {}&quot;, kvadrat1.kenglik);
    }
}</code></pre></pre>
<p>Bu yerda, agar misolning <code>kenglik</code> maydonidagi qiymat <code>0</code> dan katta bo‚Äòlsa, <code>kenglik</code> metodi <code>true</code> qiymatini qaytaradi, agar qiymat <code>0</code> bo'lsa, <code>false</code> bo‚Äòlishini tanlaymiz: biz bir xil nomdagi metod ichidagi maydonni istalgan maqsadda ishlatishimiz mumkin. <code>main</code> da, biz qavslar bilan <code>kvadrat1.kenglik</code> ga amal qilsak, Rust <code>kenglik</code> metodini nazarda tutayotganimizni biladi. Qavslardan foydalanmasak, Rust <code>kenglik</code> maydonini nazarda tutayotganimizni biladi.</p>
<p>Ko'pincha, lekin har doim emas, biz metodga maydon bilan bir xil nom berganimizda, biz u faqat maydondagi qiymatni qaytarishini va boshqa hech narsa qilmasligini xohlaymiz. Shunga o'xshash metodlar <em>getters</em> deb ataladi va Rust ularni boshqa tillarda bo'lgani kabi tizim maydonlari uchun avtomatik ravishda amalga oshirmaydi. Getterslar foydalidir, chunki siz maydonni shaxsiy(private), lekin metodni hammaga ochiq(public) qilib qo'yishingiz mumkin va shu tariqa ushbu maydonga umumiy API ning bir qismi sifatida faqat o'qish uchun ruxsatni yoqishingiz mumkin. Biz <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">7-bobda</a><!-- ignore --> public va private nima ekanligini va qanday qilib maydon yoki metodni public yoki private deb belgilashni muhokama qilamiz.</p>
<blockquote>
<h3 id="--operatori-qayerda-ishlatiladi"><a class="header" href="#--operatori-qayerda-ishlatiladi"><code>-&gt;</code> operatori qayerda ishlatiladi?</a></h3>
<p>C va C++ tillarida metodlarni chaqirish uchun ikki xil operator qo'llaniladi:
obyektdagi metodni to'g'ridan-to'g'ri chaqirayotgan bo'lsangiz <code>.</code> va agar
siz ko'rsatgichdagi metodni obyektga chaqirayotgan bo'lsangiz va avval
ko'rsatgichni yo'qotishingiz kerak bo'lsa <code>-&gt;</code> dan foydalanasiz. Boshqacha qilib aytganda,
agar <code>object</code> havola bo'lsa, u holda <code>object-&gt;something()</code> va <code>(*object).something()</code> metodi
chaqiruvlari bir xil bo'ladi.</p>
<p>Rust <code>-&gt;</code> operatoriga ekvivalentga ega emas;  Buning o'rniga Rustda
<em>avtomatik reference va dereferencing</em> deb nomlangan xususiyat mavjud. Metodni chaqirish
Rustda bunday xatti-harakatlarga ega bo'lgan kam sonli joylardan biridir.</p>
<p>Bu shunday ishlaydi: <code>object.something()</code> bilan metodni chaqirganingizda,
Rust avtomatik ravishda <code>&amp;</code>, <code>&amp;mut</code> yoki <code>*</code> ni qo'shadi, shuning uchun <code>object</code>
metod signaturega mos keladi. Boshqacha qilib aytganda, quyidagilar bir xil:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn masofa(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_kvadrat = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_kvadrat = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_kvadrat + y_kvadrat)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.masofa(&amp;p2);
(&amp;p1).masofa(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>Birinchisi ancha toza ko'rinadi. Ushbu avtomatik reference qilish harakati,
metodlar aniq qabul qiluvchiga ega bo'lganligi sababli ishlaydi - <code>self</code> turi. Qabul qiluvchi
va metod nomini hisobga olgan holda, Rust ma'lum bir holatda kod nima qilayotganini aniq aniqlashi mumkin:
o'qish <code>(&amp;self)</code>, o'zgartirish (<code>&amp;mut self</code>) yoki iste'mol qilish  (<code>self</code>). Rust metodi
qabul qiluvchilar uchun borrow qilishni yashirin qilib qo'yganligi amalda ownershipni
ergonomik qilishning katta qismidir.</p>
</blockquote>
<h3 id="koproq-parametrlarga-ega-metodlar"><a class="header" href="#koproq-parametrlarga-ega-metodlar">Ko'proq parametrlarga ega metodlar</a></h3>
<p><code>Kvadrat</code> structida ikkinchi metodni implement qilish orqali metodlardan foydalanishni mashq qilaylik. Bu safar biz <code>Kvadrat</code> misoli <code>Kvadrat</code> ning boshqa nusxasini olishini va agar ikkinchi <code>Kvadrat</code> to'liq o'ziga (birinchi <code>Kvadrat</code>) sig'ishi mumkin bo'lsa, <code>true</code> qiymatini qaytarishini istaymiz; aks holda u <code>false</code>ni qaytarishi kerak.
Ya'ni, <code>ushlab_tur</code> metodini aniqlaganimizdan so'ng, biz 5-14 ro'yxatda ko'rsatilgan dasturni yozish imkoniyatiga ega bo'lishni xohlaymiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let kvadrat1 = Kvadrat {
        kenglik: 30,
        balandlik: 50,
    };
    let kvadrat2 = Kvadrat {
        kenglik: 10,
        balandlik: 40,
    };
    let kvadrat3 = Kvadrat {
        kenglik: 60,
        balandlik: 45,
    };

    println!(&quot;kvadrat1 kvadrat2ni ushlab turadimi? {}&quot;, kvadrat1.ushlab_tur(&amp;kvadrat2));
    println!(&quot;kvadrat1 kvadrat3ni ushlab turadimi? {}&quot;, kvadrat1.ushlab_tur(&amp;kvadrat3));
}</code></pre>
<p><span class="caption">Ro'yxat 5-14: Hali yozilmagan <code>ushlab_tur</code> dan foydalanish
metodi</span></p>
<p>Kutilgan natija quyidagicha ko‚Äòrinadi, chunki <code>kvadrat2</code> ning ikkala o‚Äòlchami <code>kvadrat1</code> o‚Äòlchamidan kichikroq, lekin <code>kvadrat3</code> <code>kvadrat1</code> dan kengroq:</p>
<pre><code class="language-text">kvadrat1 kvadrat2ni ushlab turadimi? true
kvadrat1 kvadrat3ni ushlab turadimi? false
</code></pre>
<p>Biz metodni aniqlamoqchi ekanligimizni bilamiz, shuning uchun u <code>impl Kvadrat</code> blokida bo'ladi. Metod nomi <code>ushlab_tur</code> bo'ladi va u parametr sifatida boshqa <code>Kvadrat</code> ning o'zgarmas borrowini oladi. Parametrning turi qanday bo'lishini metodni chaqiruvchi kodga qarab aniqlashimiz mumkin: <code>kvadrat1.ushlab_tur(&amp;kvadrat2)</code> <code>&amp;kvadrat2</code> da o'tadi, bu <code>kvadrat2</code> ga o'zgarmas borrow, <code>Kvadrat</code> misoli. Bu mantiqqa to'g'ri keladi, chunki biz faqat <code>kvadrat2</code> ni o'qishimiz kerak (yozishdan ko'ra, bu bizga o'zgaruvchan borrow kerak degan ma'noni anglatadi), va biz <code>main</code> <code>kvadrat2</code> ownershipligini saqlab qolishini istaymiz, shuning uchun <code>ushlab_tur</code> metodini chaqirganimizdan keyin uni qayta ishlatishimiz mumkin. <code>ushlab_tur</code> ning return qiymati mantiqiy qiymat bo'ladi va implement <code>self</code> ning kengligi va balandligi mos ravishda boshqa <code>Kvadrat</code> ning kengligi va balandligidan katta ekanligini tekshiradi. Keling, 5-15 ro'yxatda ko'rsatilgan 5-13 ro'yxatdagi <code>impl</code> blokiga yangi <code>ushlab_tur</code> metodini qo'shamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Kvadrat {
</span><span class="boring">    kenglik: u32,
</span><span class="boring">    balandlik: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Kvadrat {
    fn area(&amp;self) -&gt; u32 {
        self.kenglik * self.balandlik
    }

    fn ushlab_tur(&amp;self, other: &amp;Kvadrat) -&gt; bool {
        self.kenglik &gt; other.kenglik &amp;&amp; self.balandlik &gt; other.balandlik
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let kvadrat1 = Kvadrat {
</span><span class="boring">        kenglik: 30,
</span><span class="boring">        balandlik: 50,
</span><span class="boring">    };
</span><span class="boring">    let kvadrat2 = Kvadrat {
</span><span class="boring">        kenglik: 10,
</span><span class="boring">        balandlik: 40,
</span><span class="boring">    };
</span><span class="boring">    let kvadrat3 = Kvadrat {
</span><span class="boring">        kenglik: 60,
</span><span class="boring">        balandlik: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;kvadrat1 kvadrat2ni ushlab turadimi? {}&quot;, kvadrat1.ushlab_tur(&amp;kvadrat2));
</span><span class="boring">    println!(&quot;kvadrat1 kvadrat3ni ushlab turadimi? {}&quot;, kvadrat1.ushlab_tur(&amp;kvadrat3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 5-15: Parametr sifatida boshqa <code>Kvadrat</code> misolini oladigan <code>ushlab_tur</code> metodini <code>Kvadrat</code>da qo'llash</span></p>
<p>Ushbu kodni 5-14 ro'yxatdagi <code>main</code> funksiya bilan ishga tushirganimizda, biz kerakli natijani olamiz. Metodlar biz signaturega <code>self</code> parametridan keyin qo'shadigan bir nechta parametrlarni olishi mumkin va bu parametrlar funksiyalardagi parametrlar kabi ishlaydi.</p>
<h3 id="associate-funksiyalar"><a class="header" href="#associate-funksiyalar">Associate Funksiyalar</a></h3>
<p>Associate Funksiyalar (Bog'langan Funktsiyalar).<code>impl</code> blokida aniqlangan barcha funksiyalar <em>associated funksiyalar</em> deb ataladi, chunki ular <code>impl</code> nomi bilan atalgan tur bilan bog‚Äòlangan. Biz birinchi parametr sifatida <code>self</code> ega bo'lmagan associated funksiyalarni belgilashimiz mumkin (va shuning uchun metodlar emas), chunki ular bilan ishlash uchun turdagi namuna kerak emas.
Biz allaqachon shunday funksiyadan foydalanganmiz: <code>String</code> turida aniqlangan <code>String::from</code> funksiyasi.</p>
<p>Metod bo'lmagan associated funktsiyalar ko'pincha structning yangi nusxasini qaytaradigan konstruktorlar uchun ishlatiladi. Ular ko'pincha <code>new</code> deb ataladi, ammo <code>new</code> maxsus nom emas va tilga kiritilmagan. Masalan, biz bir o‚Äòlchamli parametrga ega bo‚Äòlgan <code>kvadrat</code> nomli associated funksiyani taqdim etishimiz va undan kenglik va balandlik sifatida foydalanishimiz mumkin, bu esa bir xil qiymatni ikki marta belgilashdan ko‚Äòra <code>Kvadrat</code> kvadratini yaratishni osonlashtiradi. :</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Kvadrat {
</span><span class="boring">    kenglik: u32,
</span><span class="boring">    balandlik: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Kvadrat {
    fn kvadrat(size: u32) -&gt; Self {
        Self {
            kenglik: size,
            balandlik: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let kv = Kvadrat::kvadrat(3);
</span><span class="boring">}</span></code></pre></pre>
<p>Return turidagi va funksiya tanasidagi <code>Self</code> kalit so'zlari <code>impl</code> kalit so'zidan keyin paydo bo'ladigan turning taxalluslari bo'lib, bu holda <code>Kvadrat</code> bo'ladi. Biz bularni <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">7-bobda</a><!-- ignore --> muhokama qilamiz.</p>
<p>Ushbu associated funktsiyani chaqirish uchun biz struct nomi bilan <code>::</code> sintaksisidan foydalanamiz; <code>let kv = Kvadrat::kvadrat(3);</code> misol bo'la oladi. Bu funksiya struct tomonidan nom maydoniga ega: <code>::</code> sintaksisi ham associated funksiyalar, ham modullar tomonidan yaratilgan nomlar bo'shliqlari uchun ishlatiladi. Biz modullarni <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">7-bobda</a><!-- ignore --> muhokama qilamiz.</p>
<h3 id="bir-nechta-impl-bloklari"><a class="header" href="#bir-nechta-impl-bloklari">Bir nechta <code>impl</code> bloklari</a></h3>
<p>Har bir structga bir nechta <code>impl</code> bloklari ruxsat etiladi. Masalan, 5-15 ro'yxati 5-16 ro'yxatida ko'rsatilgan kodga ekvivalent bo'lib, har bir metod o'zining <code>impl</code> blokiga ega yani har bir metod o'z <code>impl</code> blokida.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Kvadrat {
</span><span class="boring">    kenglik: u32,
</span><span class="boring">    balandlik: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Kvadrat {
    fn area(&amp;self) -&gt; u32 {
        self.kenglik * self.balandlik
    }
}

impl Kvadrat {
    fn ushlab_tur(&amp;self, other: &amp;Kvadrat) -&gt; bool {
        self.kenglik &gt; other.kenglik &amp;&amp; self.balandlik &gt; other.balandlik
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let kvadrat1 = Kvadrat {
</span><span class="boring">        kenglik: 30,
</span><span class="boring">        balandlik: 50,
</span><span class="boring">    };
</span><span class="boring">    let kvadrat2 = Kvadrat {
</span><span class="boring">        kenglik: 10,
</span><span class="boring">        balandlik: 40,
</span><span class="boring">    };
</span><span class="boring">    let kvadrat3 = Kvadrat {
</span><span class="boring">        kenglik: 60,
</span><span class="boring">        balandlik: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;kvadrat1 kvadrat2ni ushlab turadimi? {}&quot;, kvadrat1.ushlab_tur(&amp;kvadrat2));
</span><span class="boring">    println!(&quot;kvadrat1 kvadrat3ni ushlab turadimi? {}&quot;, kvadrat1.ushlab_tur(&amp;kvadrat3));
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 5-16: Bir nechta <code>impl</code> bloklari yordamida 5-15 ro'yxatini qayta yozish</span></p>
<p>Bu metodlarni bir nechta <code>impl</code> bloklariga ajratish uchun hech qanday sabab yo'q, lekin bu to'g'ri sintaksis. Biz 10-bobda bir nechta <code>impl</code> bloklari foydali bo'lgan holatni ko'rib chiqamiz, bu yerda biz umumiy turlar va taritlarni muhokama qilamiz.</p>
<h2 id="xulosa-4"><a class="header" href="#xulosa-4">Xulosa</a></h2>
<p>Structlar sizning domeningiz uchun mazmunli bo'lgan maxsus turlarni yaratishga imkon beradi. Structlardan foydalanib, siz bog'langan ma'lumotlar qismlarini bir-biriga bog'lab qo'yishingiz va kodingizni aniq qilish uchun har bir qismga nom berishingiz mumkin. <code>impl</code> bloklarida siz o'zingizning turingiz bilan bog'liq bo'lgan funksiyalarni belgilashingiz mumkin va metodlar - bu sizning structlaringiz misollarining xatti-harakatlarini belgilashga imkon beruvchi associated funksiyaning bir turi.</p>
<p>Ammo structlar maxsus turlarni yaratishning yagona usuli emas: toolboxga boshqa toolni qo'shish uchun Rust enum xususiyatiga murojaat qilaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumlar-va-pattern-match"><a class="header" href="#enumlar-va-pattern-match">Enumlar va Pattern Match</a></h1>
<p>Ushbu bobda biz <em>enumlar</em> deb ham ataladigan <em>enumerations</em>ni ko'rib chiqamiz.
Enumlar sizga turni uning mumkin bo'lgan <em>variantlarini</em> sanab aniqlash imkonini beradi. Avval enum ma'lumotarni qanday birlashtirishi mumkinligini ko'rsatish uchun enumni aniqlaymiz va ishlatamiz. Keyinchalik, qiymatning biror narsa yoki hech narsa bo'lishi mumkinligini ifodalovchi <code>Option</code> deb nomlangan juda foydali enumni o'rganamiz. Keyin biz <code>match</code> iborasida pattern matching  enumning turli qiymatlari uchun turli kodlarni ishga tushirishni qanday osonlashtirishini ko'rib chiqamiz. Nihoyat, <code>if let</code> konstruksiyasi sizning kodingizdagi enumlar bilan ishlash uchun qanday qulay va ixcham idioma ekanligini ko'rib chiqamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enumni-aniqlash"><a class="header" href="#enumni-aniqlash">Enumni aniqlash</a></h2>
<p>Structlar sizga tegishli maydonlar va ma'lumotlarni, masalan, <code>kenglik</code> va <code>balandlik</code> bilan <code>Kvadrat</code> ni guruhlash usulini beradigan bo'lsa, enumlar qiymatni mumkin bo'lgan qiymatlar to'plamidan biri deb aytish metodini beradi. Masalan, <code>Kvadrat</code> bu mumkin bo‚Äòlgan shakllar to‚Äòplamidan biri bo‚Äòlib, <code>Doira</code> va <code>Uchburchak</code>ni ham o‚Äòz ichiga oladi, demoqchimiz. Buning uchun Rust bizga ushbu imkoniyatlarni enum sifatida kodlash imkonini beradi.</p>
<p>Keling, kodda ifodalashni xohlashimiz mumkin bo'lgan vaziyatni ko'rib chiqaylik va bu holda nima uchun enumlar foydali va structlardan ko'ra mosroq ekanligini bilib olaylik. Aytaylik, biz IP manzillar bilan ishlashimiz kerak. Hozirgi vaqtda IP manzillar uchun ikkita asosiy standart qo'llaniladi: to'rtinchi versiya va oltinchi versiya. Bular bizning dasturimiz duch keladigan IP-manzilning yagona imkoniyatlari bo'lgani uchun biz barcha mumkin bo'lgan variantlarni <em>enumerate</em> qilishimiz mumkin, bu yerda enumeration o'z nomini oladi.</p>
<p>Har qanday IP manzil to'rtinchi versiya yoki oltinchi versiya manzili bo'lishi mumkin, lekin ikkalasi bir vaqtning o'zida emas. IP-manzillarning bu xususiyati enum ma'lumotlar structini mos qiladi, chunki enum qiymati faqat uning variantlaridan biri bo'lishi mumkin.
To'rtinchi versiya va oltinchi versiya manzillari hali ham IP-manzillardir, shuning uchun kod har qanday IP-manzilga tegishli vaziyatlarni ko'rib chiqayotganda ular bir xil turdagi sifatida ko'rib chiqilishi kerak.</p>
<p>Biz ushbu kontseptsiyani kodda <code>IpAddrKind</code> ro'yxatini belgilash va IP-manzil bo'lishi mumkin bo'lgan <code>V4</code> va <code>V6</code> turlarini enumeration qilish orqali ifodalashimiz mumkin. Bular enumning variantlari:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let tort = IpAddrKind::V4;
</span><span class="boring">    let olti = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_turi: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> endi biz kodimizning boshqa joylarida foydalanishimiz mumkin bo'lgan maxsus ma'lumotlar turidir.</p>
<h3 id="enum-qiymatlari"><a class="header" href="#enum-qiymatlari">Enum qiymatlari</a></h3>
<p>Biz <code>IpAddrKind</code> ning ikkita variantining har birining misollarini quyidagicha yaratishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tort = IpAddrKind::V4;
    let olti = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_turi: IpAddrKind) {}</span></code></pre></pre>
<p>E'tibor bering, enumning variantlari uning identifikatori ostida nom maydonida joylashgan va biz ikkalasini ajratish uchun qo'sh nuqtadan foydalanamiz. Bu foydali, chunki endi ikkala <code>IpAddrKind::V4</code> va <code>IpAddrKind::V6</code> qiymatlari bir xil turdagi: <code>IpAddrKind</code>. Masalan, biz har qanday <code>IpAddrKind</code> ni qabul qiladigan funksiyani aniqlashimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let tort = IpAddrKind::V4;
</span><span class="boring">    let olti = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_turi: IpAddrKind) {}</code></pre></pre>
<p>Va biz bu funktsiyani ikkala variant bilan chaqirishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let tort = IpAddrKind::V4;
</span><span class="boring">    let olti = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_turi: IpAddrKind) {}</span></code></pre></pre>
<p>Enumlardan foydalanish yanada ko'proq afzalliklarga ega. Bizning IP manzilimiz turi haqida ko'proq o'ylab ko'rsak, hozirda bizda haqiqiy IP-manzilni <em>ma'lumotlarni</em> saqlash imkoni yo'q; biz faqat qanday <em>turdagi</em> ekanligini bilamiz. 5-bobda structlar haqida hozirgina bilib olganingizni hisobga olsak, 6-1 ro'yxatda ko'rsatilganidek, bu muammoni structlar yordamida hal qilish istagi paydo bo'lishi mumkin.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        tur: IpAddrKind,
        manzil: String,
    }

    let asosiy = IpAddr {
        tur: IpAddrKind::V4,
        manzil: String::from(&quot;127.0.0.1&quot;),
    };

    let orqaga_qaytish = IpAddr {
        tur: IpAddrKind::V6,
        manzil: String::from(&quot;::1&quot;),
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 6-1: <code>struct</code> yordamida IP manzilining ma'lumotlarini va <code>IpAddrKind</code> variantini saqlash</span></p>
<p>Bu yerda biz ikkita maydonga ega bo ªlgan <code>IpAddr</code> structini aniqladik: <code>IpAddrKind</code> turidagi <code>tur</code> maydoni (biz avvalroq belgilagan raqam) va <code>String</code> tipidagi <code>manzil</code> maydoni. Bizda bu structning ikkita misoli bor. Birinchisi <code>asosiy</code> bo ªlib, u <code>127.0.0.1</code> bog ªlangan manzil ma ºlumotlari bilan <code>tur</code> sifatida <code>IpAddrKind::V4</code> qiymatiga ega. Ikkinchi misol - <code>orqaga_qaytish</code>. U <code>tur</code> qiymati sifatida <code>IpAddrKind</code> ning boshqa variantiga ega, <code>V6</code> va u bilan bog'langan <code>::1</code> manzili mavjud. Biz <code>tur</code> va <code>manzil</code> qiymatlarini birlashtirish uchun structdan foydalanganmiz, shuning uchun endi variant qiymat bilan bog'langan.</p>
<p>Shu bilan birga, bir xil kontseptsiyani faqat enum yordamida ifodalash yanada ixchamroqdir: struct ichidagi enum o'rniga, biz ma'lumotlarni to'g'ridan-to'g'ri har bir enum variantiga qo'yishimiz mumkin. <code>IpAddr</code> enumining ushbu yangi ta'rifida aytilishicha, <code>V4</code> va <code>V6</code> variantlari ham associated <code>String</code> qiymatlariga ega bo'ladi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let asosiy = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let orqaga_qaytish = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Biz to'g'ridan-to'g'ri enumning har bir variantiga ma'lumotlarni biriktiramiz, shuning uchun qo'shimcha structga ehtiyoj qolmaydi. Bu yerda, shuningdek, enumlar qanday ishlashining yana bir tafsilotini ko'rish osonroq bo'ladi: biz belgilagan har bir enum variantining nomi, shuningdek, enum nusxasini yaratuvchi funktsiyaga aylanadi. Ya'ni, <code>IpAddr::V4()</code> funksiya chaqiruvi bo'lib, u <code>String</code> argumentini oladi va <code>IpAddr</code> tipidagi misolni qaytaradi. Enumni aniqlash natijasida aniqlangan ushbu konstruktor funksiyasini avtomatik ravishda olamiz.</p>
<p>Structdan ko'ra enumdan foydalanishning yana bir afzalligi bor: har bir variantda bog'langan ma'lumotlarning har xil turlari va miqdori bo'lishi mumkin. To'rtinchi versiyada IP-manzillar har doim 0 dan 255 gacha bo'lgan qiymatlarga ega bo'lgan to'rtta raqamli komponentga ega bo'ladi. Agar biz <code>V4</code> manzillarini to‚Äòrtta <code>u8</code> qiymati sifatida saqlamoqchi bo‚Äòlsak-da, <code>V6</code> manzillarini bitta <code>String</code> qiymati sifatida ifodalasak, biz struct bilan buni qila olmaymiz. Enumlar bu ishni osonlik bilan hal qiladi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let asosiy = IpAddr::V4(127, 0, 0, 1);

    let orqaga_qaytish = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Biz to'rtinchi versiya va oltinchi versiya IP manzillarini saqlash uchun ma'lumotlar tuzilmalarini aniqlashning bir necha xil usullarini ko'rsatdik. Biroq, ma'lum bo'lishicha, IP-manzillarni saqlash va ularning qaysi turini kodlash istagi shunchalik keng tarqalganki, <a href="../std/net/enum.IpAddr.html">standart kutubxonada biz foydalanishimiz mumkin bo'lgan defination mavjud!</a><!-- ignore --> . Keling, standart kutubxona <code>IpAddr</code> ni qanday aniqlashini ko'rib chiqaylik: u biz aniqlagan va ishlatgan aniq enum va variantlarga ega, lekin u manzil ma'lumotlarini variantlar ichida ikki xil struct shaklida joylashtiradi, har bir variant uchun turlicha belgilanadi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>Ushbu kod har qanday turdagi ma'lumotlarni enum variantiga qo'yish mumkinligini ko'rsatadi: masalan, stringlar, raqamli turlar yoki structlar. Siz hatto boshqa raqamni ham qo'shishingiz mumkin! Bundan tashqari, standart kutubxona turlari ko'pincha siz o'ylab topganingizdan ancha murakkab emas.</p>
<p>E'tibor bering, standart kutubxonada <code>IpAddr</code> uchun definition mavjud bo'lsa ham, biz o'z definitionimizni ziddiyatli holda yaratishimiz va foydalanishimiz mumkin, chunki biz standart kutubxonaning definitionini o'z doiramizga kiritmaganmiz. Biz 7-bobda turlarni qamrab olish haqida ko'proq gaplashamiz.</p>
<p>Keling, 6-2 ro'yxatdagi enumning yana bir misolini ko'rib chiqaylik: bu o'z variantlarida ko'p turdagi turlarga ega.</p>
<pre><pre class="playground"><code class="language-rust">enum Xabar {
    Chiqish,
    Kochirish { x: i32, y: i32 },
    Yozish(String),
    RangTanlash(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 6-2: <code>Xabar</code> enumi, uning variantlari har xil miqdor va qiymat turlarini saqlaydi</span></p>
<p>Ushbu enum har xil turdagi to'rtta variantga ega:</p>
<ul>
<li><code>Chiqish</code>da u bilan bog ªliq hech qanday ma ºlumot yo ªq.</li>
<li><code>Kochirish</code> da struct kabi maydonlarni nomlagan.</li>
<li><code>Yozish</code> bitta <code>String</code> ni o'z ichiga oladi.</li>
<li><code>RangTanla</code> uchta <code>i32</code> qiymatini o'z ichiga oladi.</li>
</ul>
<p>Enumni 6-2-ro ªyxatdagi kabi variantlar bilan belgilash strukturaviy definitionlarning har xil turlarini aniqlashga o ªxshaydi, faqat enum <code>struct</code> kalit so ªzidan foydalanmaydi va barcha variantlar <code>Xabar</code> turi ostida birlashtiriladi. Quyidagi structlar oldingi enum variantlari bilan bir xil ma'lumotlarni saqlashi mumkin:</p>
<pre><pre class="playground"><code class="language-rust">struct ChiqishXabar; // unit struct
struct KochirishXabar {
    x: i32,
    y: i32,
}
struct YozishXabar(String); // tuple struct
struct RangTanshlaXabar(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Lekin biz o'z turlariga ega bo'lgan turli structlardan foydalanganimizda, biz har qanday xabar turini qabul qiladigan funksiyalarni osonlikcha aniqlay olmadik, buni bitta tur bo'lgan 6-2 ro'yxatda e'lon qilingan <code>Xabar</code> turini enum bilan amalga oshirish mumkin.</p>
<p>Enumlar va structlar o'rtasida yana bir o'xshashlik bor: biz <code>impl</code> yordamida structlarda metodlarni aniqlay olganimizdek, enumlarda ham metodlarni belgilashimiz mumkin. Bu yerda biz <code>Xabar</code> enumimizda aniqlashimiz mumkin bo'lgan <code>chaqiruv</code> deb nomlangan metod:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Xabar {
</span><span class="boring">        Chiqish,
</span><span class="boring">        Kochirish { x: i32, y: i32 },
</span><span class="boring">        Yozish(String),
</span><span class="boring">        RangTanlash(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Xabar {
        fn chaqiruv(&amp;self) {
            // metod tanasi bu yerda aniqlanadi
        }
    }

    let m = Xabar::Yozish(String::from(&quot;salom&quot;));
    m.chaqiruv();
<span class="boring">}</span></code></pre></pre>
<p>Metod tanasi biz metod deb atagan qiymatni olish uchun <code>self</code> ishlatadi. Ushbu misolda biz <code>Xabar::Yozish(String::from(&quot;salom&quot;))</code> qiymatini o'z ichiga olgan <code>m</code> o'zgaruvchisini yaratdik va <code>m.chaqiruv()</code> ishga tushganda <code>chaqiruv</code> metodining tanasida aynan shunday bo ªladi.
Keling, standart kutubxonadagi juda keng tarqalgan va foydali bo'lgan yana bir enumni ko'rib chiqaylik: <code>Option</code>.</p>
<h3 id="option-enum-va-uning-null-qiymatlardan-ustunligi"><a class="header" href="#option-enum-va-uning-null-qiymatlardan-ustunligi"><code>Option</code> Enum va uning null qiymatlardan ustunligi</a></h3>
<p>Ushbu bo'lim standart kutubxona tomonidan aniqlangan yana bir enum bo'lgan <code>Option</code> ning misolini o'rganadi.<code>Option</code> turi qiymat nimadir yoki hech narsa bo'lmasligi mumkin bo'lgan juda keng tarqalgan senariyni kodlaydi.</p>
<p>Misol uchun, agar siz bo'sh bo'lmagan ro'yxatdagi birinchi elementni so'rasangiz, qiymat olasiz. Agar siz bo'sh ro'yxatdagi birinchi elementni so'rasangiz, hech narsa olmaysiz.
Ushbu kontseptsiyani turdagi tizim nuqtai nazaridan ifodalash kompilyator siz ko'rib chiqishingiz kerak bo'lgan barcha ishlarni ko'rib chiqqaningizni tekshirishi mumkinligini anglatadi; bu funksiya boshqa dasturlash tillarida juda keng tarqalgan xatolarni oldini oladi.</p>
<p>Dasturlash tilining dizayni ko'pincha siz qaysi xususiyatlarni o'z ichiga olganligingiz nuqtai nazaridan o'ylanadi, ammo siz chiqarib tashlagan xususiyatlar ham muhimdir. Rust ko'plab boshqa tillarda mavjud bo'lgan null xususiyatiga ega emas. <em>Null</em> - bu qiymat yo'qligini bildiradi. Null bo'lgan tillarda o'zgaruvchilar har doim ikkita holatdan birida bo'lishi mumkin: null yoki null emas.</p>
<p>2009 yilgi &quot;Null References: The Million Dollar Mistake&quot; taqdimotida null ixtirochisi Tony Hoare shunday deydi:</p>
<blockquote>
<p>Men buni milliard dollarlik xatoyim deb atayman. O'sha paytda men object-oriented language
referencelar uchun birinchi keng qamrovli turdagi tizimni loyihalashtirgan edim. Mening maqsadim
referencelardan foydalanishning mutlaqo xavfsiz bo'lishini ta'minlash edi, tekshirish kompilyator
tomonidan avtomatik ravishda amalga oshiriladi. Lekin men null reference qo'yish vasvasasiga
qarshi tura olmadim, chunki uni amalga oshirish juda oson edi.
Bu so'nggi qirq yil ichida bir milliard dollar og'riq va zarar keltirgan
son-sanoqsiz xatolar, zaifliklar va tizimning ishdan chiqishiga olib keldi.</p>
</blockquote>
<p>Null qiymatlari bilan bog'liq muammo shundaki, agar siz null qiymatdan a sifatida foydalanishga harakat qilsangiz
no-null qiymat bo'lsa, siz qandaydir xatoga duch kelasiz. Ushbu null yoki not-null xususiyat keng tarqalganligi sababli, bunday xatoga yo'l qo'yish juda oson.</p>
<p>Biroq, null ifodalamoqchi bo'lgan kontseptsiya hali ham foydalidir: null hozirda yaroqsiz yoki biron sababga ko'ra mavjud bo'lmagan qiymatdir.</p>
<p>Muammo aslida kontseptsiyada emas, balki muayyan amalga oshirishda. Shunday qilib, Rust nulllarga ega emas, lekin u mavjud yoki yo'q qiymat tushunchasini kodlay oladigan enumga ega. Bu enum <code>Option&lt;T&gt;</code> bo'lib, u <a href="../std/option/enum.Option.html">standart kutubxona tomonidan</a><!-- ignore --> quyidagicha aniqlanadi: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> enumi shunchalik foydaliki, u hatto muqaddimaga ham kiritilgan; uni aniq doiraga kiritishingiz shart emas. Uning variantlari ham muqaddima tarkibiga kiritilgan: <code>Some</code> va <code>None</code> dan <code>Option::</code> prefiksisiz bevosita foydalanishingiz mumkin. <code>Option&lt;T&gt;</code> enum hali ham oddiy enum bo'lib, <code>Some(T)</code> va <code>None</code> hali ham <code>Option&lt;T&gt;</code> turidagi variantlardir.</p>
<p><code>&lt;T&gt;</code> sintaksisi Rustning o ªziga xos xususiyati bo ªlib, biz hali gaplashmaganmiz. Bu umumiy turdagi parametr va biz 10-bobda genericlarni batafsil ko'rib chiqamiz.
Hozircha siz bilishingiz kerak bo'lgan narsa shuki, <code>&lt;T&gt;</code> <code>Option</code> enumining <code>Some</code> varianti har qanday turdagi ma'lumotlarning bir qismini saqlashi mumkinligini va o'rniga qo'llaniladigan har bir konkret turni bildiradi. <code>T</code> umumiy <code>Option&lt;T&gt;</code> turini boshqa turga aylantiradi. Raqam turlari va qator turlarini saqlash uchun <code>Option</code> qiymatlaridan foydalanishga misollar keltiramiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let raqam = Some(5);
    let belgi = Some('e');

    let yoq_raqam: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p><code>raqam</code> turi - <code>Option&lt;i32&gt;</code>. <code>belgi</code> turi <code>Option&lt;char&gt;</code> bo'lib, u boshqa tur. Rust bu turlarni aniqlashi mumkin, chunki biz <code>Some</code> variantida qiymat belgilaganmiz. <code>yoq_raqam</code> uchun Rust bizdan umumiy <code>Option</code> turiga izoh berishimizni talab qiladi: kompilyator faqat <code>None</code> qiymatiga qarab mos keladigan <code>Some</code> varianti qanday turga ega bo'lishini aniqlay olmaydi. Bu yerda biz Rustga aytamizki, biz <code>yoq_raqam</code> <code>Option&lt;i32&gt;</code> turida bo'lishini nazarda tutamiz.</p>
<p>Agar bizda <code>Some</code> qiymati bo'lsa, biz qiymat mavjud ekanligini va qiymat <code>Some</code> ichida saqlanishini bilamiz. Agar bizda <code>None</code> qiymati bo'lsa, u qaysidir ma'noda null bilan bir xil narsani anglatadi: bizda haqiqiy qiymat yo'q. Xo'sh, nega <code>Option&lt;T&gt;</code> nullga ega bo'lishdan yaxshiroq?</p>
<p>Xulosa qilib aytganda, <code>Option&lt;T&gt;</code> va <code>T</code> (bu erda <code>T</code> har qanday tur bo'lishi mumkin) har xil turdagi, chunki kompilyator bizga <code>Option&lt;T&gt;</code> qiymatidan foydalanishga ruxsat bermaydi, go'yo bu haqiqiy qiymat. Masalan, bu kod kompilyatsiya qilinmaydi, chunki u <code>Option&lt;i8&gt;</code>ga <code>i8</code> qo`shishga harakat qilmoqda:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let natija = x + y;
<span class="boring">}</span></code></pre>
<p>Agar biz ushbu kodni ishlatsak, biz quyidagi kabi xato xabarini olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let natija = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;
            &lt;i8 as Add&lt;&amp;i8&gt;&gt;
            &lt;i8 as Add&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Kuchli! Aslida, bu xato xabari Rust <code>i8</code> va <code>Option&lt;i8&gt;</code> ni qanday qo'shishni tushunmasligini anglatadi, chunki ular turli xil. Rustda <code>i8</code> kabi turdagi qiymatga ega bo'lsak, kompilyator bizda har doim haqiqiy qiymatga ega bo'lishini ta'minlaydi. Ushbu qiymatdan foydalanishdan oldin nullni tekshirmasdan ishonch bilan davom etishimiz mumkin. Faqat bizda <code>Option&lt;i8&gt;</code> (yoki qanday turdagi qiymat bilan ishlayotgan bo'lishimizdan qat'iy nazar) mavjud bo'lganda, biz qiymatga ega bo'lmasligimizdan xavotirlanishimiz kerak va kompilyator qiymatdan foydalanishdan oldin bu holatni hal qilishimizga ishonch hosil qiladi.</p>
<p>Boshqacha qilib aytganda, <code>T</code> amallarini bajarishdan oldin <code>Option&lt;T&gt;</code>ni <code>T</code> ga aylantirishingiz kerak. Umuman olganda, bu null bilan bog'liq eng keng tarqalgan muammolardan birini hal qilishga yordam beradi: agar biror narsa bo'lsa, u null emas deb taxmin qilish.</p>
<p>Null bo'lmagan qiymatni noto'g'ri qabul qilish xavfini yo'q qilish kodingizga ko'proq ishonch hosil qilishingizga yordam beradi. Null bo'lishi mumkin bo'lgan qiymatga ega bo'lish uchun, siz ushbu qiymatning turini <code>Option&lt;T&gt;</code> qilib aniq belgilashingiz kerak.
Keyin, ushbu qiymatdan foydalanganda, qiymat null bo'lsa, ishni aniq ko'rib chiqishingiz talab qilinadi. Qiymat <code>Option&lt;T&gt;</code> bo'lmagan turga ega bo'lgan har bir joyda, qiymat null emas deb ishonch bilan taxmin qilishingiz mumkin. Bu Rust uchun nullning tarqalishini cheklash va Rust kodining xavfsizligini oshirish uchun ataylab qilingan dizayn qarori edi.</p>
<p>Xo'sh, <code>Option&lt;T&gt;</code> turidagi qiymatga ega bo'lganingizda, <code>Some</code> variantidan <code>T</code> qiymatini qanday qilib olish mumkin, shunda siz ushbu qiymatdan foydalanishingiz mumkin? <code>Option&lt;T&gt;</code> enumi turli vaziyatlarda foydali bo ªlgan ko ªp sonli usullarga ega; siz ularni uning <a href="../std/option/enum.Option.html">hujjatlarida</a><!-- ignore --> tekshirishingiz mumkin. <code>Option&lt;T&gt;</code> dagi metodlar bilan tanishish Rust bilan sayohatingizda juda foydali bo`ladi.</p>
<p>Umuman olganda, <code>Option&lt;T&gt;</code> qiymatidan foydalanish uchun siz har bir variantni boshqaradigan kodga ega bo'lishni xohlaysiz. Siz faqat <code>Some(T)</code> qiymatiga ega bo'lganingizda ishlaydigan ba'zi kodni xohlaysiz va bu kod ichki <code>T</code> dan foydalanishga ruxsat etiladi. Agar sizda <code>None</code> qiymati bo'lsa va bu kodda <code>T</code> qiymati bo'lmasa, ishlaydigan boshqa kod ham kerak bo'ladi. <code>match</code> ifodasi control flow konstruksiyasi bo‚Äòlib, u enumlar bilan foydalanilganda aynan shunday qiladi: u enumning qaysi variantiga ega bo‚Äòlishiga qarab turli xil kodlarni ishga tushiradi va bu kod mos keladigan qiymat ichidagi ma‚Äôlumotlardan foydalanishi mumkin.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="match-control-flow-konstruksiyasi"><a class="header" href="#match-control-flow-konstruksiyasi"><code>match</code> Control Flow konstruksiyasi</a></h2>
<p>Rust <code>match</code> deb nomlangan juda kuchli control flow konstruksiyasiga ega, bu sizga qiymatni bir qator patternlar bilan solishtirish va keyin qaysi pattern mos kelishiga qarab kodni bajarish imkonini beradi. Patternlar literal qiymatlar, o'zgaruvchilar nomlari, wildcardlar va boshqa ko'plab narsalardan iborat bo'lishi mumkin; <a href="ch18-00-patterns.html">18-bobda</a><!-- ignore --> har xil turdagi patternlar va ular bajaradigan ishlar yoritilgan. <code>match</code>ning kuchi patternlarning ifodaliligidan va kompilyator barcha mumkin bo'lgan holatlar ko'rib chiqilishini tasdiqlashidan kelib chiqadi.</p>
<p><code>match</code> iborasini tanga saralash mashinasiga o'xshatib tasavvur qiling: tangalar bo'ylab turli o'lchamdagi teshiklari bo'lgan yo'ldan pastga siljiydi va har bir tanga o'zi mos keladigan birinchi teshikdan tushadi. Xuddi shu tarzda, qiymatlar <code>match</code> dagi har bir patterndan o'tadi va birinchi patternda qiymat ‚Äúfits,‚Äù, qiymat bajarish paytida ishlatiladigan tegishli kod blokiga tushadi.</p>
<p>Tangalar haqida gap ketganda, keling, ularni <code>match</code> yordamida misol qilib olaylik! Biz noma'lum AQSH tangasini oladigan funksiyani yozishimiz mumkin va xuddi sanash mashinasiga o'xshab uning qaysi tanga ekanligini aniqlaydi va 6-3 ro'yxatda ko'rsatilganidek, uning qiymatini sentlarda qaytaradi.</p>
<pre><pre class="playground"><code class="language-rust">enum Tanga {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn sentdagi_qiymat(tanga: Tanga) -&gt; u8 {
    match tanga {
        Tanga::Penny =&gt; 1,
        Tanga::Nickel =&gt; 5,
        Tanga::Dime =&gt; 10,
        Tanga::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 6-3: Enum va <code>match</code> ifodasi, uning namunalari sifatida enumning variantlari mavjud</span></p>
<p>Keling, <code>sentdagi_qiymat</code> funksiyasidagi <code>match</code> ni ajratamiz. Avval biz <code>match</code> kalit so'zidan keyin ifodani keltiramiz, bu holda bu qiymat <code>tanga</code> bo'ladi. Bu <code>if</code> bilan ishlatiladigan shartli ifodaga juda o'xshaydi, lekin
katta farq bor: <code>if</code> bilan shart mantiqiy qiymatga baholanishi kerak, ammo bu yerda u har qanday turdagi bo'lishi mumkin. Ushbu misoldagi <code>tanga</code> turi biz birinchi qatorda belgilagan <code>Tanga</code> enumidir.</p>
<p>Keyingi <code>match</code> armlari. Arm ikki qismdan iborat: pattern va ba'zi kod. Bu yerdagi birinchi arm <code>Tanga::Penny</code> qiymati bo ªlgan patternga ega, so ªngra ishlash uchun pattern va kodni ajratuvchi <code>=&gt;</code> operatori. Bu holatda kod faqat <code>1</code> qiymatidan iborat. Har bir arm keyingisidan vergul bilan ajratiladi.</p>
<p><code>match</code> ifodasi bajarilganda, natijaviy qiymatni har bir armning patterniga solishtiradi. Agar pattern qiymatga mos kelsa, ushbu pattern bilan bog'langan kod bajariladi. Agar bu pattern qiymatga mos kelmasa, ijro tanga saralash mashinasida bo'lgani kabi keyingi armda davom etadi.
Bizda qancha arm kerak bo'lsa, shuncha arm bo'lishi mumkin: 6-3 ro'yxatda bizning <code>match</code>imizda to'rtta arm bor.</p>
<p>Har bir arm bilan bog'langan kod ifodadir va mos keladigan qismdagi ifodaning natijaviy qiymati butun <code>match</code> ifodasi uchun qaytariladigan qiymatdir.</p>
<p>Agar mos keladigan arm kodi qisqa bo'lsa, biz odatda jingalak qavslardan foydalanmaymiz, chunki bu ro'yxat 6-3da bo'lgani kabi, har bir arm shunchaki qiymat qaytaradi. Agar siz mos keladigan chiziqda bir nechta kod qatorlarini ishlatmoqchi bo'lsangiz, jingalak qavslardan foydalaning va armdan keyingi vergul ixtiyoriy bo'ladi. Masalan, quyidagi kodda <code>Omadli tanga!</code> metod har safar <code>Tanga::Penny</code> bilan chaqirilganda, lekin baribir blokning oxirgi qiymatini qaytaradi, <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Tanga {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn sentdagi_qiymat(tanga: Tanga) -&gt; u8 {
    match tanga {
        Tanga::Penny =&gt; {
            println!(&quot;Omadli tanga!&quot;);
            1
        }
        Tanga::Nickel =&gt; 5,
        Tanga::Dime =&gt; 10,
        Tanga::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="qiymatlarni-boglaydigan-patternlar"><a class="header" href="#qiymatlarni-boglaydigan-patternlar">Qiymatlarni bog'laydigan patternlar</a></h3>
<p>match armlarining yana bir foydali xususiyati shundaki, ular patternga mos keladigan qiymatlarning qismlarini bog'lashlari mumkin. Enum variantlaridan qiymatlarni shunday chiqarishimiz mumkin.</p>
<p>Misol tariqasida, uning ichida ma'lumotlarni saqlash uchun enum variantlarimizdan birini o'zgartiraylik.
1999 yildan 2008 yilgacha Qo'shma Shtatlar bir tomondan 50 shtatning har biri uchun turli dizayndagi tangalarni bosib chiqardi. Boshqa hech qanday tangalar davlat dizayniga ega emas, shuning uchun faqat quarterlarda bunday qo'shimcha qiymat mavjud. Biz ushbu ma ºlumotni <code>Quarter</code> variantini uning ichida saqlangan <code>UsState</code> qiymatini kiritish uchun o ªzgartirish orqali <code>enum</code>ga qo ªshishimiz mumkin, biz buni 6-4 ro ªyxatda qilganmiz.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Tanga {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 6-4: <code>Quarter</code> varianti ham <code>UsState</code> qiymatiga ega bo ªlgan <code>Tanga</code> enumi</span></p>
<p>Tasavvur qiling-a, sizning do'stingiz barcha 50 shtatdan quarter yig'ishga harakat qilmoqda. Biz tangalar turi bo'yicha saralashimiz bilan birga, agar do'stimizda yo'q bo'lsa, ular uni o'z kollektsiyasiga qo'shishlari uchun har quarter bilan bog'liq shtat nomini ham chaqiramiz.</p>
<p>Ushbu kod uchun match ifodasida biz <code>Tanga::Quarter</code> varianti qiymatlariga mos keladigan patternga <code>shtat</code> deb nomlangan o'zgaruvchini qo‚Äòshamiz. <code>Tanga::Quarter</code> mos kelganda, <code>shtat</code> o'zgaruvchisi o'sha quarter holati qiymatiga bog'lanadi. Keyin biz ushbu arm uchun kodda <code>shtat</code> dan foydalanishimiz mumkin, masalan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Tanga {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn sentdagi_qiymat(tanga: Tanga) -&gt; u8 {
    match tanga {
        Tanga::Penny =&gt; 1,
        Tanga::Nickel =&gt; 5,
        Tanga::Dime =&gt; 10,
        Tanga::Quarter(shtat) =&gt; {
            println!(&quot;{:?} dan shtat quarter!&quot;, shtat);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    sentdagi_qiymat(Tanga::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Agar biz <code>sentdagi_qiymat(Tanga::Quarter(UsState::Alaska))</code> deb ataydigan bo'lsak, <code>tanga</code> <code>Tanga::Quarter(UsState::Alaska)</code> bo'ladi. Ushbu qiymatni har bir match armi bilan solishtirganda, biz <code>Tanga::Quarter(shtat)</code> ga yetguncha ularning hech biri mos kelmaydi. O'sha paytda <code>shtat</code> uchun majburiy <code>UsState::Alaska</code> qiymati bo'ladi. Keyin biz bu bog'lanishni <code>println!</code> ifodasida qo'llashimiz mumkin, shu bilan <code>Quarter</code> uchun <code>Tanga</code> enum variantidan ichki holat qiymatini olamiz.</p>
<h3 id="optiont-uchun-match"><a class="header" href="#optiont-uchun-match"><code>Option&lt;T&gt;</code> uchun Match</a></h3>
<p>Oldingi bo'limda biz <code>Option&lt;T&gt;</code> dan foydalanilganda <code>Some</code> holatidan ichki <code>T</code> qiymatini olishni xohladik; Biz, shuningdek, <code>Tanga</code> enum bilan qilganimizdek, <code>match</code> yordamida <code>Option&lt;T&gt;</code>ni boshqarishimiz mumkin! Tangalarni solishtirish o'rniga, biz <code>Option&lt;T&gt;</code> variantlarini solishtiramiz, lekin <code>match</code> ifodasining ishlash usuli bir xil bo'lib qoladi.</p>
<p>Aytaylik, biz <code>Option&lt;i32&gt;</code> ni oladigan funksiya yozmoqchimiz va agar ichida qiymat bo'lsa, bu qiymatga 1 qo'shiladi. Agar ichida qiymat bo'lmasa, funktsiya <code>None</code> qiymatini qaytarishi va hech qanday operatsiyani bajarishga urinmasligi kerak.</p>
<p>Ushbu funktsiyani yozish juda oson,  <code>match</code> tufayli va 6-5-Ro'yxatga o'xshaydi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn bir_qoshish(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let besh = Some(5);
    let olti = bir_qoshish(besh);
    let yoq = bir_qoshish(None);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 6-5: <code>Option</code>da <code>match</code> ifodasidan foydalanadigan funksiya<i32>`</span></p>
<p>Keling, <code>bir_qoshish</code> ning birinchi bajarilishini batafsilroq ko'rib chiqamiz. Biz <code>bir_qoshish(besh)</code> ni chaqirganimizda, <code>bir_qoshish</code> tanasidagi <code>x</code> o'zgaruvchisi <code>Some(5)</code> qiymatiga ega bo'ladi. Keyin biz buni har bir matchning armi bilan taqqoslaymiz:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn bir_qoshish(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let besh = Some(5);
</span><span class="boring">    let olti = bir_qoshish(besh);
</span><span class="boring">    let yoq = bir_qoshish(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code> qiymati <code>None</code> patterniga mos kelmaydi, shuning uchun keyingi armga o'tamiz:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn bir_qoshish(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let besh = Some(5);
</span><span class="boring">    let olti = bir_qoshish(besh);
</span><span class="boring">    let yoq = bir_qoshish(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code> ga <code>Some(i)</code> pattern mos keladimi? Ha bu shunday! Bizda ham xuddi shunday variant bor. Keyin <code>i</code> o'zgaruvchisi <code>Some</code> ichidagi qiymatga bog'lanadi, shuning uchun <code>i</code> <code>5</code> qiymatini oladi. Shundan so'ng match armidagi kod bajariladi, shuning uchun biz <code>i</code> qiymatiga 1 qo'shamiz va ichida jami <code>6</code> bo'lgan yangi <code>Some</code> qiymatini yaratamiz.</p>
<p>Keling, 6-5-Ro'yxatdagi <code>bir_qoshish</code> ning ikkinchi chaqiruvini ko'rib chiqaylik, bunda <code>x</code> <code>None</code>. Biz <code>match</code> ga kiramiz va birinchi arm bilan taqqoslaymiz:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn bir_qoshish(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let besh = Some(5);
</span><span class="boring">    let olti = bir_qoshish(besh);
</span><span class="boring">    let yoq = bir_qoshish(None);
</span><span class="boring">}</span></code></pre>
<p>Bu mos keladi! Qo'shiladigan qiymat yo'q, shuning uchun dastur to'xtaydi va <code>=&gt;</code> o'ng tomonidagi <code>None</code> qiymatini qaytaradi. Birinchi arm mos kelganligi sababli, boshqa armlar taqqoslanmaydi.</p>
<p><code>match</code> va enumlarni birlashtirish ko'p holatlarda foydalidir. Rust kodida siz ushbu patterni juda ko'p ko'rasiz: enum bilan <code>match</code>, o'zgaruvchini ichidagi ma'lumotlarga bog'lang va keyin unga asoslangan kodni bajaring. Avvaliga bu biroz qiyin, lekin ko'nikkaningizdan so'ng uni barcha tillarda bo'lishini xohlaysiz. Bu har doim foydalanuvchilarning sevimli texnikasi.</p>
<h3 id="match-barcha-qiymat-variantlarini-qamrab-oladi"><a class="header" href="#match-barcha-qiymat-variantlarini-qamrab-oladi">Match barcha qiymat variantlarini qamrab oladi</a></h3>
<p>Biz muhokama qilishimiz kerak bo'lgan <code>match</code> ning yana bir jihati bor: arm patterlari barcha imkoniyatlarni qamrab olishi kerak. Xatoga ega va kompilyatsiya qilinmaydigan <code>bir_qoshish</code> funksiyamizning ushbu versiyasini ko'rib chiqing:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn bir_qoshish(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let besh = Some(5);
</span><span class="boring">    let olti = bir_qoshish(besh);
</span><span class="boring">    let yoq = bir_qoshish(None);
</span><span class="boring">}</span></code></pre>
<p>Biz <code>None</code> holatini ko‚Äòrib chiqmadik, shuning uchun bu kod xatolikka olib keladi. Yaxshiyamki, bu xato Rust qanday tutishni biladi. Agar biz ushbu kodni kompilyatsiya qilishga harakat qilsak, biz ushbu xatoni olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:1
  |
  = note:
/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:5: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Rust biz barcha mumkin bo'lgan holatlarni qamrab olmaganimizni biladi va hatto qaysi patterni unutganimizni biladi! Rust-da matchlar to'liq: kod to'g'ri bo'lishi uchun biz barcha mumkin bo'lgan holatlarni qamrab olishimiz kerak. Ayniqsa, <code>Option&lt;T&gt;</code> holatida, Rust bizni <code>None</code> holatini aniq ko'rib chiqishni unutib qo'yishimizga to'sqinlik qilsa, bizni null bo'lishi mumkin bo'lgan qiymatga ega bo`lishimizdan himoya qiladi, shunday qilib, ilgari muhokama qilingan milliard dollarlik xatoni imkonsiz qiladi.</p>
<h3 id="hammasini-ushlash-patternlari-va-_-placeholder"><a class="header" href="#hammasini-ushlash-patternlari-va-_-placeholder">Hammasini ushlash patternlari va <code>_</code> placeholder</a></h3>
<p>Enumlardan foydalanib, biz bir nechta ma'lum qiymatlar uchun maxsus harakatlarni amalga oshirishimiz mumkin, ammo boshqa barcha qiymatlar uchun bitta standart amalni bajaramiz. Tasavvur qiling-a, biz o'yinni amalga oshirmoqdamiz, unda 3 ta o'yinda o'yinchi qimirlamaydi, aksincha, chiroyli yangi shlyapa oladi. Agar siz 7 ni aylantirsangiz, o'yinchingiz chiroyli shlyapasini yo'qotadi. Boshqa barcha qiymatlar uchun o'yinchi o'yin taxtasida shuncha bo'sh joyni siljitadi. Mana, bu mantiqni amalga oshiradigan <code>match</code>, bu erda narda toshlarni o'rash natijasi tasodifiy qiymat emas, balki qattiq kodlangan va mantiqning qolgan qismi jismlarsiz funktsiyalar bilan ifodalanadi, chunki ularni amalga oshirish ushbu doiradan tashqarida. misol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let narda_toshi = 9;
    match narda_toshi {
        3 =&gt; chiroyli_shlyapa_qoshish(),
        7 =&gt; chiroyli_shlyapani_ochirish(),
        boshqa =&gt; player_harakati(boshqa),
    }

    fn chiroyli_shlyapa_qoshish() {}
    fn chiroyli_shlyapani_ochirish() {}
    fn player_harakati(bosh_joylar: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Dastlabki ikkita arm uchun patternlar <code>3</code> va <code>7</code> harfli qiymatlardir. Boshqa barcha mumkin bo'lgan qiymatlarni qamrab oladigan oxirgi arm uchun pattern biz <code>boshqa</code> deb nomlash uchun tanlagan o'zgaruvchidir. <code>boshqa</code> arm uchun ishlaydigan kod o'zgaruvchini <code>player_harakati</code> funksiyasiga o'tkazish orqali ishlatadi.</p>
<p>Ushbu kod kompilatsiya qilinadi, garchi biz <code>u8</code> ga ega bo'lishi mumkin bo'lgan barcha qiymatlarni sanab o'tmagan bo'lsak ham, chunki oxirgi pattern maxsus sanab o'tilmagan barcha qiymatlarga mos keladi. Bu <code>match</code> to ªliq bo ªlishi kerakligi haqidagi talabga javob beradi. E'tibor bering, biz armni eng oxirgi qo'yishimiz kerak, chunki patternlar tartibda baholanadi. Agar biz ushlovchi armni oldinroq qo'ysak, boshqa armlar hech qachon run bo'lmaydi, shuning uchun biz hammamizni tutgandan keyin arm qo'shsak, Rust bizni ogohlantiradi!</p>
<p>Rustda umumiy patterda qiymatdan foydalanishni istamaganimizda foydalanish mumkin bo'lgan pattern ham mavjud: <code>_</code> - har qanday qiymatga mos keladigan va bu qiymatga bog'lanmaydigan maxsus pattern. Bu Rustga biz qiymatdan foydalanmasligimizni bildiradi, shuning uchun Rust bizni foydalanilmagan o'zgaruvchi haqida ogohlantirmaydi.</p>
<p>Keling, o'yin qoidalarini shunday o'zgartiraylik: agar 3 yoki 7 dan boshqa narda toshi paydo bo'lsa, siz yana boshqatdan aylantirib tashlashingiz  kerak. Biz endi catch-all qiymatidan foydalanishimiz shart emas, shuning uchun biz kodimizni <code>boshqa</code> deb nomlangan o‚Äòzgaruvchi o‚Äòrniga <code>_</code> ishlatish uchun o‚Äòzgartirishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let narda_toshi = 9;
    match narda_toshi {
        3 =&gt; chiroyli_shlyapa_qoshish(),
        7 =&gt; chiroyli_shlyapani_ochirish(),
        _ =&gt; qaytadan(),
    }

    fn chiroyli_shlyapa_qoshish() {}
    fn chiroyli_shlyapani_ochirish() {}
    fn qaytadan() {}
<span class="boring">}</span></code></pre></pre>
<p>Bu misol, shuningdek, to'liqlik talabiga javob beradi, chunki biz oxirgi qismdagi barcha boshqa qiymatlarni e'tiborsiz qoldiramiz; biz hech narsani unutmadik.</p>
<p>Nihoyat, biz o'yin qoidalarini yana bir bor o'zgartiramiz, shunda siz 3 yoki 7 ni o'tkazmaguningizcha sizning navbatingizda hech narsa sodir bo'lmaydi. Biz buni birlik qiymatidan (biz <a href="ch03-02-data-types.html#the-tuple-type">&quot;Tuple turi&quot;</a><!-- ignore --> section da aytib o'tgan bo'sh tuple turi) <code>_</code> armi bilan birga keladigan kod sifatida ifodalashimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let narda_toshi = 9;
    match narda_toshi {
        3 =&gt; chiroyli_shlyapa_qoshish(),
        7 =&gt; chiroyli_shlyapani_ochirish(),
        _ =&gt; (),
    }

    fn chiroyli_shlyapa_qoshish() {}
    fn chiroyli_shlyapani_ochirish() {}
<span class="boring">}</span></code></pre></pre>
<p>Bu yerda biz Rustga aniq aytamizki, biz avvalgi armdagi patternga mos kelmaydigan boshqa qiymatdan foydalanmaymiz va bu holda hech qanday kodni ishga tushirishni xohlamaymiz.</p>
<p><a href="ch18-00-patterns.html">18-bobda</a><!-- ignore --> biz ko'rib chiqadigan patternlar va match haqida ko'proq ma'lumot bor.
Hozircha biz <code>if let</code> sintaksisiga o‚Äòtamiz, bu <code>match</code> ifodasi juda batafsil bo'lgan holatlarda foydali bo'lishi mumkin.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="if-let-bilan--control-flow"><a class="header" href="#if-let-bilan--control-flow"><code>if let</code> bilan  Control Flow</a></h2>
<p><code>if let</code> sintaksisi sizga <code>if</code> va <code>let</code> ni birlashtirib, qolganlarini e'tiborsiz qoldirib, bitta patternga mos keladigan qiymatlarni boshqarishning kamroq batafsil metodiga imkon beradi. 6-6 ro'yxatdagi dasturni ko'rib chiqaylik, u <code>max_sozlama</code> o'zgaruvchisidagi <code>Variant&lt;u8&gt;</code> qiymatiga mos keladigan, lekin <code>Some</code> varianti bo ªlsagina kodni bajarishni xohlaydigan dasturni ko ªrib chiqamiz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let max_sozlama = Some(3u8);
    match max_sozlama {
        Some(max) =&gt; println!(&quot;Maksimal {} qilib sozlangan&quot;, max),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 6-6. Qiymat <code>Some</code> bo'lsagina kodni bajaradigan <code>match</code> ifoda</span></p>
<p>Agar qiymat <code>Some</code> bo'lsa, biz qiymatni patterndagi <code>max</code> o'zgaruvchisiga bog'lash orqali <code>Some</code> variantidagi qiymatni chop qilamiz. Biz <code>None</code> qiymati bilan hech narsa qilishni xohlamaymiz. <code>match</code> ifodasini qondirish uchun faqat bitta variantni qayta ishlagandan so‚Äòng <code>_ =&gt; ()</code> qo‚Äòshishimiz kerak, bu esa qo‚Äòshish uchun zerikarli boilerplate koddir.</p>
<p>Buning o'rniga, biz buni qisqaroq qilib <code>if let</code> yordamida yozishimiz mumkin. Quyidagi kod 6-6 ro'yxatdagi <code>match</code> bilan bir xil ishlaydi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let max_sozlama = Some(3u8);
    if let Some(max) = max_sozlama {
        println!(&quot;Maksimal {} qilib sozlangan&quot;, max);
    }
<span class="boring">}</span></code></pre></pre>
<p><code>if let</code> sintaksisi teng belgisi bilan ajratilgan pattern va ifodani oladi. U xuddi <code>match</code> bilan ishlaydi, bunda ifoda <code>match</code>ga beriladi va pattern uning birinchi armi hisoblanadi. Bunday holda, pattern <code>Some(max)</code> bo'lib, <code>max</code>  <code>Some</code> ichidagi qiymatga bog'lanadi. Shundan so'ng biz <code>if let</code> blokining tanasida <code>max</code> dan xuddi mos keladigan <code>match</code> armida <code>max</code> dan foydalanganimiz kabi foydalanishimiz mumkin. Qiymat patternga mos kelmasa, <code>if let</code> blokidagi kod ishga tushmaydi.</p>
<p><code>if let</code> dan foydalanish kamroq yozish, kamroq chekinish va kamroq kodli kodni bildiradi.
Biroq, siz <code>match</code> amal qiladigan to'liq tekshirishni yo'qotasiz. <code>match</code> va <code>if let</code> o‚Äòrtasida tanlov qilish sizning muayyan vaziyatingizda nima qilayotganingizga va ixchamlikka ega bo‚Äòlish to‚Äòliq tekshirishni yo‚Äòqotish uchun to‚Äòg‚Äòri kelishilganligiga bog‚Äòliq.</p>
<p>Boshqacha qilib aytganda, siz <code>if let</code> konstruktsiyasini <code>match</code> uchun sintaktik shakar sifatida o'ylab ko'rishingiz mumkin, agar kiritilgan qiymat bitta patterga mos kelsa va boshqa barcha qiymatlarga e'tibor bermasa, kodni bajaradi.</p>
<p>Biz <code>else</code>ni <code>if let</code> bilan kiritishimiz mumkin. <code>else</code> bilan birlashtirilgan kod bloki <code>if let</code> va <code>else</code>ga ekvivalent bo‚Äòlgan <code>match</code> ifodasidagi <code>_</code> registriga mos keladigan kod bloki bilan bir xil. 6-4 ro ªyxatdagi <code>Tanga</code> definitionni eslang, bunda <code>Quarter</code> varianti ham <code>UsState</code> qiymatiga ega edi. Agar biz quarterlarning holatini e'lon qilishda ko'rgan barcha quarter bo'lmagan tangalarni sanashni istasak, buni quyidagi kabi <code>match</code> ifodasi bilan qilishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Tanga {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let tanga = Tanga::Penny;
</span>    let mut hisobchi = 0;
    match tanga {
        Tanga::Quarter(shtat) =&gt; println!(&quot;{:?} dan shtat kvartal!&quot;, shtat),
        _ =&gt; hisobchi += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>Yoki <code>if let</code> va <code>else</code> ifodalaridan foydalanishimiz mumkin, masalan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Tanga {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let tanga = Tanga::Penny;
</span>    let mut hisobchi = 0;
    if let Tanga::Quarter(shtat) = tanga {
        println!(&quot;{:?} dan shtat kvartal!&quot;, shtat);
    } else {
        hisobchi += 1;
    }
<span class="boring">}</span></code></pre></pre>
<p>Agar dasturingizda <code>match</code> yordamida ifodalash uchun juda batafsil mantiq mavjud bo'lsa, Rust toolboxda <code>if let</code> ham mavjudligini unutmang.</p>
<h2 id="xulosa-5"><a class="header" href="#xulosa-5">Xulosa</a></h2>
<p>Endi biz sanab o'tilgan qiymatlar to'plamidan biri bo'lishi mumkin bo'lgan maxsus turlarni yaratish uchun enumlardan qanday foydalanishni ko'rib chiqdik. Biz standart kutubxonaning <code>Option&lt;T&gt;</code> turi xatolarni oldini olish uchun type tizimidan qanday foydalanishni ko'rsatdik. Enum qiymatlari ichida ma'lumotlar mavjud bo'lsa, siz qancha holatlarni ko'rib chiqishingiz kerakligiga qarab, ushbu qiymatlarni ajratib olish va ishlatish uchun <code>match</code> yoki <code>if let</code> dan foydalanishingiz mumkin.</p>
<p>Rust dasturlaringiz endi structlar va enumlar yordamida domeningizdagi tushunchalarni ifodalashi mumkin. API-da foydalanish uchun maxsus turlarni yaratish turdagi xavfsizligini ta'minlaydi: kompilyator sizning funksiyalaringiz faqat har bir funktsiya kutgan turdagi qiymatlarni olishiga ishonch hosil qiladi.</p>
<p>Foydalanuvchilaringizga foydalanish uchun qulay va faqat sizning foydalanuvchilarga nima kerakligini aniq ko'rsatadigan yaxshi tashkil etilgan API taqdim etish uchun endi Rust modullariga murojaat qilaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osib-borayotgan-loyihalarni-paketlar-cratelar-va-modullar-bilan-boshqarish"><a class="header" href="#osib-borayotgan-loyihalarni-paketlar-cratelar-va-modullar-bilan-boshqarish">O'sib borayotgan loyihalarni paketlar, cratelar va modullar bilan boshqarish</a></h1>
<p>Katta dasturlarni yozganingizda, kodingizni tartibga solish tobora muhim ahamiyat kasb etadi. Tegishli funksiyalarni guruhlash va kodni alohida xususiyatlar bilan ajratish orqali siz ma'lum bir xususiyatni amalga oshiradigan kodni qayerdan topish va funksiya qanday ishlashini o'zgartirish uchun qayerga borish kerakligini aniqlaysiz.</p>
<p>Biz hozirgacha yozgan dasturlar bitta faylda bitta modulda bo'lgan. Loyiha o'sib borishi bilan siz kodni bir nechta modullarga va keyin bir nechta fayllarga bo'lish orqali tartibga solishingiz kerak. Paketda bir nechta binary cratelar va ixtiyoriy ravishda bitta kutubxona cratesi bo'lishi mumkin. Paket o'sishi bilan siz qismlarni alohida cratelarga ajratib olishingiz mumkin, ular tashqi bog'liqlikka aylanadi. Ushbu bo'lim ushbu texnikaning barchasini o'z ichiga oladi. Birgalikda rivojlanadigan o'zaro bog'liq paketlar to'plamini o'z ichiga olgan juda katta loyihalar uchun Cargo <em>workspacelarni</em> taqdim etadi, biz ularni 14-bobdagi <a href="ch14-03-cargo-workspaces.html">&quot;Cargo Workspacelari&quot;</a><!-- ignore --> bo'limida ko'rib chiqamiz.</p>
<p>Shuningdek, biz kodni yuqoriroq darajada qayta ishlatish imkonini beruvchi implement tafsilotlarini muhokama qilamiz: operatsiyani amalga oshirganingizdan so'ng, boshqa kod dastur qanday ishlashini bilmasdan kodingizni umumiy interfeysi orqali chaqirishi mumkin. Kodni yozish usuli qaysi qismlar boshqa koddan foydalanishi uchun public ekanligini va qaysi qismlar o'zgartirish huquqiga ega bo'lgan private implement tafsilotlarini belgilaydi. Bu yodda tutish kerak bo'lgan tafsilotlar miqdorini cheklashning yana bir usuli.</p>
<p>Tegishli tushuncha - bu scope: kod yoziladigan ichki kontekstda &quot;scope&quot; deb belgilangan nomlar to'plami mavjud. Kodni o'qish, yozish va kompilyatsiya qilishda dasturchilar va kompilyatorlar ma'lum bir nuqtadagi ma'lum bir nom o'zgaruvchiga, funksiyaga, structga, enumga, modulga, constantaga yoki boshqa elementga tegishli ekanligini va bu element nimani anglatishini bilishlari kerak. Siz scopelarni yaratishingiz va qaysi nomlar doirasida yoki tashqarida ekanligini o'zgartirishingiz mumkin. Bir xil nomdagi ikkita elementni bir xil scopeda bo'lishi mumkin emas; nom ziddiyatlarini hal qilish uchun tollar mavjud.</p>
<p>Rust sizga kodingizning tuzilishini boshqarish imkonini beruvchi bir qator xususiyatlarga ega, jumladan, qaysi tafsilotlar oshkor bo'lishi, qaysi tafsilotlar shaxsiy va dasturlaringizdagi har bir sohada qanday nomlar mavjudligi. Ba'zan birgalikda <em>modul tizimi</em> deb ataladigan bu xususiyatlar quyidagilarni o'z ichiga oladi:</p>
<ul>
<li><strong>Paketlar:</strong> Cratelarni qurish, sinab ko'rish va almashish imkonini beruvchi cargo xususiyati</li>
<li><strong>Cratelar:</strong> Kutubxona yoki bajariladigan faylni yaratuvchi modullar daraxti</li>
<li><strong>Modullar</strong> va <strong>use:</strong> Fayl yo ªllarning tashkil etilishi, ko ªlami va maxfiyligini nazorat qilish imkonini beradi</li>
<li><strong>Pathlar:</strong> Struct, funksiya yoki modul kabi elementni nomlash usuli</li>
</ul>
<p>Ushbu bobda biz ushbu xususiyatlarning barchasini ko'rib chiqamiz, ularning qanday o'zaro ta'sirini muhokama qilamiz va qamrovni boshqarish uchun ulardan qanday foydalanishni tushuntiramiz. Oxir-oqibat, siz modul tizimi haqida yaxshi tushunchaga ega bo'lishingiz va professional kabi sohalar bilan ishlashingiz kerak!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paketlar-va-cratelar"><a class="header" href="#paketlar-va-cratelar">Paketlar va Cratelar</a></h2>
<p>Biz qamrab oladigan modul tizimining birinchi qismlari paketlar va cratelardir.</p>
<p><em>Crate</em> - bu Rust kompilyatori bir vaqtning o'zida ko'rib chiqadigan eng kichik kod miqdori. Agar siz <code>cargo</code> o'rniga <code>rustc</code> ni ishga tushirsangiz va bitta manba faylga o'tsangiz ham (biz 1-bob, &quot;Rust dasturini yozish va ishga tushirish&quot;da qilganimiz kabi), kompilyator bu faylni crate sifatida ko'radi. Cratelar modullarni o'z ichiga olishi mumkin va modullar crate bilan tuzilgan boshqa fayllarda aniqlanishi mumkin, buni keyingi bo'limlarda ko'rib chiqamiz.</p>
<p>Crate ikkita shakldan birida bo'lishi mumkin: binary crate yoki kutubxona cratesi.
<em>Binary cratelar</em> - bu buyruq qatori dasturi yoki server kabi ishga tushirishingiz mumkin bo'lgan bajariladigan faylga kompilyatsiya qilishingiz mumkin bo'lgan dasturlar. Har birida bajariladigan fayl ishga tushganda nima sodir bo'lishini belgilaydigan <code>main</code> funksiyasi bo'lishi kerak. Biz hozirgacha yaratgan barcha cratelar binary cratelar edi.</p>
<p><em>Kutubxona cratelari</em> <code>main</code> funksiyaga ega emas va ular bajariladigan faylga kompilyatsiya qilinmaydi. Buning o'rniga, ular bir nechta loyihalar bilan bo'lishish uchun mo'ljallangan funksionallikni belgilaydi. Misol uchun, biz <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">2-bobda</a><!-- ignore -->  ishlatgan <code>rand</code> cratesi tasodifiy sonlarni yaratuvchi funksionallikni ta ºminlaydi.
Ko'pincha Rustaceanlar  ‚Äúcrate‚Äù deganda, ular kutubxona crateni anglatadi va ular &quot;kutubxona&quot; ning umumiy dasturlash tushunchasi bilan &quot;crate&quot; dan foydalanadilar.</p>
<p><em>Crate root</em> bu Rust kompilyatori cratengizning ildiz modulini yaratishni boshlaydigan manba fayldir (biz modullarni <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">‚ÄúQo'llanish doirasi va maxfiylikni nazorat qilish uchun modullarni aniqlash‚Äù</a><!-- ignore --> bo‚Äòlimida chuqur tushuntiramiz).</p>
<p><em>Paket</em> - bu bir yoki bir nechta cratelar to'plami bo'lib, u funksiyalar to'plamini ta'minlaydi. Paketda ushbu cratelarni qanday build qilishni tavsiflovchi <em>Cargo.toml</em> fayli mavjud. Cargo - bu sizning kodingizni yaratishda foydalanayotgan buyruq qatori vositasi uchun binary crateni o'z ichiga olgan paket. Cargo paketida binary crate bog'liq bo'lgan kutubxona cratesi ham mavjud. Boshqa loyihalar Cargo buyruq qatori vositasi ishlatadigan mantiqdan foydalanish uchun cargo kutubxonasi cratesiga bog'liq bo'lishi mumkin.</p>
<p>Paket siz xohlagancha ko'p ikkilik binary cratelarni o'z ichiga olishi mumkin, lekin bitta kutubxona cratesidan ko'p bo'lmasligi kerak. Paketda kamida bitta crate bo'lishi kerak, u kutubxona yoki binary crate bo'lishi kerak.</p>
<p>Keling, paketni yaratganimizda nima sodir bo'lishini ko'rib chiqaylik. Birinchidan, biz <code>cargo new</code> buyrug'ini kiritamiz:</p>
<pre><code class="language-console">$ cargo new mening-paketim
     Created binary (application) `mening-paketim` package
$ ls mening-paketim
Cargo.toml
src
$ ls mening-paketim/src
main.rs
</code></pre>
<p>Biz <code>cargo new</code> ni ishga tushirgandan so'ng, biz cargo nima yaratganini ko'rish uchun <code>ls</code> dan foydalanamiz. <code>mening-paketim</code> jildida bizga paketni taqdim qiluvchi <em>Cargo.toml</em> fayli mavjud. Shuningdek, <em>main.rs</em> ni o'z ichiga olgan <em>src</em> jildi ham mavjud. Matn muharririda <em>Cargo.toml</em> ni oching va <em>src/main.rs</em> haqida hech qanday eslatma yo‚Äòqligiga e'tibor bering. Cargo, <em>src/main.rs</em> paket bilan bir xil nomga ega binary cratening crate ildizi ekanligi haqidagi konventsiyaga amal qiladi. Xuddi shunday, Cargo ham biladiki, agar paket jildida <em>src/lib.rs</em> bo'lsa, paketda paket bilan bir xil nomdagi kutubxona cratesi mavjud va <em>src/lib.rs</em> uning crate ildizi hisoblanadi. Cargo kutubxona yoki binaryni yaratish uchun cratening ildiz fayllarini <code>rustc</code> ga o'tkazadi.</p>
<p>Bu yerda bizda faqat <em>src/main.rs</em> ni o'z ichiga olgan paket bor, ya'ni u faqat <code>mening-paketim</code> nomli binary crateni o'z ichiga oladi. Agar paketda <code>src/main.rs</code> va <code>src/lib.rs</code> bo'lsa, unda ikkita crate, binary crate va kutubxona cratesi mavjud bo'lib, ikkalasi ham paket bilan bir xil nomga ega. Paketda fayllarni <em>src/bin</em> jildiga joylashtirish orqali bir nechta binary cratelar bo'lishi mumkin: har bir fayl alohida binary crate bo'ladi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="qollanish-doirasi-va-maxfiylikni-nazorat-qilish-uchun-modullarni-aniqlash"><a class="header" href="#qollanish-doirasi-va-maxfiylikni-nazorat-qilish-uchun-modullarni-aniqlash">Qo'llanish doirasi va maxfiylikni nazorat qilish uchun modullarni aniqlash</a></h2>
<p>Ushbu bo'limda biz modullar va modul tizimining boshqa qismlari haqida gapiramiz, ya'ni elementlarni nomlash imkonini beruvchi <em>pathlar(yo'llar)</em>; pathni qamrab oluvchi <code>use</code> kalit so'zi; va obyektlarni hammaga ochiq qilish(public) uchun <code>pub</code> kalit so'zi. Shuningdek, biz <code>as</code> kalit so'zini, tashqi paketlarni va glob operatorini muhokama qilamiz.</p>
<p>Birinchidan, kelajakda kodingizni tartibga solishda qulay foydalanish uchun qoidalar ro'yxatidan boshlaymiz. Keyin har bir qoidalarni batafsil tushuntiramiz.</p>
<h3 id="modullar-qollanmasi"><a class="header" href="#modullar-qollanmasi">Modullar qo'llanmasi</a></h3>
<p>Bu yerda biz modullar, pathlar, <code>use</code> kalit so ªzi va <code>pub</code> kalit so ªzining kompilyatorda qanday ishlashi va ko ªpchilik ishlab chiquvchilar o ªz kodlarini qanday tashkil qilishlari haqida qisqacha ma ºlumot beramiz. Ushbu bobda biz ushbu qoidalarning har biriga misollarni ko'rib chiqamiz va modullar qanday ishlashini takrorlash uchun yaxshi vaqt.
work.</p>
<ul>
<li><strong>Cratening ildizidan boshlang</strong>: Crateni kompilyatsiya qilishda kompilyator kodni kompilyatsiya qilish uchun avval cratening ildiz fayliga (odatda kutubxona cratesi uchun <em>src/lib.rs</em> yoki binary crate uchun <em>src/main.rs</em>) qaraydi.</li>
<li><strong>Modullarni e'lon qilish</strong>: Cratening ildiz faylida siz yangi modullarni e'lon qilishingiz mumkin; aytaylik, siz <code>mod poliz</code> bilan <code>poliz</code> modulini e'lon qilasiz; 
Kompilyator modul kodini quyidagi joylarda qidiradi:
<ul>
<li>Inline, jingalak qavs ichida <code>mod poliz</code> dan keyingi nuqta-vergul o'rnini egallaydi</li>
<li><em>src/poliz.rs</em> faylida</li>
<li><em>src/poliz/mod.rs</em> faylida</li>
</ul>
</li>
<li><strong>Submodullarni e'lon qilish</strong>: Crate ildizidan boshqa har qanday faylda siz submodullarni e'lon qilishingiz mumkin. Masalan, <em>src/poliz.rs</em> da <code>mod sabzavotlar;</code> deb e`lon qilishingiz mumkin. Kompilyator quyi modul kodini quyidagi joylarda ota-modul uchun nomlangan jilddan qidiradi:
<ul>
<li>Inline, to'g'ridan-to'g'ri <code>mod sabzavotlar</code> dan keyin, nuqta-vergul o'rniga jingalak qavslar ichida</li>
<li><em>src/poliz/sabzavotlar.rs</em> faylida</li>
<li><em>src/poliz/sabzavotlar/mod.rs</em> faylida</li>
</ul>
</li>
<li><strong>Modullarda kodlash yo'llari</strong>: Modul sizning cratengizning bir qismi bo'lgandan so'ng, maxfiylik qoidalari ruxsat bergan bo'lsa, kod yo'lidan foydalanib, xuddi shu cratening istalgan joyidan ushbu moduldagi kodga murojaat qilishingiz mumkin. Misol uchun, poliz sabzavotlari modulidagi <code>Pomidor</code> turi <code>Crate::poliz::sabzavotlar::Pomidor</code> da topiladi.</li>
<li><strong>Private va Public</strong>: Modul ichidagi kod standart bo'yicha uning ota-modullaridan maxfiydir. Modulni public qilish uchun uni <code>mod</code> o'rniga <code>pub mod</code> bilan e‚Äôlon qiling. Public moduldagi elementlarni ham hammaga ochiq qilish uchun ularni e'lon qilishdan oldin <code>pub</code> dan foydalaning.</li>
<li><strong><code>use</code> kalit so'zi</strong>: Bir doirada <code>use</code> kalit so'zidan foydalanish uzoq yo'llarning takrorlanishini kamaytirish uchun elementlar uchun taxalluslarni yaratadi. <code>Crate::poliz::sabzavotlar::Pomidor</code> ga murojaat qilishi mumkin bo'lgan har qanday sohada siz <code>use crate::poliz::sabzavotlar::Pomidor;</code> bilan taxallus yaratishingiz mumkin va shundan so'ng siz ushbu turdagi ushbu doirada foydalanish uchun <code>Pomidor </code>deb yozishingiz kerak.</li>
</ul>
<p>Bu erda biz ushbu qoidalarni aks ettiruvchi <code>orqa_hovli</code> nomli binary crate yaratamiz. Crate jildi, shuningdek, <code>orqa_hovli</code> deb nomlangan, quyidagi fayllar va jildlarni o'z ichiga oladi:</p>
<pre><code class="language-text">orqa_hovli
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ poliz
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ sabzavotlar.rs
    ‚îú‚îÄ‚îÄ poliz.rs
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
<p>Bu holda cratening ildiz fayli <em>src/main.rs</em> bo'lib, u quyidagilarni o'z ichiga oladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::poliz::sabzavotlar::Pomidor;

pub mod poliz;

fn main() {
    let ekin = Pomidor {};
    println!(&quot;Men {:?} o'stiryapman!&quot;, ekin);
}</code></pre>
<p><code>pub mod poliz;</code> qatori kompilyatorga <em>src/poliz.rs</em> da topilgan kodni kiritishni aytadi, ya'ni:</p>
<p><span class="filename">Fayl nomi: src/poliz.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod sabzavotlar;</code></pre>
<p>Bu yerda <code>pub mod sabzavotlar;</code> <em>src/poliz/sabzavotlar.rs</em> dagi kod ham kiritilganligini bildiradi. That code is:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Pomidor {}</code></pre>
<p>Keling, ushbu qoidalarning tafsilotlari bilan tanishamiz va ularni amalda ko'rsatamiz!</p>
<h3 id="modullarda-tegishli-kodlarni-guruhlash"><a class="header" href="#modullarda-tegishli-kodlarni-guruhlash">Modullarda tegishli kodlarni guruhlash</a></h3>
<p><em>Modullar</em> kodni o'qish va qayta foydalanishni osonlashtirish uchun crate ichida tartibga solish imkonini beradi.
Modullar bizga elementlarning <em>maxfiyligini</em> boshqarishga ham imkon beradi, chunki modul ichidagi kod standart bo ªyicha shaxsiy(private) hisoblanadi. Private elementlar tashqi foydalanish uchun mavjud bo'lmagan ichki dastur tafsilotlari. Biz modullar va ulardagi elementlarni hammaga ochiq qilishni tanlashimiz mumkin, bu esa ularni tashqi koddan foydalanish va ularga bog'liq bo'lishiga imkon beradi.</p>
<p>Misol tariqasida, restoranning funksionalligini ta'minlaydigan kutubxona cratesini yozamiz. Biz funksiyalarning signaturelarini aniqlaymiz, lekin restoranni implement qilishga emas, balki kodni tashkil etishga e'tibor qaratish uchun ularning tanasini bo'sh qoldiramiz.</p>
<p>Restoran sanoatida restoranning ba'zi qismlari <em>uyning old tomoni</em> va boshqalari <em>uyning orqa tomoni</em> deb ataladi. Uyning old tomoni mijozlar joylashgan joy; Bu mezbonlar mijozlarni joylashtiradigan, serverlar buyurtma va to'lovlarni qabul qiladigan va barmenlar ichimliklar tayyorlaydigan joyni o'z ichiga oladi. Uyning orqa tomonida oshpazlar va oshpazlar oshxonada ishlaydi, idishlarni yuvish mashinalari tozalaydi va menejerlar ma'muriy ishlarni bajaradilar.</p>
<p>Cratemizni shu tarzda tuzish uchun biz uning funksiyalarini ichki modullarga ajratishimiz mumkin. <code>cargo new restoran --lib</code> ishga tushirish orqali <code>restoran</code> nomli yangi kutubxona yarating; keyin ba'zi modullar va funksiya signaturelarini aniqlash uchun 7-1 ro'yxatidagi kodni <em>src/lib.rs</em> ichiga kiriting. Mana, uyning old qismi:
<span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod uyning_oldi {
    mod xizmat {
        fn navbat_listiga_qoshish() {}

        fn stolga_otirish() {}
    }

    mod serving {
        fn buyurtma_olish() {}

        fn buyurtma_berish() {}

        fn tolovni_qabul_qilish() {}
    }
}</code></pre>
<p><span class="caption">Ro ªyxat 7-1: <code>uyning_oldi</code> moduli, keyin funksiyalarni o ªz ichiga olgan boshqa modullarni o ªz ichiga oladi.</span></p>
<p>Biz modulni <code>mod</code> kalit so'zidan keyin modul nomi bilan belgilaymiz (bu holda <code>uyning_oldi</code>). Keyin modul tanasi jingalak qavslar ichiga kiradi. Modullar ichida biz boshqa modullarni joylashtirishimiz mumkin, masalan, <code>xizmat</code> va <code>xizmat_korsatish</code> modullari. Modullar, shuningdek, structlar, enumlar, konstantalar, belgilar va 7-1 ro'yxatdagi kabi boshqa elementlar uchun ta'riflarga ega bo'lishi mumkin.</p>
<p>Modullardan foydalanib, biz bir-biriga bog'liq definitionlarni guruhlashimiz va ular nima uchun bog'liqligini nomlashimiz mumkin. Ushbu koddan foydalanadigan dasturchilar barcha definitionlarni o'qib chiqmasdan, guruhlarga asoslangan kodni boshqarishi mumkin, bu ularga tegishli definitionlarni topishni osonlashtiradi. Ushbu kodga yangi funksiya qo'shadigan dasturchilar dasturni tartibli saqlash uchun kodni qayerga joylashtirishni bilishadi.</p>
<p>Yuqorida aytib o'tganimizdek, <em>src/main.rs</em> va <em>src/lib.rs</em> fayllari crate ildiz modullari deb ataladi. Ularning nomlanishining sababi shundaki, bu ikki faylning birortasining mazmuni <em>modul daraxti</em> deb nomlanuvchi crate modul strukturasining ildizida joylashgan <code>crate</code> nomli modulni tashkil qiladi.</p>
<p>7-2 ro'yxatda 7-1 ro'yxatdagi strukturaning modul daraxti ko'rsatilgan.</p>
<pre><code class="language-text">crate
 ‚îî‚îÄ‚îÄ uyning_oldi
     ‚îú‚îÄ‚îÄ xizmat
     ‚îÇ   ‚îú‚îÄ‚îÄ navbat_listiga_qoshish
     ‚îÇ   ‚îî‚îÄ‚îÄ stolga_otirish
     ‚îî‚îÄ‚îÄ xizmat_korsatish
         ‚îú‚îÄ‚îÄ buyurtma_olish
         ‚îú‚îÄ‚îÄ buyurtma_berish
         ‚îî‚îÄ‚îÄ tolov_qilish
</code></pre>
<p><span class="caption">7-2 ro'yxat: 7-1 ro'yxatdagi kod uchun modul daraxti</span></p>
<p>Bu daraxt ba'zi modullar bir-birining ichida qanday joylashishini ko'rsatadi; masalan, <code>xizmat</code> uyasi <code>uyning_oldi</code> ichida. Daraxt shuningdek, ba'zi modullar bir-birining aka-uka ekanligini, ya'ni ular bir modulda aniqlanganligini ko'rsatadi; <code>xizmat</code> va <code>xizmat_korsatish</code> <code>uyning_oldi</code> ichida belgilangan aka-ukalardir. Agar A moduli B modulida joylashgan bo'lsa, biz A moduli B modulining <em>bolasi</em> va B moduli A modulining <em>otasi</em> deb aytamiz. E'tibor bering, butun modul daraxti <code>Crate</code> nomli yashirin modul ostida joylashgan.</p>
<p>Modul daraxti sizga kompyuteringizdagi fayl tizimining jildlar daraxtini eslatishi mumkin; bu juda to'g'ri taqqoslash! Fayl tizimidagi jildlar singari, siz kodingizni tartibga solish uchun modullardan foydalanasiz. Va xuddi jilddagi fayllar singari, bizga modullarimizni topish usuli kerak.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modul-daraxtidagi-elementga-murojaat-qilish-yollari"><a class="header" href="#modul-daraxtidagi-elementga-murojaat-qilish-yollari">Modul daraxtidagi elementga murojaat qilish yo'llari</a></h2>
<p>Rust-ga modul daraxtidagi elementni qayerdan topish mumkinligini ko'rsatish uchun biz fayl tizimida harakat qilishda qanday yo'l(path) ishlatgan bo'lsak, xuddi shunday yo'ldan foydalanamiz. Funksiyani chaqirish uchun biz uning yo'lini bilishimiz kerak.</p>
<p>Yo'l ikki shaklda bo'lishi mumkin:</p>
<ul>
<li><em>Absolyut yo'l</em> - bu crate ildizidan boshlanadigan to'liq yo'l; tashqi cretedagi kod uchun mutlaq yo'l crate nomidan boshlanadi va joriy cratedagi kod uchun esa <code>crate</code> bilan boshlanadi..</li>
<li><em>N   isbiy yo‚Äòl</em> joriy moduldan boshlanadi va joriy modulda <code>self</code>, <code>super</code> yoki identifikatordan foydalanadi.</li>
</ul>
<p>Mutlaq va nisbiy yo‚Äòllardan keyin ikki nuqta (<code>::</code>) bilan ajratilgan bir yoki bir nechta identifikatorlar keladi.</p>
<p>7-1 ro'yxatiga qaytsak, biz <code>navbat_listiga_qoshish</code> funksiyasini chaqirmoqchimiz deylik.
Bu so'rash bilan bir xil: <code>navbat_listiga_qoshish</code> funksiyasining yo'li nima?
7-3 ro'yxatda 7-1 ro'yxati mavjud bo'lib, ba'zi modullar va funksiyalar olib tashlangan.</p>
<p>Biz crate ildizida belgilangan yangi <code>restoranda_ovqatlanish</code> funksiyasidan <code>navbat_listiga_qoshish</code> funksiyasini chaqirishning ikkita usulini ko‚Äòrsatamiz. Bu yo ªllar to ªg ªri, ammo bu misolni avvalgidek tuzishga to ªsqinlik qiladigan yana bir muammo bor. Sababini birozdan keyin tushuntiramiz.</p>
<p><code>restoranda_ovqatlanish</code> funksiyasi kutubxonamizning public API-ning bir qismidir, shuning uchun biz uni <code>pub</code> kalit so'zi bilan belgilaymiz. <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">‚Äú<code>pub</code> kalit so'zi bilan yo'llarni ochish‚Äù</a><!-- ignore --> bo‚Äòlimida biz <code>pub</code> haqida batafsilroq to‚Äòxtalib o'tamiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod uyning_oldi {
    mod xizmat {
        fn navbat_listiga_qoshish() {}
    }
}

pub fn restoranda_ovqatlanish() {
    // Mutlaq yo'l (Absolute path)
    crate::uyning_oldi::xizmat::navbat_listiga_qoshish();

    // Nisbiy yo'l (Relative path)
    uyning_oldi::xizmat::navbat_listiga_qoshish();
}</code></pre>
<p><span class="caption">Ro'yxat 7-3: <code>navbat_listiga_qoshish</code> funksiyasini mutlaq va nisbiy yo'llar yordamida chaqirish</span></p>
<p>Biz birinchi marta <code>restoranda_ovqatlanish</code> ichida <code>navbat_listiga_qoshish</code> funksiyasini chaqirganimizda mutlaq yo'ldan foydalanamiz. <code>navbat_listiga_qoshish</code> funksiyasi <code>restoranda_ovqatlanish</code> bilan bir xil crateda belgilangan, ya'ni mutlaq yo ªlni boshlash uchun <code>crate</code> kalit so ªzidan foydalanishimiz mumkin. Keyin biz <code>navbat_listiga_qoshish</code> ga o'tgunimizcha ketma-ket modullarning har birini o'z ichiga olamiz. Siz bir xil strukturaga ega fayl tizimini tasavvur qilishingiz mumkin: biz <code>navbat_listiga_qoshish</code> dasturini ishga tushirish uchun <code>/uyning_oldi/xizmat/navbat_listiga_qoshish</code> yo'lini belgilaymiz; crate ildizidan boshlash uchun <code>crate</code> nomidan foydalanish shelldagi fayl tizimi ildizidan boshlash uchun <code>/</code> dan foydalanishga o'xshaydi.</p>
<p>Biz <code>restoranda_ovqatlanish</code> ichida <code>navbat_listiga_qoshish</code> ni ikkinchi marta chaqirganimizda nisbiy yo'ldan foydalanamiz. Yo'l <code>uyning_oldi</code> bilan boshlanadi, modul nomi <code>restoranda_ovqatlanish</code> bilan bir xil modul daraxti darajasida belgilangan. Bu yerda fayl tizimi ekvivalenti <code>uyning_oldi/xizmat/navbat_listiga_qoshish</code> yo'lidan foydalaniladi. Modul nomi bilan boshlash yo'l nisbiy ekanligini bildiradi.</p>
<p>Nisbiy yoki mutlaq yo‚Äòldan foydalanishni tanlash loyihangiz asosida qabul qilinadigan qaror bo‚Äòlib, element definitioni kodini elementdan foydalanadigan koddan alohida yoki birga ko‚Äòchirish ehtimoli ko‚Äòproq ekanligiga bog‚Äòliq.
Masalan, <code>uyning_oldi</code> moduli va <code>restoranda_ovqatlanish</code> funksiyasini <code>mijoz_tajribasi</code> nomli modulga o‚Äòtkazsak, mutlaq yo‚Äòlni <code>navbat_listiga_qoshish</code>ga yangilashimiz kerak bo‚Äòladi, lekin nisbiy yo‚Äòl baribir amal qiladi.
Biroq, agar biz <code>restoranda_ovqatlanish</code> funksiyasini <code>ovqatlanish</code> nomli modulga alohida ko'chirsak, <code>restoranda_ovqatlanish</code> chaqiruvining mutlaq yo'li bir xil bo'lib qoladi, lekin nisbiy yo'l yangilanishi kerak bo'ladi. Umuman olganda, bizning afzal ko'rganimiz mutlaq yo'llarni belgilashdir, chunki biz kod definitionlari va element chaqiruvlarini bir-biridan mustaqil ravishda ko'chirishni xohlaymiz.</p>
<p>Keling, 7-3 ro'yxatini kompilatsiya qilishga harakat qilaylik va nima uchun u hali kompilatsiya bo'lmaganligini bilib olaylik! Biz olgan xato 7-4 ro'yxatda ko'rsatilgan.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `xizmat` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::uyning_oldi::xizmat::navbat_listiga_qoshish();
  |                            ^^^^^^^ private module
  |
note: the module `xizmat` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod xizmat {
  |     ^^^^^^^^^^^

error[E0603]: module `xizmat` is private
  --&gt; src/lib.rs:12:21
   |
12 |     uyning_oldi::xizmat::navbat_listiga_qoshish();
   |                     ^^^^^^^ private module
   |
note: the module `xizmat` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod xizmat {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Ro'yxat 7-4: 7-3 ro'yxatdagi kodni kompilyatsiya qilishda kompilyator xatolari</span></p>
<p>Xato xabarlari <code>xizmat</code> moduli private ekanligini aytadi. Boshqacha qilib aytadigan bo'lsak, bizda <code>xizmat</code> moduli va <code>navbat_listiga_qoshish</code> funksiyasi uchun to'g'ri yo'llar mavjud, ammo Rust ulardan foydalanishimizga ruxsat bermaydi, chunki u private bo'limlarga kirish imkoniga ega emas. Rust-da barcha elementlar (funktsiyalar, metodlar, structlar, enumlar, modullar va konstantalar) standart bo'yicha ota-modullar uchun privatedir. Agar siz funksiya yoki struktura kabi elementni yaratmoqchi bo'lsangiz, uni modulga joylashtirasiz.</p>
<p>Ota-moduldagi elementlar ichki modullar ichidagi private elementlardan foydalana olmaydi, lekin bolalar modullaridagi elementlar o'zlarining ota-modullaridagi elementlardan foydalanishi mumkin. Buning sababi shundaki, bolalar modullari o'zlarining amalga oshirish tafsilotlarini o'rab oladi va yashiradi, lekin bolalar modullari ular aniqlangan kontekstni ko'rishlari mumkin. Bizning metaforamizni davom ettirish uchun, maxfiylik qoidalarini restoranning orqa ofisi kabi tasavvur qiling: u erda nima sodir bo'layotgani restoran mijozlari uchun private, ammo ofis menejerlari o'zlari ishlayotgan restoranda hamma narsani ko'rishlari va qilishlari mumkin.</p>
<p>Rust modul tizimining shu tarzda ishlashini tanladi, shuning uchun ichki dastur tafsilotlarini yashirish standart bo'yichadir. Shunday qilib, siz ichki kodning qaysi qismlarini tashqi kodni buzmasdan o'zgartirishingiz mumkinligini bilasiz. Biroq, Rust sizga obyektni hammaga ochiq qilish uchun <code>pub</code> kalit so'zidan foydalanib, tashqi ajdod modullariga ichki modullar kodining ichki qismlarini ochish imkoniyatini beradi.</p>
<h3 id="pub-kalit-sozi-bilan-yollarni-ochish"><a class="header" href="#pub-kalit-sozi-bilan-yollarni-ochish"><code>pub</code> kalit so'zi bilan yo'llarni ochish</a></h3>
<p>Keling, 7-4 ro'yxatdagi xatoga qaytaylik, bu bizga <code>xizmat</code> moduli private ekanligini aytdi. Biz ota-moduldagi <code>restoranda_ovqatlanish</code> funksiyasi bolalar modulidagi <code>navbat_listiga_qoshish</code> funksiyasiga kirishini xohlaymiz, shuning uchun biz <code>xizmat</code> modulini <code>pub</code> kalit so'zi bilan belgilaymiz, ro'yxat 7-5da ko`rsatilganidek.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod uyning_oldi {
    pub mod xizmat {
        fn navbat_listiga_qoshish() {}
    }
}

pub fn restoranda_ovqatlanish() {
    // Mutlaq yo'l (Absolute path)
    crate::uyning_oldi::xizmat::navbat_listiga_qoshish();

    // Nisbiy yo'l (Relative path)
    uyning_oldi::xizmat::navbat_listiga_qoshish();
}</code></pre>
<p><span class="caption">Ro'yxat 7-5: <code>xizmat</code> modulini <code>restoranda_ovqatlanish</code> dan foydalanish uchun <code>pub</code> deb e'lon qilish</span></p>
<p>Afsuski, 7-5 ro'yxatdagi kod hali ham 7-6 ro'yxatda ko'rsatilganidek xatolikka olib keladi.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `navbat_listiga_qoshish` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::uyning_oldi::xizmat::navbat_listiga_qoshish();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `navbat_listiga_qoshish` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn navbat_listiga_qoshish() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `navbat_listiga_qoshish` is private
  --&gt; src/lib.rs:12:30
   |
12 |     uyning_oldi::xizmat::navbat_listiga_qoshish();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `navbat_listiga_qoshish` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn navbat_listiga_qoshish() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Ro'yxat 7-6: 7-5 ro'yxatdagi kodni build qilishda kompilyator xatolari</span></p>
<p>Nima bo'ldi? <code>mod xizmat</code> oldiga <code>pub</code> kalit so‚Äòzini qo‚Äòshish modulni hammaga ochiq qiladi. Ushbu o'zgarish bilan, agar biz <code>uyning_oldi</code> ga kira olsak, biz <code>xizmat</code> ga kira olamiz. Lekin <code>xizmat</code> ning <em>tarkibi</em> hamon private; modulni public qilish uning mazmunini ochiq qilmaydi. Moduldagi <code>pub</code> kalit so‚Äòzi faqat uning ota-modullaridagi kodni unga murojaat qilish imkonini beradi, uning ichki kodiga kirishga ruxsat bermaydi.
Modullar konteyner bo'lgani uchun modulni faqat public qilish orqali biz ko'p narsa qila olmaymiz; biz oldinga borishimiz va modul ichidagi bir yoki bir nechta narsalarni ham hammaga ochiq qilishni tanlashimiz kerak.</p>
<p>7-6 ro ªyxatdagi xatolar <code>navbat_listiga_qoshish</code> funksiyasi private ekanligini bildiradi.
Maxfiylik qoidalari structlar, enumlar, funksiyalar va metodlar hamda modullarga nisbatan qo'llaniladi.</p>
<p>7-7 ro'yxatda ko'rsatilganidek, definitiondan oldin <code>pub</code> kalit so'zini qo'shish orqali <code>navbat_listiga_qoshish</code> funksiyasini ham hammaga ochiq qilaylik.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod uyning_oldi {
    pub mod xizmat {
        pub fn navbat_listiga_qoshish() {}
    }
}

pub fn restoranda_ovqatlanish() {
    // Mutlaq yo'l (Absolute path)
    crate::uyning_oldi::xizmat::navbat_listiga_qoshish();

    // Nisbiy yo'l (Relative path)
    uyning_oldi::xizmat::navbat_listiga_qoshish();
}</code></pre>
<p><span class="caption">Ro'yxat 7-7: <code>mod xizmat</code> va <code>fn navbat_listiga_qoshish</code> ga <code>pub</code> kalit so'zini qo'shish bizga <code>restoranda_ovqatlanish</code> funksiyasini chaqirish imkonini beradi.</span></p>
<p>Endi kod kompilyatsiya qilinadi! Nima uchun<code>pub</code> kalit so ªzini qo ªshish ushbu yo ªllardan <code>navbat_listiga_qoshish</code> da maxfiylik qoidalariga nisbatan foydalanish imkonini berishini bilish uchun mutlaq va nisbiy yo ªllarni ko ªrib chiqamiz.</p>
<p>Mutlaq yo'lda biz crate modul daraxtining ildizi bo'lgan <code>crate</code> dan boshlaymiz. <code>uyning_oldi</code> moduli crate ildizida belgilangan. <code>uyning_oldi</code> ochiq bo ªlmasa-da, <code>restoranda_ovqatlanish</code> funksiyasi <code>uyning_oldi</code> bilan bir xil modulda aniqlanganligi sababli (ya ºni, <code>restoranda_ovqatlanish</code> va <code>uyning_oldi</code> siblingdir ya'ni aka-uka), biz <code>restoranda_ovqatlanish</code> dan <code>uyning_oldi</code>ga murojaat qilishimiz mumkin. Keyingi o'rinda <code>pub</code> bilan belgilangan <code>xizmat</code> moduli. Biz <code>xizmat</code> ning ota-moduliga kira olamiz, shuning uchun biz <code>xizmat</code> ga kira olamiz. Nihoyat, <code>navbat_listiga_qoshish</code> funksiyasi <code>pub</code> bilan belgilangan va biz uning asosiy moduliga kira olamiz, shuning uchun bu funksiya chaqiruvi ishlaydi!</p>
<p>Nisbiy yo'lda mantiq birinchi qadamdan tashqari mutlaq yo'l bilan bir xil bo'ladi: yo'l crate ildizidan emas, <code>uyning_oldi</code>dan boshlanadi. <code>uyning_oldi</code> moduli <code>restoranda_ovqatlanish</code> bilan bir xil modul ichida aniqlanadi, shuning uchun <code>restoranda_ovqatlanish</code> belgilangan moduldan boshlanadigan nisbiy yo‚Äòl ishlaydi. Keyin, <code>xizmat</code> va <code>navbat_listiga_qoshish</code> <code>pub</code> bilan belgilanganligi sababli, qolgan yo‚Äòl ishlaydi va bu funksiya chaqiruvi amal qiladi!</p>
<p>Agar siz kutubxona crateyingizni boshqa loyihalar sizning kodingizdan foydalanishi uchun baham ko'rishni rejalashtirmoqchi bo'lsangiz, public API sizning crateyingiz foydalanuvchilari bilan tuzilgan shartnoma bo'lib, ular sizning kodingiz bilan qanday aloqada bo'lishini belgilaydi. Odamlar sizning crateyingizga bog'liq bo'lishini osonlashtirish uchun public API-ga o'zgartirishlarni boshqarish bo'yicha ko'plab fikrlar mavjud. Bu mulohazalar ushbu kitob doirasidan tashqarida; agar sizni ushbu mavzu qiziqtirsa, <a href="https://rust-lang.github.io/api-guidelines/">Rust API ko'rsatmalari</a>ga qarang.</p>
<blockquote>
<h4 id="binary-va-kutubxonaga-ega-paketlar-uchun-eng-yaxshi-amaliyotlar"><a class="header" href="#binary-va-kutubxonaga-ega-paketlar-uchun-eng-yaxshi-amaliyotlar">Binary va kutubxonaga ega paketlar uchun eng yaxshi amaliyotlar</a></h4>
<p>Paketda <em>src/main.rs</em> binary crate ildizi ham, <em>src/lib.rs</em> kutubxona cratesi ildizi
ham bo‚Äòlishi mumkinligini aytib o'tdik va ikkala crate ham standart bo‚Äòyicha
paket nomiga ega bo‚Äòladi. Odatda, kutubxona va binary crateni o'z ichiga olgan
ushbu patternli paketlar kutubxona cratesi bilan kod chaqiradigan bajariladigan
faylni ishga tushirish uchun binary crateda yetarli kodga ega bo'ladi. Bu boshqa
loyihalarga paket taqdim etadigan eng ko'p funksiyalardan foydalanish imkonini
beradi, chunki kutubxona cratesi kodi public bo'lishi mumkin.</p>
<p>Modul daraxti <em>src/lib.rs</em> da aniqlanishi kerak. Keyin har qanday public obyektlar
binary crateda paket nomi bilan yo'llarni boshlash orqali ishlatilishi mumkin.
Binary crate kutubxona cratesidan foydalanuvchiga aylanadi, xuddi butunlay tashqi
crate kutubxona cratesidan foydalanadi: u faqat pulic APIdan foydalanishi mumkin.
Bu sizga yaxshi API yaratishga yordam beradi; Siz nafaqat muallif, balki
mijoz hamsiz!</p>
<p><a href="ch12-00-an-io-project.html">12-bobda</a><!-- ignore --> biz ushbu tashkiliy amaliyotni binary crate va
kutubxona cratesini o'z ichiga olgan buyruq qatori dasturi bilan ko'rsatamiz.</p>
</blockquote>
<h3 id="nisbiy-yollarni-super-bilan-boshlash"><a class="header" href="#nisbiy-yollarni-super-bilan-boshlash">Nisbiy yo'llarni <code>super</code> bilan boshlash</a></h3>
<p>Yo'l boshida <code>super</code> dan foydalanib, joriy modul yoki crate ildizi emas, balki ota-modulda boshlanadigan nisbiy yo'llarni qurishimiz mumkin. Bu fayl tizimi yo ªlini <code>..</code> sintaksisi bilan boshlashga o ªxshaydi. <code>super</code> dan foydalanish bizga ota-modulda ekanligini biladigan elementga murojaat qilish imkonini beradi, bu modul ota-ona bilan chambarchas bog'liq bo'lsa, modul daraxtini qayta tartibga solishni osonlashtiradi, lekin ota-ona bir kun kelib modul daraxtining boshqa joyiga ko'chirilishi mumkin.</p>
<p>7-8 ro'yxatdagi kodni ko'rib chiqing, unda oshpaz noto'g'ri buyurtmani tuzatgan va uni mijozga shaxsan yetkazgan vaziyatni modellashtiradi. <code>uyning_orqasi</code> modulida aniqlangan <code>buyurtmani_tuzatish</code> funksiyasi <code>super</code> bilan boshlanadigan <code>yetkazib_berish</code> yo‚Äòlini belgilash orqali asosiy modulda belgilangan <code>yetkazib_berish</code> funksiyasini chaqiradi:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn yetkazib_berish() {}

mod uyning_orqasi {
    fn buyurtmani_tuzatish() {
        oshpaz();
        super::yetkazib_berish();
    }

    fn oshpaz() {}
}</code></pre>
<p><span class="caption">Ro'yxat 7-8: <code>super</code> bilan boshlanadigan nisbiy yo'l yordamida funksiyani chaqirish</span></p>
<p><code>buyurtmani_tuzatish</code> funksiyasi <code>uyning_orqasi</code> modulida joylashgan, shuning uchun biz <code>super</code> dan <code>uyning_orqasi</code> ota-moduliga o'tishimiz mumkin. U yerdan <code>yetkazib_berish</code> ni qidiramiz va uni topamiz.
Muvaffaqiyat! Bizning fikrimizcha, <code>uyning_orqasi</code> moduli va <code>yetkazib_berish</code> funksiyasi bir-biri bilan bir xil munosabatda bo'lib qoladi va agar biz cratening modul daraxtini qayta tashkil etishga qaror qilsak, birgalikda harakatlanadi. Shu sababli, biz <code>super</code> dan foydalandik, shuning uchun kelajakda bu kod boshqa modulga ko‚Äòchirilsa, kodni yangilash uchun kamroq joylarga ega bo‚Äòlamiz.</p>
<h3 id="structlar-va-enumlarni-public-qilish"><a class="header" href="#structlar-va-enumlarni-public-qilish">Structlar va Enumlarni public qilish</a></h3>
<p>Shuningdek, structlar va enumlarni public sifatida belgilash uchun <code>pub</code> dan foydalanishimiz mumkin, ammo <code>pub</code> dan structlar va enumlar bilan foydalanish uchun qo'shimcha tafsilotlar mavjud. Agar struct definitiondan oldin <code>pub</code> dan foydalansak, biz structni hammaga public qilamiz, lekin structning maydonlari hali ham private bo'lib qoladi. Biz har bir sohani alohida-alohida public qilishimiz yoki qilmasligimiz mumkin. 7-9 ro ªyxatda biz public <code>qizdirilgan_non</code> maydoni, lekin private <code>mavsumiy_meva</code> maydoni bilan public <code>uyning_orqasi:: nonushta</code> structini belgilab oldik. Bu restoranda mijoz ovqat bilan birga keladigan non turini tanlashi mumkin bo'lgan holatni modellashtiradi, ammo oshpaz qaysi meva mavsumda va omborda borligiga qarab ovqatga hamroh bo'lishini hal qiladi. Mavjud mevalar tezda o'zgaradi, shuning uchun mijozlar mevani tanlay olmaydi yoki hatto qaysi mevani olishini ko'ra olmaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod uyning_orqasi {
    pub struct Nonushta {
        pub yopilgan_non: String,
        mavsumiy_meva: String,
    }

    impl Nonushta {
        pub fn yoz(yopilgan_non: &amp;str) -&gt; Nonushta {
            Nonushta {
                yopilgan_non: String::from(yopilgan_non),
                mavsumiy_meva: String::from(&quot;shaftoli&quot;),
            }
        }
    }
}

pub fn restoranda_ovqatlanish() {
    // Yozda javdar yopilgan noni bilan nonushta buyurtma qiling
    let mut ovqat = uyning_orqasi::Nonushta::yoz(&quot;Javdar&quot;);
    // Qaysi nonni xohlashimiz haqidagi fikrimizni o'zgartiring
    ovqat.yopilgan_non = String::from(&quot;Bug'doy&quot;);
    println!(&quot;Iltimos, {}li yopilgan nonni istayman&quot;, ovqat.yopilgan_non);

    // Agar izohni olib tashlasak, keyingi qator kompilyatsiya qilinmaydi;
    // ovqat bilan birga keladigan mavsumiy mevalarni ko'rish yoki 
    // o'zgartirishga ruxsat berilmagan
    // ovqat.mavsumiy_meva = String::from(&quot;ko'katlar&quot;);
}</code></pre>
<p><span class="caption">Ro'yxat 7-9: Ba'zi public maydonlari va ba'zilari bo'lgan struct
xususiy maydonlar</span></p>
<p><code>uyning_orqasi::Nonushta</code> structdagi <code>yopilgan_non</code> maydoni public bo'lgani uchun <code>restoranda_ovqatlanish</code> da biz <code>yopilgan_non</code> maydoniga nuqta belgisi yordamida yozishimiz va o'qishimiz mumkin. Esda tutingki, biz <code>mavsumiy_meva</code> maydonidan <code>restoranda_ovqatlanish</code>da foydalana olmaymiz, chunki <code>mavsumiy_meva</code> privatedir. Qaysi xatoga yo'l qo'yganingizni bilish uchun <code>mavsumiy_meva</code> maydoni qiymatini o'zgartiruvchi qatorni izohdan chiqarib ko'ring!</p>
<p>Shuni ham yodda tutingki, <code>uyning_orqasi::Nonushta</code> private maydonga ega bo'lgani uchun struct <code>Nonushta</code> misolini yaratuvchi public bog'langan funksiyani ta'minlashi kerak (biz uni bu yerda <code>yoz</code> deb nomladik).Agar <code>Nonushta</code> bunday funksiyaga ega bo ªlmagan bo ªlsa, biz <code>restoranda_ovqatlanish</code>da <code>Nonushta</code> misolini yarata olmadik, chunki biz <code>restoranda_ovqatlanish</code>da private <code>mavsumiy_meva</code> maydonining qiymatini o ªrnata olmadik.</p>
<p>Aksincha, agar biz enumni public qilsak, uning barcha variantlari public bo'ladi. 7 10 ro ªyxatda ko ªrsatilganidek, bizga faqat <code>enum</code> kalit so ªzidan oldin <code>pub</code> kerak bo ªladi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod uyning_orqasi {
    pub enum Taom {
        Palov,
        Salat,
    }
}

pub fn restoranda_ovqatlanish() {
    let buyurtma1 = uyning_orqasi::Taom::Palov;
    let buyurtma2 = uyning_orqasi::Taom::Salat;
}</code></pre>
<p><span class="caption">Ro'yxat 7-10: Enumni public deb belgilash uning barcha variantlarini hammaga ochiq qiladi</span></p>
<p>Biz <code>Taom</code> ro‚Äòyxatini hammaga public qilganimiz uchun <code>restoranda_ovqatlanish</code>da <code>Palov</code> va <code>Salat</code> variantlaridan foydalanishimiz mumkin.</p>
<p>Enumlar, agar ularning variantlari public bo'lmasa, unchalik foydali emas; Har bir holatda <code>pub</code> bilan barcha enum variantlariga izoh qo'yish zerikarli bo'lar edi, shuning uchun enum variantlari uchun standart umumiy bo'lishi kerak. Structlar ko'pincha maydonlari public bo'lmasdan foydali bo'ladi, shuning uchun struct maydonlari, agar <code>pub</code> bilan izohlanmagan bo'lsa, standart bo'yicha hamma narsa private bo'lishining umumiy qoidasiga amal qiladi.</p>
<p><code>pub</code> bilan bog'liq yana bir holat bor, biz uni ko'rib chiqmaganmiz va bu bizning modul tizimining oxirgi xususiyati: <code>use</code> kalit so'zi. Biz avval <code>use</code> ni o'z ichiga olamiz, so'ngra <code>pub</code> va <code>use</code> ni qanday birlashtirishni ko'rsatamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="use-kalit-sozi-bilan-yollarni-doiraga-kiritish"><a class="header" href="#use-kalit-sozi-bilan-yollarni-doiraga-kiritish"><code>use</code> kalit so'zi bilan yo'llarni doiraga kiritish</a></h2>
<p>Funksiyalarni chaqirish yo'llarini yozishga to'g'ri kelishi noqulay va takroriy tuyulishi mumkin. 7-7-Ro'yxatda <code>navbat_listiga_qoshish</code> funksiyasiga mutlaq yoki nisbiy yo ªlni tanladikmi, har safar <code>navbat_listiga_qoshish</code> funksiyasiga murojat qilmoqchi bo ªlganimizda, <code>uyning_oldi</code> va <code>xizmat</code>ni ham belgilashimiz kerak edi. Yaxshiyamki, bu jarayonni soddalashtirishning bir usuli bor: biz bir marta <code>use</code> kalit so‚Äòzi bilan yo‚Äòlga nom yaratishimiz mumkin, so‚Äòngra boshqa hamma joyda qisqaroq nomdan foydalanishimiz mumkin.</p>
<p>7-11 ro'yxatda biz <code>crate::uyning_oldi::xizmat</code> modulini <code>restoranda_ovqatlanish</code> funksiyasi doirasiga kiritamiz, shuning uchun <code>restoranda_ovqatlanish</code>dagi <code>navbat_listiga_qoshish</code> funksiyasini chaqirish uchun faqat <code>xizmat::navbat_listiga_qoshish</code> ni belgilashimiz kerak.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod uyning_oldi {
    pub mod xizmat {
        pub fn navbat_listiga_qoshish() {}
    }
}

use crate::uyning_oldi::xizmat;

pub fn restoranda_ovqatlanish() {
    xizmat::navbat_listiga_qoshish();
}</code></pre>
<p><span class="caption">Ro'yxat 7-11: Modulni <code>use</code> bilan qamrab olish</span></p>
<p><code>use</code> va sohaga yo'lni qo'shish fayl tizimida ramziy havola yaratishga o'xshaydi. Crate ildiziga <code>use crate::uyning_oldi::xizmat</code> ni qo‚Äòshish orqali <code>xizmat</code> endi bu doirada haqiqiy nom bo‚Äòlib qoladi, xuddi <code>xizmat</code> moduli crate ildizida aniqlangandek. <code>use</code> doirasiga kiritilgan yo'llar boshqa yo'llar kabi maxfiylikni ham tekshiradi.</p>
<p>E'tibor bering, <code>use</code> faqat <code>use</code> ishlaydigan aniq doira uchun yorliqni yaratadi. 7-12 ro ªyxat <code>restoranda_ovqatlanish</code> funksiyasini <code>mijoz</code> nomli yangi bolalar moduliga o ªtkazadi, bu keyinchalik <code>use</code> statementidan farq qiladi, shuning uchun funksiyaning tanasi kompilyatsiya qilinmaydi:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod uyning_oldi {
    pub mod xizmat {
        pub fn navbat_listiga_qoshish() {}
    }
}

use crate::uyning_oldi::xizmat;

mod mijoz {
    pub fn restoranda_ovqatlanish() {
        xizmat::navbat_listiga_qoshish();
    }
}</code></pre>
<p><span class="caption">Ro'yxat 7-12: <code>use</code> statementi faqat u joylashgan doirada qo'llaniladi</span></p>
<p>Kompilyator xatosi yorliq endi <code>mijoz</code> modulida qo'llanilmasligini ko'rsatadi:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
warning: unused import: `crate::uyning_oldi::xizmat`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::uyning_oldi::xizmat;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

error[E0433]: failed to resolve: use of undeclared crate or module `xizmat`
  --&gt; src/lib.rs:11:9
   |
11 |         xizmat::navbat_listiga_qoshish();
   |         ^^^^^^ use of undeclared crate or module `xizmat`

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` due to previous error; 1 warning emitted
</code></pre>
<p>E'tibor bering, <code>use</code> endi uning doirasida qo'llanilmasligi haqida ogohlantirish ham bor! Bu muammoni hal qilish uchun <code>use</code> ni <code>mijoz</code> moduliga ham o‚Äòtkazing yoki <code>mijoz</code> modulidagi <code>super::xizmat</code> bilan ota-moduldagi yorliqlarga murojaat qiling.</p>
<h3 id="use-bilan-idiomatik-yollarni-yaratish"><a class="header" href="#use-bilan-idiomatik-yollarni-yaratish"><code>use</code> bilan idiomatik yo'llarni yaratish</a></h3>
<p>7-11 ro'yxatda siz shunday deb hayron bo'lishingiz mumkin,Nima uchun biz bir xil natijaga erishish uchun <code>navbat_listiga_qoshish</code> funksiyasigacha to ªliq yo ªlni ishlatish o ªrniga, <code>crate::uyning_oldi::xizmat</code> ni ishlatishni belgilab qo ªydik va keyin <code>restoranda_ovqatlanish</code> ichidagi <code>xizmat::navbat_listiga_qoshish</code> ga murojat qildik, 7-13 ro'yxatdagi kabi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod uyning_oldi {
    pub mod xizmat {
        pub fn navbat_listiga_qoshish() {}
    }
}

use crate::uyning_oldi::xizmat::navbat_listiga_qoshish;

pub fn restoranda_ovqatlanish() {
    navbat_listiga_qoshish();
}</code></pre>
<p><span class="caption">Ro'yxat 7-13: <code>navbat_listiga_qoshish</code> funksiyasini <code>use</code> bilan qamrab olish, bu unidiomatikdir</span></p>
<p>Garchi 7-11 va 7-13 ro'yxatlari bir xil vazifani bajarsa-da, 7-11 ro'yxat funksiyani <code>use</code> bilan qamrab olishning idiomatik usulidir. Funksiyaning ota-modulini <code>use</code> bilan qamrab olish funksiyani chaqirishda ota-modulni belgilashimiz kerakligini anglatadi. Funksiyani chaqirishda ota-modulni ko'rsatish, to'liq yo'lning takrorlanishini minimallashtirish bilan birga, funksiya mahalliy sifatida aniqlanmaganligini aniq ko'rsatadi. 7-13 ro'yxatda <code>navbat_listiga_qoshish</code> qayerda aniqlangani aniq emas.</p>
<p>Boshqa tomondan, <code>use</code> bilan structlar, enumlar va boshqa elementlarni keltirishda to'liq yo'lni ko'rsatish idiomatikdir. 7-14 ro'yxat standart kutubxonaning <code>HashMap</code> structini binary crate doirasiga olib kirishning idiomatik usulini ko'rsatadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 7-14: <code>HashMap</code> ni idiomatik tarzda qamrab olish</span></p>
<p>Bu idioma ortida hech qanday yaxshi sabab yo'q: Bu shunchaki konventsiya paydo bo'ldi va odamlar Rust kodini shu tarzda o'qish va yozishga o'rganib qolgan.</p>
<p>Bu idiomadan istisno shundaki, biz bir xil nomdagi ikkita elementni <code>use</code> statementi yordamida doiraga kiritganimizda - Rust bunga yo'l qo'ymaydi. 7-15 ro'yxatda bir xil nomga ega, ammo har xil ota-modullarga ega bo'lgan ikkita <code>Result</code> turini qanday ko'rinishga kiritish va ularga qanday murojaat qilish kerakligi ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn funksiya1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn funksiya2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Ro'yxat 7-15: Bir xil nomdagi ikkita turni bir xil doiraga kiritish uchun ularning ota-modullaridan foydalanish talab etiladi.</span></p>
<p>Ko'rib turganingizdek, ota-modullardan foydalanish ikkita <code>Result</code> turini ajratib turadi.
Buning o'rniga <code>use std::fmt::Result</code> va <code>us std::io::Result</code> ni belgilagan bo'lsak, bizda bir xil miqyosda ikkita <code>Result</code> turi bo'lar edi va Rust <code>Result</code> dan foydalanganda qaysi birini nazarda tutganimizni bilmas edi.</p>
<h3 id="as-kalit-sozi-bilan-yangi-nomlarni-taqdim-etish"><a class="header" href="#as-kalit-sozi-bilan-yangi-nomlarni-taqdim-etish"><code>as</code> kalit so'zi bilan yangi nomlarni taqdim etish</a></h3>
<p>Bir xil nomdagi ikkita turni <code>use</code> bilan bir xil doiraga olib kirish muammosining yana bir yechimi bor: yo ªldan so ªng biz <code>as</code> va yangi mahalliy nom yoki tur uchun <em>taxallus</em> belgilashimiz mumkin. 7-16 ro'yxatda ikkita <code>Result</code> turidan birini <code>as</code> yordamida qayta nomlash orqali 7-15 ro'yxatdagi kodni yozishning yana bir usuli ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn funksiya1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn funksiya2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Ro'yxat 7-16: <code>as</code> kalit so'zi bilan qamrovga kiritilgan tur nomini o'zgartirish</span></p>
<p>Ikkinchi <code>use</code> statementida biz <code>std::io::Result</code> turi uchun yangi <code>IoResult</code> nomini tanladik, bu endi <code>std::fmt</code> dan <code>Result</code> turiga zid kelmaydi, u ham doiraga kiradi. 7-15 va 7-16 ro'yxatlar idiomatik hisoblanadi, shuning uchun tanlov sizga bog'liq!</p>
<h3 id="pub-use-bilan-nomlarni-qayta-eksportre-eksport-qilish"><a class="header" href="#pub-use-bilan-nomlarni-qayta-eksportre-eksport-qilish"><code>pub use</code> bilan nomlarni qayta eksport(re-eksport) qilish</a></h3>
<p><code>use</code> kalit so'zidan foydalanib, nomni qamrovga kiritganimizda, yangi doirada mavjud bo'lgan nom private bo'ladi. Bizning kodimizni chaqiradigan kodni xuddi shu kod doirasida aniqlangandek ushbu nomga murojaat qilishini yoqish uchun biz <code>pub</code> va <code>use</code> ni birlashtira olamiz. Bu usul <em>re-eksport</em> deb nomlanadi, chunki biz obyektni qamrovga kiritmoqdamiz, lekin elementni boshqa qamrovlarga kiritish uchun ham mavjud qilamiz.</p>
<p>7-17 ro'yxatda 7-11 ro'yxatdagi kod ko'rsatilgan, ildiz modulidagi <code>use</code> <code>pub use</code> ga o'zgartirilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod uyning_oldi {
    pub mod xizmat {
        pub fn navbat_listiga_qoshish() {}
    }
}

pub use crate::uyning_oldi::xizmat;

pub fn restoranda_ovqatlanish() {
    xizmat::navbat_listiga_qoshish();
}</code></pre>
<p><span class="caption">Ro'yxat 7-17. <code>pub use</code> bilan yangi doiradagi istalgan kod tomonidan foydalanish uchun nom berish</span></p>
<p>Ushbu o'zgarishdan oldin tashqi kod <code>restoran::uyning_oldi::xizmat::navbat_listiga_qoshish()</code> yo'lidan foydalanib, <code>navbat_listiga_qoshish</code> funksiyasini chaqirishi kerak bo'ladi. Endi bu <code>pub use</code> <code>xizmat</code> modulini ildiz modulidan qayta eksport qilgan bo‚Äòlsa, tashqi kod endi <code>restoran::xizmat::navbat_listiga_qoshish()</code> yo‚Äòlidan foydalanishi mumkin..</p>
<p>Qayta eksport qilish sizning kodingizning ichki tuzilishi sizning kodingizni chaqirayotgan dasturchilarning domen haqida o'ylashlaridan farq qilganda foydali bo'ladi. Misol uchun, ushbu restoran metaforasida restoranni boshqaradigan odamlar &quot;uyning old tomoni&quot; va &quot;uyning orqasi&quot; haqida o'ylashadi. Ammo restoranga tashrif buyurgan mijozlar, ehtimol, restoranning qismlari haqida o'ylamaydilar. <code>pub use</code> bilan biz kodimizni bitta struct bilan yozishimiz mumkin, lekin boshqa structni ko'rsatamiz. Bu bizning kutubxonamizni kutubxonada ishlaydigan dasturchilar va kutubxonaga murojat qilayotgan dasturchilar uchun uchun yaxshi tashkil etilgan holda saqlaydi. Biz 14-bobning <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">‚Äú<code>pub use</code> bilan qulay umumiy APIni eksport qilish‚Äù</a><!-- ignore --> bo‚Äòlimida <code>pub use</code>ning yana bir misolini va uning cratengiz hujjatlariga qanday ta‚Äôsir qilishini ko‚Äòrib chiqamiz.</p>
<h3 id="tashqi-paketlardan-foydalanish"><a class="header" href="#tashqi-paketlardan-foydalanish">Tashqi paketlardan foydalanish</a></h3>
<p>2-bobda biz tasodifiy raqamlarni olish uchun <code>rand</code> deb nomlangan tashqi paketdan foydalangan holda taxminiy o'yin loyihasini dasturlashtirdik. Loyihamizda <code>rand</code> dan foydalanish uchun biz ushbu qatorni <em>Cargo.toml</em> ga qo'shdik:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.5&quot;
</code></pre>
<p><em>Cargo.toml</em>-ga <code>rand</code>ni dependency sifatida qo'shish Cargo-ga <a href="crates.io">crates.io</a>-dan <code>rand</code> paketini va har qanday bog'liqliklarni yuklab olishni va <code>rand</code>ni loyihamiz uchun ishlatishni aytadi.</p>
<p>Keyin, <code>rand</code> ta'riflarini paketimiz doirasiga kiritish uchun biz crate nomidan boshlanadigan <code>use</code> qatorini qo'shdik, <code>rand</code> va biz qamrab olmoqchi bo'lgan elementlarni sanab o'tdik. Eslatib o‚Äòtamiz, 2-bobdagi <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">‚ÄúTasodifiy raqamni yaratish‚Äù</a><!-- ignore --> bo‚Äòlimida biz <code>Rng</code> traitini qamrab oldik va <code>rand::thread_rng</code> funksiyasini chaqirdik:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span>    let yashirin_raqam = rand::rng().random_range(1..=100);
<span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span>}</code></pre>
<p>Rust hamjamiyatining a'zolari <a href="crates.io">crates.io</a> saytida ko'plab paketlarni taqdim etishdi va ulardan birini o'z paketingizga olish xuddi shu bosqichlarni o'z ichiga oladi: ularni paketingizning <em>Cargo.toml</em> faylida ro ªyxatga kiriting va <code>use</code> dan foydalanib, ularni cratelaridagi elementlarni qamrab oling.</p>
<p>E'tibor bering, standart <code>std</code> kutubxonasi bizning paketimizdan tashqarida joylashgan cratedir. Standart kutubxona Rust tili bilan birga kelganligi sababli, biz <em>Cargo.toml</em> ni <code>std</code> qo'shish uchun o'zgartirishimiz shart emas. Ammo biz u yerdan elementlarni paketimiz doirasiga olib kirish uchun <code>use</code> bilan murojaat qilishimiz kerak. Masalan, <code>HashMap</code> bilan biz ushbu qatordan foydalanamiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Bu standart kutubxona cratesining nomi bo'lgan <code>std</code> bilan boshlanadigan mutlaq yo'ldir.</p>
<h3 id="uzun-use-royxatini-qisqartirish-uchun-ichki-yollardan-foydalanish"><a class="header" href="#uzun-use-royxatini-qisqartirish-uchun-ichki-yollardan-foydalanish">Uzun <code>use</code> ro'yxatini qisqartirish uchun ichki yo'llardan foydalanish</a></h3>
<p>Agar biz bir xil crate yoki bir xil modulda belgilangan bir nechta elementlardan foydalansak, har bir elementni o'z qatoriga qo'yish bizning fayllarimizda juda ko'p vertikal joy egallashi mumkin. Masalan, 2-4 ro ªyxatdagi raqamlarni taxmin qilish dasturida mavjud bo ªlgan ushbu ikkita <code>use</code> statementi <code>std</code> dagi elementlarni qamrab oladi:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o'qib bo'lmadi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">
</span><span class="boring">    match taxmin.cmp(&amp;yashirin_raqam) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Siz yutdingiz!&quot;),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Buning o'rniga, biz bir xil elementlarni bir qatorga kiritish uchun ichki yo'llardan foydalanishimiz mumkin. Buni 7-18 ro ªyxatda ko ªrsatilganidek, yo ªlning umumiy qismini, keyin ikkita nuqta qo ªyib, so ªngra yo ªllarning bir-biridan farq qiladigan qismlari ro ªyxati atrofida jingalak qavslarni belgilash orqali qilamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut taxmin)
</span><span class="boring">        .expect(&quot;Satrni o'qib bo'lmadi&quot;);
</span><span class="boring">
</span><span class="boring">    let taxmin: u32 = taxmin.trim().parse().expect(&quot;Iltimos, raqam yozing!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">
</span><span class="boring">    match taxmin.cmp(&amp;yashirin_raqam) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;Siz yutdingiz!&quot;),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 7-18. Qo'llash sohasiga bir xil prefiksli bir nechta elementlarni qo'shish uchun ichki yo'lni belgilash</span></p>
<p>Kattaroq dasturlarda bir xil crate yoki moduldan ko'plab elementlarni o'rnatilgan yo'llar yordamida qamrab olish juda ko'p talab qilinadigan alohida <code>use</code> statementlari sonini kamaytirishi mumkin!</p>
<p>Siz har qanday darajadagi ichki yo'ldan foydalanishingiz mumkin, bu yo'l qismini ulashuvchi ikkita <code>use</code> statementini birlashtirishda foydalidir. Masalan, 7-19 ro'yxat ikkita <code>use</code> statementini ko'rsatadi: biri <code>std::io</code> ni qamrab oladi va ikkinchisi <code>std::io::Write</code> ni qamrab oladi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
<p><span class="caption">Ro'yxat 7-19: biri ikkinchisining bir qismi bo'lgan ikkita <code>use</code> statementi</span></p>
<p>Ushbu ikkita yo'lning umumiy qismi <code>std::io</code> va to'liq birinchi yo'ldir. Ushbu ikkita yo'lni bitta <code>use</code> statementiga birlashtirish uchun biz 7-20 ro'yxatda ko'rsatilganidek, ichki yo'lda <code>self</code> dan foydalanishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
<p><span class="caption">Ro'yxat 7-20: Ro'yxat 7-19dagi yo'llarni bitta <code>use</code> statementiga birlashtirish</span></p>
<p>Bu satr <code>std::io</code> va <code>std::io::Write</code> ni qamrab oladi.</p>
<h3 id="glob-operatori"><a class="header" href="#glob-operatori">Glob operatori</a></h3>
<p>Agar biz yo'lda belgilangan <em>barcha</em> umumiy elementlarni qamrovga kiritmoqchi bo'lsak, biz <code>*</code> glob operatori tomonidan keyingi yo'lni belgilashimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>Ushbu <code>use</code> statementi <code>std::collections</code> da aniqlangan barcha public elementlarni joriy doiraga olib keladi. Glob operatoridan foydalanganda ehtiyot bo'ling! Glob qaysi nomlar qamrovda ekanligini va dasturingizda ishlatiladigan nom qayerda aniqlanganligini aniqlashni qiyinlashtirishi mumkin.</p>
<p>Glob operatori ko'pincha sinovdan o'tgan hamma narsani <code>tests</code> moduliga kiritish uchun test paytida ishlatiladi; biz bu haqda 11-bobdagi <a href="ch11-01-writing-tests.html#how-to-write-tests">&quot;Testlarni qanday yozish kerak&quot;</a><!-- ignore --> bo'limida gaplashamiz. Glob operatori ba'zan prelude patterning bir qismi sifatida ham qo'llaniladi: ushbu pattern haqida qo'shimcha ma'lumot olish uchun <a href="../std/prelude/index.html#other-preludes">standart kutubxona texnik hujjatlariga</a><!-- ignore --> qarang.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modullarni-turli-fayllarga-ajratish"><a class="header" href="#modullarni-turli-fayllarga-ajratish">Modullarni turli fayllarga ajratish</a></h2>
<p>Hozirgacha ushbu bobdagi barcha misollar bitta faylda bir nechta modullarni aniqladi.
Modullar kattalashganda, kodni boshqarishni osonlashtirish uchun ularning definitionlarini alohida faylga ko'chirishingiz mumkin.</p>
<p>Masalan, 7-17 ro'yxatdagi bir nechta restoran moduliga ega bo'lgan koddan boshlaylik. Biz cratening ildiz modulidagi barcha modullarni aniqlash o'rniga modullarni fayllarga ajratamiz. Bunday holda, cratening ildiz fayli <em>src/lib.rs</em> bo'ladi, lekin bu protsedura crate ildiz fayli <em>src/main.rs</em> bo'lgan binary cratelar bilan ham ishlaydi.</p>
<p>Birinchidan, biz <code>uyning_oldi</code> modulini o'z fayliga chiqaramiz. <code>uyning_oldi</code> moduli uchun jingalak qavslar ichidagi kodni olib tashlang va faqat <code>mod uyning_oldi</code> deklaratsiyasini qoldiring, shunda <em>src/lib.rs</em> ro'yxat 7-21da ko'rsatilgan kodni o`z ichiga oladi. E'tibor bering, biz 7-22 ro'yxatda <em>src/uyning_oldi.rs</em> faylini yaratmagunimizcha, bu kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod uyning_oldi;

pub use crate::uyning_oldi::xizmat;

pub fn restoranda_ovqatlanish() {
    xizmat::navbat_listiga_qoshish();
}</code></pre>
<p><span class="caption">Ro'yxat 7-21. Tarkibi <code>src/uyning_oldi.rs</code> da joylashgan <code>uyning_oldi</code> modulini e'lon qilish</span></p>
<p>Keyin, jingalak qavslardagi kodni yangi faylga joylashtiring
7-22 ro'yxatda ko'rsatilganidek <em>src/uyning_oldi.rs</em> deb nomlangan. Kompilyator bu faylda nimani izlash kerakligini biladi, chunki u <code>uyning_oldi</code> deb nomlangan cratening ildiz modulida modul deklaratsiyasiga duch keldi.</p>
<p><span class="filename">Fayl nomi: src/uyning_oldi.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-21-and-22/src/front_of_house.rs}}</code></pre>
<p><span class="caption">Ro'yxat 7-22. <em>src/uyning_oldi.rs</em> faylida <code>uyning_oldi</code> modulining mazmunini aniqlash</span></p>
<p>Esda tutingki, modul daraxtida <em>bir marta</em> <code>mod</code> deklaratsiyasidan foydalanib faylni yuklashingiz kerak. Kompilyator fayl loyihaning bir qismi ekanligini bilgandan so'ng (va <code>mod</code> statementi qo'ygan joyingiz tufayli kod modul daraxtining qayerida joylashganligini biladi), loyihangizdagi boshqa fayllar yuklangan fayl kodiga u e'lon qilingan joyga yo'l orqali murojaat qilishi kerak, bu <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">&quot;Modul daraxtidagi elementga murojaat qilish yo'llari&quot;</a><!-- ignore --> bo'limida yoritilgan. Boshqacha qilib aytganda, <code>mod</code> boshqa dasturlash tillarida ko'rishingiz mumkin bo'lgan ‚Äúinclude‚Äù operatsiyasi emas.</p>
<p>Keyinchalik, biz <code>xizmat</code> modulini o'z fayliga chiqaramiz. Jarayon biroz boshqacha, chunki <code>xizmat</code> ildiz modulining emas, balki <code>uyning_oldi</code> ichki modulidir.Biz <code>xizmat</code> faylini modul daraxtidagi ajdodlari nomi bilan ataladigan yangi jildga joylashtiramiz, bu holda <em>src/uyning_oldi/</em>.</p>
<p><code>xizmat</code>ni ko‚Äòchirishni boshlash uchun biz <em>src/uyning_oldi.rs</em> ni faqat <code>xizmat</code> moduli deklaratsiyasini o‚Äòz ichiga olgan holda o‚Äòzgartiramiz:</p>
<p><span class="filename">Fayl nomi: src/uyning_oldi.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-02-extracting-hosting/src/front_of_house.rs}}</code></pre>
<p>Keyin biz <em>src/uyning_oldi</em> jildini va <code>xizmat</code> modulida berilgan definitionlarni o'z ichiga olgan <em>xizmat.rs</em> faylini yaratamiz:</p>
<p><span class="filename">Fayl nomi: src/uyning_oldi/xizmat.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-02-extracting-hosting/src/front_of_house/hosting.rs}}</code></pre>
<p>Agar biz <em>src</em> jildiga <em>xizmat.rs</em> ni qo'ysak, kompilyator <em>xizmat.rs</em> kodi crate ildizida e'lon qilingan va <code>uyning_oldi</code> modulining yordamchisi sifatida e'lon qilinmagan <code>xizmat</code> modulida bo'lishini kutadi. Kompilyator qoidalari qaysi modullarning kodini o'z ichiga olgan fayllarni tekshirish uchun jildlar va fayllar modul daraxtiga to'liq mos kelishini taxmin qiladi.</p>
<blockquote>
<h3 id="muqobil-fayl-yollari"><a class="header" href="#muqobil-fayl-yollari">Muqobil fayl yo'llari</a></h3>
<p>Hozirgacha biz Rust kompilyatori foydalanadigan eng idiomatik fayl yo'llarini ko'rib chiqdik,
lekin Rust fayl yo'lining eski uslubini ham qo'llab-quvvatlaydi. Crate ildizida e'lon qilingan
<code>uyning_oldi</code> nomli modul uchun kompilyator modul kodini quyidagilardan qidiradi:
module‚Äôs code in:</p>
<ul>
<li><em>src/uyning_oldi.rs</em> (biz nimani qamrab oldik)</li>
<li><em>src/uyning_oldi/mod.rs</em> (eski uslub, hali ham qo'llab-quvvatlanadigan yo'l)</li>
</ul>
<p><code>uyning_oldi</code> submodul bo'lgan <code>xizmat</code> nomli modul uchun kompilyator modul kodini qidiradi:</p>
<ul>
<li><em>src/uyning_oldi/xizmat.rs</em> (biz nimani qamrab oldik)</li>
<li><em>src/uyning_oldi/xizmat/mod.rs</em> (eski uslub, hali ham qo'llab-quvvatlanadigan yo'l)</li>
</ul>
<p>Agar bir xil modul uchun ikkala uslubdan foydalansangiz, kompilyator xatosi paydo bo'ladi. Bitta
loyihada turli modullar uchun ikkala uslubning aralashmasidan foydalanishga ruxsat
beriladi, lekin loyihangizni boshqarayotgan odamlar uchun chalkash bo'lishi mumkin.</p>
<p><em>mod.rs</em> nomli fayllardan foydalanadigan uslubning asosiy kamchiligi
shundaki, sizning loyihangiz <em>mod.rs</em> nomli ko‚Äòplab fayllar bilan
tugashi mumkin, ular bir vaqtning o‚Äòzida muharriringizda ochilganda
chalkash bo‚Äòlishi mumkin.</p>
</blockquote>
<p>Biz har bir modul kodini alohida faylga ko'chirdik va modul daraxti o'zgarishsiz qoldi. <code>restoranda_ovqatlanish</code> funksiyasi chaqiruvlari, definitionlar turli fayllarda bo'lsa ham, hech qanday o'zgartirishlarsiz ishlaydi. Ushbu texnika modullarni hajmi oshgani sayin yangi fayllarga ko'chirish imkonini beradi.</p>
<p>Esda tutingki, <em>src/lib.rs</em> dagi <code>pub use crate::uyning_oldi::xizmat</code> statementi ham o'zgarmagan va <code>use</code> qaysi fayllar cratening bir qismi sifatida tuzilganiga ta'sir qilmaydi. <code>mod</code> kalit so'zi modullarni e'lon qiladi va Rust ushbu modulga kiradigan kod moduli bilan bir xil nomdagi faylga qaraydi.</p>
<h2 id="xulosa-6"><a class="header" href="#xulosa-6">Xulosa</a></h2>
<p>Rust sizga paketni bir nechta cratelarga va crateni modullarga bo'lish imkonini beradi, shunda siz bir modulda belgilangan elementlarga boshqa moduldan murojaat qilishingiz mumkin. Buni mutlaq yoki nisbiy yo'llarni belgilash orqali amalga oshirishingiz mumkin. Ushbu yo'llar <code>use</code> statementi bilan qamrab olinishi mumkin, shuning uchun siz ushbu doiradagi elementdan bir nechta foydalanish uchun qisqaroq yo'ldan foydalanishingiz mumkin. Modul kodi standart bo ªyicha maxfiydir, lekin <code>pub</code> kalit so ªzini qo ªshish orqali definitionlarni hammaga public qilishingiz mumkin.</p>
<p>Keyingi bobda biz standart kutubxonadagi ma'lumotlar tuzilmalarining ba'zi to'plamlarini ko'rib chiqamiz, ulardan siz o'zingizning aniq tartiblangan kodingizda foydalanishingiz mumkin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="umumiy-toplamlar"><a class="header" href="#umumiy-toplamlar">Umumiy to'plamlar</a></h1>
<p>Rustning standart kutubxonasi <em>kolleksiyalar</em> deb nomlangan juda foydali ma'lumotlar tuzilmalarini o'z ichiga oladi. Ko'pgina boshqa ma'lumotlar turlari bitta ma'lum qiymatni ifodalaydi, lekin to'plamlar bir nechta qiymatlarni o'z ichiga olishi mumkin. O'rnatilgan array va tuple turlaridan farqli o'laroq, ushbu to'plamlar ko'rsatadigan ma'lumotlar heapda saqlanadi, ya'ni ma'lumotlar miqdori kompilyatsiya vaqtida ma'lum bo'lishi shart emas va dastur ishga tushganda o'sishi yoki qisqarishi mumkin. To'plamning har bir turi o'z imkoniyatlariga ega va ishlash jihatidan farq qiladi, shuning uchun ma'lum bir to'plamni tanlash vaziyatga bog'liq va vaqt o'tishi bilan ishlab chiquvchining mahoratidir. Ushbu bobda biz Rust dasturlarida tez-tez ishlatiladigan uchta to'plamni muhokama qilamiz:</p>
<ul>
<li><em>vector</em> o'zgaruvchan sonli qiymatlarni bir-birining yonida saqlashga imkon beradi.</li>
<li><em>string</em> - bu belgilar to'plami. Biz <code>String</code> turini avval aytib o'tgan edik, ammo bu bobda biz bu haqda chuqurroq gaplashamiz.</li>
<li><em>hash map</em> ma'lum bir kalit bilan qiymatni bog'lash imkonini beradi.Bu <em>map</em> deb nomlangan umumiy ma'lumotlar strukturasining o'ziga xos tatbiqidir.</li>
</ul>
<p>Standart kutubxona tomonidan taqdim etilgan boshqa turdagi to'plamlar haqida bilish uchun <a href="../std/collections/index.html">texnik hujjatlarga</a> qarang.</p>
<p>Biz vectorlarni, stringlarni va hash-maplarni qanday yaratish va yangilashni, shuningdek, har birining o'ziga xosligini muhokama qilamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vectorlar-bilan-qiymatlar-royxatini-saqlash"><a class="header" href="#vectorlar-bilan-qiymatlar-royxatini-saqlash">Vectorlar bilan qiymatlar ro'yxatini saqlash</a></h2>
<p>Biz ko'rib chiqadigan birinchi to'plam turi <code>Vec&lt;T&gt;</code> bo'lib, u <em>vector</em> sifatida ham tanilgan.
Vectorlar xotirada barcha qiymatlarni yonma-yon joylashtirgan yagona ma'lumotlar strukturasida bir nechta qiymatlarni saqlash imkonini beradi. Vectorlar faqat bir xil turdagi qiymatlarni saqlashi mumkin. Ular sizda fayldagi matn satrlari yoki xarid qilish savatidagi narsalarning narxlari kabi elementlar ro'yxatiga ega bo'lsangiz foydali bo'ladi.</p>
<h3 id="yangi-vector-yaratish"><a class="header" href="#yangi-vector-yaratish">Yangi vector yaratish</a></h3>
<p>Yangi bo'sh vector yaratish uchun biz 8-1 ro'yxatda ko'rsatilganidek, <code>Vec::new</code> funksiyasini chaqiramiz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 8-1: <code>i32</code> turidagi qiymatlarni saqlash uchun yangi, bo ªsh vector yaratish</span></p>
<p>E'tibor bering, biz bu erda annation tur qo'shdik. Biz ushbu vectorga hech qanday qiymat kiritmayotganimiz sababli, Rust biz qanday elementlarni saqlashni xohlayotganimizni bilmaydi. Bu muhim nuqta. Vectorlar generiklar yordamida amalga oshiriladi; Biz 10-bobda o'zingizning turlaringiz bilan generiklardan qanday foydalanishni ko'rib chiqamiz. Hozircha shuni bilingki, standart kutubxona tomonidan taqdim etilgan <code>Vec&lt;T&gt;</code> turi har qanday turni sig'dira oladi.
Muayyan turni ushlab turish uchun vector yaratganimizda, burchakli qavslar([]) ichida turni belgilashimiz mumkin. 8-1 ro ªyxatida biz Rustga <code>v</code>dagi <code>Vec&lt;T&gt;</code> <code>i32</code> turidagi elementlarni saqlashini aytdik.</p>
<p>Ko'pincha siz boshlang'ich qiymatlari bilan <code>Vec&lt;T&gt;</code> ni yaratasiz va Rust siz saqlamoqchi bo'lgan qiymat turini aniqlaydi, shuning uchun kamdan-kam hollarda bu turdagi annotionni bajarishingiz kerak bo'ladi. Rust qulay tarzda <code>vec!</code> makrosini taqdim etadi, bu esa siz bergan qiymatlarni saqlaydigan yangi vectorni yaratadi. 8-2 ro ªyxati <code>1</code>, <code>2</code> va <code>3</code> qiymatlariga ega bo ªlgan yangi <code>Vec&lt;i32&gt;</code>ni yaratadi. Butun son turi <code>i32</code> dir, chunki bu standart butun son turi, biz 3-bobning <a href="ch03-02-data-types.html#data-types">&quot;Ma'lumotlar turlari&quot;</a><!-- ignore --> bo'limida muhokama qilganimizdek.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-2: qiymatlarni o'z ichiga olgan yangi vector yaratish</span></p>
<p>Biz boshlang‚Äòich <code>i32</code> qiymatlarini berganimiz sababli, Rust <code>v</code> turi <code>Vec&lt;i32&gt;</code> ekanligini va tur izohi shart emas degan xulosaga kelishi mumkin. Keyinchalik vectorni qanday o'zgartirishni ko'rib chiqamiz.</p>
<h3 id="vectorni-yangilash"><a class="header" href="#vectorni-yangilash">Vectorni yangilash</a></h3>
<p>Vector yaratish va unga elementlar qo'shish uchun biz 8-3 ro'yxatda ko'rsatilganidek, <code>push</code> metodidan foydalanishimiz mumkin.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-3: vectorga qiymatlar qo'shish uchun <code>push</code> metodidan foydalanish</span></p>
<p>Har qanday o'zgaruvchida bo'lgani kabi, agar biz uning qiymatini o'zgartirish imkoniyatiga ega bo'lishni istasak, 3-bobda muhokama qilinganimizdek, <code>mut</code> kalit so'zidan foydalanib, uni o'zgaruvchan qilishimiz kerak. Biz joylashtirgan raqamlarning barchasi <code>i32</code> turiga kiradi va Rust buni ma ºlumotlardan chiqaradi, shuning uchun bizga <code>Vec&lt;i32&gt;</code> annotationi kerak emas.</p>
<h3 id="vector-elementlarini-oqish"><a class="header" href="#vector-elementlarini-oqish">Vector elementlarini o'qish</a></h3>
<p>Vectorda saqlangan qiymatga murojaat qilishning ikki yo'li mavjud: indekslash yoki <code>get</code> metodi yordamida. Quyidagi misollarda biz qo'shimcha aniqlik uchun ushbu funksiyalardan qaytariladigan qiymatlar turlarini izohladik.</p>
<p>8-4 ro'yxatda indekslash sintaksisi va <code>get</code> metodi bilan vectordagi qiymatga kirishning ikkala usuli ko'rsatilgan.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let uchinchi: &amp;i32 = &amp;v[2];
    println!(&quot;Uchinchi element {uchinchi}&quot;);

    let uchinchi: Option&lt;&amp;i32&gt; = v.get(2);
    match uchinchi {
        Some(uchinchi) =&gt; println!(&quot;Uchinchi element {uchinchi}&quot;),
        None =&gt; println!(&quot;Uchinchi element yo'q.&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-4: Vectordagi elementga kirish uchun indekslash sintaksisi yoki <code>get</code> metodidan foydalanish</span></p>
<p>Bu erda bir nechta detallarga e'tibor bering. Uchinchi elementni olish uchun <code>2</code> indeks qiymatidan foydalanamiz, chunki vectorlar noldan boshlab raqamlar bo ªyicha indekslanadi. <code>&amp;</code> va <code>[]</code> dan foydalanish bizga indeks qiymatidagi elementga reference beradi. Argument sifatida berilgan indeks bilan <code>get</code> metodidan  foydalansak, biz <code>match</code> bilan foydalanishimiz mumkin bo'lgan <code>Option&lt;&amp;T&gt;</code>ni olamiz.</p>
<p>Rust elementga reference qilishning ushbu ikki usulini taqdim etishining sababi shundaki, siz mavjud elementlar doirasidan tashqarida indeks qiymatidan foydalanmoqchi bo'lganingizda dastur qanday harakat qilishini tanlashingiz mumkin. Misol sifatida, keling, besh elementli vectorga ega bo'lganimizda nima sodir bo'lishini ko'rib chiqamiz va keyin 8-5 ro'yxatda ko'rsatilganidek, har bir texnikada 100 indeksidagi elementga kirishga harakat qilamiz.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let mavjud_emas = &amp;v[100];
    let mavjud_emas = v.get(100);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-5: besh elementni o'z ichiga olgan vectorda 100 indeksidagi elementga kirishga urinish</span></p>
<p>Ushbu kodni ishga tushirganimizda, birinchi <code>[]</code> metodi dasturda panic chiqaradi, chunki u mavjud bo'lmagan elementga murojaat qiladi. Ushbu usul vector oxiridan o'tgan elementga kirishga urinish bo'lsa, dasturingiz ishdan chiqishini xohlasangiz yaxshi qo'llaniladi.</p>
<p><code>get</code> metodi vectordan tashqaridagi indeksdan o'tganda, panic qo'ymasdan  <code>None</code>ni qaytaradi. Vector doirasidan tashqaridagi elementga kirish vaqti-vaqti bilan oddiy sharoitlarda sodir bo'lishi mumkin bo'lsa, siz ushbu usuldan foydalanasiz. Keyin sizning kodingiz 6-bobda muhokama qilinganidek, <code>Some(&amp;element)</code>  yoki <code>None</code>ga ega bo'lish mantiqiga ega bo'ladi.Misol uchun, indeks raqamni kiritgan odamdan kelib chiqishi mumkin. Agar ular tasodifan juda katta raqamni kiritsa va dastur  <code>None</code> qiymatiga ega bo'lsa, siz foydalanuvchiga joriy vectorda nechta element borligini aytishingiz va ularga to'g'ri qiymat kiritish uchun yana bir imkoniyat berishingiz mumkin.Bu imlo xatosi tufayli dasturni buzishdan ko'ra foydalanuvchilar uchun qulayroq bo'lar edi!</p>
<p>Dasturda tegishli reference mavjud bo'lsa, borrow tekshiruvi ushbu reference va vector mazmuniga boshqa har qanday referencelar haqiqiyligini ta'minlash uchun ownership va borrowing qoidalarini (4-bobda ko'rsatilgan) amalga oshiradi. Bir xil doirada o'zgaruvchan va o'zgarmas referencelarga ega bo'lolmaysiz degan qoidani eslang. Ushbu qoida 8-6 ro'yxatda qo'llaniladi, bu yerda biz vectordagi birinchi elementga o'zgarmas referenceni ushlab turamiz va elementni oxiriga qo'shishga harakat qilamiz. Agar biz ushbu elementga keyinroq funksiyada murojaat qilsak, bu dastur ishlamaydi:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let birinchi = &amp;v[0];

    v.push(6);

    println!(&quot;Birinchi element: {birinchi}&quot;);
<span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 8-6. Vector elementiga reference mavjud bo'lganda vectorga biron bir element qo'shishga urinish</span></p>
<p>Ushbu kodni kompilyatsiya qilish ushbu xatoga olib keladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let birinchi = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;Birinchi element: {birinchi}&quot;);
  |                                 ----------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<p>8-6 ro'yxatdagi kod ishlashi kerakdek ko'rinishi mumkin: nima uchun birinchi elementga reference vector oxiridagi o'zgarishlar haqida qayg'urishi kerak? Bu xato vectorlarning ishlash usuli bilan bog'liq: vectorlar qiymatlarni xotirada bir-birining yoniga qo'yganligi sababli vector oxiriga yangi element qo'shish yangi xotira ajratishni va eski elementlarni yangi bo'sh joyga ko'chirishni talab qilishi mumkin. Hozirda vector saqlanadigan barcha elementlarni bir-birining yoniga qo'yish uchun joy etarli emas. Bunday holda, birinchi elementga reference ajratilgan xotiraga ishora qiladi. Borrowing qoidalari dasturlarning bunday vaziyatga tushishiga yo'l qo'ymaydi.</p>
<blockquote>
<p>Eslatma: <code>Vec&lt;T&gt;</code> turini implement qilish haqida ko'proq ma'lumot olish uchun
<a href="../nomicon/vec/vec.html">&quot;Rustonomikon&quot;</a> ga qarang.</p>
</blockquote>
<h3 id="vectordagi-qiymatlarni-takrorlash"><a class="header" href="#vectordagi-qiymatlarni-takrorlash">Vectordagi qiymatlarni takrorlash</a></h3>
<p>Vectordagi har bir elementga navbatma-navbat kirish uchun biz indekslarni birma-bir kirish uchun ishlatmasdan, barcha elementlarni takrorlaymiz. 8-7 ro'yxatda <code>i32</code> qiymatlari vectoridagi har bir elementga o'zgarmas referencelarni olish va ularni chop etish uchun <code>for</code> siklidan qanday foydalanish ko'rsatilgan.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{i}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-7: <code>for</code> sikli yordamida elementlarni takrorlash orqali vectordagi har bir elementni chop etish</span></p>
<p>Shuningdek, biz barcha elementlarga o'zgartirish kiritish uchun o'zgaruvchan vectordagi har bir elementga o'zgaruvchan referencelarni takrorlashimiz mumkin. 8-8 ro'yxatdagi <code>for</code> sikli har bir elementga <code>50</code> qo'shadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-8: Vectordagi elementlarga o'zgaruvchan referencelarni takrorlash</span></p>
<p>O'zgaruvchan  reference nazarda tutilgan qiymatni o'zgartirish uchun biz <code>+=</code> operatoridan foydalanishimizdan oldin <code>i</code> qiymatiga o'tish uchun <code>*</code> dereference operatoridan foydalanishimiz kerak. Biz 15-bobning <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">&quot;Dereference operatori bilan ko'rsatgichni qiymatga kuzatib borish&quot;</a><!-- ignore --> bo'limida dereference operatori haqida ko'proq gaplashamiz.</p>
<p>O'zgarmas yoki o'zgaruvchan bo'lsin, vector bo'yicha takrorlash, borrow tekshiruvi qoidalari tufayli xavfsizdir. Agar biz 8-7 va 8-8 ro'yxatlardagi <code>for</code> siklining tanasiga elementlarni qo'shishga yoki olib tashlashga harakat qilsak, biz 8-6 ro'yxatdagi kodga o'xshash kompilyator xatosiga duch kelamiz. <code>for</code> siklidagi vectorga murojaat qilish butun vectorni bir vaqtning o'zida o'zgartirishni oldini oladi.</p>
<h3 id="bir-nechta-turlarni-saqlash-uchun-enumdan-foydalanish"><a class="header" href="#bir-nechta-turlarni-saqlash-uchun-enumdan-foydalanish">Bir nechta turlarni saqlash uchun enumdan foydalanish</a></h3>
<p>Vectorlar faqat bir xil turdagi qiymatlarni saqlashi mumkin. Bu noqulay bo'lishi mumkin; Har xil turdagi elementlar ro'yxatini saqlash zarurati uchun, albatta, foydalanish holatlari mavjud. Yaxshiyamki, enumlashning variantlari bir xil enum turi ostida aniqlanadi, shuning uchun bizga har xil turdagi elementlarni ko'rsatish uchun bitta tur kerak bo'lganda, enumni aniqlashimiz va ishlatishimiz mumkin!</p>
<p>Misol uchun, biz elektron jadvalning bir qator ustunlarida integer sonlar, ba'zi float raqamlar va ba'zi stringlar mavjud bo'lgan satrdan qiymatlarni olishni xohlaymiz. Variantlari turli qiymat turlariga ega bo'lgan enumni aniqlashimiz mumkin va barcha enum variantlari bir xil turdagi hisoblanadi: enum. Keyin biz ushbu enumni ushlab turish uchun vectorni yaratishimiz mumkin va natijada har xil turlarni ushlab turadi. Biz buni 8-9 ro'yxatda ko'rsatdik.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum ElektronJadval {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let qator = vec![
        ElektronJadval::Int(3),
        ElektronJadval::Text(String::from(&quot;ko'k&quot;)),
        ElektronJadval::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-9: Har xil turdagi qiymatlarni bitta vectorda saqlash uchun <code>enum</code>ni aniqlash</span></p>
<p>Rust kompilyatsiya vaqtida vectorda qanday turlar bo'lishini bilishi kerak, shuning uchun u har bir elementni saqlash uchun heapda qancha xotira kerakligini aniq biladi. Shuningdek, ushbu vectorda qanday turlarga ruxsat berilganligini aniq bilishimiz kerak. Agar Rust vectorga har qanday turni ushlab turishga ruxsat bergan bo'lsa, bir yoki bir nechta tur vector elementlari ustida bajarilgan operatsiyalarda xatoliklarni keltirib chiqarishi mumkin edi. Enum va <code>match</code> ifodasidan foydalanish Rust kompilyatsiya vaqtida 6-bobda muhokama qilinganidek, barcha mumkin bo'lgan holatlar ko'rib chiqilishini ta'minlaydi.</p>
<p>Agar siz vectorda saqlash uchun dastur runtimeda oladigan turlarning to'liq to'plamini bilmasangiz, enum texnikasi ishlamaydi. Buning o'rniga, biz 17-bobda ko'rib chiqiladigan trait obyektidan foydalanishingiz mumkin.</p>
<p>Endi biz vectorlardan foydalanishning eng keng tarqalgan usullarini ko'rib chiqdik, standart kutubxona tomonidan <code>Vec&lt;T&gt;</code> da belgilangan barcha foydali usullar uchun <a href="../std/vec/struct.Vec.html">API texnik hujjatlarini</a><!-- ignore --> ko'rib chiqishni unutmang. Masalan, <code>push</code> dan tashqari, <code>pop</code> usuli oxirgi elementni olib tashlaydi va qaytaradi.</p>
<h3 id="vectordan-elementlarni-olib-tashlash"><a class="header" href="#vectordan-elementlarni-olib-tashlash">Vectordan elementlarni olib tashlash</a></h3>
<p><code>struct</code>lar singari, vector ham 8-10 ro'yxatda ko'rsatilganidek, amal qilish doirasidan tashqariga chiqqanda xotirasini bo'shatadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // v bilan ish
    } // &lt;- v doiradan chiqib ketadi va bu erda bo'shatiladi
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-10. Vector va uning elementlarini qanday o'chirishni ko'rsatadi</span></p>
<p>Vector o'chirilganda, uning barcha tarkibi ham o'chiriladi: vectorni o'chirish uning tarkibidagi qiymatlarni o'chirishni anglatadi. Borrow tekshiruvi vector mazmuniga har qanday referencelar faqat vectorning o'zi haqiqiy bo'lganda ishlatilishini ta'minlaydi.</p>
<p>Keling, keyingi to'plam turiga o'tamiz: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="utf-8-kodlangan-matnni-string-bilan-saqlash"><a class="header" href="#utf-8-kodlangan-matnni-string-bilan-saqlash">UTF-8 kodlangan matnni String bilan saqlash</a></h2>
<p>Biz 4-bobda stringlar haqida gapirgan edik, ammo hozir ularni batafsil ko'rib chiqamiz.
Yangi Rustaceanlar odatda uchta sababning kombinatsiyasiga ko'ra stringlarga yopishib qolishadi: Rustning mumkin bo'lgan xatolarni ochishga moyilligi, stringlar ko'plab dasturchilar tushunganidan ko'ra murakkabroq ma'lumotlar tuzilishi va UTF-8. Bu omillar shunday birlashadiki, agar siz boshqa dasturlash tillaridan kelgan bo'lsangiz, mavzu murakkab ko'rinishi mumkin.</p>
<p>To'plamlar kontekstida stringlarni muhokama qilish foydalidir, chunki stringlar baytlar to'plami sifatida amalga oshiriladi, shuningdek, bu baytlar matn sifatida talqin qilinganda foydali funksiyalarni ta'minlashning ba'zi usullari. Ushbu bo'limda biz <code>String</code> bo'yicha har bir to'plam turiga ega bo'lgan yaratish, yangilash va o'qish kabi operatsiyalar haqida gapiramiz. Shuningdek, biz <code>String</code> ning boshqa to'plamlardan qanday farq qilishini, ya'ni <code>String</code> ga indekslash odamlar va kompyuterlarning <code>String</code> ma'lumotlarini qanday talqin qilishlari o'rtasidagi farqlar tufayli qanday murakkablashishini muhokama qilamiz.</p>
<h3 id="string-nima"><a class="header" href="#string-nima">String nima?</a></h3>
<p>Biz birinchi navbatda <em>string</em> atamasi bilan nimani nazarda tutayotganimizni aniqlaymiz. Rust asosiy tilda faqat bitta string turiga ega, bu <code>str</code> qator slice bo ªlib, odatda uning <code>&amp;str</code> shaklida ko ªrinadi. 4-bobda biz boshqa joyda saqlangan ba'zi UTF-8 kodlangan string ma'lumotlariga referencelar bo'lgan <em>string slicelar</em> haqida gaplashdik. Masalan, satr literallari dasturning binary tizimida saqlanadi va shuning uchun satr slicedir.</p>
<p>Rust standart kutubxonasi tomonidan taqdim etilgan <code>String</code> turi asosiy tilga o'rnatilmagan va kengaytiriladigan, o'zgaruvchan, ega bo'lgan, UTF-8 kodlangan string turidir. Rustaceanlar Rust tilidagi &quot;stringlar&quot; ga murojaat qilganda, ular bu turlardan birini emas, balki <code>String</code> yoki string slice <code>&amp;str</code> turlarini nazarda tutishi mumkin. Garchi bu bo'lim asosan String haqida bo'lsa-da, ikkala tur ham Rust standart kutubxonasida ko'p qo'llaniladi, <code>String</code> va string slicelari UTF-8 da kodlangan.</p>
<h3 id="yangi-string-yaratish"><a class="header" href="#yangi-string-yaratish">Yangi String yaratish</a></h3>
<p><code>Vec&lt;T&gt;</code> bilan mavjud bo'lgan bir xil amallarning ko'pchiligi <code>String</code> bilan ham mavjud, chunki <code>String</code> aslida qo'shimcha kafolatlar, cheklovlar va imkoniyatlarga ega baytlar vectori atrofida o'rash sifatida amalga oshiriladi. <code>Vec&lt;T&gt;</code> va <code>String</code> bilan bir xil ishlaydigan funksiyaga misol qilib, 8-11 ro'yxatda ko'rsatilgan yangi turdagi misolni yaratuvchi <code>new</code> funksiyadir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-11: Yangi, bo'sh <code>String</code> yaratish</span></p>
<p>Ushbu satr <code>s</code> deb nomlangan yangi bo'sh qatorni yaratadi, biz keyin unga ma'lumotlarni yuklashimiz mumkin. Ko'pincha, biz stringni boshlamoqchi bo'lgan dastlabki ma'lumotlarga ega bo'lamiz. Buning uchun biz string literallari kabi <code>Display</code> traittini amalga oshiradigan har qanday turda mavjud bo'lgan <code>to_string</code> metotidan foydalanamiz. Ro'yxat 8-12 ikkita misolni ko'rsatadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let malumot = &quot;dastlabki tarkib&quot;;

    let s = malumot.to_string();

    // the method also works on a literal directly:
    let s = &quot;dastlabki tarkib&quot;.to_string();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-12: string literalidan <code>String</code> yaratish uchun <code>to_string</code> metodidan foydalanish</span></p>
<p>Bu kod <code>dastlabki tarkib</code>ni o‚Äòz ichiga olgan stringni yaratadi.</p>
<p>Satr literalidan <code>String</code> yaratish uchun <code>String::from</code> funksiyasidan ham foydalanishimiz mumkin. 8-13 ro'yxatdagi kod <code>to_string</code> funksiyasidan foydalanadigan 8-12 ro'yxatdagi kodga teng:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;dastlabki tarkib&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-13: string literalidan <code>String</code> yaratish uchun <code>String::from</code> funksiyasidan foydalanish</span></p>
<p>Stringlar juda ko'p narsalar uchun ishlatilganligi sababli, biz stringlar uchun juda ko'p turli xil umumiy API'lardan foydalanishimiz mumkin, bu bizga juda ko'p imkoniyatlarni taqdim etadi. Ulardan ba'zilari ortiqcha bo'lib tuyulishi mumkin, ammo ularning barchasi o'z joylariga ega! Bunday holda, <code>String::from</code> va <code>to_string</code> bir xil ishni bajaradi, shuning uchun tanlov sizga eng yoqqan uslubga bog'liq.</p>
<p>Yodda tutingki, stringlar UTF-8 bilan kodlangan, shuning uchun 8-14 ro'yxatda ko'rsatilganidek, biz ularga har qanday to'g'ri kodlangan ma'lumotlarni kiritishimiz mumkin.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
    let hello = String::from(&quot;Dobr√Ω den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
    let hello = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
    let hello = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
    let hello = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
    let hello = String::from(&quot;‰Ω†Â•Ω&quot;);
    let hello = String::from(&quot;Ol√°&quot;);
    let hello = String::from(&quot;Salom&quot;);
    let hello = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-14: Salom so'zini turli tillarda stringlarda saqlash</span></p>
<p>Bularning barchasi yaroqli <code>String</code> qiymatlari.</p>
<h3 id="stringni-yangilash"><a class="header" href="#stringni-yangilash">Stringni yangilash</a></h3>
<p>Agar siz unga ko'proq ma'lumot kiritsangiz, <code>String</code> hajmi kattalashishi mumkin va uning tarkibi <code>Vec&lt;T&gt;</code> tarkibidagi kabi o'zgarishi mumkin. Bundan tashqari, <code>String</code> qiymatlarini birlashtirish uchun <code>+</code> operatori yoki <code>format!</code> makrosidan qulay foydalanish mumkin.</p>
<h4 id="push_str-va-push-yordamida-stringga-biriktirish"><a class="header" href="#push_str-va-push-yordamida-stringga-biriktirish"><code>push_str</code> va <code>push</code> yordamida stringga biriktirish</a></h4>
<p>Biz 8-15 ro ªyxatda ko ªrsatilganidek, string bo ªlagini qo ªshish uchun <code>push_str</code> metodidan foydalanib <code>String</code>ni kengaytirishimiz mumkin.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;dastur&quot;);
    s.push_str(&quot;chi&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 8-15: <code>push_str</code> metodi yordamida <code>String</code> ga satr bo ªlagini qo ªshish</span></p>
<p>Ushbu ikki qatordan keyin <code>s</code> tarkibida <code>dasturchi</code> bo'ladi. <code>push_str</code> metodi string bo'lagini oladi, chunki biz parametrga egalik qilishni xohlamaymiz. Masalan, 8-16 ro ªyxatdagi kodda biz uning mazmunini <code>s1</code> ga qo ªshgandan so ªng <code>s2</code> dan foydalanish imkoniyatiga ega bo ªlishni xohlaymiz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;dastur&quot;);
    let s2 = &quot;chi&quot;;
    s1.push_str(s2);
    println!(&quot;s2 - {s2}&quot;);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-16: Tarkibni <code>String</code> ga qo'shgandan so'ng, string bo'lagidan foydalanish</span></p>
<p>Agar <code>push_str</code> metodi <code>s2</code> ga egalik qilgan bo‚Äòlsa, biz uning qiymatini oxirgi satrda chop eta olmaymiz. Biroq, bu kod biz kutgandek ishlaydi!</p>
<p><code>push</code> metodi parametr sifatida bitta belgini oladi va uni <code>String</code> ga qo'shadi. 8-17 ro'yxatda <code>push</code> metodi yordamida <code>String</code> ga <code>v</code> harfi qo'shiladi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;su&quot;);
    s.push('v');
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 8-17: <code>push</code> yordamida <code>String</code> qiymatiga bitta belgi qo ªshish</span></p>
<p>Natijada, <code>s</code> tarkibida <code>suv</code> bo'ladi.</p>
<h4 id="-operatori-yoki-format-makrosidan-foydalanib-satrlarni-birlashtirish"><a class="header" href="#-operatori-yoki-format-makrosidan-foydalanib-satrlarni-birlashtirish"><code>+</code> operatori yoki <code>format!</code> makrosidan foydalanib satrlarni birlashtirish</a></h4>
<p>Ko'pincha siz ikkita mavjud satrni birlashtirishni xohlaysiz. Buning usullaridan biri 8-18 ro'yxatda ko'rsatilganidek, <code>+</code> operatoridan foydalanishdir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Salom, &quot;);
    let s2 = String::from(&quot;Rust!&quot;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 8-18: Ikkita <code>String</code> qiymatini yangi <code>String</code> qiymatiga birlashtirish uchun <code>+</code> operatoridan foydalanish</span></p>
<p><code>s3</code> qatorida <code>Salom, Rust!</code> bo'ladi. Qo‚Äòshishdan keyin <code>s1</code> ning endi haqiqiy emasligi va <code>s2</code>ga referenceni qo‚Äòllaganimiz sababi <code>+</code> operatoridan foydalanganda chaqirilayotgan metodning imzosi bilan bog‚Äòliq.
<code>+</code> operatori <code>add</code> metodidan foydalanadi, uning imzosi quyidagicha ko'rinadi:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>Standart kutubxonada siz umumiy va tegishli turlar yordamida aniqlangan <code>add</code>ni ko'rasiz. Bu erda biz aniq turlarni almashtirdik, bu metodni <code>String</code> qiymatlari bilan chaqirganimizda sodir bo'ladi. Biz 10-bobda generiklarni muhokama qilamiz.
Ushbu imzo bizga <code>+</code> operatorining murakkab bitlarini tushunishimiz kerak bo'lgan maslahatlarni beradi.</p>
<p>Birinchidan, <code>s2</code> <code>&amp;</code> belgisiga ega, ya'ni biz birinchi satrga ikkinchi satrning <em>reference</em>ni qo'shmoqdamiz. Buning sababi <code>add</code> funksiyasidagi <code>s</code> parametri: biz faqat <code>String</code>ga <code>&amp;str</code> qo'shishimiz mumkin; biz ikkita <code>String</code> qiymatini qo'sha olmaymiz. Lekin kuting ‚Äì <code>&amp;s2</code> turi <code>add</code> uchun ikkinchi parametrda ko‚Äòrsatilganidek, <code>&amp;str</code> emas, <code>&amp;String</code>dir. Xo'sh, nima uchun 8-18 ro'yxatdagi kod kompilyatsiya bo'ladi?</p>
<p><code>add</code> chaqiruvida <code>&amp;s2</code> dan foydalanishimiz sababi shundaki, kompilyator <code>&amp;String</code> argumentini <code>&amp;str</code> ga <em>majburlashi(coerce)</em> mumkin. Biz <code>add</code> metodini chaqirganimizda Rust <em>deref coercion</em> dan foydalanadi, bu erda <code>&amp;s2</code> ni <code>&amp;s2[..]</code> ga aylantiradi.
Biz 15-bobda coercion haqida batafsilroq gaplashamiz. <code>add</code> <code>s</code> parametriga egalik qilmaganligi sababli, <code>s2</code> bu amaldan keyin ham haqiqiy <code>String</code> bo'lib qoladi.</p>
<p>Ikkinchidan, imzoda <code>add</code> <code>self</code> egalik qilishini ko'rishimiz mumkin, chunki <code>self</code>da <code>&amp;</code> <em>yo'q</em>. Bu shuni anglatadiki, 8-18-sonli ro'yxatdagi <code>s1</code> <code>add</code> chaqiruviga o'tkaziladi va bundan keyin endi yaroqsiz bo'ladi. Shunday qilib, <code>let s3 = s1 + &amp;s2;</code> har ikkala satrdan nusxa ko'chiradigan va yangisini yaratadiganga o'xshasa-da, bu statement aslida <code>s1</code>ga egalik qiladi va <code>s2</code> mazmunining nusxasini qo'shadi, va keyin natijaga egalik huquqini qaytaradi. Boshqacha qilib aytganda, u juda ko'p nusxa ko'chirayotganga o'xshaydi, lekin unday emas; implement qilish nusxalashdan ko'ra samaraliroq.</p>
<p>Agar biz bir nechta satrlarni birlashtirishimiz kerak bo'lsa, <code>+</code> operatorining xatti-harakati noqulay bo'ladi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>Bu vaqtda <code>s</code> <code>tic-tac-toe</code> bo'ladi. Barcha <code>+</code> va <code>&quot;</code> belgilar bilan nima sodir bo'layotganini ko'rish qiyin. Murakkab qatorlarni birlashtirish uchun biz <code>format!</code> makrosidan foydalanishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{s1}-{s2}-{s3}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Ushbu kod <code>s</code> ni <code>tic-tac-toe</code> ga ham o'rnatadi. <code>format!</code> makrosi <code>println!</code> kabi ishlaydi, lekin natijani ekranga chop etish o'rniga mazmuni bilan <code>String</code>ni qaytaradi. Kodning <code>format!</code> dan foydalanilgan versiyasini o‚Äòqish ancha oson va <code>format!</code> makrosi tomonidan yaratilgan kod bu chaqiruv uning parametrlaridan birortasiga egalik qilmasligi uchun havolalardan foydalanadi.</p>
<h3 id="stringlarni-indekslash"><a class="header" href="#stringlarni-indekslash">Stringlarni indekslash</a></h3>
<p>Ko'pgina boshqa dasturlash tillarida stringdagi alohida belgilarga indeks bo'yicha murojaat qilish orqali kirish to'g'ri va keng tarqalgan operatsiya hisoblanadi. Biroq, agar siz Rust-da indekslash sintaksisidan foydalanib, <code>String</code> qismlariga kirishga harakat qilsangiz, xatoga duch kelasiz. 8-19 ro'yxatdagi noto'g'ri kodni ko'rib chiqing.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;salom&quot;);
    let h = s1[0];
<span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 8-19: String bilan indekslash sintaksisidan foydalanishga urinish</span></p>
<p>Ushbu kod quyidagi xatoga olib keladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`
  = help: the following other types implement trait `Index&lt;Idx&gt;`:
            &lt;String as Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeFull&gt;&gt;
            &lt;String as Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeTo&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Xato va eslatma Rust indekslashni qo'llab-quvvatlamasligini aytadi. Lekin nega yo'q? Bu savolga javob berish uchun Rust stringlarni xotirada qanday saqlashini muhokama qilishimiz kerak.</p>
<h4 id="ichki-vakillik"><a class="header" href="#ichki-vakillik">Ichki vakillik</a></h4>
<p><code>String</code> turi - bu <code>Vec&lt;u8&gt;</code> turidagi wrapper. Keling, 8-14 ro'yxatdagi to'g'ri kodlangan UTF-8 misol stringlarini ko'rib chiqaylik. Birinchidan, bu:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
</span><span class="boring">    let hello = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let hello = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let hello = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let hello = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let hello = String::from(&quot;Ol√°&quot;);
</span><span class="boring">    let hello = String::from(&quot;Salom&quot;);
</span><span class="boring">    let hello = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>Bunday holda, <code>len</code> 4 bo'ladi, ya'ni &quot;Hola&quot; qatorini saqlaydigan vektor 4 bayt uzunlikda. Bu harflarning har biri UTF-8 da kodlanganda 1 baytni oladi. Biroq, keyingi qator sizni hayratda qoldirishi mumkin. (E'tibor bering, bu qator arabcha 3 raqami emas, kirill alifbosining bosh harfi Ze bilan boshlanadi.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobr√Ω den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;);
</span><span class="boring">    let hello = String::from(&quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;);
</span><span class="boring">    let hello = String::from(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;);
</span><span class="boring">    let hello = String::from(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
</span><span class="boring">    let hello = String::from(&quot;‰Ω†Â•Ω&quot;);
</span><span class="boring">    let hello = String::from(&quot;Ol√°&quot;);
</span><span class="boring">    let hello = String::from(&quot;Salom&quot;);
</span><span class="boring">    let hello = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>String uzunligi so'ralganda, siz 12 deb aytishingiz mumkin. Aslida, Rustning javobi 24: bu UTF 8 da ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äù ni kodlash uchun zarur bo'lgan baytlar soni, chunki bu satrdagi har bir Unicode skalyar qiymati 2 bayt xotirani oladi. Shuning uchun, satr baytlaridagi indeks har doim ham haqiqiy Unicode skalyar qiymatiga mos kelmaydi. Namoyish qilish uchun ushbu yaroqsiz Rust kodini ko'rib chiqing:</p>
<pre><code class="language-rust ignore does_not_compile">let salom = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let javob = &amp;salom[0];</code></pre>
<p>Siz allaqachon bilasizki, <code>javob</code> birinchi harf bo'lgan <code>–ó</code> bo'lmaydi. UTF-8 da kodlanganda, <code>–ó</code> birinchi bayti <code>208</code>, ikkinchisi esa <code>151</code>, shuning uchun <code>javob</code> aslida <code>208</code> bo'lishi kerakdek tuyuladi, lekin <code>208</code> o'z-o'zidan haqiqiy belgi emas. Agar foydalanuvchi ushbu qatorning birinchi harfini so'ragan bo'lsa, <code>208</code> ni qaytarish, ehtimol bu emas; ammo, bu Rust bayt indeksi 0 bo'lgan yagona ma'lumotdir. Foydalanuvchilar odatda bayt qiymatini qaytarishni xohlamaydilar, hatto satrda faqat lotin harflari bo‚Äòlsa ham: agar <code>&amp;‚Äúhello‚Äù[0]</code> bayt qiymatini qaytaruvchi yaroqli kod bo‚Äòlsa, u <code>h</code> emas, <code>104</code>ni qaytaradi. .</p>
<p>Javob shundaki, kutilmagan qiymatni qaytarmaslik va darhol topilmasligi mumkin bo'lgan xatolarni keltirib chiqarmaslik uchun Rust ushbu kodni umuman kompilyatsiya qilmaydi va ishlab chiqish jarayonida tushunmovchiliklarning oldini oladi.</p>
<h4 id="baytlar-va-skalyar-qiymatlar-va-grafema-klasterlari"><a class="header" href="#baytlar-va-skalyar-qiymatlar-va-grafema-klasterlari">Baytlar va skalyar qiymatlar va grafema klasterlari!</a></h4>
<p>UTF-8 bilan bog'liq yana bir nuqta shundaki, Rust nuqtai nazaridan satrlarga qarashning uchta mos usuli mavjud: baytlar, skalyar qiymatlar va grafema klasterlari (biz <em>harflar</em> deb ataydigan narsaga eng yaqin narsa).</p>
<p>Devanagari skriptida yozilgan hindcha ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù so'ziga qarasak, u <code>u8</code> qiymatlari vektori sifatida saqlanadi, bu quyidagicha ko'rinadi:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Bu 18 bayt va kompyuterlar oxir-oqibat bu ma'lumotlarni qanday saqlaydi. Agar biz ularni Rustning <code>char</code> turiga ega bo'lgan Unicode skalyar qiymatlari sifatida qarasak, bu baytlar quyidagicha ko'rinadi:</p>
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<p>Bu yerda oltita <code>char</code> qiymati bor, lekin to'rtinchi va oltinchi harflar emas: ular o'z-o'zidan ma'noga ega bo'lmagan diakritikdir. Nihoyat, agar baytlarni grafema klasterlari sifatida ko'rib chiqsak, inson to'rt harfli hindcha so'z deb ataydigan narsani olamiz:</p>
<pre><code class="language-text">[&quot;‡§®&quot;, &quot;‡§Æ&quot;, &quot;‡§∏‡•ç&quot;, &quot;‡§§‡•á&quot;]
</code></pre>
<p>Rust kompyuterlar saqlaydigan ma'lumotlar qatorini talqin qilishning turli usullarini taqdim etadi, shunda ma'lumotlar qaysi inson tilida bo'lishidan qat'i nazar, har bir dastur kerakli talqinni tanlashi mumkin.</p>
<p>Rust bizga belgini olish uchun <code>String</code> ga indekslashga ruxsat bermasligining yakuniy sababi shundaki, indekslash operatsiyalari doimo konstanta(doimiy) vaqtni oladi (O(1)). Ammo <code>Strin</code>g bilan ishlashni kafolatlab bo‚Äòlmaydi, chunki Rust qancha to‚Äòg‚Äòri belgilar mavjudligini aniqlash uchun tarkibni boshidan indeksgacha bosib o‚Äòtishi kerak edi.</p>
<h3 id="string-bolaklari"><a class="header" href="#string-bolaklari">String bo'laklari</a></h3>
<p>Satrni indekslash ko'pincha noto'g'ri fikrdir, chunki satrni indekslash operatsiyasining qaytish turi qanday bo'lishi kerakligi aniq emas: bayt qiymati, belgi, grafema klasteri yoki satr bo'lagi. Agar chindan ham string bo'laklarini yaratish uchun indekslardan foydalanish kerak bo'lsa, Rust sizdan aniqroq bo'lishingizni so'raydi.</p>
<p>Bitta raqam bilan <code>[]</code> yordamida indeksatsiya qilish o'rniga, muayyan baytlarni o'z ichiga olgan string bo'laklarini yaratish uchun diapazon bilan <code>[]</code> dan foydalanishingiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let salom = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;

let s = &amp;salom[0..4];
<span class="boring">}</span></code></pre></pre>
<p>Bu erda <code>s</code> qatorning dastlabki 4 baytini o'z ichiga olgan <code>&amp;str</code> bo'ladi.
Avvalroq, biz ushbu belgilarning har biri 2 baytdan iborat bo'lganligini aytib o'tgan edik, ya'ni <code>s</code> <code>–ó–¥</code> bo'ladi.</p>
<p>Agar biz <code>&amp;salom[0..1]</code> kabi belgi baytlarining faqat bir qismini kesishga harakat qilsak, Rust ish runtimeda xuddi vektordagi yaroqsiz indeksga kirish kabi panic qo'yadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside '–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ehtiyotkorlik bilan string bo'laklarni yaratish uchun diapazonlardan foydalanishingiz kerak, chunki bu dasturni buzishi mumkin.</p>
<h3 id="stringlarni-takrorlash-usullari"><a class="header" href="#stringlarni-takrorlash-usullari">Stringlarni takrorlash usullari</a></h3>
<p>String bo'laklari bilan ishlashning eng yaxshi usuli - belgilar yoki baytlarni xohlaysizmi, aniq bo'lishdir. Unicode skalyar qiymatlari uchun <code>chars</code> metodidan foydalaning. ‚Äú–ó–¥‚Äù da <code>chars</code>ni chaqirish <code>char</code> turidagi ikkita qiymatni ajratib turadi va qaytaradi va har bir elementga kirish uchun natijani takrorlashingiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;–ó–¥&quot;.chars() {
    println!(&quot;{c}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Ushbu kod quyidagilarni chop etadi:</p>
<pre><code class="language-text">–ó
–¥
</code></pre>
<p>Shu bilan bir qatorda, <code>bytes</code> metodi boshqa domenga mos kelishi mumkin bo'lgan har bir baytni qaytaradi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;–ó–¥&quot;.bytes() {
    println!(&quot;{b}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Ushbu kod ushbu satrni tashkil etuvchi to'rt baytni chop etadi:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Lekin esda tutingki, joriy Unicode skalyar qiymatlari 1 baytdan ortiq bo'lishi mumkin.</p>
<p>Devanagari skriptidagi kabi satrlardan grafema klasterlarini olish juda murakkab, shuning uchun bu funksiya standart kutubxona tomonidan ta'minlanmagan. Agar sizga ushbu funksiya kerak bo'lsa, <a href="https://crates.io/">crates.io</a><!-- ignore --> saytida cratelar mavjud.</p>
<h3 id="stringlar-unchalik-oddiy-emas"><a class="header" href="#stringlar-unchalik-oddiy-emas">Stringlar unchalik oddiy emas</a></h3>
<p>Xulosa qilib aytganda, satrlar murakkab. Turli xil dasturlash tillari ushbu murakkablikni dasturchiga qanday taqdim etish bo'yicha turli xil tanlovlar qiladi. Rust <code>String</code> ma'lumotlarini to'g'ri ishlashni barcha Rust dasturlari uchun standart xatti-harakatga aylantirishni tanladi, bu esa dasturchilar UTF-8 ma'lumotlari bilan ishlash haqida oldindan ko'proq o'ylashlari kerakligini anglatadi. Ushbu o'zaro kelishuv boshqa dasturlash tillarida ko'rinadiganidan ko'ra ko'proq stringlarning murakkabligini ochib beradi, lekin keyinchalik ishlab chiqish jarayonida paydo bo'lishi mumkin bo'lgan ASCII bo'lmagan belgilar xatolarini qayta ishlash zaruratini oldini oladi.</p>
<p>Yaxshi xabar shundaki, standart kutubxona ushbu murakkab vaziyatlarni to'g'ri hal qilishga yordam beradigan <code>String</code> va <code>&amp;str</code> turlaridan iborat ko'plab funksiyalarni taklif etadi. Satrda qidirish uchun <code>contains</code> va qator qismlarini boshqa satr bilan almashtirish uchun <code>replace</code> kabi foydali metodlar uchun texnik hujjatlarni ko'rib chiqing.</p>
<p>Keling, biroz murakkabroq narsaga o'taylik: HashMap!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hash-maplarda-boglangan-qiymatlarga-ega-kalitlarni-saqlash"><a class="header" href="#hash-maplarda-boglangan-qiymatlarga-ega-kalitlarni-saqlash">Hash Maplarda bog'langan qiymatlarga ega kalitlarni saqlash</a></h2>
<p>Umumiy to'plamlarimizning oxirgisi <em>hash map</em>. <code>HashMap&lt;K, V&gt;</code> turi <code>K</code> turidagi kalitlarning <code>V</code> turidagi qiymatlarga xaritasini <em>xeshlash funksiyasi</em> yordamida saqlaydi, bu kalit va qiymatlarni xotiraga qanday joylashtirishini belgilaydi. Ko'pgina dasturlash tillari bunday ma'lumotlar strukturasini qo'llab-quvvatlaydi, lekin ular ko'pincha bir nechtasini nomlash uchun hash, map, object, hash table, dictionary, yoki associative array kabi boshqa nomlardan foydalanadilar.</p>
<p>Hash maplar ma'lumotlarni vectorlar bilan bo'lgani kabi indeks yordamida emas, balki har qanday turdagi kalit yordamida qidirmoqchi bo'lsangiz foydali bo'ladi. Misol uchun, o'yinda siz har bir jamoaning balini hesh-mapda kuzatib borishingiz mumkin, unda har bir kalit jamoaning nomi va qiymatlar har bir jamoaning ballidir. Jamoa nomi berilgan bo'lsa, siz uning ballini olishingiz mumkin.</p>
<p>Ushbu bo'limda biz hesh-mapllarining asosiy API-ni ko'rib chiqamiz, ammo yana ko'plab foydali funksiyalar standart kutubxona tomonidan <code>HashMap&lt;K, V&gt;</code> da belgilangan funksiyalarda yashiringan.
Har doimgidek, qo'shimcha ma'lumot olish uchun standart kutubxona texnik hujjatlarini tekshiring.</p>
<h3 id="yangi-hash-map-yaratish"><a class="header" href="#yangi-hash-map-yaratish">Yangi Hash Map yaratish</a></h3>
<p>Bo'sh hesh mapni yaratishning bir usuli - <code>new</code> dan foydalanish va <code>insert</code> bilan elementlarni qo'shish. 8-20 ro'yxatda biz nomlari <em>Yashil</em> va <em>Sariq</em> bo'lgan ikkita jamoaning ballarini kuzatib boramiz. Yashil jamoa 10 ball bilan, Sariq jamoa esa 50 ball bilan boshlanadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut ballar = HashMap::new();

    ballar.insert(String::from(&quot;Yashil&quot;), 10);
    ballar.insert(String::from(&quot;Sariq&quot;), 50);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-20: Yangi hesh mapni yaratish va ba'zi kalitlar va qiymatlarni kiritish</span></p>
<p>E'tibor bering, biz birinchi navbatda standart kutubxonaning to'plamlar qismidagi <code>HashMap</code> dan foydalanishimiz kerak. Bu quyidagicha bo'ladi <code>use std::collections::HashMap;</code>. Bizning uchta keng tarqalgan to'plamlarimiz orasida bu eng kam qo'llaniladi, shuning uchun u muqaddimada avtomatik ravishda kiritilgan funtsiyalarga kiritilmagan. Hash Maplar standart kutubxonadan ham kamroq qo'llab-quvvatlanadi; masalan, ularni yaratish uchun o'rnatilgan makros mavjud emas.</p>
<p>Vectorlar singari, hash maplar ham o'z ma'lumotlarini heapda saqlaydi. Ushbu <code>HashMap</code>da <code>String</code> turidagi kalitlar va <code>i32</code> turidagi qiymatlar mavjud. Vectorlar singari, hash maplar ham bir xildir: barcha kalitlar bir-biri bilan bir xil turdagi va barcha qiymatlar bir xil turga ega bo'lishi kerak.</p>
<h3 id="hashmap-dagi-malumotlarga-kirish"><a class="header" href="#hashmap-dagi-malumotlarga-kirish">HashMap-dagi ma'lumotlarga kirish</a></h3>
<p>Biz 8-21 ro'yxatda ko'rsatilganidek, <code>get</code> metodiga kalitni taqdim etish orqali hash mapdan qiymat olishimiz mumkin.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut ballar = HashMap::new();

    ballar.insert(String::from(&quot;Yashil&quot;), 10);
    ballar.insert(String::from(&quot;Sariq&quot;), 50);

    let jamoa_nomi = String::from(&quot;Yashil&quot;);
    let ball = ballar.get(&amp;jamoa_nomi).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-21: Hesh-Mapda saqlangan Yashil jamoa hisobiga kirish</span></p>
<p>Bu yerda <code>ball</code> Yashil jamoa bilan bog'liq qiymatga ega bo'ladi va natija <code>10</code> bo'ladi. <code>get</code> metodi <code>Option&lt;&amp;V&gt;</code>ni qaytaradi; agar hesh-mapda ushbu kalit uchun qiymat bo'lmasa, <code>get</code> <code>None</code> ni qaytaradi. Bu dastur <code>Option&lt;&amp;i32&gt;</code> emas, <code>Option&lt;i32&gt;</code> olish uchun <code>copied</code> ga murojaat qilib <code>Option</code>ni boshqaradi, so'ngra <code>unwrap_or</code> <code>ballar</code> da ushbu kalit uchun ma'lumotlar bo'lmasa, ballni nolga o'rnatish uchun.</p>
<p>Biz hesh-mapdagi har bir kalit/qiymat juftligini vectorlar bilan bo'lgani kabi, <code>for</code> siklidan foydalangan holda takrorlashimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut ballar = HashMap::new();

    ballar.insert(String::from(&quot;Yashil&quot;), 10);
    ballar.insert(String::from(&quot;Sariq&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{key}: {value}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p>Ushbu kod har bir juftlikni tasodifiy tartibda chop etadi:</p>
<pre><code class="language-text">Sariq: 50
Yashil: 10
</code></pre>
<h3 id="hash-maplar-va-ownershipegalik"><a class="header" href="#hash-maplar-va-ownershipegalik">Hash Maplar va Ownership(Egalik)</a></h3>
<p><code>Copy</code> traitini amalga oshiradigan turlar uchun, masalan, <code>i32</code>, qiymatlar hesh-mapiga ko'chiriladi. <code>String</code> kabi tegishli qiymatlar uchun qiymatlar boshqa joyga ko ªchiriladi va 8-22 ro ªyxatda ko ªrsatilganidek, hesh-map ushbu qiymatlarning egasi bo ªladi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let maydon_nomi = String::from(&quot;Sevimli rang&quot;);
    let maydon_qiymati = String::from(&quot;Yashil&quot;);

    let mut map = HashMap::new();
    map.insert(maydon_nomi, maydon_qiymati);
    // maydon_nomi va maydon_qiymati hozirda yaroqsiz, ulardan foydalanib ko'ring va qanday
    // kompilyator xatosiga yo'l qo'yganingizni ko'ring!
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-22: kalitlar va qiymatlar kiritilgandan so'ng ular hesh-mapda tegishli ekanligini ko'rsatish</span></p>
<p><code>maydon_nomi</code> va <code>maydon_qiymati</code> o'zgaruvchilari qiymatlari <code>insert</code> metodini chaqirish orqali HashMap-ga ko'chirilgandan keyin foydalana olmaymiz.</p>
<p>Agar biz HashMap-ga qiymatlarga referencelar kiritsak, ular HashMap-ga ko'chirilmaydi. Murojaatlar ko'rsatadigan qiymatlar hech bo'lmaganda hesh-mapda amal qiladigan vaqt davomida amal qilishi kerak. Biz ushbu muammolar haqida 10-bobning <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">&quot;Lifetime bilan referencelarni tekshirish&quot;</a><!-- ignore --> bo'limida ko'proq gaplashamiz.</p>
<h3 id="hash-mapni-yangilash"><a class="header" href="#hash-mapni-yangilash">Hash Mapni yangilash</a></h3>
<p>Kalit va qiymat juftlarining soni o'sishi mumkin bo'lsa-da, har bir noyob kalit bir vaqtning o'zida u bilan bog'langan faqat bitta qiymatga ega bo'lishi mumkin (lekin aksincha emas: masalan, Yashil jamoa ham, Sariq jamoa ham <code>ballar</code> hash-mapida saqlangan 10 qiymatiga ega bo'lishi mumkin).</p>
<p>Hash-mapdagi ma'lumotlarni o'zgartirmoqchi bo'lganingizda, kalit allaqachon tayinlangan qiymatga ega bo'lgan holatda qanday ishlashni hal qilishingiz kerak. Eski qiymatni butunlay e'tiborsiz qoldirib, eski qiymatni yangi qiymat bilan almashtirishingiz mumkin. Eski qiymatni saqlab qolishingiz va yangi qiymatni e'tiborsiz qoldirishingiz mumkin, faqat kalitda <em>qiymat bo'lmasa</em>, yangi qiymat qo'shishingiz mumkin. Yoki eski qiymat va yangi qiymatni birlashtira olasiz. Keling, bularning har birini qanday qilishni ko'rib chiqaylik!</p>
<h4 id="qiymatni-qayta-yozish"><a class="header" href="#qiymatni-qayta-yozish">Qiymatni qayta yozish</a></h4>
<p>Agar biz kalit va qiymatni hash-mapga kiritsak va keyin boshqa qiymat bilan bir xil kalitni kiritsak, bu kalit bilan bog'langan qiymat almashtiriladi. Ro'yxat 8-23dagi kod ikki marta <code>insert</code> ni chaqirsa ham, hash-mapda faqat bitta kalit/qiymat juftligi bo'ladi, chunki biz har ikki marta Yashil jamoa kaliti qiymatini kiritamiz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut ballar = HashMap::new();

    ballar.insert(String::from(&quot;Yashil&quot;), 10);
    ballar.insert(String::from(&quot;Yashil&quot;), 25);

    println!(&quot;{:?}&quot;, ballar);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-23: Saqlangan qiymatni ma'lum bir kalit bilan almashtirish</span></p>
<p>Bu kod <code>{&quot;Yashil&quot;: 25}</code>ni chop etadi. <code>10</code>ning asl qiymati ustiga yozildi.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="kalit-va-qiymatni-faqat-kalit-mavjud-bolmaganda-qoshish"><a class="header" href="#kalit-va-qiymatni-faqat-kalit-mavjud-bolmaganda-qoshish">Kalit va qiymatni faqat kalit mavjud bo'lmaganda qo'shish</a></h4>
<p>Hash Mapda ma'lum bir kalit allaqachon qiymatga ega yoki yo'qligini tekshirish odatiy holdir, keyin quyidagi amallarni bajaring: agar kalit hash-mapda mavjud bo'lsa, mavjud qiymat avvalgidek qolishi kerak. Agar kalit mavjud bo'lmasa, insert va uning qiymatini kiriting.</p>
<p>Hash Mapda buning uchun <code>entry</code> deb nomlangan maxsus API mavjud bo'lib, siz tekshirmoqchi bo'lgan kalitni parametr sifatida qabul qiladi. <code>entry</code> metodining qaytish qiymati <code>Entry</code> nomli enum bo‚Äòlib, u mavjud yoki bo‚Äòlmasligi mumkin bo‚Äòlgan qiymatni ifodalaydi. Aytaylik, biz Sariq jamoa uchun kalitning u bilan bog'liq qiymati bor-yo'qligini tekshirmoqchimiz. Agar shunday bo'lmasa, biz 50 qiymatini qo'shishni xohlaymiz va Yashil jamoa uchun ham xuddi shunday. <code>Entry</code> API-dan foydalanib, kod Ro'yxat 8-24 kabi ko'rinadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut ballar = HashMap::new();
    ballar.insert(String::from(&quot;Yashil&quot;), 10);

    ballar.entry(String::from(&quot;Sariq&quot;)).or_insert(50);
    ballar.entry(String::from(&quot;Yashil&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, ballar);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-24: <code>entry</code> metodidan faqat kalitda qiymat mavjud bo'lmasa, kiritish uchun foydalanish</span></p>
<p><code>Entry</code> da <code>or_insert</code> metodi mos keladigan <code>Entry</code> kaliti qiymatiga o'zgaruvchan referenceni qaytarish uchun belgilangan, agar bu kalit mavjud bo'lsa,  parametrni ushbu kalit uchun yangi qiymat sifatida kiritadi va yangi qiymatga o'zgaruvchan referenceni qaytaradi. Ushbu metod mantiqni o'zingiz yozishdan ko'ra ancha toza va u xavfsizroq va borrowing qoidalariga mos keladi.</p>
<p>8-24-raqamdagi kodni ishga tushirish <code>{&quot;Sariq&quot;: 50, &quot;Yashil&quot;: 10}</code> chop etiladi. <code>entry</code> ga birinchi chaqiruv 50 qiymatiga ega Sariq jamoa uchun kalitni kiritadi, chunki sariq jamoada allaqachon qiymat yo'q.  <code>entry</code> ga ikkinchi chaqiruv hash-mapni o'zgartirmaydi, chunki Yashil jamoa allaqachon 10 qiymatiga ega.</p>
<h4 id="eski-qiymat-asosida-yangi-qiymatni-yangilash"><a class="header" href="#eski-qiymat-asosida-yangi-qiymatni-yangilash">Eski qiymat asosida yangi qiymatni yangilash</a></h4>
<p>Hash-Maplar uchun yana bir keng tarqalgan foydalanish holati kalit qiymatini izlash va keyin uni eski qiymat asosida yangilashdir. Misol uchun, 8-25 ro'yxatda har bir so'z ba'zi matnda necha marta takrorlanganini hisoblaydigan kodni ko'rsatadi. Biz kalit sifatida so'zlar bilan hash-mapdan foydalanamiz va bu so'zni necha marta ko'rganimizni kuzatib borish uchun qiymatni oshiramiz. Agar so'zni birinchi marta ko'rayotgan bo'lsak, avval 0 qiymatini kiritamiz.</p>
<pre><pre class="playground"><code class="language-rustword"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let matn = &quot;salom rust qiziqarli rust&quot;;

    let mut map = HashMap::new();

    for soz in matn.split_whitespace() {
        let hisoblash = map.entry(soz).or_insert(0);
        *hisoblash += 1;
    }

    println!(&quot;{:?}&quot;, map);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 8-25: So'zlar va hisoblarni saqlaydigan hash-mapi yordamida so'zlarning necha marta takrorlanganini hisoblash</span></p>
<p>Bu kod <code>{&quot;qiziqarli&quot;: 1, &quot;salom&quot;: 1, &quot;rust&quot;: 2}</code>ni chop etadi. Siz boshqa tartibda chop etilgan bir xil kalit/qiymat juftliklarini ko'rishingiz mumkin: <a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">‚ÄúHash-Mapdagi qiymatlarga kirish‚Äù</a><!-- ignore --> bo'limidan hash-mapni takrorlash ixtiyoriy tartibda sodir bo'lishini eslang.</p>
<p><code>split_whitespace</code> metodi <code>matn</code> qiymatining bo'sh joy bilan ajratilgan pastki bo'limlari ustidan iteratorni qaytaradi.<code>or_insert</code> metodi belgilangan kalit qiymatiga o'zgaruvchan havolani (<code>&amp;mut V</code>) qaytaradi. Bu yerda biz o'zgaruvchan referenceni <code>hisoblash</code> o'zgaruvchisida saqlaymiz, shuning uchun bu qiymatni belgilash uchun avval yulduzcha (<code>*</code>) yordamida <code>hisoblash</code> ga murojaat qilishimiz kerak. O'zgaruvchan reference <code>for</code> siklining oxirida ko'lamdan chiqib ketadi, shuning uchun bu o'zgarishlarning barchasi xavfsiz va borrowing qoidalari bilan ruxsat etiladi.</p>
<h3 id="hashing-funksiyalari"><a class="header" href="#hashing-funksiyalari">Hashing funksiyalari</a></h3>
<p>Odatda, <code>HashMap</code> <em>SipHash</em> nomli hashlash funksiyasidan foydalanadi, u <sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore --> hash-jadvallari ishtirokidagi Xizmatni rad etish (DoS) hujumlariga qarshilik ko'rsatishi mumkin. Bu mavjud bo'lgan eng tezkor hashlash algoritmi emas, lekin ishlashning pasayishi bilan birga keladigan yaxshi xavfsizlik uchun kelishuv bunga arziydi. Agar siz kodingizni profilga kiritsangiz va standart hash funksiyasi sizning maqsadlaringiz uchun juda sekin ekanligini aniqlasangiz, boshqa hasherni belgilash orqali boshqa funksiyaga o'tishingiz mumkin. <em>hasher</em> bu <code>BuildHasher</code> traitini amalga oshiradigan tur. Traitlar va ularni qanday implement qilish haqida 10-bobda gaplashamiz. Siz o'zingizning hasheringizni noldan implement qilishingiz shart emas; <a href="https://crates.io/">crates.io</a><!-- ignore -->-da boshqa Rust foydalanuvchilari tomonidan baham ko'rilgan kutubxonalar mavjud bo'lib, ular ko'plab umumiy hashlash algoritmlarini implement qiladigan hasherlarni ta'minlaydi.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="xulosa-7"><a class="header" href="#xulosa-7">Xulosa</a></h2>
<p>Vectorlar, stringlar va hash-maplar ma'lumotlarni saqlash, kirish va o'zgartirish kerak bo'lganda dasturlarda zarur bo'lgan katta hajmdagi funksionallikni ta'minlaydi. Mana endi hal qilish uchun tayyorlanishingiz kerak bo'lgan ba'zi mashqlar:</p>
<ul>
<li>
<p>Butun sonlar ro ªyxati berilgan bo ªlsa, vectordan foydalaning va ro ªyxatning medianasini (tartiblanganda, o ªrtadagi qiymat) va  rejimni (ko ªpincha sodir bo ªladigan qiymat; bu yerda hash-map foydali bo ªladi) qaytaring.</p>
</li>
<li>
<p>Satrlarni pig lotin tiliga aylantiring. Har bir so'zning birinchi undoshi so'z oxiriga ko'chiriladi va &quot;ay&quot; qo'shiladi, shuning uchun &quot;birinchi&quot; &quot;birinchi-ay&quot; bo'ladi. Unli tovush bilan boshlangan so‚Äòzlarning oxiriga ‚Äúhay‚Äù qo‚Äòshiladi (‚Äúolma‚Äù ‚Äúolma-hay‚Äùga aylanadi). UTF-8 kodlash haqidagi tafsilotlarni yodda tuting!</p>
</li>
<li>
<p>Hash Map va vectorlardan foydalanib, foydalanuvchiga kompaniyadagi bo'limga xodimlarning ismlarini qo'shishga ruxsat berish uchun matn interfeysini yarating. Masalan, &quot;Asilbekni muhandislikka qo'shish&quot; yoki &quot;Sardorni savdoga qo'shish&quot;. Keyin foydalanuvchi bo'limdagi barcha odamlar yoki kompaniyadagi barcha odamlar ro'yxatini bo'limlar bo'yicha, alifbo tartibida tartiblangan holda olishiga ruxsat bering.</p>
</li>
</ul>
<p>Standart kutubxona API texnik hujjatlari vectorlar, stringlar va hash-maplarda ushbu mashqlar uchun foydali bo'lgan usullarni tavsiflaydi!</p>
<p>Biz operatsiyalar muvaffaqiyatsiz bo'lishi mumkin bo'lgan yanada murakkab dasturlarga kirishmoqdamiz, shuning uchun xatolarni hal qilishni muhokama qilish uchun ajoyib vaqt. Qani kettik.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xatolar-bilan-ishlash"><a class="header" href="#xatolar-bilan-ishlash">Xatolar bilan ishlash</a></h1>
<p>Xatolar dasturiy ta'minotdagi hayot haqiqatidir, shuning uchun Rust nimadir noto'g'ri bo'lgan vaziyatlarni hal qilish uchun bir qator xususiyatlarga ega. Ko'p hollarda Rust sizdan xatolik ehtimolini tan olishingizni va kodingizni kompilyatsiya qilishdan oldin ba'zi choralarni ko'rishingizni talab qiladi. Ushbu talab sizning kodingizni ishlab chiqarishga joylashtirishdan oldin xatolarni aniqlashingiz va ularni to'g'ri hal qilishingizni ta'minlash orqali dasturingizni yanada mustahkam qiladi!</p>
<p>Rust xatolarni ikkita asosiy toifaga ajratadi: <em>tiklash mumkin</em> va <em>tiklab bo‚Äòlmaydigan</em> xatolar. <em>file not found (fayl topilmadi)</em> xatosi kabi tiklanadigan xatolik uchun biz muammo haqida foydalanuvchiga xabar berishni va operatsiyani qaytadan urinib ko'rishni xohlaymiz.
Qayta tiklanmaydigan xatolar har doim xato belgilaridir, masalan, array oxiridan tashqaridagi joyga kirishga urinish va shuning uchun biz dasturni darhol to'xtatmoqchimiz.</p>
<p>Aksariyat tillar bu ikki turdagi xatolarni farqlamaydi va istisnolar(exceptions) kabi mexanizmlardan foydalangan holda ikkalasini ham xuddi shunday hal qiladi. Rustda istisnolar yo'q. Buning o'rniga, u tiklanadigan xatolar uchun <code>Result&lt;T, E&gt;</code> turiga va dastur tuzatib bo'lmaydigan xatolikka duch kelganda jarayonni to'xtatuvchi <code>panic!</code> makrosiga ega. Bu bob avval <code>panic!</code> chaqirish haqida so'z boradi, so ªngra <code>Result&lt;T, E&gt;</code> qiymatlarini qaytarish haqida so'z boradi. Bundan tashqari, biz xatolikdan xalos bo'lish yoki bajarishni to'xtatish haqida qaror qabul qilishda fikrlarni o'rganamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-bilan-tuzatib-bolmaydigan-xatolar"><a class="header" href="#panic-bilan-tuzatib-bolmaydigan-xatolar"><code>panic!</code> bilan tuzatib bo'lmaydigan xatolar</a></h2>
<p>Ba'zida sizning kodingizda yomon narsalar sodir bo'ladi va siz bu haqda hech narsa qila olmaysiz. Bunday hollarda Rustda <code>panic!</code> makrosi mavjud. Amalda panic chaqirishning ikki yo'li mavjud: kodimizni panic chiqaradigan harakatni amalga oshirish (masalan, arrayning oxiridan o'tib kirish) yoki aniq <code>panic!</code> makrosini chaqirish.
Ikkala holatda ham biz dasturimizda panicni keltirib chiqaramiz. Odatiy bo'lib, bu panic muvaffaqiyatsizlik xabarini chop etadi, dasturni bajarish paytida ajratilgan resurslarni tozalaydi, stackni tozalaydi va ishdan chiqadi. Atrof-muhit o'zgaruvchisi orqali siz panic paydo bo'lganda panic manbasini kuzatishni osonlashtirish uchun Rust chaqiruvlar srackini ko'rsatishi ham mumkin.</p>
<blockquote>
<h3 id="panicga-javoban-stackni-boshatish-yoki-bekor-qilish"><a class="header" href="#panicga-javoban-stackni-boshatish-yoki-bekor-qilish">panicga javoban stackni bo'shatish yoki bekor qilish</a></h3>
<p>Odatiy bo'lib, panic paydo bo'lganda, dastur o'chiriladi, ya'ni Rust
stekni zaxiraga olib chiqadi va duch kelgan har bir funksiyadan ma'lumotlarni
tozalaydi. Biroq, bu orqaga qaytish va tozalash juda ko'p ishdir. Rust,
shuning uchun dasturni tozalamasdan tugatadigan darhol bekor
qilishning muqobilini tanlashga imkon beradi.</p>
<p>Dastur ishlatgan xotira keyinchalik operatsion tizim tomonidan
tozalanishi kerak bo'ladi. Agar loyihangizda natijada olingan binary faylni
iloji boricha kichikroq qilishingiz kerak bo'lsa, <em>Cargo.toml</em> faylingizdagi
tegishli <code>[profile]</code> bo'limlariga <code>panic = 'abort'</code> qo'shish orqali panic
bo'yicha bo'shatishdan bekor qilishga o'tishingiz mumkin. Misol uchun, agar siz
bo'shatish rejimida panic holatini to'xtatmoqchi bo'lsangiz, quyidagilarni qo'shing:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Keling, oddiy dasturda <code>panic!</code> deb chaqirib ko'raylik:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;halokatli xato&quot;);
}</code></pre></pre>
<p>Dasturni ishga tushirganingizda, siz shunga o'xshash narsani ko'rasiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'halokatli xato', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>panic!</code> chaqiruvi oxirgi ikki qatordagi xato xabarini keltirib chiqaradi.
Birinchi qatorda panic haqidagi xabarimiz va manba kodimizdagi panic sodir bo'lgan joy ko'rsatilgan: <em>src/main.rs:2:5</em> bu bizning <em>src/main.rs</em> faylimizning ikkinchi qatori, beshinchi belgisi ekanligini bildiradi.</p>
<p>Bunday holda, ko'rsatilgan qator bizning kodimizning bir qismidir va agar biz ushbu qatorga o'tsak, biz <code>panic!</code> makro chaqiruvini ko'ramiz. Boshqa hollarda, <code>panic!</code> chaqiruvi bizning kodimiz chaqiradigan kodda bo'lishi mumkin, va xato xabari tomonidan bildirilgan fayl nomi va satr raqami boshqa birovning kodi bo'ladi, bu yerda <code>panic!</code> makro chaqiriladi, kodimizning oxir-oqibat <code>panic!</code> chaqiruviga olib kelgan qatori emas. Kodimizning muammoga sabab bo'lgan qismini aniqlash uchun <code>panic!</code> chaqiruvidan kelgan funksiyalarning backtracedan foydalanishimiz mumkin. Keyinchalik orqaga qaytish(backtraces) haqida batafsilroq gaplashamiz.</p>
<h3 id="panic-backtracedan-foydalanish"><a class="header" href="#panic-backtracedan-foydalanish"><code>panic!</code> Backtracedan foydalanish</a></h3>
<p>Yana bir misolni ko‚Äòrib chiqaylik, <code>panic!</code> chaqiruvi to‚Äòg‚Äòridan-to‚Äòg‚Äòri makroni chaqiruvchi kodimizdan emas, balki kodimizdagi xato tufayli kutubxonadan kelganida qanday bo‚Äòlishini ko‚Äòraylik. 9-1 ro'yxatida joriy indekslar doirasidan tashqarida vectordagi indeksga kirishga harakat qiladigan ba'zi kodlar mavjud.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 9-1: Vector oxiridan tashqaridagi elementga kirishga urinish, bu esa <code>panic!</code> chaqiruviga sabab bo ªladi.</span></p>
<p>Bu erda biz vectorimizning 100-elementiga kirishga harakat qilyapmiz (bu indeks 99-da, chunki indekslash noldan boshlanadi), lekin vectorda faqat 3 ta element mavjud.
Bunday vaziyatda Rust panic qo'yadi. <code>[]</code> dan foydalanish elementni qaytarishi kerak, lekin siz noto'g'ri indeksni o'tkazyapsiz: Rust qaytara oladigan element yo'q.</p>
<p>C tilida ma'lumotlar strukturasining oxiridan tashqarida o'qishga urinish aniqlanmagan xatti-harakatlardir. Siz xotirada ma'lumotlar strukturasidagi ushbu elementga mos keladigan har qanday joyni olishingiz mumkin, garchi xotira ushbu tuzilishga tegishli bo'lmasa ham. Bu <em>buffer overread</em> deb ataladi va agar tajovuzkor indeksni ma'lumotlar tuzilmasidan keyin saqlanadigan ma'lumotlarni o'qishga ruxsat etilmasligi kerak bo'lgan tarzda o'zgartira olsa, xavfsizlik zaifliklariga olib kelishi mumkin.</p>
<p>Dasturingizni bunday zaiflikdan himoya qilish uchun, agar siz mavjud bo'lmagan indeksdagi elementni o'qishga harakat qilsangiz, Rust ishlashni to'xtatadi va davom etishni rad etadi. Keling, sinab ko'raylik va ko'ramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Bu xatolik <code>main.rs</code> ning 4-qatoriga ishora qiladi, bu yerda biz 99 indeksiga kirishga harakat qilamiz. Keyingi eslatma satrida biz xatoga nima sabab bo'lganligining backtraceni olish uchun <code>RUST_BACKTRACE</code> muhit o'zgaruvchisini o'rnatishimiz mumkinligini aytadi. <em>backtrace</em> - bu dastur bajarilishining ma'lum bir nuqtasiga qadar chaqirilgan barcha funktsiyalar ro'yxatini. Backtrace boshqa tillarda bo'lgani kabi Rust tilida ham xuddi shunday ishlaydi. Shuning uchun, biz boshqa joylarda bo'lgani kabi, backtrace ma'lumotlarini o'qishni tavsiya qilamiz - siz yozgan fayllar haqidagi ma'lumotlarni ko'rmaguningizcha yuqoridan pastga o'qing. Bu muammo paydo bo'lgan joy. Yuqoridagi satrlar sizning kodingiz chaqirgan koddir; Quyidagi satrlar sizning kodingiz deb ataladigan koddir. Ushbu oldingi va keyingi qatorlar asosiy Rust kodini, standart kutubxona kodi yoki siz foydalanayotgan cratelarni o'z ichiga olishi mumkin. <code>RUST_BACKTRACE</code> muhit o ªzgaruvchisini 0 dan tashqari istalgan qiymatga o ªrnatish orqali backtraceni olishga harakat qilaylik. 9-2 ro'yxati siz ko'rgan narsaga o'xshash natijani ko'rsatadi.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Ro ªyxat 9-2: <code>RUST_BACKTRACE</code> muhit o ªzgaruvchisi o ªrnatilganda ko ªrsatiladigan <code>panic!</code> chaqiruvi tomonidan yaratilgan backtrace</span></p>
<p>Bu juda ko'p natija! Siz ko'rgan aniq chiqish operatsion tizimingiz va Rust versiyasiga qarab farq qilishi mumkin. Ushbu ma'lumotlar bilan backtrace uchun debug symbollari yoqilgan bo'lishi kerak. Nosozliklarni tuzatish belgilari standart bo ªyicha <code>--release</code> opsiyasiz <code>cargo build</code> yoki <code>cargo run</code> funksiyalaridan foydalanilganda yoqilgan.</p>
<p>9-2 ro'yxatdagi chiqishda backtracening 6-qatori muammoni keltirib chiqarayotgan loyihamizdagi chiziqqa ishora qiladi: <em>src/main.rs</em> ning 4-qatori. Agar dasturimiz panic bo'lishini istamasak, biz yozgan faylni eslatib o'tgan birinchi qatorda ko'rsatilgan joydan tekshirishni boshlashimiz kerak. 9-1 ro'yxatida biz panic qo'yadigan kodni ataylab yozganmiz. panicni tuzatish usuli vector indekslari doirasidan tashqarida elementni so'ramaslikdir. Kelajakda sizning kodingiz panic qo'zg'atganda, siz panic qo'zg'ash uchun kod qanday harakatlarni amalga oshirayotganini va buning o'rniga kod nima qilishi kerakligini aniqlashingiz kerak bo'ladi.</p>
<p>Biz <code>panic!</code> makrosi va qachon <code>panic!</code> qo'llashimiz kerak va qachon foydalanmaslik kerakligi haqidagi muhokamaga qaytamiz! Ushbu bobning keyingi qismida <a href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">‚Äú<code>panic!</code> qo'yish yoki <code>panic!</code> qo'ymaslik‚Äù</a><!-- ignore --> haqida gapalashamiz.</p>
<p>Keyinchalik, <code>Result</code> yordamida xatoni qanday tiklashni ko'rib chiqamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="result-bilan-tiklanadigan-xatolar"><a class="header" href="#result-bilan-tiklanadigan-xatolar"><code>Result</code> bilan tiklanadigan xatolar</a></h2>
<p>Ko'pgina xatolar dasturni butunlay to'xtatishni talab qiladigan darajada jiddiy emas.
Ba'zan, funksiya bajarilmasa, bu siz osongina talqin qilishingiz va javob berishingiz mumkin bo'lgan sababdir. Misol uchun, agar siz faylni ochishga urinib ko'rsangiz va fayl mavjud bo'lmagani uchun bu operatsiya bajarilmasa, jarayonni tugatish o'rniga faylni yaratishni xohlashingiz mumkin.</p>
<p>2-bobdagi <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">‚ÄúPotentsial muvaffaqiyatsizlikni <code>Result</code> bilan hal qilish‚Äù</a><!-- ignore --> bo'limini eslang: biz u yerda muvaffaqiyatsizliklarni hal qilish uchun ikkita variantga ega bo'lgan <code>Ok</code> va <code>Err</code> varianti bo'lgan <code>Result</code> enumidan foydalanganmiz. Enumning o'zi quyidagicha aniqlanadi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> va <code>E</code> umumiy turdagi parametrlardir: biz generiklarni 10-bobda batafsilroq muhokama qilamiz. Siz hozir bilishingiz kerak bo'lgan narsa shundaki, <code>T</code> <code>Ok</code> variantida muvaffaqiyatli holatda qaytariladigan qiymat turini bildiradi, va <code>E</code> <code>Err</code>(Xato) variantida xatolik holatida qaytariladigan xato turini ifodalaydi. <code>Result</code>da ushbu umumiy turdagi parametrlar mavjud bo'lganligi sababli, biz qaytarmoqchi bo'lgan muvaffaqiyatli qiymat va xato qiymati har xil bo'lishi mumkin bo'lgan turli vaziyatlarda <code>Result</code> turidan va unda belgilangan funksiyalardan foydalanishimiz mumkin.</p>
<p>Keling, <code>Result</code> qiymatini qaytaruvchi funksiyani chaqiraylik, chunki funksiya bajarilmasligi mumkin. 9-3 ro'yxatda biz faylni ochishga harakat qilamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let fayl_ochish = File::open(&quot;olma.txt&quot;);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 9-3: Faylni ochish</span></p>
<p><code>File::open</code> return(qaytish) turi <code>Result&lt;T, E&gt;</code>dir. <code>File::open</code>ni amalga oshirishdagi umumiy <code>T</code> turi muvaffaqiyatli qabul qilingan qiymat turiga, <code>std::fs::File</code>ga, ya'ni fayl deskriptoriga mos keladi. Xato qiymatida ishlatiladigan <code>E</code> turi <code>std::io::Error</code>. Qaytish(return) turi <code>File::open</code> ga chaqiruv muvaffaqiyatli bo'lishi va biz o'qishimiz yoki yozishimiz mumkin bo'lgan fayl handleni qaytarishi mumkinligini anglatadi. Funksiya chaqiruvi ham muvaffaqiyatsiz bo'lishi mumkin: masalan, fayl mavjud bo'lmasligi yoki faylga kirish uchun ruxsatimiz bo'lmasligi mumkin. <code>File::open</code> funksiyasi muvaffaqiyatli yoki muvaffaqiyatsiz bo'lganligini va bir vaqtning o'zida bizga fayl identifikatori yoki xato haqida ma'lumot beradigan metodga ega bo'lishi kerak. Ushbu ma'lumot aynan <code>Result</code> enumini bildiradi.</p>
<p>Agar <code>File::open</code> muvaffaqiyatli bo'lsa, <code>fayl_ochish</code> qiymati fayl identifikatorini o'z ichiga olgan <code>Ok</code> misoli bo'ladi.
Muvaffaqiyatsiz bo'lgan taqdirda, <code>fayl_ochish</code> dagi qiymat <code>Err</code> misoli bo'lib, sodir bo'lgan xato turi haqida qo'shimcha ma'lumotni o'z ichiga oladi.</p>
<p><code>File::open</code> qiymatiga qarab turli amallarni bajarish uchun 9-3-Ro'yxatdagi kodga o'zgartirishimiz kerak. 9-4 ro'yxatda biz 6-bobda muhokama qilgan asosiy tool - <code>match</code> ifodasi yordamida <code>Result</code> ni boshqarishning bir usuli ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let fayl_ochish = File::open(&quot;olma.txt&quot;);

    let fayl = match fayl_ochish {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Faylni ochishda muammo: {:?}&quot;, error),
    };
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 9-4: Qaytarilishi mumkin bo ªlgan <code>Result</code> variantlarini boshqarish uchun <code>match</code> ifodasidan foydalanish</span></p>
<p>E'tibor bering, <code>Option</code> enumi kabi, <code>Result</code> enumi va uning variantlari avtomatik import (prelude) orqali kiritilgan, shuning uchun biz <code>match</code>  qatoridagi <code>Ok</code> va <code>Err</code>  variantlaridan oldin <code>Result::</code> ni belgilashimiz shart emas.</p>
<p>Natija <code>Ok</code> bo'lsa, bu kod <code>Ok</code> variantidan ichki <code>file</code> qiymatini qaytaradi va biz ushbu faylni ishlov berish qiymatini <code>fayl_ochish</code> o'zgaruvchisiga tayinlaymiz. <code>match</code>dan so'ng biz o'qish yoki yozish uchun fayl boshqaruvidan foydalanishimiz mumkin.</p>
<p><code>match</code>ning boshqa qismi <code>File::open</code> dan <code>Err</code> qiymatini oladigan holatni boshqaradi. Ushbu misolda biz <code>panic!</code>  makrosini tanladik. Agar joriy jildimizda <em>olma.txt</em> nomli fayl bo‚Äòlmasa va biz ushbu kodni ishga tushirsak, biz <code>panic!</code> makrosidan quyidagi natijani ko‚Äòramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Odatdagidek, bu chiqish bizga nima noto'g'ri ketganligini aniq aytadi.</p>
<h3 id="turli-xil-xatolarga-moslashish"><a class="header" href="#turli-xil-xatolarga-moslashish">Turli xil xatolarga moslashish</a></h3>
<p>9-4 ro ªyxatdagi kod nima uchun <code>File::open</code> muvaffaqiyatsiz bo ªlishidan qat ºiy nazar <code>panic!</code> qo ªyadi.
Biroq, biz turli sabablarga ko'ra turli xil harakatlarni amalga oshirishni xohlaymiz: agar fayl mavjud bo'lmagani uchun <code>File::open</code> muvaffaqiyatsiz bo'lsa, biz faylni yaratmoqchimiz va fayl boshqaruvini yangi faylga qaytaramiz. Agar <code>File::open</code> boshqa sabablarga ko'ra, masalan, faylni ochishga ruxsatimiz yo'qligi sababli muvaffaqiyatsiz bo'lsa, biz hali ham kodga 9-4 ro'yxatdagi kabi <code>panic!</code> qo'yishini xohlaymiz. Buning uchun biz 9-5 ro'yxatda ko'rsatilgan ichki <code>match</code> ifodasini qo'shamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let fayl_ochish = File::open(&quot;olma.txt&quot;);

    let fayl = match fayl_ochish {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;olma.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Fayl yaratishda muammo: {:?}&quot;, e),
            },
            boshqa_xato =&gt; {
                panic!(&quot;Faylni ochishda muammo: {:?}&quot;, boshqa_xato);
            }
        },
    };
}</code></pre>
<p><span class="caption">Ro'yxat 9-5: Har xil turdagi xatolarni turli yo'llar bilan hal qilish</span></p>
<p><code>File::open</code> <code>Err</code> variantida qaytaradigan qiymat turi <code>io::Error</code> bo'lib, bu standart kutubxona tomonidan taqdim etilgan strukturadir. Ushbu strukturada <code>io::ErrorKind</code> qiymatini olish uchun chaqirishimiz mumkin bo'lgan <code>kind</code> metodi mavjud. <code>io::ErrorKind</code> enumi standart kutubxona tomonidan taqdim etilgan va <code>io</code> operatsiyasi natijasida yuzaga kelishi mumkin bo'lgan turli xil xatolarni ifodalovchi variantlarga ega. Biz foydalanmoqchi bo ªlgan variant <code>ErrorKind::NotFound</code> bo ªlib, biz ochmoqchi bo ªlgan fayl hali mavjud emasligini bildiradi. Shunday qilib, biz <code>fayl_ochish</code> bo'yicha mos kelamiz, lekin bizda <code>error.kind()</code> da ichki match ham bor.</p>
<p>Biz ichki matchni tekshirmoqchi bo'lgan shart - <code>error.kind()</code> tomonidan qaytarilgan qiymat <code>ErrorKind</code> enumining <code>NotFound</code> variantidir. Agar shunday bo'lsa, biz faylni <code>File::create</code> yordamida yaratishga harakat qilamiz. Biroq, <code>File::create</code> ham muvaffaqiyatsiz bo'lishi mumkinligi sababli, bizga ichki <code>match</code> ifodasida ikkinchi arm kerak. Faylni yaratib bo'lmaganda, boshqa xato xabari chop etiladi. Tashqi <code>match</code> ning ikkinchi armi bir xil bo'lib qoladi, shuning uchun dastur yetishmayotgan fayl xatosidan tashqari har qanday xato haqida panic qo'yadi.</p>
<blockquote>
<h3 id="resultt-e-bilan-match-dan-foydalanishning-muqobillari"><a class="header" href="#resultt-e-bilan-match-dan-foydalanishning-muqobillari"><code>Result&lt;T, E&gt;</code> bilan <code>match</code> dan foydalanishning muqobillari</a></h3>
<p>Bu juda ko'p <code>match</code>! <code>match</code> ifodasi juda foydali, lekin ayni paytda
juda primitivdir. 13-bobda siz <code>Result&lt;T, E&gt;</code> da belgilangan ko ªplab
metodlarda qo ªllaniladigan yopilishlar(closures) haqida bilib olasiz. Ushbu
metodlar kodingizdagi <code>Result&lt;T, E&gt;</code> qiymatlari bilan ishlashda <code>match</code> 
dan foydalanishdan ko'ra qisqaroq bo'lishi mumkin.</p>
<p>Misol uchun, 9-5 ro'yxatda ko'rsatilgan mantiqni yozishning yana bir
usuli, bu safar closures va <code>unwrap_or_else</code> metodi yordamida:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let fayl_ochish = File::open(&quot;olma.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;olma.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Fayl yaratishda muammo: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Faylni ochishda muammo: {:?}&quot;, error);
        }
    });
}</code></pre>
<p>Garchi bu kod 9-5 ro ªyxatdagi kabi harakatga ega bo ªlsa-da, unda
<code>match</code> iboralari mavjud emas va o ªqish uchun qulayroq. 13-bobni o‚Äòqib bo‚Äòlgach,
ushbu misolga qayting va standart kutubxona hujjatlarida <code>unwrap_or_else</code>
metodini qidiring. Ushbu metodlarning ko'pchiligi xatolar bilan
shug'ullanayotganda katta o'rinli <code>match</code>  iboralarni tozalashi mumkin.</p>
</blockquote>
<h3 id="xatoda-panic-uchun-yorliqlar-unwrap-va-expect"><a class="header" href="#xatoda-panic-uchun-yorliqlar-unwrap-va-expect">Xatoda panic uchun yorliqlar: <code>unwrap</code> va <code>expect</code></a></h3>
<p><code>match</code> dan foydalanish yetarlicha yaxshi ishlaydi, lekin u biroz batafsil bo'lishi mumkin va har doim ham maqsadni yaxshi bildirmaydi. <code>Result&lt;T, E&gt;</code> turida turli, aniqroq vazifalarni bajarish uchun belgilangan ko ªplab yordamchi metodlar mavjud. <code>unwrap</code> metodi biz 9-4 ro'yxatda yozgan <code>match</code> iborasi kabi implemen qilinadigan yorliq metodidir. Agar <code>Result</code> qiymati <code>Ok</code> varianti bo'lsa, <code>unwrap</code> qiymati <code>Ok</code> ichidagi qiymatni qaytaradi. Agar <code>Result</code> <code>Err</code> varianti bo‚Äòlsa, <code>unwrap</code> biz uchun <code>panic!</code> makrosini chaqiradi. Mana amaldagi <code>unwrap</code> misoli:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let fayl_ochish = File::open(&quot;olma.txt&quot;).unwrap();
}</code></pre></pre>
<p>Agar biz ushbu kodni <em>olma.txt</em> faylisiz ishga tushiradigan bo‚Äòlsak, biz <code>panic!</code> chaqiruvidan xato xabarini ko‚Äòramiz.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:4:49
</code></pre>
<p>Xuddi shunday, <code>expect</code> metodi bizga <code>panic!</code> xato xabarini tanlash imkonini beradi.
<code>unwrap</code> o'rniga <code>expect</code> dan foydalanish va yaxshi xato xabarlarini taqdim etish niyatingizni bildirishi va panic manbasini kuzatishni osonlashtirishi mumkin. <code>expect</code> sintaksisi quyidagicha ko'rinadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let fayl_ochish = File::open(&quot;olma.txt&quot;)
        .expect(&quot;olma.txt ushbu loyihaga kiritilishi kerak&quot;);
}</code></pre></pre>
<p>Biz <code>expect</code> dan xuddi <code>unwrap</code> kabi foydalanamiz: fayl boshqaruvini qaytarish yoki <code>panic!</code> makrosini chaqirish uchun.<code>panic!</code> chaqiruvida <code>expect</code> tomonidan foydalanilgan xato xabari <code>unwrap</code> ishlatadigan standart <code>panic!</code> xabari emas, balki <code>expect</code> parametriga o‚Äòtadigan parametr bo‚Äòladi. Bu qanday ko'rinishga ega:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'olma.txt should be included in this project: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:5:10
</code></pre>
<p>Ishlab chiqarish sifati kodida ko'pchilik Rustaceanlar <code>unwrap</code> o'rniga  <code>expect</code> ni tanlaydilar va nima uchun operatsiya har doim muvaffaqiyatli bo'lishi kutilayotgani haqida ko'proq kontekst beradi. Shunday qilib, agar sizning taxminlaringiz noto'g'ri ekanligi isbotlangan bo'lsa, debuggingda foydalanish uchun ko'proq ma'lumotga ega bo'lasiz.</p>
<h3 id="xatoni-yonaltirish---propagating"><a class="header" href="#xatoni-yonaltirish---propagating">Xatoni yo'naltirish - Propagating</a></h3>
<p>Funksiyani amalga oshirish muvaffaqiyatsiz bo'lishi mumkin bo'lgan narsani chaqirganda, xatoni funksiyaning o'zida hal qilish o'rniga, nima qilish kerakligini hal qilish uchun xatoni chaqiruvchi kodga qaytarishingiz mumkin. Bu xatoni <em>propagating</em> deb nomlanadi va chaqiruv kodini ko'proq nazorat qiladi, bu yerda kodingiz kontekstida mavjud bo'lgan narsadan ko'ra xatoni qanday hal qilish kerakligini ko'rsatadigan ko'proq ma'lumot yoki mantiq bo'lishi mumkin.</p>
<p>Misol uchun, 9-6 ro'yxati fayldan foydalanuvchi nomini o'qiydigan funksiyani ko'rsatadi. Agar fayl mavjud bo'lmasa yoki o'qib bo'lmasa, bu funksiya ushbu xatolarni funksiya chaqirgan kodga qaytaradi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn fayldan_foydalanuvchi_nomini_olish() -&gt; Result&lt;String, io::Error&gt; {
    let foydalanuvchi_fayli_natijasi = File::open(&quot;olma.txt&quot;);

    let mut foydalanuvchi_fayli = match foydalanuvchi_fayli_natijasi {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut foydalanuvchi = String::new();

    match foydalanuvchi_fayli.read_to_string(&amp;mut foydalanuvchi) {
        Ok(_) =&gt; Ok(foydalanuvchi),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 9-6: <code>match</code> yordamida chaqiruv kodiga xatoliklarni qaytaruvchi funksiya</span></p>
<p>Bu funksiyani ancha qisqaroq tarzda yozish mumkin, lekin biz xatolarni qayta ishlashni o'rganish uchun uning ko'p qismini qo'lda qilishdan boshlaymiz; oxirida biz qisqaroq yo'lni ko'rsatamiz. Avval funksiyaning qaytish turini ko'rib chiqamiz: <code>Result&lt;String, io::Error&gt;</code>. Bu funksiya <code>Result&lt;T, E&gt;</code> turidagi qiymatni qaytarayotganini bildiradi, bunda parametr <code>T</code> aniq turdagi <code>String</code> bilan to'ldirilgan, va <code>E</code> umumiy turi aniq turdagi <code>io::Error</code> bilan to`ldirilgan.</p>
<p>Agar bu funksiya hech qanday muammosiz muvaffaqiyatli bajarilsa, ushbu funksiyani chaqiruvchi kod <code>String</code> ga ega bo ªlgan <code>Ok</code> qiymatini oladi ‚Äì bu funksiya fayldan o'qigan foydalanuvchi nomi. Agar bu funksiya biron bir muammoga duch kelsa, murojaat qiluvchi kod <code>io::Error</code> misolini o'z ichiga olgan <code>Err</code> qiymatini oladi, unda muammolar nima bo'lganligi haqida qo'shimcha ma'lumot mavjud. Biz ushbu funktsiyaning qaytish turi sifatida <code>io::Error</code> ni tanladik, chunki bu funksiyaning tanasida bajarilmay qolishi mumkin bo‚Äòlgan ikkala operatsiyadan qaytarilgan xato qiymatining turi: <code>File::open</code> funksiyasi va <code>read_to_string</code> metodi.</p>
<p>Funksiyaning asosiy qismi <code>File::open</code> funksiyasini chaqirish orqali boshlanadi. Keyin biz <code>Result</code> qiymatini 9-4 ro'yxatdagi <code>match</code>ga o'xshash <code>match</code> bilan ishlaymiz.
Agar <code>File::open</code> muvaffaqiyatli bajarilsa, <code>file</code> pattern o'zgaruvchisidagi fayl ishlovi <code>foydalanuvchi_fayli</code> o'zgaruvchan o'zgaruvchisidagi qiymatga aylanadi va funksiya davom etadi. <code>Err</code> holatida, <code>panic!</code> deb chaqirish o‚Äòrniga, biz <code>return</code>  kalit so‚Äòzidan funksiyadan to‚Äòliq chiqib ketish uchun foydalanamiz va xato qiymatini <code>File::open</code> dan, endi <code>e</code> pattern o‚Äòzgaruvchisiga o‚Äòtkazamiz, bu funksiya xato qiymati sifatida chaqiruvchi kodga qaytaradi.</p>
<p>Shunday qilib, agar bizda <code>foydalanuvchi_fayli</code> da fayl boshqaruvi mavjud bo'lsa, keyin funksiya <code>foydalanuvchi</code> o'zgaruvchisida yangi <code>String</code> yaratadi va fayl mazmunini <code>foydalanuvchi</code> ni o'qish uchun <code>foydalanuvchi_fayli</code> da fayl boshqaruvidagi <code>read_to_string</code> metodini chaqiradi. <code>read_to_string</code> metodi ham <code>Result</code>ni qaytaradi, chunki u <code>File::open</code> muvaffaqiyatli bo'lishi ham mumkin, muvaffaqiyatsiz bo'lishi ham mumkin. Demak, ushbu <code>Result</code> bilan ishlash uchun bizga yana bir <code>match</code> kerak bo'ladi: agar <code>read_to_string</code> muvaffaqiyatli bo'lsa, demak, bizning funksiyamiz muvaffaqiyatli bo'ldi va biz foydalanuvchi nomini hozirda <code>Ok</code> bilan o'ralgan <code>foydalanuvchi</code> faylidan qaytaramiz. Agar <code>read_to_string</code> bajarilmasa, biz xato qiymatini xuddi <code>File::open</code> qiymatini qayta ishlagan <code>match</code> da xato qiymatini qaytarganimizdek qaytaramiz. Biroq, biz <code>return</code> ni aniq aytishimiz shart emas, chunki bu funksiyadagi oxirgi ifoda.</p>
<p>Ushbu kodni chaqiruvchi kod foydalanuvchi nomini o'z ichiga olgan <code>Ok</code>  qiymatini yoki <code>io::Error</code> ni o'z ichiga olgan <code>Err</code> qiymatini olishni boshqaradi. Ushbu qiymatlar bilan nima qilishni hal qilish chaqiruv kodiga bog'liq. Agar chaqiruv kodi <code>Err</code> qiymatini olsa, u <code>panic!</code> deb chaqirishi va dasturni buzishi mumkin, standart foydalanuvchi nomidan foydalaning yoki foydalanuvchi nomini fayldan boshqa joydan qidiring, masalan. Bizda chaqiruv kodi aslida nima qilmoqchi ekanligi haqida yetarli ma'lumot yo'q, shuning uchun biz barcha muvaffaqiyat yoki xato ma'lumotlarini to'g'ri ishlashi uchun xatolarni propagate qilamiz.</p>
<p>Xatolarni propagating qilish namunasi Rustda shu qadar keng tarqalganki, Rust buni osonlashtirish uchun savol belgisi operatori <code>?</code> beradi.</p>
<h4 id="propagating-xatolar-uchun-qisqa-kod--operatori"><a class="header" href="#propagating-xatolar-uchun-qisqa-kod--operatori">Propagating xatolar uchun qisqa kod: <code>?</code> operatori</a></h4>
<p>9-7 ro'yxatda 9-6 ro'yxatdagi kabi funksiyaga ega bo'lgan <code>foydalanuvchi_fayli</code> ilovasi ko'rsatilgan, ammo bu dastur <code>?</code> operatoridan foydalanadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn fayldan_foydalanuvchi_nomini_olish() -&gt; Result&lt;String, io::Error&gt; {
    let mut foydalanuvchi_fayli = File::open(&quot;olma.txt&quot;)?;
    let mut foydalanuvchi = String::new();
    foydalanuvchi_fayli.read_to_string(&amp;mut foydalanuvchi)?;
    Ok(foydalanuvchi)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 9-7: <code>?</code> operatori yordamida chaqiruvchi kodga xatoliklarni qaytaruvchi funksiya</span></p>
<p><code>Result</code> qiymatidan keyin qo ªyilgan <code>?</code> 9-6 ro ªyxatdagi <code>Result</code> qiymatlarini boshqarish uchun biz belgilagan <code>match</code> iboralari bilan deyarli bir xil ishlaydi. Agar <code>Result</code> qiymati <code>Ok</code> bo'lsa, <code>Ok</code> ichidagi qiymat ushbu ifodadan qaytariladi va dastur davom etadi. Agar qiymat <code>Err</code> bo'lsa, <code>Err</code> butun funktsiyadan qaytariladi, xuddi biz <code>return</code> kalit so'zidan foydalanganimizdek, xato qiymati chaqiruvchi kodga propagate qiladi.</p>
<p>9-6 ro ªyxatdagi <code>match</code> ifodasi va <code>?</code> operatori nima qilishi o ªrtasida farq bor: <code>?</code> operatori chaqirilgan xato qiymatlari <code>from</code> funksiyasidan o ªtadi, qiymatlarni bir turdan ikkinchi turga aylantirish uchun foydalaniladigan standart kutubxonadagi <code>From</code> traitida aniqlanadi.
<code>?</code> operatori <code>from</code> funksiyasini chaqirganda, qabul qilingan xato turi joriy funksiyaning qaytish turida aniqlangan xato turiga aylanadi. Bu funksiya muvaffaqiyatsiz bo'lishi mumkin bo'lgan barcha usullarni ifodalash uchun bitta xato turini qaytarganda foydalidir, agar qismlar turli sabablarga ko'ra ishlamay qolsa ham.</p>
<p>Misol uchun, biz 9-7 ro'yxatdagi <code>fayldan_foydalanuvchi_nomini_olish</code> funksiyasini o'zgartirishimiz mumkin, bu biz aniqlagan <code>OurError</code>  nomli maxsus xato turini qaytarishimiz mumkin. Agar <code>io::Error</code> dan <code>OurError</code> misolini yaratish uchun <code>OurError</code> uchun <code>impl From&lt;io::Error&gt; for OurError</code> ni ham aniqlasak, keyin <code>fayldan_foydalanuvchi_nomini_olish</code> asosiy qismidagi <code>?</code> operatori chaqiruvlari <code>from</code>ga murojaat qiladi va funksiyaga boshqa kod qo'shmasdan xato turlarini o'zgartiradi.
<code>foydalanuvchi_fayli</code> o'zgaruvchisiga qaytaradi.Agar xatolik yuzaga kelsa, <code>?</code> operatori butun funksiyadan erta qaytadi va chaqiruvchi kodga istalgan <code>Err</code> qiymatini beradi. Xuddi shu narsa <code>read_to_string</code> chaqiruvi oxiridagi <code>?</code> uchun ham amal qiladi.</p>
<p><code>?</code> operatori ko'plab nosozliklarni bartaraf qiladi va bu funksiyani amalga oshirishni soddalashtiradi. 9-8 ro'yxatda ko'rsatilganidek, biz ushbu kodni <code>?</code> dan keyin metod chaqiruvlar zanjiridan foydalansak, bu kodni yanada qisqartirishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn fayldan_foydalanuvchi_nomini_olish() -&gt; Result&lt;String, io::Error&gt; {
    let mut foydalanuvchi = String::new();

    File::open(&quot;olma.txt&quot;)?.read_to_string(&amp;mut foydalanuvchi)?;

    Ok(foydalanuvchi)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 9-8: <code>?</code> operatoridan keyin zanjirlash(chaining) metodi chaqiruvlari</span></p>
<p>Biz <code>foydalanuvchi</code> da yangi <code>String</code> yaratishni funksiya boshiga o‚Äòtkazdik; bu qism o'zgarmagan. <code>foydalanuvchi_fayli</code> o ªzgaruvchisini yaratish o ªrniga, <code>File::open(&quot;olma.txt&quot;)?</code> natijasiga to ªg ªridan-to ªg ªri <code>read_to_string</code> chaqiruvlarini bog ªladik. Bizda <code>read_to_string</code>  chaqiruvi oxirida hali ham <code>?</code> bor va biz xatoliklarni qaytarish o ªrniga <code>File::open</code> va <code>read_to_string</code> muvaffaqiyatli bo ªlganda ham <code>foydalanuvchi</code>ni o ªz ichiga olgan <code>OK</code> qiymatini qaytaramiz. Funksionallik yana 9-6 va 9-7 ro'yxatdagi kabi; Bu uni yozishning boshqacha, ergonomik usuli.</p>
<p>9-9 ro'yxati <code>fs::read_to_string</code> yordamida buni yanada qisqartirish yo'lini ko'rsatadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 9-9: faylni ochish va keyin o ªqish o ªrniga <code>fs::read_to_string</code> dan foydalanish</span></p>
<p>Faylni stringda o'qish juda keng tarqalgan operatsiya, shuning uchun standart kutubxona faylni ochadigan, yangi <code>String</code> yaratadigan qulay <code>fs::read_to_string</code> funksiyasini ta'minlaydi fayl mazmunini o'qiydi, mazmunini o'sha <code>String</code> ga qo'yadi va uni qaytaradi. Albatta, <code>fs::read_to_string</code> dan foydalanish bizga xatolarni qanday hal qilishni tushuntirishga imkon bermaydi, shuning uchun biz birinchi navbatda uzoq yo'lni o'rgandik.</p>
<h4 id="-operatoridan-qayerda-foydalanish-mumkin"><a class="header" href="#-operatoridan-qayerda-foydalanish-mumkin"><code>?</code> Operatoridan qayerda foydalanish mumkin</a></h4>
<p><code>?</code> operatori faqat qaytarish turi <code>?</code> ishlatiladigan qiymatga mos keladigan funksiyalarda ishlatilishi mumkin. Buning sababi, <code>?</code> operatori biz 9-6 ro'yxatda belgilagan <code>match</code> ifodasi kabi funksiyadan tashqari qiymatni erta qaytarish uchun belgilangan. 9-6 ro ªyxatda <code>match</code> <code>Result</code> qiymatidan foydalanilgan va erta qaytish armi <code>Err(e)</code> qiymatini qaytargan. Funksiyaning qaytish turi <code>Result</code> bo'lishi kerak, shunda u ushbu <code>return</code> bilan mos keladi.</p>
<p>9-10 ro'yxatda, agar biz <code>?</code> dan foydalanadigan qiymat turiga mos kelmaydigan qaytish turi bilan <code>main</code> funksiyada <code>?</code> operatoridan foydalansak, qanday xatoga duch kelamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let fayl_ochish = File::open(&quot;olma.txt&quot;)?;
}</code></pre>
<p><span class="caption">Ro ªyxat 9-10: <code>()</code> qaytaradigan <code>main</code>  funksiyadagi <code>?</code> dan foydalanishga urinish kompilyatsiya qilinmaydi.</span></p>
<p>Ushbu kod faylni ochadi, bu muvaffaqiyatsiz bo'lishi mumkin. <code>?</code> operatori <code>File::open</code> tomonidan qaytarilgan <code>Result</code> qiymatiga amal qiladi, lekin bu <code>main</code> funksiya <code>Result</code> emas, <code>()</code> qaytish turiga ega. Ushbu kodni kompilyatsiya qilganimizda, biz quyidagi xato xabarini olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let fayl_ochish = File::open(&quot;olma.txt&quot;)?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>Bu xato bizga <code>?</code> operatoridan faqat <code>Result</code>, <code>Option</code> yoki <code>FromResidual</code>ni qo'llaydigan boshqa turdagi qaytaruvchi funksiyada foydalanishga ruxsat berilganligini ko`rsatadi.</p>
<p>Xatoni tuzatish uchun sizda ikkita variant bor. Tanlovlardan biri, funksiyangizning qaytish turini <code>?</code> operatoridan foydalanayotgan qiymatga mos keladigan qilib o'zgartirish, agar bunga hech qanday cheklovlar bo'lmasa. Boshqa usul esa, <code>Result&lt;T, E&gt;</code> ni mos keladigan usulda boshqarish uchun <code>match</code> yoki <code>Result&lt;T, E&gt;</code> metodlaridan birini qo`llashdir.</p>
<p>Xato xabarida, shuningdek, <code>?</code> ni <code>Option&lt;T&gt;</code> qiymatlari bilan ham foydalanish mumkinligi aytilgan. <code>Result</code>da <code>?</code> dan foydalanish kabi, siz <code>?</code> dan faqat <code>Option</code> ni qaytaradigan funksiyada foydalanishingiz mumkin. <code>?</code> operatorining <code>Option&lt;T&gt;</code> bo'yicha chaqirilgandagi xatti-harakati <code>Result&lt;T, E&gt;</code> da chaqirilgandagi xatti-harakatiga o'xshaydi: agar qiymat <code>None</code> bo'lsa <code>None</code> bo'ladi o'sha paytda  funksiyadan erta qaytariladi. Agar qiymat <code>Some</code> bo'lsa, <code>Some</code> ichidagi qiymat ifodaning natijaviy qiymati bo`lib, funksiya davom etadi. 9-11 ro'yxatda berilgan matndagi birinchi qatorning oxirgi belgisini topadigan funksiya misoli mavjud:</p>
<pre><pre class="playground"><code class="language-rust">fn birinchi_satrning_oxirgi_belgisi(matn: &amp;str) -&gt; Option&lt;char&gt; {
    matn.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        birinchi_satrning_oxirgi_belgisi(&quot;Salom Do'stim\n Ahvollaring qanday?&quot;),
</span><span class="boring">        Some('m')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(birinchi_satrning_oxirgi_belgisi(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(birinchi_satrning_oxirgi_belgisi(&quot;\nhi&quot;), None);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 9-11: <code>Option</code>da <code>?</code> operatoridan foydalanish<T>`
value</span></p>
<p>Bu funksiya <code>Option&lt;char&gt;</code>ni qaytaradi, chunki u yerda belgi(character) bo ªlishi mumkin, lekin yo ªq bo ªlishi ham mumkin. Bu kod <code>matn</code> string argumentini oladi va undagi <code>lines</code> metodini chaqiradi, bu esa satrdagi satrlar ustidan iteratorni qaytaradi. Ushbu funksiya birinchi qatorni tekshirmoqchi bo'lganligi sababli, iteratordan birinchi qiymatni olish uchun iteratorda <code>next</code> ni chaqiradi. Agar <code>matn</code> bo ªsh qator bo ªlsa, <code>next</code> ga murojat qilish <code>None</code>ni qaytaradi, bu holda biz <code>birinchi_satrning_oxirgi_belgisi</code>dan <code>None</code>ni to ªxtatish va qaytarish uchun <code>?</code> operatoridan foydalanamiz. Agar <code>matn</code> bo'sh qator bo'lmasa, <code>next</code> <code>matn</code>dagi birinchi qatorning string sliceni o'z ichiga olgan <code>Some</code> qiymatini qaytaradi.</p>
<p><code>?</code> operatori satr bo'lagini chiqaradi va biz uning belgilarining iteratorini olish uchun ushbu qator bo'limidagi <code>chars</code>larni chaqirishimiz mumkin. Bizni ushbu birinchi qatordagi oxirgi belgi qiziqtiradi, shuning uchun biz iteratordagi oxirgi elementni qaytarish uchun <code>last</code> deb chaqiramiz.
Bu <code>Option</code>dir, chunki birinchi qator bo ªsh satr bo ªlishi mumkin, masalan, <code>matn</code> bo ªsh satr bilan boshlansa, lekin <code>&quot;\nhi&quot;</code>dagi kabi boshqa qatorlarda belgilar bo ªlsa. Biroq, agar birinchi qatorda oxirgi belgi bo'lsa, u <code>Some</code> variantida qaytariladi. O'rtadagi <code>?</code> operatori bu mantiqni ifodalashning ixcham usulini beradi, bu funksiyani bir qatorda amalga oshirish imkonini beradi. Agar biz <code>Option</code> da<code>?</code> operatoridan foydalana olmasak, biz bu mantiqni ko'proq metod chaqiruvlari yoki <code>match</code> ifodasi yordamida amalga oshirishimiz kerak edi.</p>
<p>Esda tutingki, <code>?</code> operatoridan <code>Result</code> qaytaruvchi funksiyada <code>Result</code>da foydalanishingiz mumkin, va <code>?</code> operatoridan <code>Option</code> qaytaradigan funksiyada <code>Option</code>da foydalanishingiz mumkin, lekin siz aralashtirib, moslashtira olmaysiz. <code>?</code> operatori <code>Result</code>ni avtomatik ravishda <code>Option</code>ga yoki aksincha o'zgartirmaydi; Bunday hollarda konvertatsiyani aniq amalga oshirish uchun <code>Result</code>dagi <code>ok</code> metodi yoki <code>Option</code>dagi <code>ok_or</code> kabi metodlardan foydalanishingiz mumkin.</p>
<p>Hozirgacha biz ishlatgan barcha <code>main</code> funksiyalar <code>()</code> ni qaytaradi. <code>main</code> funksiya maxsus, chunki u bajariladigan dasturlarning kirish va chiqish nuqtasi bo'lib, dasturlar kutilgandek harakat qilishi uchun uning qaytish(return) turi qanday bo'lishi mumkinligiga cheklovlar mavjud.</p>
<p>Yaxshiyamki, <code>main</code> <code>Result&lt;(), E&gt;</code>ni ham qaytarishi mumkin. 9-12 ro'yxatda 9-10 ro'yxatdagi kod mavjud, biroq biz <code>main</code> ning qaytish turini <code>Result&lt;(),  Box&lt;dyn Error&gt;&gt;</code> qilib o'zgartirdik va oxiriga <code>Ok(())</code>  qaytish qiymatini qo'shdik. Ushbu kod endi kompilyatsiya qilinadi:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let fayl_ochish = File::open(&quot;olma.txt&quot;)?;

    Ok(())
}</code></pre>
<p><span class="caption">Ro ªyxat 9-12: <code>main</code>ni <code>Result&lt;(), E&gt;</code> qaytarishga o ªzgartirish <code>Result</code> qiymatlarida <code>?</code> operatoridan foydalanish imkonini beradi.</span></p>
<p><code>Box&lt;dyn Error&gt;</code> turi bu <em>trait ob'ekti</em> bo'lib, biz 17-bobning <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">&quot;Turli turdagi qiymatlarga ruxsat beruvchi trait ob'ektlaridan foydalanish&quot;</a><!-- ignore -->  bo'limida gaplashamiz. Hozircha siz <code>Box&lt;dyn Error&gt;</code>ni ‚Äúhar qanday xato‚Äù degan ma'noni anglatadi deb o'ylashingiz mumkin. <code>Box&lt;dyn Error&gt;</code> xato turi bilan <code>main</code> funksiyadagi <code>Result</code> qiymatida <code>?</code> dan foydalanishga ruxsat beriladi, chunki bu har qanday <code>Err</code> qiymatini erta qaytarish imkonini beradi. Garchi bu <code>main</code> funksiyaning tanasi faqat <code>std::io::Error</code> turidagi xatolarni qaytarsa ham, <code>Box&lt;dyn Error&gt;</code> ni belgilab, <code>main</code> funksiyaga boshqa xatolarni qaytaruvchi ko'proq kod qo'shilsa ham, bu kod to'g'ri bo'lib qoladi.</p>
<p><code>main</code>  funksiya <code>Result&lt;(), E&gt;</code>ni qaytarsa, bajariladigan fayl(executable file) <code>0</code> qiymati bilan chiqadi, agar <code>main</code> <code>Ok(())</code> qaytarsa va <code>main</code> <code>Err</code> qiymatini qaytarsa nolga teng bo'lmagan qiymat bilan chiqadi. C tilida yozilgan bajariladigan fayllar(executable file) chiqqanda butun sonlarni qaytaradi: muvaffaqiyatli chiqqan dasturlar <code>0</code> butun sonini qaytaradi, xatoga yo'l qo'ygan dasturlar esa <code>0</code> dan boshqa butun sonni qaytaradi. Rust shuningdek, ushbu konventsiyaga mos kelishi uchun bajariladigan fayllardan butun(integer) sonlarni qaytaradi.</p>
<p><code>main</code> funksiya <a href="../std/process/trait.Termination.html"><code>std::process::Termination</code> traitini</a><!-- ignore --> amalga oshiradigan har qanday turlarni qaytarishi mumkin, bunda <code>ExitCode</code> qaytaruvchi <code>report</code> funksiyasi mavjud. O'zingizning turlaringiz uchun <code>Termination</code> traitini qo'llash bo'yicha qo'shimcha ma'lumot olish uchun standart kutubxona texnik hujjatlariga murojaat qiling.</p>
<p>Endi biz <code>panic!</code> chaqirish yoki <code>Result</code>ni qaytarish tafsilotlarini muhokama qilganimizdan so‚Äòng, keling, qaysi hollarda qaysi biri to‚Äòg‚Äòri kelishini hal qilish mavzusiga qaytaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-yoki-panic-qoymaslik"><a class="header" href="#panic-yoki-panic-qoymaslik"><code>panic!</code> yoki <code>panic!</code> qo'ymaslik</a></h2>
<p>Xo'sh, qachon <code>panic!</code> deb murojat qilish va qachon <code>Result</code>ni qaytarish kerakligini qanday hal qilasiz? Kodda panic paydo bo'lganda, uni tiklashning iloji yo'q. Qayta tiklashning mumkin bo'lgan yo'li bormi yoki yo'qmi, har qanday xatolik uchun <code>panic!</code> deb chaiqruv qilishingiz mumkin, lekin siz chaqiruv kodi nomidan vaziyatni tuzatib bo'lmaydi degan qarorga kelasiz. <code>Result</code> qiymatini qaytarishni tanlaganingizda, siz chaqiruv kodini tanlash imkoniyatini berasiz. Chaqiruv kodi vaziyatga mos keladigan tarzda tiklashga urinishi mumkin yoki <code>Err</code>dagi xatoni qayta tiklab bo'lmaydi, deb qaror qilishi va <code>panic!</code> qo'yishi mumkin, bu sizning tiklanadigan xatongizni tuzatib bo'lmaydiganga aylantiradi. Shuning uchun, muvaffaqiyatsiz bo'lishi mumkin bo'lgan funksiyani belgilashda <code>Result</code> ni qaytarish yaxshi standart tanlovdir.</p>
<p>Misollar, prototip kodi va testlar kabi holatlarda <code>Result</code>ni qaytarish o'rniga panic qo'yadigan kodni yozish maqsadga muvofiqdir. Keling, nima uchun ekanligini ko'rib chiqaylik, keyin kompilyator muvaffaqiyatsizlik mumkin emasligini ayta olmaydigan vaziyatlarni muhokama qilaylik, lekin siz inson sifatida buni qila olasiz. Bob kutubxona kodida panic qo'yish yoki yo'qligini hal qilish bo'yicha ba'zi umumiy ko'rsatmalar bilan yakunlanadi.</p>
<h3 id="misollar-prototip-kodi-va-testlar"><a class="header" href="#misollar-prototip-kodi-va-testlar">Misollar, Prototip Kodi va Testlar</a></h3>
<p>Ba'zi bir kontseptsiyani tasvirlash uchun misol yozayotganingizda, shuningdek, xatolarni qayta ishlash kodini o'z ichiga olgan holda, misolni kamroq tushunarli qilish mumkin. Misollarda, panic qo'zg'atishi mumkin bo'lgan <code>unwrap</code> kabi metodga murojaat qilish sizning ilovangiz xatoliklarni qanday hal qilishini xohlayotganingiz uchun to'ldiruvchi sifatida tushuniladi, bu sizning kodingizning qolgan qismi nima qilayotganiga qarab farq qilishi mumkin.</p>
<p>Xuddi shunday, prototiplashda xatolarni qanday hal qilishni hal qilishdan oldin <code>unwrap</code> va <code>expect</code> metodllari juda qulaydir.
Dasturingizni yanada mustahkamroq qilishga tayyor bo'lganingizda ular kodingizda aniq belgilar qoldiradilar.</p>
<p>Agar testda metod chaqiruvi muvaffaqiyatsiz bo'lsa, bu metod sinovdan o'tkazilayotgan funksiya bo'lmasa ham, butun test muvaffaqiyatsiz bo'lishini xohlaysiz. Chunki <code>panic!</code> ‚Äì bu sinovning muvaffaqiyatsiz deb belgilanishi, <code>unwrap</code> yoki <code>expect</code> deb atalgan narsa aynan shunday bo'lishi kerak.</p>
<h3 id="siz-kompilyatordan-kora-koproq-malumotga-ega-bolgan-holatlar"><a class="header" href="#siz-kompilyatordan-kora-koproq-malumotga-ega-bolgan-holatlar">Siz kompilyatordan ko'ra ko'proq ma'lumotga ega bo'lgan holatlar</a></h3>
<p>Agar sizda <code>Result</code> <code>Ok</code> qiymatiga ega bo'lishini ta'minlaydigan boshqa mantiqqa ega bo'lsangiz, <code>unwrap</code> yoki <code>expect</code> ni chaqirish ham o'rinli bo'lardi, ammo mantiq kompilyator tushunadigan narsa emas. Siz hali ham <code>Result</code> qiymatiga ega bo'lasiz, uni hal qilishingiz kerak: siz murojaat qilayotgan har qanday operatsiya sizning vaziyatingizda mantiqan imkonsiz bo'lsa ham, umuman muvaffaqiyatsiz bo'lish ehtimoli bor. Agar siz kodni qo‚Äòlda tekshirish orqali sizda hech qachon <code>Err</code> varianti bo‚Äòlmasligiga ishonch hosil qilsangiz, <code>unwrap</code> deb nomlash juda maqbuldir, va <code>expect</code> matnida hech qachon <code>Err</code> varianti bo'lmaydi deb o'ylagan sababni hujjatlash yaxshiroqdir. Mana bir misol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let asosiy: IpAddr = &quot;127.0.0.1&quot;
        .parse()
        .expect(&quot;Qattiq kodlangan IP manzil haqiqiy bo'lishi kerak&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Qattiq kodlangan stringni tahlil qilish orqali <code>IpAddr</code> misolini yaratmoqdamiz. Biz <code>127.0.0.1</code> to‚Äòg‚Äòri IP manzil ekanligini ko‚Äòramiz, shuning uchun bu yerda <code>expect</code> dan foydalanish mumkin. Biroq, qattiq kodlangan, yaroqli satrga ega bo'lish <code>parse</code> metodining qaytish turini o'zgartirmaydi: biz hali ham <code>Result</code> qiymatini olamiz va kompilyator bizni <code>Result</code> bilan ishlashga majbur qiladi, go‚Äòyo <code>Err</code> varianti mumkin, chunki kompilyator bu satr har doim haqiqiy IP manzil ekanligini ko‚Äòrish uchun yetarlicha aqlli emas. Agar IP-manzillar qatori dasturga qattiq kodlanganidan ko'ra foydalanuvchidan kelgan bo'lsa va shuning uchun muvaffaqiyatsizlikka uchragan bo'lsa, biz, albatta, <code>Result</code> ni yanada ishonchli tarzda boshqarishni xohlaymiz.
Ushbu IP-manzil qattiq kodlangan degan taxminni eslatib o'tsak, agar kelajakda IP-manzilni boshqa manbadan olishimiz kerak bo'lsa, bizni <code>expect</code> ni xatolarni boshqarish kodini yaxshiroq o'zgartirishga undaydi.</p>
<h3 id="xatolarni-bartaraf-etish-boyicha-korsatmalar"><a class="header" href="#xatolarni-bartaraf-etish-boyicha-korsatmalar">Xatolarni bartaraf etish bo'yicha ko'rsatmalar</a></h3>
<p>Agar kodingiz yomon holatda bo'lishi mumkin bo'lsa, kodingiz panic qo'yishi tavsiya etiladi. Shu nuqtai nazardan, <em>yomon holat</em> deganda ba ºzi taxminlar(assumption), kafolatlar(guarantee), shartnomalar(contract,) yoki o ªzgarmasliklar buzilganda, masalan, noto ªg ªri qiymatlar, qarama-qarshi qiymatlar yoki yetishmayotgan qiymatlar kodingizga o ªtkazilganda, shuningdek quyidagilardan biri yoki bir nechtasi:</p>
<ul>
<li>Yomon holat - foydalanuvchi noto'g'ri formatda ma'lumotlarni kiritishi kabi vaqti-vaqti bilan sodir bo'lishi mumkin bo'lgan narsadan farqli o'laroq, kutilmagan narsa.</li>
<li>Ushbu nuqtadan keyin sizning kodingiz har qadamda muammoni tekshirishdan ko'ra, bu yomon holatda bo'lmaslikka tayanishi kerak.</li>
<li>Siz foydalanadigan turlarda ushbu ma'lumotni kodlashning yaxshi usuli yo'q. Biz 17-bobning <a href="ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">&quot;Turlar sifatida kodlash holatlari va behaviorlari&quot;</a><!-- ignore --> bo'limida nimani nazarda tutayotganimizni misol qilib ko'rib chiqamiz.</li>
</ul>
<p>Agar kimdir sizning kodingizga chaqiruv qilsa va mantiqiy bo'lmagan qiymatlarni o'tkazsa, kutubxona foydalanuvchisi bu holatda nima qilishni xohlashini hal qilishi uchun xatolikni qaytarish yaxshidir. Biroq, davom etish xavfli yoki zararli bo'lishi mumkin bo'lgan hollarda, eng yaxshi tanlov <code>panic!</code> deb chaqiruv qilish va kutubxonangizdan foydalanuvchini kodidagi xatolik haqida ogohlantirish bo'lishi mumkin, shunda ular ishlab chiqish jarayonida uni tuzatishi mumkin. Xuddi shunday, <code>panic!</code>ko'pincha sizning nazoratingizdan tashqarida bo'lgan tashqi kodga chaqiruv qilsangiz va uni tuzatishning imkoni bo'lmagan yaroqsiz holatni qaytarsangiz mos keladi.</p>
<p>Biroq, muvaffaqiyatsizlik kutilganda, <code>panic!</code> chaqiruv qilishdan ko'ra, <code>Result</code>ni qaytarish maqsadga muvofiqdir. Misollar, tahlilchiga noto'g'ri tuzilgan ma'lumotlar yoki tarif chegarasiga yetganingizni bildiruvchi holatni qaytaruvchi HTTP so'rovini o'z ichiga oladi. Bunday hollarda, <code>Result</code> ni qaytarish, chaqiruv kodi qanday ishlov berishni hal qilishi kerak bo'lgan muvaffaqiyatsizlik kutilgan imkoniyat ekanligini ko'rsatadi.</p>
<p>Agar kodingiz noto'g'ri qiymatlar yordamida chaqirilgan bo'lsa, foydalanuvchini xavf ostiga qo'yishi mumkin bo'lgan operatsiyani bajarganda, kodingiz avval qiymatlarning haqiqiyligini tekshirishi va qiymatlar noto'g'ri bo'lsa panic qo'yishi kerak.Bu asosan xavfsizlik nuqtai nazaridan: noto'g'ri ma'lumotlar bilan ishlashga urinish kodingizni zaifliklarga olib kelishi mumkin.
Agar siz chegaradan tashqari xotiraga kirishga harakat qilsangiz, standart kutubxona <code>panic!</code> deb chaqirishining asosiy sababi shu: joriy ma'lumotlar tuzilishiga tegishli bo'lmagan xotiraga kirishga urinish umumiy xavfsizlik muammosidir. Funksiyalarda ko'pincha <em>shartnomalar(contracts)</em> mavjud: agar kirish ma'lum talablarga javob bersa, ularning xatti-harakati kafolatlanadi. Shartnoma buzilganda panic qo'yish mantiqan to'g'ri keladi, chunki shartnoma buzilishi har doim chaqiruv qiluvchi tomonidagi xatolikni ko'rsatadi va bu siz chaqiruv kodini aniq ko'rib chiqishni xohlagan xatolik emas. Aslida, chaqiruv kodini tiklashning oqilona usuli yo'q; kodni chaqiruvchi <em>dasturchilar</em> kodni tuzatishi kerak. Funksiya uchun shartnomalar, ayniqsa buzilish panic keltirib chiqaradigan bo'lsa, funksiya uchun API texnik hujjatlarida tushuntirilishi kerak.</p>
<p>Biroq, barcha funksiyalaringizda ko'plab xatolarni tekshirish batafsil va zerikarli bo'ladi. Yaxshiyamki, siz Rustning turdagi tizimidan (va shunday qilib, kompilyator tomonidan amalga oshiriladigan turdagi tekshirish) siz uchun ko'plab tekshiruvlarni amalga oshiradi. Agar funksiyangiz parametr sifatida ma'lum bir turga ega bo'lsa, kompilyator sizda haqiqiy qiymatga ega ekanligiga ishonch hosil qilgan holda kodingiz mantig'ini davom ettirishingiz mumkin. Misol uchun, agar sizda <code>Option</code> emas, balki turingiz bo'lsa, dasturingiz <em>nothing(hech narsa)</em> emas, balki <em>something(nimadir)</em> bo'lishini kutadi. Sizning kodingiz <code>Some</code> va <code>None</code> variantlari uchun ikkita holatni ko'rib chiqishi shart emas: aniq qiymatga ega bo'lish uchun faqat bitta holat bo'ladi. Funksiyangizga hech narsa o'tkazmaslikka harakat qiladigan kodni kompilyatsiya qilinmaydi, shuning uchun funksiyangiz runtimeda bu holatni tekshirishi shart emas.
Yana bir misol, parametr hech qachon manfiy bo'lmasligini ta'minlaydigan <code>u32</code> kabi belgisiz butun son turidan foydalanishdir.</p>
<h3 id="tasdiqlash-uchun-maxsus-turlarni-yaratish"><a class="header" href="#tasdiqlash-uchun-maxsus-turlarni-yaratish">Tasdiqlash uchun maxsus turlarni yaratish</a></h3>
<p>Keling, bir qadam oldin haqiqiy qiymatga ega ekanligimizga ishonch hosil qilish uchun Rust turi tizimidan foydalanish g'oyasini olaylik va tekshirish uchun maxsus turni yaratishni ko'rib chiqaylik. 2-bobdagi taxmin qilish o'yinini eslang, unda bizning kodimiz foydalanuvchidan 1 dan 100 gacha bo'lgan raqamni taxmin qilishni so'radi. Biz hech qachon foydalanuvchining taxmini o'sha raqamlar o'rtasida ekanligini tasdiqlaganimiz yo'q, uni bizning maxfiy raqamimizga nisbatan tekshirishdan oldin; biz faqat taxmin ijobiy ekanligini tasdiqladik. Bunday holda, natijalar unchalik dahshatli emas edi: bizning &quot;Raqam katta!&quot; yoki &quot;Raqam Kichik!&quot; chiqishimiz hali ham to'g'ri bo'lar edi. Lekin foydalanuvchini to'g'ri taxmin qilishga va foydalanuvchi diapazondan tashqaridagi raqamni taklif qilganda va foydalanuvchi, masalan, raqamlar o'rniga harflarni kiritganda, boshqacha xatti-harakatlarga ega bo'lishga undash yaxshi bo'lardi.</p>
<p>Buning usullaridan biri potentsial manfiy raqamlarga ruxsat berish uchun taxminni faqat <code>u32</code> o‚Äòrniga <code>i32</code> sifatida tahlil qilish va keyin diapazondagi raqamni tekshirishni qo‚Äòshishdir, masalan:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut taxmin)
</span><span class="boring">            .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span>        let taxmin: i32 = match taxmin.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if taxmin &lt; 1 || taxmin &gt; 100 {
            println!(&quot;Yashirin raqam 1 dan 100 gacha bo'ladi.&quot;);
            continue;
        }

        match taxmin.cmp(&amp;yashirin_raqam) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Siz yutdingiz!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
<p><code>If</code> ifodasi bizning qiymatimiz diapazondan tashqarida yoki yo‚Äòqligini tekshiradi, foydalanuvchiga muammo haqida xabar beradi va siklning keyingi iteratsiyasini boshlash uchun <code>continue</code> ni chaqiradi va yana bir taxminni so‚Äòraydi. <code>if</code> ifodasidan keyin <code>taxmin</code> 1 dan 100 gacha ekanligini bilgan holda <code>taxmin</code> va maxfiy raqam o‚Äòrtasidagi taqqoslashni davom ettirishimiz mumkin.</p>
<p>Biroq, bu ideal echim emas: agar dastur faqat 1 dan 100 gacha bo'lgan qiymatlarda ishlaganligi juda muhim bo'lsa va bu talab bilan ko'plab funksiyalarga ega bo'lsa, har bir funksiyada bunday tekshiruvga ega bo'lish zerikarli bo'ladi (va ishlashga ta'sir qilishi mumkin).</p>
<p>Buning o'rniga, biz yangi turni yaratishimiz va tekshirishlarni hamma joyda takrorlashdan ko'ra, turdagi namunani yaratish uchun funksiyaga qo'yishimiz mumkin. Shunday qilib, funksiyalar o'zlarining imzolarida yangi turdan foydalanishlari va ular olgan qiymatlardan ishonchli foydalanishlari xavfsiz bo'ladi. 9-13 ro ªyxatda <code>Taxmin</code> turini aniqlashning bir usuli ko ªrsatilgan, bu <code>new</code> funksiya 1 dan 100 gacha bo ªlgan qiymatni qabul qilsagina <code>Taxmin</code> misolini yaratadi.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Taxmin {
    qiymat: i32,
}

impl Taxmin {
    pub fn new(qiymat: i32) -&gt; Taxmin {
        if qiymat &lt; 1 || qiymat &gt; 100 {
            panic!(&quot;Taxmin qilingan qiymat 1 dan 100 gacha bo'lishi kerak, {} qabul qilnmaydi.&quot;, qiymat);
        }

        Taxmin { qiymat }
    }

    pub fn qiymat(&amp;self) -&gt; i32 {
        self.qiymat
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 9-13: <code>Taxmin</code> turi, u faqat 1 dan 100 gacha qiymatlar bilan davom etadi</span></p>
<p>Birinchidan, biz <code>i32</code> ga ega <code>qiymat</code> nomli maydonga ega <code>Taxmin</code> nomli structni aniqlaymiz. Bu yerda raqam saqlanadi.</p>
<p>Keyin biz <code>Taxmin</code> da <code>new</code> nomli bog'langan funktsiyani amalga oshiramiz, u <code>Taxmin</code> qiymatlari misollarini yaratadi. <code>new</code> funksiya <code>i32</code> turidagi <code>qiymat</code> nomli bitta parametrga ega bo‚Äòlishi va <code>Taxmin</code>ni qaytarishi uchun belgilangan. <code>new</code> funksiyaning asosiy qismidagi kod <code>qiymat</code>ni 1 dan 100 gacha ekanligiga ishonch hosil qilish uchun tekshiradi.
Agar <code>qiymat</code> bu sinovdan o‚Äòtmasa, biz <code>panic!</code> chaqiruvini qilamiz, bu chaqiruv kodini yozayotgan dasturchini tuzatishi kerak bo‚Äòlgan xatolik haqida ogohlantiradi, chunki bu diapazondan tashqarida <code>qiymat</code> bilan <code>Taxmin</code> yaratish <code>Taxmin::new</code> tayanadigan qoidani buzadi. <code>Taxmin::new</code> panic qo'zg'atishi mumkin bo'lgan shartlar uning API texnik hujjatlarida muhokama qilinishi kerak; biz 14-bobda yaratgan API texnik hujjatlarida <code>panic!</code> ehtimolini ko‚Äòrsatuvchi hujjatlar konventsiyalarini qamrab olamiz. Agar <code>qiymat</code> testdan o'tgan bo'lsa, biz uning <code>qiymat</code> maydoni <code>qiymat</code> parametriga o'rnatilgan yangi <code>Taxmin</code> yaratamiz va <code>Taxmin</code>ni qaytaramiz.</p>
<p>Keyinchalik, biz <code>self</code> ni oladigan, boshqa parametrlarga ega bo'lmagan va <code>i32</code> ni qaytaradigan <code>qiymat</code> nomli metodni qo'llaymiz. Bunday usul ba'zan <em>getter(oluvchi)</em> deb ataladi, chunki uning maqsadi o'z maydonlaridan ba'zi ma'lumotlarni olish va uni qaytarishdir. Ushbu umumiy metod zarur, chunki <code>Taxmin</code> strukturasining <code>qiymat</code> maydoni shaxsiydir(private). <code>qiymat</code> maydoni shaxsiy(private) bo'lishi juda muhim, shuning uchun <code>Taxmin</code> strukturasi yordamida kod to'g'ridan-to'g'ri <code>qiymat</code> ni o'rnatishga ruxsat berilmaydi: moduldan tashqaridagi kod <code>Taxmin::new</code> funksiyasidan <code>Taxmin</code> misolini yaratish uchun foydalanishi kerak, shunday qilib, <code>Taxmin</code> ning <code>Taxmin::new</code> funksiyasidagi shartlar bo‚Äòyicha tekshirilmagan <code>qiymat</code>ga ega bo‚Äòlishining imkoni yo‚Äòqligini ta‚Äôminlaydi.</p>
<p>Parametrga ega bo'lgan yoki faqat 1 dan 100 gacha bo'lgan raqamlarni qaytaradigan funksiya o'z imzosida <code>i32</code> emas, <code>Taxmin</code> ni olishi yoki qaytarishi va uning tanasida qo'shimcha tekshiruvlar o'tkazishga hojat qolmasligini e'lon qilishi mumkin.</p>
<h2 id="xulosa-8"><a class="header" href="#xulosa-8">Xulosa</a></h2>
<p>Rust-ning xatolarni boshqarish xususiyatlari sizga yanada mustahkam kod yozishga yordam berish uchun mo'ljallangan.
<code>panic!</code> makrosi dasturingiz u bardosh bera olmaydigan holatda ekanligini bildiradi va noto‚Äòg‚Äòri yoki noto‚Äòg‚Äòri qiymatlar bilan davom etish o‚Äòrniga jarayonni to‚Äòxtatishni aytish imkonini beradi. <code>Result</code> enumi operatsiyalar muvaffaqiyatsiz bo'lishi va kodingiz tiklanishi mumkinligini bildirish uchun Rust turdagi tizimdan foydalanadi. Kodingizga chaqiruv qiladigan kod potentsial muvaffaqiyat yoki muvaffaqiyatsizlikni hal qilishi kerakligini aytish uchun <code>Result</code> dan foydalanishingiz mumkin. Tegishli vaziyatlarda <code>panic!</code> va <code>Result</code> dan foydalanish muqarrar muammolar oldida kodingizni yanada ishonchli qiladi.</p>
<p>Endi siz standart kutubxonada <code>Option</code> va <code>Result</code> enumlari bilan generiklardan foydalanishning foydali usullarini ko'rganingizdan so'ng, biz generiklar qanday ishlashi va ularni kodingizda qanday ishlatishingiz haqida gaplashamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generik-turlar-traitlar-va-lifetimelar"><a class="header" href="#generik-turlar-traitlar-va-lifetimelar">Generik turlar, Traitlar va Lifetimelar</a></h1>
<p>Har bir dasturlash tilida kontseptsiyalarning takrorlanishini samarali boshqarish vositalari mavjud. Rustda bunday vositalardan biri <em>generiklar</em>: concrete  turlari yoki boshqa xususiyatlar uchun mavhum stendlar. Kodni kompilyatsiya qilish va ishga tushirishda ularning o'rnida nima bo'lishini bilmasdan, biz generiklarning xatti-harakatlarini yoki ularning boshqa generiklar bilan qanday bog'liqligini ifodalashimiz mumkin.</p>
<p>Funktsiyalar <code>i32</code> yoki <code>String</code> kabi aniq turdagi o'rniga ba'zi umumiy turdagi parametrlarni olishi mumkin, xuddi shu tarzda funksiya bir xil kodni bir nechta aniq qiymatlarda ishlatish uchun noma'lum qiymatlarga ega parametrlarni oladi. Aslida, biz 6-bobda <code>Option&lt;T&gt;</code>, 8-bobda <code>Vec&lt;T&gt;</code> va <code>HashMap&lt;K, V&gt;</code> va 9-bobda <code>Result&lt;T, E&gt;</code> bilan generiklardan allaqachon foydalanganmiz. Ushbu bobda siz o'zingizning turlaringizni, funksiyalaringizni va metodlaringizni generiklar bilan qanday aniqlashni o'rganasiz!</p>
<p>Birinchidan, kodning takrorlanishini kamaytirish uchun funksiyani qanday chiqarishni ko'rib chiqamiz. Keyin biz bir xil texnikadan faqat parametrlari turida farq qiladigan ikkita funksiyadan umumiy funksiyani yaratamiz. Shuningdek, biz struct va enum ta'riflarida generik turlardan qanday foydalanishni tushuntiramiz.</p>
<p>Keyin xulq-atvorni umumiy tarzda aniqlash uchun <em>traitlar</em> dan qanday foydalanishni o'rganasiz. Har qanday turdan farqli o'laroq, faqat ma'lum bir xatti-harakatga ega bo'lgan turlarni qabul qilish uchun umumiy turni cheklash uchun traitlarni umumiy turlar bilan birlashtira olasiz.</p>
<p>Va nihoyat, biz <em>lifetimelar</em> haqida gaplashamiz: kompilyatorga referencelar bir-biriga qanday bog'liqligi haqida ma'lumot beradigan turli xil generiklar. Lifetimelar kompilyatorga olingan qiymatlar haqida yetarli ma'lumot berishga imkon beradi, shunda u murojaatlar bizning yordamimizsiz ko'proq holatlarda haqiqiy bo'lishini ta'minlaydi.</p>
<h2 id="funksiyani-ajratib-olish-orqali-takrorlanishni-olib-tashlash"><a class="header" href="#funksiyani-ajratib-olish-orqali-takrorlanishni-olib-tashlash">Funksiyani ajratib olish orqali takrorlanishni olib tashlash</a></h2>
<p>Generiklar bizga kodning takrorlanishini olib tashlash uchun bir nechta turlarni ifodalovchi maxsus turlarni to'ldiruvchi bilan almashtirishga imkon beradi. Generik sintaksisga kirishdan oldin, keling, birinchi navbatda, ma'lum qiymatlarni bir nechta qiymatlarni ifodalovchi to'ldiruvchi bilan almashtiradigan funksiyani chiqarib, generik turlarni o'z ichiga olmaydigan tarzda takrorlashni qanday olib tashlashni ko'rib chiqaylik. Keyin generik funksiyani chiqarish uchun xuddi shu texnikani qo'llaymiz! Funksiyaga chiqarishingiz mumkin bo'lgan takrorlangan kodni qanday tanib olishni ko'rib chiqsangiz, generiklardan foydalanishi mumkin bo'lgan takrorlangan kodni taniy boshlaysiz.</p>
<p>Biz ro'yxatdagi eng katta raqamni topadigan 10-1 ro'yxatidagi qisqa dasturdan boshlaymiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqamlar_listi = vec![34, 50, 25, 100, 65];

    let mut eng_katta = &amp;raqamlar_listi[0];

    for raqam in &amp;raqamlar_listi {
        if raqam &gt; eng_katta {
            eng_katta = raqam;
        }
    }

    println!(&quot;Eng katta raqam {}&quot;, eng_katta);
<span class="boring">    assert_eq!(*eng_katta, 100);
</span>}</code></pre></pre>
<p><span class="caption">Ro'yxat 10-1: Raqamlar ro'yxatidagi eng katta raqamni topish</span></p>
<p>Biz butun sonlar ro ªyxatini <code>raqamlar_listi</code> o ªzgaruvchisida saqlaymiz va ro ªyxatdagi birinchi raqamga referenceni <code>eng_katta</code> nomli o ªzgaruvchiga joylashtiramiz. Keyin biz ro ªyxatdagi barcha raqamlarni takrorlaymiz va agar joriy raqam <code>eng_katta</code>da saqlangan raqamdan katta bo ªlsa, ushbu o ªzgaruvchidagi referenceni almashtiramiz.
Biroq, agar joriy raqam hozirgacha ko'rilgan eng katta raqamdan kichik yoki unga teng bo'lsa, o'zgaruvchi o'zgarmaydi va kod ro'yxatdagi keyingi raqamga o'tadi. Ro'yxatdagi barcha raqamlarni ko'rib chiqqandan so'ng, <code>eng_katta</code> eng katta raqamga ishora qilishi kerak, bu holda bu 100 ga teng.</p>
<p>Bizga endi ikki xil raqamlar ro‚Äòyxatidagi eng katta raqamni topish vazifasi qo‚Äòyildi. Buning uchun biz 10-1 ro ªyxatdagi kodni takrorlashni tanlashimiz va 10-2 ro ªyxatda ko ªrsatilganidek, dasturning ikki xil joyida bir xil mantiqdan foydalanishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raqamlar_listi = vec![34, 50, 25, 100, 65];

    let mut eng_katta = &amp;raqamlar_listi[0];

    for raqam in &amp;raqamlar_listi {
        if raqam &gt; eng_katta {
            eng_katta = raqam;
        }
    }

    println!(&quot;Eng katta raqam {}&quot;, eng_katta);

    let raqamlar_listi = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut eng_katta = &amp;raqamlar_listi[0];

    for raqam in &amp;raqamlar_listi {
        if raqam &gt; eng_katta {
            eng_katta = raqam;
        }
    }

    println!(&quot;Eng katta raqam {}&quot;, eng_katta);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 10-2: <em>ikkita</em> raqamlar ro ªyxatidagi eng katta raqamni topish uchun kod</span></p>
<p>Ushbu kod ishlayotgan bo'lsa-da, kodni takrorlash zerikarli va xatolarga moyil. Shuningdek, biz kodni o'zgartirmoqchi bo'lganimizda uni bir nechta joyda yangilashni unutmasligimiz kerak.</p>
<p>Ushbu takrorlanishni bartaraf qilish uchun biz parametrda berilgan butun sonlar ro'yxatida ishlaydigan funktsiyani aniqlash orqali abstraksiya yaratamiz. Ushbu yechim bizning kodimizni aniqroq qiladi va bizga ro'yxatdagi eng katta raqamni topish tushunchasini mavhum tarzda ifodalash imkonini beradi.</p>
<p>10-3 ro'yxatda biz eng katta raqamni topadigan kodni <code>eng_katta</code> deb nomlangan funksiyaga chiqaramiz. Keyin biz 10-2 ro'yxatdagi ikkita ro'yxatdagi eng katta raqamni topish uchun funksiyani chaqiramiz. Bundan tashqari, biz kelajakda ega bo'lishi mumkin bo'lgan <code>i32</code> qiymatlarining boshqa ro'yxatida ham funksiyadan foydalanishimiz mumkin.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn eng_katta(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut eng_katta = &amp;list[0];

    for element in list {
        if element &gt; eng_katta {
            eng_katta = element;
        }
    }

    eng_katta
}

fn main() {
    let raqamlar_listi = vec![34, 50, 25, 100, 65];

    let natija = eng_katta(&amp;raqamlar_listi);
    println!(&quot;Eng katta raqam {}&quot;, natija);
<span class="boring">    assert_eq!(*natija, 100);
</span>
    let raqamlar_listi = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let natija = eng_katta(&amp;raqamlar_listi);
    println!(&quot;Eng katta raqam {}&quot;, natija);
<span class="boring">    assert_eq!(*natija, 6000);
</span>}</code></pre></pre>
<p><span class="caption">Ro'yxat 10-3: Ikkita ro ªyxatdagi eng katta raqamni topish uchun abstrakt kod</span></p>
<p><code>eng_katta</code> funksiya <code>list</code> deb nomlangan parametrga ega bo'lib, biz funktsiyaga o'tkazishimiz mumkin bo'lgan <code>i32</code> qiymatlarining har qanday aniq qismini ifodalaydi. Natijada, biz funksiyani chaqirganimizda, kod biz kiritadigan maxsus qiymatlarda ishlaydi.</p>
<p>Xulosa qilib aytganda, biz kodni kodni 10-2-ro'yxadan 10-3-ro'yxaga o ªzgartirish uchun qilgan qadamlarimiz:</p>
<ol>
<li>Ikki nusxadagi kodni aniqlang.</li>
<li>Ikki nusxadagi kodni funktsiya tanasiga chiqarib oling va ushbu kodning kirish va qaytish qiymatlarini funktsiya imzosida belgilang.</li>
<li>Buning o'rniga funktsiyani chaqirish uchun ikki nusxadagi kodning ikkita nusxasini yangilang.</li>
</ol>
<p>Keyinchalik, kodning takrorlanishini kamaytirish uchun generiklar bilan bir xil qadamlardan foydalanamiz. Xuddi shu tarzda, funksiya tanasi ma'lum qiymatlar o'rniga mavhum <code>list</code> bo'yicha ishlay oladi, generiklar kodni mavhum turlarda ishlashga imkon beradi.</p>
<p>Misol uchun, bizda ikkita funksiya bor edi deylik: biri <code>i32</code> qiymatlari bo‚Äòlimidagi eng katta elementni topadigan va ikkinchisi <code>char</code> qiymatlari bo‚Äòlimidagi eng katta elementni topadigan. Bu takroriylikni qanday yo'q qilamiz? Keling, bilib olaylik!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generik-malumotlar-turlari"><a class="header" href="#generik-malumotlar-turlari">Generik ma'lumotlar turlari</a></h2>
<p>Funksiya imzolari yoki structlar kabi elementlar uchun definitionlarni yaratish uchun biz generik(umumiy) ma'lumotlardan foydalanamiz, keyin ularni turli xil aniq ma'lumotlar turlari bilan ishlatishimiz mumkin. Keling, avval generiklar yordamida funksiyalar, structlar, enumlar va metodlarni qanday aniqlashni ko'rib chiqaylik. Keyin biz generiklar kod ishlashiga qanday ta'sir qilishini muhokama qilamiz.</p>
<h3 id="funksiya-tariflarida"><a class="header" href="#funksiya-tariflarida">Funksiya ta'riflarida</a></h3>
<p>Generiklardan foydalanadigan funksiyani belgilashda biz generiklarni funksiya imzosiga joylashtiramiz, u yerda biz odatda parametrlarning ma'lumotlar turlarini va qiymatni qaytaramiz. Bu bizning kodimizni yanada moslashuvchan qiladi va kodning takrorlanishining oldini olish bilan birga funksiyamizni chaqiruvchilarga ko'proq funksionallik beradi.</p>
<p><code>eng_katta</code> funksiyamizni davom ettirsak, 10-4 ro ªyxatda ikkalasi ham bo ªlakdagi eng katta qiymatni topadigan ikkita funksiya ko ªrsatilgan. Keyin biz ularni generiklardan foydalanadigan yagona funksiyaga birlashtiramiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn eng_katta_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut eng_katta = &amp;list[0];

    for element in list {
        if element &gt; eng_katta {
            eng_katta = element;
        }
    }

    eng_katta
}

fn eng_katta_char(list: &amp;[char]) -&gt; &amp;char {
    let mut eng_katta = &amp;list[0];

    for element in list {
        if element &gt; eng_katta {
            eng_katta = element;
        }
    }

    eng_katta
}

fn main() {
    let raqamlar_listi = vec![34, 50, 25, 100, 65];

    let natija = eng_katta_i32(&amp;raqamlar_listi);
    println!(&quot;Eng katta raqam {}&quot;, natija);
<span class="boring">    assert_eq!(*natija, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let natija = eng_katta_char(&amp;char_list);
    println!(&quot;Eng katta belgi {}&quot;, natija);
<span class="boring">    assert_eq!(*natija, 'y');
</span>}</code></pre></pre>
<p><span class="caption">Ro ªyxat 10-4: Ikki funksiya faqat nomlari va imzolaridagi turlari bilan farqlanadi</span></p>
<p><code>eng_katta_i32</code> funksiyasi biz 10-3 ro ªyxatda ajratib olingan funksiya bo ªlib, u bo ªlakdagi eng katta <code>i32</code>ni topadi. <code>eng_katta_char</code> funksiyasi bo‚Äòlakdagi eng katta <code>char</code>ni topadi. Funksiya organlari bir xil kodga ega, shuning uchun bitta funksiyaga generik turdagi parametrni kiritish orqali takrorlanishni bartaraf qilaylik.</p>
<p>Yangi bitta funksiyada turlarni parametrlash uchun, biz funksiyaning qiymat parametrlari uchun qilganimiz kabi, tur parametrini nomlashimiz kerak. Tur parametri nomi sifatida istalgan identifikatordan foydalanishingiz mumkin. Lekin biz <code>T</code> dan foydalanamiz, chunki Rust-dagi parametr nomlari odatda qisqa, ko ªpincha harfdan iborat bo ªladi va Rustning tur nomlash konventsiyasi UpperCamelCase hisoblanadi. ‚Äútype(tur)‚Äù so'zining qisqartmasi <code>T</code>, Rust dasturchilarining ko'pchiligining standart tanlovidir.</p>
<p>Funksiya tanasida parametrdan foydalanganda, biz imzoda parametr nomini e'lon qilishimiz kerak, shunda kompilyator bu nom nimani anglatishini biladi.
Xuddi shunday, biz funktsiya imzosida tup parametri nomini ishlatganimizda, uni ishlatishdan oldin parametr nomini e'lon qilishimiz kerak. Generik <code>eng_katta</code> funksiyani aniqlash uchun burchakli qavslar ichida <code>&lt;&gt;</code> nomi deklaratsiyasini funksiya nomi va parametrlar ro'yxati orasiga qo'ying, masalan:</p>
<pre><code class="language-rust ignore">fn eng_katta&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Biz bu ta ºrifni shunday o ªqiymiz: <code>eng_katta</code> funksiyasi <code>T</code> turiga nisbatan umumiydir. Bu funksiya <code>list</code> nomli bitta parametrga ega, bu <code>T</code> turidagi qiymatlar bo'lagidir. <code>eng_katta</code> funksiya bir xil turdagi <code>T</code> qiymatiga referenceni qaytaradi.</p>
<p>10-5 ro'yxatda imzodagi umumiy ma'lumotlar turidan foydalangan holda birlashtirilgan <code>eng_katta</code> funksiya ta'rifi ko'rsatilgan. list shuningdek, funktsiyani <code>i32</code> yoki <code>char</code> qiymatlari bilan qanday chaqirishimiz mumkinligini ko'rsatadi. E'tibor bering, bu kod hali kompilyatsiya qilinmaydi, ammo biz uni ushbu bobda keyinroq tuzatamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn eng_katta&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut eng_katta = &amp;list[0];

    for element in list {
        if element &gt; eng_katta {
            eng_katta = element;
        }
    }

    eng_katta
}

fn main() {
    let raqamlar_listi = vec![34, 50, 25, 100, 65];

    let natija = eng_katta(&amp;raqamlar_listi);
    println!(&quot;Eng katta raqam {}&quot;, natija);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let natija = eng_katta(&amp;char_list);
    println!(&quot;Eng katta belgi {}&quot;, natija);
}</code></pre>
<p><span class="caption">Ro'yxat 10-5: Generik turdagi parametrlardan foydalangan holda <code>eng_katta</code> funksiya; bu hali kompilyatsiya qilinmagan</span></p>
<p>Agar dasturni hozir kompilyatsiya qilsak, biz quyidagi xatolikni olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if element &gt; eng_katta {
  |            ------- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn eng_katta&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             +++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Yordam matnida <code>std::cmp::PartialOrd</code> qayd etilgan, bu <em>trait</em> va biz keyingi bo'limda traitlar haqida gaplashamiz. Hozircha shuni bilingki, bu xato <code>eng_katta</code> tanasi <code>T</code> bo'lishi mumkin bo'lgan barcha mumkin bo'lgan turlar uchun ishlamasligini bildiradi. Kod tanasidagi <code>T</code> turidagi qiymatlarni solishtirmoqchi bo'lganimiz uchun biz faqat qiymatlari ordere qilinadigan turlardan foydalanishimiz mumkin. Taqqoslashni yoqish uchun standart kutubxona <code>std::cmp::PartialOrd</code> traitiga ega bo'lib, uni turlarga tatbiq etishingiz mumkin (bu trait haqida batafsil ma'lumot uchun C ilovasiga qarang). Yordam matnining taklifiga amal qilib, biz <code>T</code> uchun amal qiladigan turlarni faqat <code>PartialOrd</code>-ni qo'llaydiganlar bilan cheklaymiz va bu misol kompilyatsiya qilinadi, chunki standart kutubxona <code>PartialOrd</code>ni ham <code>i32</code> va <code>char</code> da qo'llaydi.</p>
<h3 id="struktura-definitionlarida"><a class="header" href="#struktura-definitionlarida">Struktura Definitionlarida</a></h3>
<p>Shuningdek, biz <code>&lt;&gt;</code> sintaksisi yordamida bir yoki bir nechta maydonlarda generik turdagi parametrlardan foydalanish uchun structlarni belgilashimiz mumkin. Ro'yxat 10-6 har qanday turdagi <code>x</code> va <code>y</code> koordinata qiymatlarini saqlash uchun <code>Point&lt;T&gt;</code> structni belgilaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">10-6 ro ªyxat: <code>T</code> turidagi <code>x</code> va <code>y</code> qiymatlarini o ªz ichiga olgan <code>Point&lt;T&gt;</code> structi</span></p>
<p>Struktura ta'riflarida generiklardan foydalanish sintaksisi funksiya ta'riflarida qo'llaniladigan sintaksisiga juda o ªxshaydi. Birinchidan, burchakli qavslar ichida strukturaning nomidan keyin tur parametrining nomini e'lon qilamiz. Keyin biz aniq ma'lumotlar turlarini ko'rsatadigan struct ta'rifida generik turdan foydalanamiz.</p>
<p>Esda tutingki, biz <code>Point&lt;T&gt;</code>ni aniqlash uchun faqat bitta generik turdan foydalanganmiz, bu ta ºrifda aytilishicha, <code>Point&lt;T&gt;</code> structi ba'zi bir <code>T</code> turiga nisbatan umumiy bo ªlib, <code>x</code> va <code>y</code> maydonlari qaysi turdagi bo ªlishidan qat ºi nazar bir xil turdagi dir. Agar biz 10-7 ro'yxatdagi kabi har xil turdagi qiymatlarga ega bo'lgan <code>Point&lt;T&gt;</code> nusxasini yaratsak, bizning kodimiz kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let ishlamaydi = Point { x: 5, y: 4.0 };
}</code></pre>
<p><span class="caption">Ro ªyxat 10-7: <code>x</code> va <code>y</code> maydonlari bir xil turdagi bo ªlishi kerak, chunki ikkalasi ham bir xil umumiy ma ºlumotlar turi <code>T</code>ga ega.</span></p>
<p>Ushbu misolda, biz <code>x</code> ga 5 butun qiymatini belgilaganimizda, kompilyatorga <code>T</code> generik turi <code>Point&lt;T&gt;</code> misoli uchun butun son bo'lishini bildiramiz. Keyin biz <code>x</code> bilan bir xil turga ega ekanligini aniqlagan <code>y</code> uchun 4.0 ni belgilaganimizda, biz quyidagi turdagi nomuvofiqlik xatosini olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let ishlamaydi = Point { x: 5, y: 4.0 };
  |                                       ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p><code>x</code> va <code>y</code> ikkalasi ham generik bo'lgan, lekin har xil turlarga ega bo'lishi mumkin bo'lgan <code>Point</code> strukturasini aniqlash uchun biz bir nechta generik turdagi parametrlardan foydalanishimiz mumkin. Masalan, 10-8 ro ªyxatda biz <code>Point</code> ta ºrifini <code>T</code> va <code>U</code> turlari bo ªyicha umumiy qilib o ªzgartiramiz, bunda <code>x</code> <code>T</code> turiga, <code>y</code> esa <code>U</code> turiga tegishli.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let ikkita_integer = Point { x: 5, y: 10 };
    let ikkita_float = Point { x: 1.0, y: 4.0 };
    let integer_va_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 10-8: <code>x</code> va <code>y</code> har xil turdagi qiymatlar bo ªlishi uchun ikki turdagi umumiy <code>Point&lt;T, U&gt;</code>.</span></p>
<p>Endi ko'rsatilgan <code>Point</code> ning barcha misollariga ruxsat berilgan! Ta'rifda siz xohlagancha turdagi parametrlardan generik foydalanishingiz mumkin, lekin bir nechtadan ko'proq foydalanish kodingizni o'qishni qiyinlashtiradi. Agar siz kodingizda ko'plab generik turlar kerakligini aniqlasangiz, bu sizning kodingizni kichikroq qismlarga qayta qurish kerakligini ko'rsatishi mumkin.</p>
<h3 id="enum-definitionlarida"><a class="header" href="#enum-definitionlarida">Enum Definitionlarida</a></h3>
<p>Structlar bilan qilganimizdek, ularning variantlarida generik ma'lumotlar turlarini saqlash uchun enumlarni belgilashimiz mumkin. Biz 6-bobda foydalanilgan standart kutubxona taqdim etadigan <code>Option&lt;T&gt;</code> enumini yana bir ko'rib chiqamiz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Bu ta'rif endi siz uchun yanada ma'noli bo'lishi kerak. Ko'rib turganingizdek, <code>Option&lt;T&gt;</code> enum <code>T</code> turiga nisbatan generik va ikkita variantga ega: <code>T</code> turidagi bitta qiymatga ega <code>Some</code> va hech qanday qiymatga ega bo'lmagan <code>None</code> varianti.
<code>Option&lt;T&gt;</code> enum yordamida biz ixtiyoriy qiymatning mavhum kontseptsiyasini ifodalashimiz mumkin va <code>Option&lt;T&gt;</code> umumiy bo'lgani uchun biz ixtiyoriy qiymatning turi qanday bo'lishidan qat`i nazar, bu abstraktsiyadan foydalanishimiz mumkin.</p>
<p>Enumlar bir nechta generik turlardan ham foydalanishi mumkin. Biz 9-bobda aytib o'tgan <code>Result</code> enumining ta'rifi ushbu foydalanishga misoldir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result</code> enumlari ikki xil, <code>T</code> va <code>E</code> uchun generikdir va ikkita variantga ega: <code>T</code> turidagi qiymatga ega <code>OK</code> va <code>E</code> turidagi qiymatga ega bo'lgan <code>Err</code>. Bu ta ºrif <code>Result</code> enumidan bizda muvaffaqiyatli bo ªlishi mumkin bo ªlgan (<code>T</code> turidagi qiymatni qaytarish) yoki muvaffaqiyatsiz bo ªlishi mumkin bo ªlgan (<code>E</code> turidagi xatolikni qaytarish) istalgan joyda foydalanishni qulay qiladi. Aslida, biz 9-3 ro'yxatdagi faylni shunday ochar edik, bu yerda fayl muvaffaqiyatli ochilganda <code>T</code> <code>std::fs::File</code> turi bilan to'ldirilgan va faylni ochishda muammolar yuzaga kelganda <code>E</code> <code>std::io::Error</code> turi bilan to`ldirilgan.</p>
<p>Kodingizdagi vaziyatlarni faqat ular ega bo'lgan qiymatlar turlarida farq qiluvchi bir nechta struct yoki enum ta'riflari bilan tanib olganingizda, uning o'rniga generik turlardan foydalanish orqali takrorlanishdan qochishingiz mumkin.</p>
<h3 id="metod-definitionlarida"><a class="header" href="#metod-definitionlarida">Metod Definitionlarida</a></h3>
<p>Biz structlar va enumlar bo'yicha metodlarni qo'llashimiz mumkin (5-bobda qilganimiz kabi) va ularning ta'riflarida generik turlardan ham foydalanishimiz mumkin. 10-9 ro'yxatda biz 10-6 ro'yxatda belgilagan <code>Point&lt;T&gt;</code> structi ko'rsatilgan va unda <code>x</code> nomli metod qo'llaniladi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 10-9: <code>Point&lt;T&gt;</code> structida <code>x</code> nomli metodni qo'llash, bu <code>T</code> turidagi <code>x</code> maydoniga referenceni qaytaradi</span></p>
<p>Bu yerda biz <code>Point&lt;T&gt;</code> da <code>x</code> nomli metodni belgilab oldik, u <code>x</code> maydonidagi ma`lumotlarga referenceni qaytaradi.</p>
<p>Esda tutingki, biz <code>impl</code> dan keyin <code>T</code> ni e'lon qilishimiz kerak, shuning uchun biz <code>Point&lt;T&gt;</code> turidagi metodlarni amalga oshirayotganimizni aniqlash uchun <code>T</code> dan foydalanishimiz mumkin. <code>T</code> ni <code>impl</code> dan keyin generik tur sifatida e'lon qilish orqali Rust <code>Point</code> dagi burchak qavslaridagi tur aniq tur emas, balki generik tur ekanligini aniqlay oladi. Biz ushbu umumiy parametr uchun struct ta ºrifida e ºlon qilingan generik parametrdan boshqa nom tanlashimiz mumkin edi, lekin bir xil nomdan foydalanish odatiy hisoblanadi. Generik turni e'lon qiladigan <code>impl</code> ichida yozilgan metodlar, generik turdagi o'rnini bosadigan aniq turdagi qanday bo'lishidan qat'i nazar, har qanday turdagi namunada aniqlanadi.</p>
<p>Tur bo'yicha metodlarni belgilashda generik turlarga cheklovlarni ham belgilashimiz mumkin. Biz, masalan, har qanday generik turdagi <code>Point&lt;T&gt;</code> misollarida emas, balki faqat <code>Point&lt;f32&gt;</code> misollarida metodlarni amalga oshirishimiz mumkin. 10-10 ro'yxatda biz <code>f32</code> aniq turidan foydalanamiz, ya'ni <code>impl</code> dan keyin hech qanday turni e'lon qilmaymiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn kelib_chiqishidan_masofa(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro ªyxat 10-10: <code>impl</code> bloki, faqat <code>T</code> generik tur parametri uchun ma`lum bir aniq turdagi strukturaga tegishli.</span></p>
<p>Bu kod <code>Point&lt;f32&gt;</code> turi <code>kelib_chiqishidan_masofa</code> metodiga ega bo'lishini bildiradi; <code>T</code> <code>f32</code> turiga tegishli bo'lmagan <code>Point&lt;T&gt;</code> ning boshqa misollarida bu metod aniqlanmaydi. Metod bizning pointimizning koordinatadagi nuqtadan qanchalik uzoqligini o'lchaydi (0,0, 0,0) va faqat floating point turlari uchun mavjud bo'lgan matematik operatsiyalardan foydalanadi.</p>
<p>Struct ta ºrifidagi generik turdagi parametrlar har doim ham o ªsha structning metod imzolarida foydalanadigan parametrlar bilan bir xil bo ªlavermaydi. 10-11 ro ªyxatda misolni aniqroq qilish uchun <code>Point</code>  structsi uchun <code>X1</code> va <code>Y1</code> va <code>aralashtirish</code> metodi imzosi uchun <code>X2</code> <code>Y2</code> generik turlari qo ªllaniladi. Metod yangi <code>Point</code> misolini yaratadi
<code>self</code> <code>Point</code> (<code>X1</code> turidagi) <code>x</code> qiymati va o'tkazilgan <code>Point</code> (<code>Y2</code> turidagi) <code>y</code> qiymati.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn aralashtirish&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Salom&quot;, y: 'c' };

    let p3 = p1.aralashtirish(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 10-11: O'zining strukturasi ta'rifidan farqli generik turlardan foydalanadigan metod</span></p>
<p><code>main</code>da biz <code>x</code> uchun <code>i32</code> (<code>5</code> qiymati bilan) va <code>y</code> uchun <code>f64</code> (<code>10,4</code> qiymati bilan) bo'lgan <code>Point</code> ni aniqladik. <code>p2</code> o'zgaruvchisi bu <code>Point</code> structi bo'lib, <code>x</code> (<code>Salom</code> qiymati bilan) va <code>y</code> (<code>c</code> qiymati bilan) uchun <code>char</code> bo'lagiga ega. <code>p1</code> da <code>aralashtirish</code>ni <code>p2</code> argumenti bilan chaqirish bizga <code>p3</code>ni beradi, bunda <code>x</code> uchun <code>i32</code> bo‚Äòladi, chunki <code>x</code> <code>p1</code> dan kelgan. <code>p3</code> o‚Äòzgaruvchisi <code>y</code> uchun <code>char</code>ga ega bo‚Äòladi, chunki <code>y</code> <code>p2</code> dan kelgan. <code>println!</code> makro chaqiruvi <code>p3.x = 5, p3.y = c</code> ni chop etadi.</p>
<p>Ushbu misolning maqsadi ba'zi generik parametrlar <code>impl</code> bilan e'lon qilingan va ba'zilari metod ta'rifi bilan e'lon qilingan vaziyatni ko'rsatishdir. Bu erda <code>X1</code> va <code>Y1</code> generik parametrlari <code>impl</code> dan keyin e'lon qilinadi, chunki ular struct ta'rifiga mos keladi. <code>X2</code> va <code>Y2</code> generik parametrlari <code>fn aralashtirish</code> dan keyin e'lon qilinadi, chunki ular faqat metodga tegishli.</p>
<h3 id="generiklar-yordamida-kodning-ishlashi"><a class="header" href="#generiklar-yordamida-kodning-ishlashi">Generiklar yordamida kodning ishlashi</a></h3>
<p>Generik turdagi parametrlardan foydalanganda ish vaqti narxi bor yoki yo'qligini sizni qiziqtirgan bo'lishi mumkin. Yaxshi xabar shundaki, generik turlardan foydalanish dasturingizning aniq turlariga qaraganda sekinroq ishlashiga olib kelmaydi.</p>
<p>Rust buni kompilyatsiya vaqtida generiklar yordamida kodni monomorfizatsiya qilish orqali amalga oshiradi. <em>Monomorfizatsiya</em> - bu kompilyatsiya paytida ishlatiladigan aniq turlarni to'ldirish orqali generik kodni maxsus kodga aylantirish jarayoni. Ushbu jarayonda kompilyator biz 10-5 ro'yxatdagi generik funksiyani yaratishda qo'llagan qadamlarning teskarisini bajaradi: kompilyator generik kod chaqiriladigan barcha joylarni ko'rib chiqadi va generik kod chaqirilgan aniq turlar uchun kod ishlab chiqaradi.</p>
<p>Keling, bu standart kutubxonaning umumiy <code>Option&lt;T&gt;</code> enum yordamida qanday ishlashini ko'rib chiqaylik:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Rust ushbu kodni kompilyatsiya qilganda, u monomorfizatsiyani amalga oshiradi. Ushbu jarayon davomida kompilyator <code>Option&lt;T&gt;</code> misollarida ishlatilgan qiymatlarni o'qiydi va ikki xil <code>Option&lt;T&gt;</code>ni aniqlaydi: biri <code>i32</code>, ikkinchisi esa <code>f64</code>. Shunday qilib, u <code>Option&lt;T&gt;</code> ning umumiy ta'rifini <code>i32</code> va <code>f64</code> uchun ixtisoslashgan ikkita ta'rifga kengaytiradi va shu bilan umumiy ta'rifni o'ziga xos ta'riflar bilan almashtiradi.</p>
<p>Kodning monomorflashtirilgan versiyasi quyidagiga o'xshaydi (kompilyator biz tasvirlash uchun ishlatayotganimizdan boshqa nomlardan foydalanadi):</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>Generik <code>Option&lt;T&gt;</code> kompilyator tomonidan yaratilgan maxsus ta`riflar bilan almashtiriladi. Rust generik kodni har bir misolda turni belgilaydigan kodga kompilyatsiya qilganligi sababli, biz generiklardan foydalanish uchun hech qanday ish vaqti to'lamaymiz. Kod ishga tushganda, agar biz har bir ta'rifni qo'lda takrorlagan bo'lsak, xuddi shunday ishlaydi. Monomorfizatsiya jarayoni Rust generiklarini runtimeda juda samarali qiladi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traitlar-umumiy-xatti-harakatni-aniqlash"><a class="header" href="#traitlar-umumiy-xatti-harakatni-aniqlash">Traitlar: umumiy xatti-harakatni aniqlash</a></h2>
<p><em>trait</em> ma'lum bir turga ega bo'lgan va boshqa turlar bilan bo'lishishi mumkin bo'lgan funksionallikni belgilaydi. Biz umumiy xatti-harakatni mavhum tarzda aniqlash uchun traitlardan foydalanishimiz mumkin. Generik tur ma'lum xatti-harakatlarga ega bo'lgan har qanday tur bo'lishi mumkinligini aniqlash uchun <em>trait (bound)chegaralari</em> dan foydalanishimiz mumkin.</p>
<blockquote>
<p>Eslatma: Traitlar ba'zi farqlarga ega bo'lsa-da, ko'pincha boshqa tillarda
<em>interfeyslar</em> deb ataladigan xususiyatga o'xshaydi.</p>
</blockquote>
<h3 id="traitni-aniqlash"><a class="header" href="#traitni-aniqlash">Traitni aniqlash</a></h3>
<p>Turning xatti-harakati biz ushbu turga murojaat qilishimiz mumkin bo'lgan metodlardan iborat. Agar biz ushbu turlarning barchasida bir xil metodlarni chaqira olsak, har xil turlar bir xil xatti-harakatlarga ega. Trait ta'riflari - bu qandaydir maqsadga erishish uchun zarur bo'lgan xatti-harakatlar to'plamini aniqlash uchun metod imzolarini birgalikda guruhlash usuli.</p>
<p>Misol uchun, bizda turli xil va hajmdagi matnlarni o'z ichiga olgan bir nechta structlar mavjud deylik: ma'lum bir joyda joylashtirilgan yangiliklarni o'z ichiga olgan <code>YangiMaqola</code> structi va eng ko'pi 280 belgidan iborat bo'lishi mumkin bo'lgan <code>Maqola</code> yangi post, retpost yoki boshqa postga javob ekanligini ko'rsatadigan metama'lumotlar.</p>
<p>Biz <code>YangiMaqola</code> yoki <code>Maqola</code> misolida saqlanishi mumkin bo‚Äòlgan ma‚Äôlumotlarning qisqacha mazmunini ko‚Äòrsata oladigan <code>aggregator</code> nomli media agregator kutubxonasini yaratmoqchimiz. Buni amalga oshirish uchun bizga har bir tur bo'yicha xulosa kerak bo'ladi va biz ushbu xulosani misolda <code>umumiy_xulosa</code> metodini chaqirish orqali so'raymiz. 10-12 ro'yxatda ushbu xatti-harakatni ifodalovchi umumiy <code>Xulosa</code> traitining ta'rifi ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Xulosa {
    fn umumiy_xulosa(&amp;self) -&gt; String;
}</code></pre>
<p><span class="caption">Ro ªyxat 10-12: <code>umumiy_xulosa</code> metodi bilan ta ºminlangan xatti-harakatlardan iborat <code>Xulosa</code> traiti</span></p>
<p>Bu yerda biz <code>trait</code> kalit so'zidan foydalanib traitni e'lon qilamiz, so'ngra belgi nomi, bu holda <code>Xulosa</code>. Shuningdek, biz ushbu traitni <code>pub</code> deb e‚Äôlon qildik, shunda bu cratega bog‚Äòliq bo‚Äòlgan cratelar ham bu traitdan foydalanishi mumkin, buni bir necha misollarda ko‚Äòramiz. Jingalak qavslar ichida biz ushbu traitni amalga oshiradigan turlarning xatti-harakatlarini tavsiflovchi metod imzolarini e'lon qilamiz, bu holda <code>fn umumiy_xulosa(&amp;self) -&gt; String</code>.</p>
<p>Metod imzosidan so'ng, jingalak qavslar ichida amalga oshirish o'rniga, biz nuqta-verguldan foydalanamiz. Ushbu traitni amalga oshiradigan har bir tur metod tanasi uchun o'ziga xos xatti-harakatni ta'minlashi kerak. Kompilyator <code>Xulosa</code> traitiga ega bo ªlgan har qanday turda aynan shu imzo bilan aniqlangan <code>umumiy_xulosa</code> metodi bo ªlishini talab qiladi.</p>
<p>Traitining tanasida bir nechta metodlar bo'lishi mumkin: metod imzolari har bir satrda bittadan ko'rsatilgan va har bir satr nuqtali vergul bilan tugaydi.</p>
<h3 id="turga-xos-traitni-amalga-oshirish"><a class="header" href="#turga-xos-traitni-amalga-oshirish">Turga xos traitni amalga oshirish</a></h3>
<p>Endi biz <code>Xulosa</code> traiti metodlarining kerakli imzolarini aniqlaganimizdan so‚Äòng, uni media agregatorimizdagi turlarga qo‚Äòllashimiz mumkin. 10-13 ro ªyxat sarlavhadan foydalanadigan <code>YangiMaqola</code> structidagi <code>Xulosa</code> traitining amalga oshirilishini ko ªrsatadi, muallif va <code>umumiy_xulosa</code> qaytish qiymatini yaratish uchun joy. <code>Maqola</code> structi uchun biz <code>umumiy_xulosa</code>ni foydalanuvchi nomi va undan keyin maqolaning butun matni sifatida belgilaymiz, maqola mazmuni allaqachon 280 belgi bilan cheklangan deb hisoblaymiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct YangiMaqola {
    pub sarlavha: String,
    pub manzil: String,
    pub muallif: String,
    pub mazmuni: String,
}

impl Xulosa for YangiMaqola {
    fn umumiy_xulosa(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.sarlavha, self.muallif, self.manzil)
    }
}

pub struct Maqola {
    pub foydalanuvchi: String,
    pub mazmuni: String,
    pub javob_berish: bool,
    pub repost: bool,
}

impl Xulosa for Maqola {
    fn umumiy_xulosa(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
    }
}</code></pre>
<p><span class="caption">Ro ªyxat 10-13: <code>Xulosa</code> traitini <code>YangiMaqola</code> va <code>Maqola</code> turlariga joriy qilish</span></p>
<p>Traitni turga tatbiq etish odatiy usullarni amalga oshirishga o'xshaydi. Farqi shundaki, <code>impl</code> dan so'ng biz amalga oshirmoqchi bo'lgan trait nomini qo'yamiz, so'ng <code>for</code> kalit so'zidan foydalanamiz va keyin traitni amalga oshirmoqchi bo'lgan tur nomini belgilaymiz. <code>impl</code> blokida biz trait ta'rifi belgilagan metod imzolarini qo'yamiz. Har bir imzodan keyin nuqta-vergul qo'yish o'rniga, biz jingalak qavslardan foydalanamiz va metod tanasini o'ziga xos xatti-harakat bilan to'ldiramiz, biz traitning metodlari ma'lum bir turga ega bo'lishini xohlaymiz.</p>
<p>Kutubxona <code>YangiMaqola</code> va <code>Maqola</code>da <code>Xulosa</code> traitini joriy qilganligi sababli, crate foydalanuvchilari <code>YangiMaqola</code> va <code>Maqola</code> misollaridagi xususiyat metodlarini biz odatdagi metodlar deb ataganimizdek chaqirishlari mumkin. Yagona farq shundaki, foydalanuvchi o'ziga xos traitni turlari bilan bir qatorda qamrab olishi kerak. Binary crate bizning <code>aggregator</code> kutubxonamiz cratesidan qanday foydalanishi mumkinligiga misol:</p>
<pre><code class="language-rust ignore">use aggregator::{Xulosa, Maqola};

fn main() {
    let maqola = Maqola {
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        mazmuni: String::from(
            &quot;Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim&quot;,
        ),
        javob_berish: false,
        repost: false,
    };

    println!(&quot;1 ta yangi xabar: {}&quot;, maqola.umumiy_xulosa());
}</code></pre>
<p>Bu kod <code>1 ta yangi xabar: ismoilovdev: Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim</code> chop etadi.</p>
<p><code>aggregator</code> cratesiga bog'liq bo'lgan boshqa cratelar ham <code>Xulosa</code> traitini o'z turlari bo'yicha <code>Xulosa</code>ni amalga oshirish uchun qamrab olishi mumkin. E'tiborga olish kerak bo'lgan cheklashlardan biri shundaki, biz trait yoki turning hech bo'lmaganda bittasi bizning cratemiz uchun mahalliy(local) bo'lsa, biz traitni turga qo'llashimiz mumkin. Misol uchun, biz <code>Maqola</code> kabi maxsus turdagi <code>Display</code> kabi standart kutubxona traitlarini <code>aggregator</code> crate funksiyamizning bir qismi sifatida amalga oshirishimiz mumkin, chunki <code>Maqola</code> turi <code>aggregator</code> cratemiz uchun mahalliydir. Shuningdek, biz  <code>Vec&lt;T&gt;</code> da <code>Xulosa</code>ni <code>aggregator</code> cratemizda ham qo‚Äòllashimiz mumkin, chunki <code>Xulosa</code> traiti <code>aggregator</code> cratemiz uchun mahalliydir.</p>
<p>Ammo biz tashqi turlarga tashqi traitlarni amalga oshira olmaymiz. Masalan, biz <code>aggregator</code> cratemiz ichida <code>Vec&lt;T&gt;</code> da <code>Display</code> traitini amalga oshira olmaymiz, chunki <code>Display</code> va <code>Vec&lt;T&gt;</code> ikkalasi ham standart kutubxonada belgilangan va bizning <code>aggregator</code> cratemiz uchun mahalliy emas. Bu cheklash <em>kogerentlik(coherence)</em> deb nomlangan xususiyatning bir qismi va aniqrog'i <em>yetim qoidasi(orphan rule)</em>, chunki ota-ona turi mavjud emasligi sababli shunday nomlangan. Bu qoida boshqa odamlarning kodi sizning kodingizni buzmasligini ta'minlaydi va aksincha. Qoidalarsiz ikkita crate bir xil turdagi bir xil traitni amalga oshirishi mumkin edi va Rust qaysi dasturdan foydalanishni bilmaydi.</p>
<h3 id="standart-ilovalar"><a class="header" href="#standart-ilovalar">Standart ilovalar</a></h3>
<p>Ba'zan har bir turdagi barcha metodlarni amalga oshirishni talab qilish o'rniga, traitdagi ba'zi yoki barcha metodlar uchun standart xatti-harakatlarga ega bo'lish foydali bo'ladi.
Keyin, biz traitni ma'lum bir turga qo'llaganimizda, har bir metodning standart xatti-harakatlarini saqlab qolishimiz yoki bekor qilishimiz mumkin.</p>
<p>Ro ªyxat 10-14da biz 10-12 ro'yxatda bo'lgani kabi faqat metod imzosini belgilash o'rniga <code>Xulosa</code> traitining <code>umumiy_xulosa</code> metodi uchun standart qatorni belgilaymiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Xulosa {
    fn umumiy_xulosa(&amp;self) -&gt; String {
        String::from(&quot;(Batafsil...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct YangiMaqola {
</span><span class="boring">    pub sarlavha: String,
</span><span class="boring">    pub manzil: String,
</span><span class="boring">    pub muallif: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for YangiMaqola {}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro ªyxat 10-14: <code>Xulosa</code> traitini <code>umumiy_xulosa</code> metodini standart bo ªyicha amalga oshirish bilan aniqlash</span></p>
<p><code>YangiMaqola</code> misollarini umumlashtirish uchun standart ilovadan foydalanish uchun biz bo'sh <code>impl</code> blokini <code>impl Xulosa for YangiMaqola {}</code> bilan belgilaymiz.</p>
<p>Biz <code>YangiMaqola</code>da to‚Äòg‚Äòridan-to‚Äòg‚Äòri <code>umumiy_xulosa</code> metodini endi aniqlamasak ham, biz standart bo‚Äòyicha dasturni taqdim etdik va <code>YangiMaqola</code> <code>Xulosa</code> traitini amalga oshirishini belgilab oldik. Natijada, biz hali ham <code>YangiMaqola</code> misolida <code>umumiy_xulosa</code> metodini quyidagicha chaqirishimiz mumkin:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, YangiMaqola, Xulosa};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let maqola = YangiMaqola {
        sarlavha: String::from(&quot;Tesla yangi elektromobil ustida ishlayapti&quot;),
        manzil: String::from(&quot;USA&quot;),
        muallif: String::from(&quot;Elon Musk&quot;),
        mazmuni: String::from(
            &quot;Hozirgi kunda Tesla yangi innovatsion elektromobil\
             ustida ishlamoqda.&quot;,
        ),
    };

    println!(&quot;Yangi maqola mavjud! {}&quot;, maqola.umumiy_xulosa());
<span class="boring">}</span></code></pre>
<p>Bu kod <code>Yangi maqola mavjud! (Batafsil...)</code>ni chop etadi.</p>
<p>Standart dasturni yaratish bizdan 10-13 ro ªyxatdagi <code>Maqola</code>dagi <code>Xulosa</code>ni amalga oshirish haqida biror narsani o ªzgartirishimizni talab qilmaydi. Buning sababi, standart dasturni bekor qilish sintaksisi standart dasturga ega bo'lmagan trait metodini amalga oshirish sintaksisi bilan bir xil.</p>
<p>Standart ilovalar bir xil traitga ega bo'lgan boshqa metodlarni chaqirishi mumkin, hatto bu boshqa metodlarda standart dastur bo'lmasa ham. Shunday qilib, trait juda ko'p foydali funksiyalarni taqdim etishi mumkin va amalga oshiruvchilardan faqat uning kichik qismini ko'rsatishni talab qiladi. Misol uchun, biz <code>Xulosa</code> traitini amalga oshirish zarur bo'lgan <code>muallif_haqida</code> metodiga ega bo'lish uchun belgilashimiz va keyin <code>muallif_haqida</code> metodini chaqiradigan standart amalga oshirishga ega bo'lgan <code>umumiy_xulosa</code> metodini belgilashimiz mumkin:</p>
<pre><code class="language-rust noplayground">pub trait Xulosa {
    fn muallif_haqida(&amp;self) -&gt; String;

    fn umumiy_xulosa(&amp;self) -&gt; String {
        format!(&quot;(Batafsil: {}...)&quot;, self.muallif_haqida())
    }
}
<span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn muallif_haqida(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.foydalanuvchi)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>Xulosa</code> ning ushbu versiyasidan foydalanish uchun biz faqat bir turdagi traitni amalga oshirganimizda <code>muallif_haqida</code> ni aniqlashimiz kerak:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn muallif_haqida(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Batafsil: {}...)&quot;, self.muallif_haqida())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Xulosa for Maqola {
    fn muallif_haqida(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.foydalanuvchi)
    }
}</code></pre>
<p><code>muallif_haqida</code> ni aniqlaganimizdan so'ng, biz <code>Maqola</code> structi misollarida <code>umumiy_xulosa</code> deb atashimiz mumkin va <code>umumiy_xulosa</code> standart bajarilishi biz taqdim etgan <code>muallif_haqida</code> ta'rifini chaqiradi. Biz <code>muallif_haqida</code> ni qo'llaganimiz sababli, <code>Xulosa</code> traiti bizga boshqa kod yozishni talab qilmasdan <code>umumiy_xulosa</code> metodining harakatini berdi.</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Xulosa, Maqola};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let maqola = Maqola {
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        mazmuni: String::from(
            &quot;Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim&quot;,
        ),
        javob_berish: false,
        repost: false,
    };

    println!(&quot;1 ta yangi xabar: {}&quot;, maqola.umumiy_xulosa());
<span class="boring">}</span></code></pre>
<p>Bu kod <code>1 ta yangi xabar: (Batafsil: @ismoilovdev...)</code> ni chop etadi.</p>
<p>Shuni esda tutingki, xuddi shu metodni bekor qilish orqali standart dasturni chaqirish mumkin emas.</p>
<h3 id="traitlar-parametr-sifatida"><a class="header" href="#traitlar-parametr-sifatida">Traitlar parametr sifatida</a></h3>
<p>Endi siz traitlarni qanday aniqlash va amalga oshirishni bilganingizdan so'ng, biz ko'plab turlarni qabul qiladigan funksiyalarni aniqlash uchun traitlardan qanday foydalanishni o'rganishimiz mumkin. Biz 10-13 ro ªyxatdagi <code>YangiMaqola</code> va <code>Maqola</code> turlari uchun joriy qilingan <code>Xulosa</code> traitidan foydalanamiz, uning <code>element</code> parametri bo ªyicha umumlashtirish metodlini chaqiradigan <code>xabar_berish</code> funksiyasini belgilaymiz, u <code>Xulosa</code> traitini amalga oshiradi. Buning uchun biz <code>impl Trait</code> sintaksisidan foydalanamiz, masalan:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct YangiMaqola {
</span><span class="boring">    pub sarlavha: String,
</span><span class="boring">    pub manzil: String,
</span><span class="boring">    pub muallif: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for YangiMaqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.sarlavha, self.muallif, self.manzil)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn xabar_berish(element: &amp;impl Xulosa) {
    println!(&quot;Tezkor xabarlar! {}&quot;, element.umumiy_xulosa());
}</code></pre>
<p><code>element</code> parametri uchun aniq tur o'rniga biz <code>impl</code> kalit so'zini va trait nomini belgilaymiz. Ushbu parametr belgilangan traitni amalga oshiradigan har qanday turni qabul qiladi. <code>xabar_berish</code> qismida biz <code>Xulosa</code> traitidan kelib chiqadigan <code>element</code> bo‚Äòyicha har qanday metodlarni chaqirishimiz mumkin, masalan, <code>umumiy_xulosa</code>. Biz <code>xabar_berish</code> ga chaiqruv  qilishimiz va <code>YangiMaqola</code> yoki <code>Maqola</code> ning istalgan misolida o'tishimiz mumkin. Funksiyani <code>String</code> yoki <code>i32</code> kabi boshqa har qanday turdagi chaqiruvchi kod kompilyatsiya qilinmaydi, chunki bu turlar <code>Xulosa</code> ni amalga oshirmaydi.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="traitlarni-cheklash-sintaksisi"><a class="header" href="#traitlarni-cheklash-sintaksisi">Traitlarni cheklash sintaksisi</a></h4>
<p><code>impl Trait</code> sintaksisi oddiy holatlar uchun ishlaydi, lekin aslida <em>trait bound</em> deb nomlanuvchi uzunroq shakl uchun sintaksis shakaridir; bu shunday ko'rinadi:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish&lt;T: Xulosa&gt;(element: &amp;T) {
    println!(&quot;Tezkor xabarlar! {}&quot;, element.umumiy_xulosa());
}</code></pre>
<p>Ushbu uzunroq shakl oldingi bo'limdagi misolga teng, ammo batafsilroq. Trait chegaralarini ikki nuqta va ichki burchakli qavslardan keyin umumiy tur parametri e'lon qilingan holda joylashtiramiz.</p>
<p><code>impl Trait</code> sintaksisi qulay va oddiy holatlarda ixchamroq kodni yaratadi, to'liqroq traitlar bilan bog'langan sintaksisi esa boshqa holatlarda ko'proq murakkablikni ifodalashi mumkin. Misol uchun, bizda <code>Xulosa</code> ni amalga oshiradigan ikkita parametr bo'lishi mumkin. Buni <code>impl Trait</code> sintaksisi bilan bajarish quyidagicha ko'rinadi:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish(element1: &amp;impl Xulosa, element2: &amp;impl Xulosa) {</code></pre>
<p>Agar biz ushbu funksiya <code>element1</code> va <code>element2</code> turli xil turlarga ega bo'lishini istasak, <code>impl Trait</code> dan foydalanish maqsadga muvofiqdir (agar ikkala tur ham <code>Xulosa</code>ni qo'llasa). Agar biz ikkala parametrni bir xil turga ega bo'lishga majburlamoqchi bo'lsak, quyidagi kabi trait bounddan foydalanishimiz kerak:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish&lt;T: Xulosa&gt;(element1: &amp;T, element2: &amp;T) {</code></pre>
<p><code>element1</code> va <code>element2</code> parametrlarining turi sifatida belgilangan umumiy <code>T</code> turi funksiyani shunday cheklaydiki, <code>element1</code> va <code>element2</code> uchun argument sifatida berilgan qiymatning aniq turi bir xil bo`lishi kerak.</p>
<h4 id="-sintaksisi-bilan-bir-nechta-trait-chegaralarini-belgilash"><a class="header" href="#-sintaksisi-bilan-bir-nechta-trait-chegaralarini-belgilash"><code>+</code> sintaksisi bilan bir nechta trait chegaralarini belgilash</a></h4>
<p>Bundan tashqari, biz bir nechta traitlarni belgilashimiz mumkin. Aytaylik, biz <code>xabar_berish</code> funksiyasidan display formatlash hamda <code>element</code> bo‚Äòyicha <code>umumiy_xulosa</code>dan foydalanishni xohladik: biz <code>xabar_berish</code> ta'rifida <code>element</code> <code>Display</code> va <code>Xulosa</code> ni ham amalga oshirishi kerakligini belgilaymiz. Buni <code>+</code> sintaksisi yordamida amalga oshirishimiz mumkin:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish(element: &amp;(impl Xulosa + Display)) {</code></pre>
<p><code>+</code> sintaksisi generik turdagi belgilar chegaralari bilan ham amal qiladi:</p>
<pre><code class="language-rust ignore">pub fn xabar_berish&lt;T: Xulosa+ Display&gt;(element: &amp;T) {</code></pre>
<p>Belgilangan ikkita trait chegarasi bilan <code>xabar_berish</code> asosiy qismi <code>umumiy_xulosa</code> deb chaqirishi va <code>element</code>ni formatlash uchun <code>{}</code> dan foydalanishi mumkin.</p>
<h4 id="where-bandlari-bilan-aniqroq-trait-boundschegaralari"><a class="header" href="#where-bandlari-bilan-aniqroq-trait-boundschegaralari"><code>where</code> bandlari bilan aniqroq trait bounds(chegaralari)</a></h4>
<p>Haddan tashqari ko'p belgilar boundlaridan foydalanish o'zining salbiy tomonlariga ega. Har bir generikning o'ziga xos trait boundlari bor, shuning uchun bir nechta umumiy turdagi parametrlarga ega funksiyalar funksiya nomi va uning parametrlar ro'yxati o'rtasida ko'plab belgilar bilan bog'liq ma'lumotlarni o'z ichiga olishi mumkin, bu funksiya imzosini o'qishni qiyinlashtiradi. Shu sababli, Rust funksiya imzosidan keyin <code>where</code> bandida trait boundlarini belgilash uchun muqobil sintaksisga ega.</p>
<pre><code class="language-rust ignore">fn boshqa_funksiya&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>biz <code>where</code> bandidan foydalanishimiz mumkin, masalan:</p>
<pre><code class="language-rust ignore">fn boshqa_funksiya&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>Bu funksiya imzosi kamroq chalkash: funksiya nomi, parametrlar ro'yxati va qaytish turi bir-biriga yaqin bo'lib, ko'p trait boundlari bo'lmagan funksiyaga o'xshaydi.</p>
<h3 id="traitlarni-amalga-oshiradigan-returnqaytaruvchi-turlar"><a class="header" href="#traitlarni-amalga-oshiradigan-returnqaytaruvchi-turlar">Traitlarni amalga oshiradigan Return(qaytaruvchi) turlar</a></h3>
<p>Bu yerda ko'rsatilganidek, traitni amalga oshiradigan ba'zi turdagi qiymatni qaytarish(return) uchun <code>impl Trait</code> sintaksisini return holatida ham ishlatishimiz mumkin:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Xulosa {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct YangiMaqola {
</span><span class="boring">    pub sarlavha: String,
</span><span class="boring">    pub manzil: String,
</span><span class="boring">    pub muallif: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for YangiMaqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.sarlavha, self.muallif, self.manzil)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Maqola {
</span><span class="boring">    pub foydalanuvchi: String,
</span><span class="boring">    pub mazmuni: String,
</span><span class="boring">    pub javob_berish: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Xulosa for Maqola {
</span><span class="boring">    fn umumiy_xulosa(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.foydalanuvchi, self.mazmuni)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn return_xulosa() -&gt; impl Xulosa {
    Maqola {
        foydalanuvchi: String::from(&quot;ismoilovdev&quot;),
        mazmuni: String::from(
            &quot;Rust kitobi juda foydali ekan, men juda ko'p bilimlarni o'zlashtirdim&quot;,
        ),
        javob_berish: false,
        repost: false,
    }
}</code></pre>
<p>Qaytish(return) turi uchun <code>impl Xulosa</code> dan foydalanib, biz <code>return_xulosa</code> funksiyasi aniq turga nom bermasdan <code>Xulosa</code> traitini amalga oshiradigan ba'zi turlarni qaytarishini aniqlaymiz. Bunday holda, <code>return_xulosa</code> <code>Maqola</code> ni qaytaradi, lekin bu funksiyani chaqiruvchi kod buni bilishi shart emas.</p>
<p>Qaytish turini faqat u amalga oshiradigan traitga ko'ra belgilash qobiliyati, ayniqsa, biz 13-bobda ko'rib chiqiladigan closurelar va iteratorlar kontekstida foydalidir.  Closures va iteratorlar faqat kompilyator biladigan turlarni yoki belgilash uchun juda uzoq turlarni yaratadi. <code>impl Trait</code> sintaksisi sizga funksiya juda uzun turni yozishga hojat qoldirmasdan <code>Iterator</code> traitini amalga oshiradigan ba'zi turlarni qaytarishini qisqacha belgilash imkonini beradi.</p>
<p>Biroq, faqat bitta turni qaytarayotgan bo'lsangiz, <code>impl Trait</code> dan foydalanishingiz mumkin. Masalan, <code>YangiMaqola</code> yoki <code>Maqola</code>ni qaytaruvchi <code>impl Xulosa</code> sifatida ko‚Äòrsatilgan qaytarish turiga ega bo‚Äòlgan bu kod ishlamaydi:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p><code>YangiMaqola</code> yoki <code>Maqola</code>ni qaytarishga <code>impl Trait</code> sintaksisi kompilyatorda qanday amalga oshirilishi bilan bog‚Äòliq cheklovlar tufayli ruxsat berilmaydi. Ushbu xatti-harakat bilan funksiyani qanday yozishni biz 17-bobning <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">&quot;Turli turdagi qiymatlarga ruxsat beruvchi trait ob'ektlaridan foydalanish&quot;</a><!--
ignore --> bo'limida ko'rib chiqamiz.</p>
<h3 id="metodlarni-shartli-ravishda-amalga-oshirish-uchun-trait-boundlardan-foydalanish"><a class="header" href="#metodlarni-shartli-ravishda-amalga-oshirish-uchun-trait-boundlardan-foydalanish">Metodlarni shartli ravishda amalga oshirish uchun Trait Boundlardan foydalanish</a></h3>
<p>Umumiy turdagi parametrlardan foydalanadigan <code>impl</code> bloki bilan trait bounddan foydalanib, biz belgilangan traitlarni amalga oshiradigan turlar uchun metodlarni shartli ravishda amalga oshirishimiz mumkin. Masalan, 10-15-ro'yxatdagi <code>Pair&lt;T&gt;</code> turi har doim yangi <code>Pair&lt;T&gt;</code> nusxasini qaytarish uchun <code>new</code> funksiyasini amalga oshiradi (5-bobning <a href="ch05-03-method-syntax.html#defining-methods">‚ÄúMetodlarni aniqlash‚Äù</a><!-- ignore -->  bo ªlimidan eslaylikki, <code>Self</code> bu <code>impl</code> bloki turiga tegishli turdagi taxallus(alias) bo ªlib, bu holda <code>Pair&lt;T&gt;</code> bo ªladi). Ammo keyingi <code>impl</code> blokida <code>Pair&lt;T&gt;</code> faqat <code>cmp_display</code> metodini qo'llaydi, uning ichki turi(inner type) <code>T</code> taqqoslash imkonini beruvchi <code>PartialOrd</code> traitini <em>va</em> chop etish imkonini beruvchi <code>Display</code> traittini amalga oshiradi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Eng katta a'zo x = {}&quot;, self.x);
        } else {
            println!(&quot;Eng katta a'zo y = {}&quot;, self.y);
        }
    }
}</code></pre>
<p><span class="caption">Ro'yxat 10-15: Trait boundga qarab generik tur bo'yicha shartli ravishda qo'llash metodlari</span></p>
<p>Biz shartli ravishda boshqa traitni amalga oshiradigan har qanday tur uchun traitni amalga oshirishimiz mumkin. Trait boundlarni qondiradigan har qanday turdagi tarittni amalga oshirish <em>blanket implementations</em> deb nomlanadi va Rust standart kutubxonasida keng qo'llaniladi. Masalan, standart kutubxona <code>Display</code> traitini amalga oshiradigan har qanday turdagi <code>ToString</code> traitini amalga oshiradi. Standart kutubxonadagi <code>impl</code> bloki ushbu kodga o'xshaydi:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>Standart kutubxonada bu keng qamrovli dastur mavjud bo'lganligi sababli, biz <code>Display</code> traitini amalga oshiradigan har qanday turdagi <code>ToString</code> traiti bilan aniqlangan <code>to_string</code> metodini chaqirishimiz mumkin. Masalan, biz butun sonlarni mos keladigan <code>String</code> qiymatlariga shunday aylantirishimiz mumkin, chunki butun sonlar <code>Display</code>ni amalga oshiradi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>Blanket implementationlari &quot;Implementors&quot; bo'limidagi trait uchun texnik hujjatlarda ko'rinadi.</p>
<p>Traitlar va trait boundlar takrorlanishni kamaytirish uchun generik turdagi parametrlardan foydalanadigan kod yozishga imkon beradi, shuningdek, generik turning o'ziga xos xatti-harakatlariga ega bo'lishini kompilyatorga ko'rsatishga imkon beradi. Keyin kompilyator trait bilan bog'langan ma'lumotlardan bizning kodimiz bilan qo'llaniladigan barcha aniq turlar to'g'ri xatti-harakatni ta'minlaydiganligini tekshirish uchun foydalanishi mumkin. Dinamik ravishda tuzilgan tillarda, agar biz metodni aniqlamagan turdagi metodni chaqirsak, runtimeda xatoga yo'l qo'yamiz. Ammo Rust bu xatolarni vaqtni kompilyatsiya qilish uchun ko'chiradi, shuning uchun biz kodimiz ishga tushgunga qadar muammolarni hal qilishga majbur bo'lamiz. Bundan tashqari, biz runtimeda xatti-harakatni tekshiradigan kod yozishimiz shart emas, chunki biz kompilyatsiya vaqtida allaqachon tekshirganmiz.
Bu generiklarning moslashuvchanligidan voz kechmasdan ishlashni yaxshilaydi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referencelarni-lifetime-bilan-tekshirish"><a class="header" href="#referencelarni-lifetime-bilan-tekshirish">Referencelarni lifetime bilan tekshirish</a></h2>
<p>Lifetimelar - biz allaqachon uchratgan generiklarning yana bir turi. Turning biz xohlagan xatti-harakatga ega bo'lishini ta'minlash o'rniga, lifetime referencelar biz uchun kerak bo'lganda haqiqiyligini ta'minlaydi.</p>
<p>4-bobdagi [‚ÄúReferencelar va Borrowing‚Äù](<a href="ch04-02-references-and-borrowing.html#references-and-borrowing">references-and-borrowing</a><!-- ignore -->) bo‚Äòlimida biz muhokama qilmagan bir tafsilot shundan iboratki, Rust-dagi har bir referenceda o‚Äòsha referencening amal qilish doirasi <em>lifetime</em> bo‚Äòladi. Ko'pincha, lifetimelar yashirin va inferred bo'ladi,
ko'p hollarda bo'lgani kabi, turlar ham inferred qilinadi.Biz faqat bir nechta tur mumkin bo'lganda turlarga izoh berishimiz kerak. Shunga o'xshab, biz referencelarning lifetime bir necha xil yo'llar bilan bog'lanishi mumkin bo'lgan lifetimelarini izohlashimiz kerak. Rust bizdan runtimeda ishlatiladigan haqiqiy referencelar haqiqiy bo'lishini ta'minlash uchun generik lifetime parametrlaridan foydalangan holda munosabatlarga izoh berishimizni talab qiladi.</p>
<p>Lifetimeni izohlash boshqa dasturlash tillarining ko'pchiligida mavjud bo'lgan tushuncha ham emas, shuning uchun bu notanish tuyuladi. Garchi biz ushbu bobda lifetimeni to'liq qamrab olmasak ham, kontseptsiyadan qulay bo'lishingiz uchun lifetime sintaksisga duch kelishingiz mumkin bo'lgan umumiy usullarni muhokama qilamiz.</p>
<h3 id="lifetimeda-dangling-referencelarni-oldini-olish"><a class="header" href="#lifetimeda-dangling-referencelarni-oldini-olish">Lifetimeda dangling referencelarni oldini olish</a></h3>
<p>Lifetimening asosiy maqsadi dasturga reference qilish uchun mo'ljallangan ma'lumotlardan boshqa ma'lumotlarga reference qilishiga olib keladigan <em>dangling referencelar</em> ning oldini olishdir.
10-16 ro'yxatdagi dasturni ko'rib chiqing, uning tashqi va ichki ko'lami(tashqi va ichki ishlash doirasi) bor.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}</code></pre>
<p><span class="caption">Ro'yxat 10-16: Qiymati ishlash doiradan chiqib ketgan referencedan foydalanishga urinish</span></p>
<blockquote>
<p>Eslatma: 10-16, 10-17 va 10-23 ro'yxatlardagi misollar o'zgaruvchilarni
ularga boshlang'ich qiymat bermasdan e'lon qiladi, shuning uchun o'zgaruvchi nomi
tashqi doirada mavjud. Bir qarashda, bu Rustning null qiymatlari yo'qligiga zid
bo'lib tuyulishi mumkin. Biroq, agar biz o'zgaruvchiga qiymat berishdan oldin
foydalanmoqchi bo'lsak, biz kompilyatsiya vaqtida xatoga duch kelamiz, bu Rust
haqiqatan ham null qiymatlarga ruxsat bermasligini ko'rsatadi.</p>
</blockquote>
<p>Tashqi qamrov boshlang‚Äòich qiymati bo‚Äòlmagan <code>r</code> nomli o‚Äòzgaruvchini, ichki qamrov esa boshlang‚Äòich qiymati 5 bo‚Äòlgan <code>x</code> nomli o‚Äòzgaruvchini e‚Äôlon qiladi. Ichki doirada(qamrov) biz <code>x</code> ga reference sifatida <code>r</code> qiymatini belgilashga harakat qilamiz. Keyin ichki qamrov tugaydi va biz qiymatni <code>r</code> da chop etishga harakat qilamiz. Ushbu kod kompilyatsiya qilinmaydi, chunki biz undan foydalanishga urinishdan oldin <code>r</code> qiymati ko'rib chiqilmaydi. Mana xato xabari:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!(&quot;r: {}&quot;, r);
  |                       - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p><code>x</code> o'zgaruvchisi &quot;yetarlicha uzoq umr ko'rmaydi&quot;. Sababi, 7-qatorda ichki qamrov tugashi bilan <code>x</code> amaldan tashqarida bo'ladi. Lekin <code>r</code> tashqi doira uchun hamon amal qiladi; uning qamrovi kengroq bo'lgani uchun biz uni &quot;uzoq yashaydi&quot; deymiz. Agar Rust ushbu kodning ishlashiga ruxsat bergan bo'lsa, <code>r</code> <code>x</code> doiradan chiqib ketganda ajratilgan xotiraga reference bo'ladi va biz <code>r</code> bilan qilishga uringan har qanday narsa to'g'ri ishlamaydi. Xo'sh, Rust bu kodning yaroqsizligini qanday aniqlaydi?
Bu borrow(qarz) tekshiruvidan foydalanadi.</p>
<h3 id="borrow-tekshiruvchisi"><a class="header" href="#borrow-tekshiruvchisi">Borrow tekshiruvchisi</a></h3>
<p>Rust kompilyatorida barcha borrowlar to'g'ri yoki yo'qligini aniqlash uchun ko'lamlarni taqqoslaydigan <em>borrow tekshiruvi(borrow checker)</em> mavjud. 10-17 ro'yxat 10-16 ro'yxati bilan bir xil kodni ko'rsatadi, ammo o'zgaruvchilarning lifetime(ishlash muddatini) ko'rsatadigan izohlar bilan.</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+</code></pre>
<p><span class="caption">Ro ªyxat 10-17: <code>r</code> va <code>x</code> ning mos ravishda <code>a</code> va <code>b</code> nomlari bilan ishlash lifetimening izohlari</span></p>
<p>Bu yerda biz <code>r</code>ning lifetimeni <code>a</code> bilan va <code>x</code>ning lifetimeni <code>b</code> bilan izohladik. Ko'rib turganingizdek, ichki <code>b</code> bloki tashqi <code>'a</code> lifetime blokdan ancha kichik. Kompilyatsiya vaqtida Rust ikki lifetimening o'lchamini solishtiradi va <code>r</code> ning lifetime <code>'a</code> ekanligini, lekin u <code>'b</code> lifetime(umr bo'yi) xotiraga ishora qilishini ko'radi. Dastur rad etildi, chunki <code>'b</code> <code>'a</code> dan qisqaroq: reference mavzusi reference kabi uzoq vaqt yashamaydi.</p>
<p>Ro'yxat 10-18 kodni tuzatadi, shuning uchun u dangling referencega ega emas va hech qanday xatosiz kompilyatsiya qilinadi.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<p><span class="caption">Ro'yxat 10-18: To'g'ri reference, chunki referencelar mos yozuvlardan ko'ra uzoqroq lifetimega ega</span></p>
<p>Bu erda <code>x</code> <code>'b</code> muddatiga ega, bu holda <code>'a</code> dan kattaroqdir. Bu <code>r</code> <code>x</code> ga murojaat qilishi mumkin degan ma'noni anglatadi, chunki Rust <code>r</code> dagi reference har doim <code>x</code> amalda bo`lishini biladi.</p>
<p>Endi siz referencelarning amal qilish muddati qayerda ekanligini va referencelar har doim haqiqiy bo ªlishini ta ºminlash uchun Rust lifetimeni qanday tahlil qilishini bilganingizdan so ªng, keling, funksiyalar kontekstida parametrlarning generik lifetime va qiymatlarni qaytarishni ko ªrib chiqaylik.</p>
<h3 id="funksiyalarning-generik-lifetime"><a class="header" href="#funksiyalarning-generik-lifetime">Funksiyalarning generik lifetime</a></h3>
<p>Biz ikkita satr bo'lagining uzunligini qaytaradigan funksiyani yozamiz. Bu funksiya ikkita satr bo'lagini oladi va bitta satr bo'lagini qaytaradi. <code>eng_uzun</code> funksiyasini amalga oshirganimizdan so'ng, 10-19 ro'yxatdagi kod <code>Eng uzun satr - abcd</code> ni chop etishi kerak.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;Eng uzun satr {}&quot;, result);
}</code></pre>
<p><span class="caption">Ro'yxat 10-19: Ikki qator bo ªlagining uzunini topish uchun <code>eng_uzun</code> funksiyani chaqiruvchi <code>main</code> funksiya</span></p>
<p>E'tibor bering, biz funksiya satrlarni emas, referencelar bo'lgan satr bo'laklarini olishni xohlaymiz, chunki biz <code>eng_uzun</code> funksiya uning parametrlariga egalik qilishni xohlamaymiz. 10 19 ro ªyxatda biz foydalanadigan parametrlar nima uchun biz xohlagan parametrlar ekanligi haqida ko ªproq muhokama qilish uchun 4-bobdagi <a href="ch04-03-slices.html#string-slices-as-parameters">‚ÄúString slicelari parametr sifatida‚Äù</a><!-- ignore --> bo ªlimiga qarang.</p>
<p>Agar biz 10-20 ro'yxatda ko'rsatilganidek, <code>eng_uzun</code> funksiyasini amalga oshirishga harakat qilsak, u kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let natija = eng_uzun(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Eng uzun satr {}&quot;, natija);
</span><span class="boring">}
</span><span class="boring">
</span>fn eng_uzun(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
<p><span class="caption">Ro'yxat 10-20: Ikki qatorli bo ªlakning uzunroq qismini qaytaradigan, lekin hali kompilyatsiya qilinmagan <code>eng_uzun</code> funksiyaning amalga oshirilishi</span></p>
<p>Buning o'rniga biz lifetime haqida gapiradigan quyidagi xatoni olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn eng_uzun(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn eng_uzun&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |             ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Yordam matni shuni ko'rsatadiki, return(qaytarish) turiga umumiy lifetime parametri kerak, chunki Rust qaytarilayotgan reference <code>x</code> yoki <code>y</code> ga tegishli ekanligini aniqlay olmaydi. Aslida, biz ham bilmaymiz, chunki bu funksiyaning asosiy qismidagi <code>if</code> bloki <code>x</code> ga referenceni, <code>else</code> bloki esa <code>y</code> ga referenceni qaytaradi!</p>
<p>Ushbu funksiyani aniqlaganimizda, biz ushbu funksiyaga o'tadigan aniq qiymatlarni bilmaymiz, shuning uchun <code>if</code> yoki <code>else</code> ishi bajarilishini bilmaymiz. Shuningdek, biz uzatiladigan referencelarning aniq amal qilish muddatini bilmaymiz, shuning uchun biz qaytaradigan(return) lifetime har doim haqiqiy bo'lishini aniqlash uchun 10-17 va 10-18 ro'yxatlarda bo'lgani kabi qamrovni ko'rib chiqa olmaymiz. Borrow tekshiruvchisi buni ham aniqlay olmaydi, chunki u <code>x</code> va <code>y</code> ning ishlash lifetime qaytarilgan qiymatning lifetime(ishlash muddati) bilan qanday bog'liqligini bilmaydi. Ushbu xatoni tuzatish uchun biz referencelar o'rtasidagi munosabatni aniqlaydigan umumiy lifetime parametrlarini qo'shamiz, shunda borrow tekshiruvi tahlilini amalga oshirishi mumkin.</p>
<h3 id="lifetime-annotation-sintaksisi"><a class="header" href="#lifetime-annotation-sintaksisi">Lifetime annotation sintaksisi</a></h3>
<p>Lifetime annotationlar referencelarning qancha yashashini ko'rishini o'zgartirmaydi. Aksincha, ular lifetimega ta'sir qilmasdan, bir-biriga ko'plab murojaatlarning umrbod lifetimelar munosabatlarini tasvirlaydi. Signature generik turdagi parametrni ko'rsatsa, funksiyalar har qanday turni qabul qilishi mumkin bo'lgani kabi, funksiyalar ham umumiy lifetime parametrini belgilash orqali har qanday xizmat muddati bilan murojaatlarni qabul qilishi mumkin.</p>
<p>Lifetime annotationlar biroz noodatiy sintaksisga ega: lifetime parametrlarining nomlari apostrof (<code>'</code>) bilan boshlanishi kerak va odatda generik turlar kabi kichik va juda qisqa bo'ladi. Ko'pchilik lifetime annotation birinchi izoh uchun <code>'a</code> nomidan foydalanadi. Annotationi reference turidan ajratish uchun bo ªsh joydan foydalanib, biz lifetime parametr annotationlarini referencening <code>&amp;</code> belgisidan keyin joylashtiramiz.</p>
<p>Mana bir nechta misollar: lifetime parametri bo'lmagan <code>i32</code> ga reference, <code>'a</code> nomli lifetime parametriga ega <code>i32</code> ga reference va lifetime <code>'a</code> bo'lgan <code>i32</code> ga o'zgaruvchan reference.</p>
<pre><code class="language-rust ignore">&amp;i32        // reference
&amp;'a i32     // aniq lifetimega ega bo'lgan reference
&amp;'a mut i32 // aniq lifetimega ega o'zgaruvchan reference</code></pre>
<p>Bir umrlik lifetime annotatsiyaning o'zi katta ma'noga ega emas, chunki annotatsiyalar Rustga bir nechta referencelalarning lifetime generik parametrlari bir-biriga qanday bog'liqligini aytib berish uchun mo'ljallangan. Keling, <code>eng_uzun</code> funksiya kontekstida lifetime annotatsiyalarning bir-biriga qanday bog'liqligini ko'rib chiqaylik.</p>
<h3 id="funksiya-signaturelaridagi-lifetime-annotatsiyalar"><a class="header" href="#funksiya-signaturelaridagi-lifetime-annotatsiyalar">Funksiya signaturelaridagi lifetime annotatsiyalar</a></h3>
<p>Funksiya signaturelarida lifetime annotatsiyalardan foydalanish uchun biz generik <em>tur</em> parametrlari bilan qilganimiz kabi, funksiya nomi va parametrlar ro'yxati o'rtasida burchak qavslar ichida generik <em>lifetime</em> parametrlarini e'lon qilishimiz kerak.</p>
<p>Biz signature quyidagi cheklovni ifodalashini istaymiz: qaytarilgan(return) reference ikkala parametr ham to'g'ri bo'lsa, haqiqiy bo'ladi. Bu parametrlarning lifetime(ishlash muddati) va qaytariladigan(return) qiymat o'rtasidagi bog'liqlikdir. 10-21 ro'yxatda ko'rsatilganidek, biz lifetimega <code>'a</code> deb nom beramiz va keyin uni har bir referencega qo'shamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let natija = eng_uzun(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Eng uzun satr {}&quot;, natija);
</span><span class="boring">}
</span><span class="boring">
</span>fn eng_uzun&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p><span class="caption">Ro'yxat 10-21: Signaturedagi barcha referencelar bir xil lifetimega(ishlash muddati) ega bo'lishi kerakligini ko'rsatuvchi <code>eng_uzun</code> funksiya ta'rifi <code>'a</code></span></p>
<p>Ushbu kod 10-19-sonli ro'yxatdagi <code>main</code> funksiyadan foydalanganda biz xohlagan natijani kompilyatsiya qilishi va ishlab chiqarishi kerak.</p>
<p>Funktsiya signaturesi endi Rustga ma'lum bir lifetimeda <code>'a</code> funksiyasi ikkita parametrni qabul qilishini aytadi, ularning har ikkalasi ham kamida lifetime <code>'a</code> bo'lgan string bo'laklaridir. Funktsiya signaturesi, shuningdek, Rustga funksiyadan qaytarilgan string bo'lagi hech bo'lmaganda <code>'a</code> lifetimegacha yashashini aytadi.
Amalda, bu <code>eng_uzun</code> funksiya tomonidan qaytarilgan referencening lifetime, funksiya argumentlari bilan bog'liq bo'lgan qiymatlarning eng kichik lifetimesi bilan bir xil ekanligini anglatadi. Bu munosabatlar Rust ushbu kodni tahlil qilishda foydalanishini xohlaydigan narsadir.</p>
<p>Esda tutingki, biz ushbu funksiya signaturesida lifetime parametrlarini belgilaganimizda, biz kiritilgan yoki qaytarilgan qiymatlarning lifetimeni o'zgartirmaymiz. Aksincha, biz borrowni tekshiruvchi(borrow checker) ushbu cheklovlarga rioya qilmaydigan har qanday qiymatlarni rad etishi kerakligini ta'kidlaymiz. Shuni esda tutingki, <code>eng_uzun</code> funksiya <code>x</code> va <code>y</code> qancha vaqt ishlashini aniq bilishi shart emas, faqat ushbu signatureni qondiradigan <code>'a</code> ga ba ºzi bir qamrovni almashtirish mumkin.</p>
<p>Funksiyalarda lifetimeni izohlashda annotationlar funksiya tanasida emas, balki funksiya signaturesida bo'ladi. Signaturedagi turlar singari, lifetime annotationlar funksiya shartnomasining bir qismiga aylanadi. Funktsiya signaturelari lifetime shartnomani o'z ichiga oladi, degan ma'noni anglatadi Rust kompilyatori tahlil qilish osonroq bo'lishi mumkin. Agar funksiyaga izoh berish yoki uni chaqirish bilan bog'liq muammo bo'lsa, kompilyator xatolari kodimizning bir qismiga va cheklovlarga aniqroq ishora qilishi mumkin. Buning o'rniga, Rust kompilyatori biz lifetime munosabatlari haqida ko'proq taxminlar qilgan bo'lsa, kompilyator faqat muammoning sababidan bir necha qadam uzoqda bizning kodimizdan foydalanishni ko'rsatishi mumkin.</p>
<p>Biz <code>eng_uzun</code> ga aniq referencelar berganimizda, <code>'a</code> o‚Äòrniga qo‚Äòyilgan aniq lifetime <code>x</code> doirasining <code>y</code> doirasiga to‚Äòg‚Äòri keladigan qismidir. Boshqacha qilib aytadigan bo'lsak, <code>'a</code> generik lifetimesi <code>x</code> va <code>y</code> ning eng kichik lifetimaga teng bo'lgan aniq lifetimeni oladi. Biz qaytarilgan(return) referencega bir xil lifetime parametri <code>'a</code> bilan izoh berganimiz sababli, qaytarilgan reference <code>x</code> va <code>y</code> lifetimening kichikroq uzunligi uchun ham amal qiladi.</p>
<p>Keling, turli xil aniq lifetimelarga ega bo'lgan referencelarni o'tkazish orqali <code>eng_uzun</code> funksiyani qanday cheklashini ko'rib chiqaylik. Ro'yxat 10-22 - bu oddiy misol.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;uzundan uzun string&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let natija = eng_uzun(string1.as_str(), string2.as_str());
        println!(&quot;Eng uzun satr {}&quot;, natija);
    }
}
<span class="boring">
</span><span class="boring">fn eng_uzun&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 10-22: <code>eng_uzun</code> funksiyasidan foydalanish, turli xil aniq lifetimega ega <code>String</code> qiymatlariga referencelar</span></p>
<p>Bu misolda <code>string1</code> tashqi qamrov oxirigacha amal qiladi, <code>string2</code> ichki qamrov oxirigacha amal qiladi va <code>natija</code> ichki doiraning oxirigacha amal qiladigan narsaga ishora qiladi. Ushbu kodni ishga tushiring va siz borrowni tekshiruvchi tasdiqlaganini ko'rasiz; u kompilyatsiya qiladi va <code>Eng uzun satr - uzundan uzun string</code> ni yaratadi.</p>
<p>Keyinchalik, <code>natija</code>dagi referencening lifetime ikkita argumentning kichikroq lifetime bo'lishi kerakligini ko'rsatadigan misolni ko'rib chiqaylik. Biz <code>natija</code> o'zgaruvchisi deklaratsiyasini ichki doiradan tashqariga o'tkazamiz, lekin qiymatni belgilashni <code>string2</code> bilan doiradagi <code>natija</code> o'zgaruvchisiga qoldiramiz. Keyin, <code>natija</code>ni ishlatadigan <code>println!</code>ni ichki doira tugagandan so‚Äòng, ichki doiradan tashqariga o‚Äòtkazamiz. 10-23 ro'yxatdagi kod kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;uzundan uzun string&quot;);
    let natija;
    {
        let string2 = String::from(&quot;xyz&quot;);
        natija = eng_uzun(string1.as_str(), string2.as_str());
    }
    println!(&quot;Eng uzun satr {}&quot;, natija);
}
<span class="boring">
</span><span class="boring">fn eng_uzun&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 10-23: <code>string2</code> dan keyin <code>natija</code> dan foydalanishga urinish</span></p>
<p>Ushbu kodni kompilyatsiya qilmoqchi bo'lganimizda, biz quyidagi xatoni olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         natija = eng_uzun(string1.as_str(), string2.as_str());
  |                                             ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;Eng uzun satr {}&quot;, natija);
  |                                  ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Xato shuni ko'rsatadiki, <code>natija</code> <code>println!</code> bayonoti uchun haqiqiy bo'lishi uchun <code>string2</code> tashqi doiraning oxirigacha amal qilishi kerak. Rust buni biladi, chunki biz funksiya parametrlarining lifetimeni(ishlash muddati) va qiymatlarni bir xil <code>'a</code> parametridan foydalangan holda izohladik.</p>
<p>Inson sifatida biz ushbu kodni ko'rib chiqamiz va <code>string1</code> <code>string2</code> dan uzunroq ekanligini ko'rishimiz mumkin va shuning uchun <code>natija</code> <code>string1</code> ga referenceni o'z ichiga oladi.
<code>string1</code> hali amaldan tashqariga chiqmaganligi sababli, <code>string1</code>ga reference <code>println!</code> bayonoti uchun amal qiladi. Biroq, kompilyator bu holatda reference haqiqiy ekanligini ko'ra olmaydi. Biz Rustga aytdikki, <code>eng_uzun</code> funksiya tomonidan qaytarilgan referencening lifetime uzatilgan referencelarning lifetimesidan kichikroq vaqt bilan bir xil. Shuning uchun, borrowni tekshirish vositasi 10-23 ro'yxatdagi kodga ruxsat bermaydi, chunki noto'g'ri reference mavjud.</p>
<p><code>eng_uzun</code> funksiyaga o ªtkazilgan referencelarning qiymatlari va amal lifetime va qaytarilgan(return) referencedan qanday foydalanishni o ªzgartiruvchi ko ªproq tajribalar ishlab chiqishga harakat qiling. Kompilyatsiya qilishdan oldin tajribalaringiz borrow tekshiruvidan o'tadimi yoki yo'qmi haqida faraz qiling; keyin siz haq ekanligingizni tekshiring!</p>
<h3 id="lifetime-nuqtai-nazaridan-fikrlash"><a class="header" href="#lifetime-nuqtai-nazaridan-fikrlash">Lifetime nuqtai nazaridan fikrlash</a></h3>
<p>Lifetime parametrlarini belgilashingiz kerak bo'lgan metod sizning funksiyangiz nima qilayotganiga bog'liq. Misol uchun, agar biz <code>eng_uzun</code> funksiyasini amalga oshirishni har doim eng uzun satr bo'lagini emas, balki birinchi parametrni qaytarish uchun o'zgartirgan bo'lsak, <code>y</code> parametrida lifetimeni belgilashimiz shart emas. Quyidagi kod kompilyatsiya qilinadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let natija = eng_uzun(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Eng uzun satr {}&quot;, natija);
</span><span class="boring">}
</span><span class="boring">
</span>fn eng_uzun&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
<p>Biz <code>x</code> parametri va qaytarish(return) turi uchun lifetime <code>'a</code> parametrini belgiladik, lekin <code>y</code> parametri uchun emas, chunki <code>y</code> ning lifetimesi <code>x</code> yoki qaytarish qiymati bilan hech qanday aloqasi yo'q.</p>
<p>Funksiyadan mos yozuvlar qaytarilganda, qaytarish turi uchun lifetime parametri parametrlardan birining lifetime parametriga mos kelishi kerak. Agar qaytarilgan reference parametrlardan biriga tegishli bo'lmasa, u ushbu funksiya doirasida yaratilgan qiymatga murojaat qilishi kerak. Biroq, bu dangling reference bo'ladi, chunki funksiya oxirida qiymat doiradan chiqib ketadi.
Kompilyatsiya qilmaydigan <code>eng_uzun</code> funksiyani amalga oshirishga urinishlarni ko'rib chiqing:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let natija = eng_uzun(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Eng uzun satr {}&quot;, natija);
</span><span class="boring">}
</span><span class="boring">
</span>fn eng_uzun&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let natija = String::from(&quot;haqiqatan ham uzun satr&quot;);
    natija.as_str()
}</code></pre>
<p>Bu erda, biz qaytish turi uchun lifetime parametr <code>'a</code> ni belgilagan bo'lsak ham, bu dastur kompilyatsiya qilinmaydi, chunki qaytish qiymatining lifetime parametrlarning lifetime bilan umuman bog'liq emas. Mana biz olgan xato xabari:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Muammo shundaki, <code>natija</code> ishchi ko'lamdan tashqariga chiqadi va <code>eng_uzun</code> funksiya oxirida tozalanadi. Shuningdek, biz funksiyadan <code>natija</code>ga referenceni qaytarishga harakat qilyapmiz. Dangling referenceni o'zgartiradigan lifetime parametrlarini belgilashning iloji yo'q va Rust bizga dangling reference yaratishga ruxsat bermaydi. Bunday holda, eng yaxshi tuzatish mos yozuvlar emas, balki tegishli referencelar turini qaytarish bo'ladi, shuning uchun chaqiruv funksiyasi qiymatni tozalash uchun javobgar bo'ladi.</p>
<p>Oxir oqibat, lifetime sintaksisi turli parametrlarning ishlash muddatini va funktsiyalarning qaytish qiymatlarini bog'lashdir. Ular ulangandan so'ng, Rust xotira xavfsizligini ta'minlaydigan operatsiyalarga ruxsat berish va dangling pointerlarni yaratish yoki xotira xavfsizligini boshqa tarzda buzadigan operatsiyalarga ruxsat berish uchun yetarli ma'lumotga ega.</p>
<h3 id="struktura-tariflarida-lifetime-annotationlar"><a class="header" href="#struktura-tariflarida-lifetime-annotationlar">Struktura ta'riflarida lifetime annotationlar</a></h3>
<p>Hozirgacha biz belgilagan structlar barcha egalik turlariga ega. Biz referencelarni saqlash uchun structlarni belgilashimiz mumkin, ammo bu holda structning ta'rifidagi har bir referencega lifetime annotation qo'shishimiz kerak bo'ladi. 10-24 ro ªyxatda <code>ImportantExcerpt</code> nomli struktura mavjud bo ªlib, u string sliceni saqlaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    qism: &amp;'a str,
}

fn main() {
    let roman = String::from(&quot;Meni yaxshi dasturchi edim. Bir necha yil oldin...&quot;);
    let birinchi_jumla = roman.split('.').next().expect(&quot;'.' belgisini topib bo'lmadi.&quot;);
    let i = ImportantExcerpt {
        qism: birinchi_jumla,
    };
}</code></pre></pre>
<p><span class="caption">Ro'yxat 10-24: Referencega ega bo'lgan struct, lifetime annotationni talab qiladi</span></p>
<p>Bu structda bir satr bo ªlagini o ªz ichiga oluvchi <code>qism</code> maydoni mavjud bo ªlib, bu referencelardir. Generik(umumiy) ma'lumotlar turlarida bo'lgani kabi, biz structning nomidan keyin burchakli qavslar ichida generik lifetime parametrining nomini e'lon qilamiz, shuning uchun biz structning ta'rifi tanasida lifetime parametridan foydalanishimiz mumkin. Bu izoh <code>ImportantExcerpt</code> namunasi o ªzining <code>qism</code> maydonidagi referencedan uzoqlasha olmasligini bildiradi.</p>
<p>Bu yerda <code>main</code> funksiyasi <code>roman</code> o ªzgaruvchisiga tegishli <code>String</code>ning birinchi jumlasiga referenceni o ªz ichiga olgan <code>ImportantExcerpt</code> strukturasining namunasini yaratadi. <code>roman</code>dagi ma'lumotlar <code>ImportantExcerpt</code> misoli yaratilishidan oldin mavjud. Bundan tashqari, <code>roman</code> <code>ImportantExcerpt</code> ishchi doirasi tashqariga chiqmagunicha, ishchi doiradan chiqib ketmaydi, shuning uchun <code>ImportantExcerpt</code> misolidagi reference haqiqiy hisoblanadi.</p>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision</a></h3>
<p>Siz har bir referencening lifetime(ishlash muddati) borligini va referencelardan foydalanadigan funksiyalar yoki structlar uchun lifetime parametrlarini belgilashingiz kerakligini bilib oldingiz. Biroq, 4-bobda biz 4-9-ro'yxatdagda funksiyaga ega bo'ldik, u keyin yana 10-25 ro'yxatda ko'rsatiladi, unda kod lifetime annotationsiz tuzilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 10-25: Biz 4-9 ro'yxatda aniqlagan funksiya, parametr va qaytish(return) turi referencelar bo'lsa ham, lifetime annotationsiz(umrbod lifetime) tuzilgan.</span></p>
<p>Ushbu funktsiyaning lifetime annotationlarsiz kompilyatsiya qilinishining sababi tarixiydir: Rust-ning dastlabki versiyalarida (1.0-dan oldingi) bu kod kompilyatsiya bo'lmagan bo'lardi, chunki har bir reference aniq ishlash muddatini talab qiladi. O'sha paytda funktsiya signaturesi quyidagicha yozilgan bo'lar edi:</p>
<pre><code class="language-rust ignore">fn birinchi_belgi&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Rust-da juda ko'p kod yozgandan so'ng, Rust jamoasi Rust dasturchilari muayyan vaziyatlarda bir xil lifetime annotatiolarni qayta-qayta kiritayotganini aniqladilar. Bu vaziyatlarni oldindan aytish mumkin edi va bir nechta deterministik patternlarga amal qildi. Ishlab chiquvchilar ushbu patternlarni kompilyator kodiga dasturlashtirdilar, shuning uchun borrow tekshiruvi ushbu vaziyatlarda lifetimeni(ishlash muddatini) aniqlay oladi va aniq izohlarga muhtoj bo'lmaydi.</p>
<p>Rust tarixining ushbu qismi dolzarbdir, chunki ko'proq deterministik patternlar paydo bo'lishi va kompilyatorga qo'shilishi mumkin. Kelajakda undan ham kamroqlifetime annotationlar talab qilinishi mumkin.</p>
<p>Rustning referencelarni tahlil qilishda dasturlashtirilgan patternlar <em>lifetime elision qoidalari(lifetime elision rules)</em> deb ataladi. Bu dasturchilar rioya qilishi kerak bo'lgan qoidalar emas; ular kompilyator ko'rib chiqadigan muayyan holatlar to'plamidir va agar sizning kodingiz ushbu holatlarga mos keladigan bo'lsa, lifetime vaqtlarini aniq yozishingiz shart emas.</p>
<p>Elision qoidalari to'liq xulosa chiqarmaydi. Agar Rust qoidalarni qat'iy qo'llasa, lekin referencelarning qancha vaqt ishlashi(lifetime) haqida hali ham noaniqlik mavjud bo'lsa, kompilyator qolgan referencelarning lifetime(ishlash muddati) qancha bo'lishi kerakligini taxmin qila olmaydi. Taxmin qilish o'rniga, kompilyator sizga lifetime annotationlarni qo'shish orqali hal qilishingiz mumkin bo'lgan xatoni beradi.</p>
<p>Funksiya yoki metod parametrlari bo‚Äòyicha lifetime <em>kirish lifetime (input lifetimes)</em>, qaytariladigan(return) qiymatlar bo‚Äòyicha lifetime <em>chiqish lifetimei (output lifetimes)</em> deb ataladi.</p>
<p>Aniq izohlar(annotation) bo'lmasa, kompilyator referencelarning lifetimeni aniqlash uchun uchta qoidadan foydalanadi. Birinchi qoida kirish lifetimega(input lifetimes), ikkinchi va uchinchi qoidalar esa chiqish lifetimega(output lifetimes) tegishli. Agar kompilyator uchta qoidaning oxiriga yetib borsa va hali ham lifetimeni(foydalanish muddati) aniqlay olmaydigan referencelar mavjud bo'lsa, kompilyator xato bilan to'xtaydi.
Bu qoidalar <code>fn</code> ta'riflari hamda <code>impl</code> bloklari uchun amal qiladi.</p>
<p>Birinchi qoida shundaki, kompilyator mos yozuvlar bo'lgan har bir parametrga lifetime parametrni belgilaydi.</p>
<p>Ikkinchi qoida shuki, agar aynan bitta kirish lifetime(input) parametri mavjud bo ªlsa, u lifetime barcha chiqish(output) lifetime parametrlariga tayinlanadi: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Uchinchi qoida shundaki, agar kirish lifetime bir nechta parametrlar mavjud bo'lsa, lekin ulardan biri <code>&amp;self</code> yoki <code>&amp;mut self</code> bo'lsa, chunki bu metod bo'lsa, <code>self</code> lifetime barcha chiqish lifetime parametrlariga tayinlanadi. Ushbu uchinchi qoida metodlarni o'qish va yozishni ancha yaxshi qiladi, chunki kamroq belgilar kerak.</p>
<p>Tasavvur qilaylik, biz kompilyatormiz. 10-25 ro ªyxatdagi <code>birinchi_belgi</code> funksiyasi signaturesidagi referencelarning lifetimeni(amal qilish muddati) aniqlash uchun biz ushbu qoidalarni qo ªllaymiz. Signature referencelalar bilan bog'liq bo'lmagan lifetimesiz(muddatsiz) boshlanadi:</p>
<pre><code class="language-rust ignore">fn birinchi_belgi(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Keyin kompilyator birinchi qoidani qo'llaydi, bu har bir parametr o'z lifetimesini oladi. Biz uni odatdagidek <code>'a</code> deb ataymiz, shuning uchun endi signature quyidagicha:</p>
<pre><code class="language-rust ignore">fn birinchi_belgi&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>Ikkinchi qoida amal qiladi, chunki aynan bitta kirish lifetime mavjud. Ikkinchi qoida bitta kirish(input) parametrining lifetime chiqish lifetimesiga tayinlanishini bildiradi, shuning uchun signature endi quyidagicha:</p>
<pre><code class="language-rust ignore">fn birinchi_belgi&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Endi ushbu funksiya signaturesidagi barcha referencelar lifetimesiga ega va kompilyator dasturchiga ushbu funksiya signaturesidagi lifetimeni izohlashiga hojat qoldirmasdan tahlilini davom ettirishi mumkin.</p>
<p>Keling, yana bir misolni ko'rib chiqaylik, bu safar biz 10 20 ro'yxatda ishlashni boshlaganimizda lifetime parametrlarga ega bo'lmagan <code>eng_uzun</code> funksiyadan foydalangan holda:</p>
<pre><code class="language-rust ignore">fn eng_uzun(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Keling, birinchi qoidani qo'llaymiz: har bir parametr o'z lifetimeni oladi. Bu safar bizda bitta emas, ikkita parametr bor, shuning uchun bizda ikkita lifetime bor:</p>
<pre><code class="language-rust ignore">fn eng_uzun&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Siz ikkinchi qoida qo'llanilmasligini ko'rishingiz mumkin, chunki bir nechta kirish lifetime mavjud. Uchinchi qoida ham qo'llanilmaydi, chunki <code>eng_uzun</code> - bu metod emas, balki funksiya, shuning uchun parametrlarning hech biri <code>self</code> emas. Barcha uchta qoidani ko'rib chiqqandan so'ng, biz qaytish(return) turining lifetime nima ekanligini hali aniqlay olmadik. Shuning uchun biz 10-20 ro'yxatdagi kodni kompilyatsiya qilishda xatoga yo'l qo'ydik: kompilyator lifetime elision qoidalari bo'yicha ishladi, lekin signaturedagi referencelarning butun lifetimeni aniqlay olmadi.</p>
<p>Uchinchi qoida haqiqatan ham faqat metod signaturelarida amal qilganligi sababli, biz ushbu kontekstda lifetimeni ko'rib chiqamiz, nima uchun uchinchi qoida biz metod signaturelariga tez-tez izoh qo'yishimiz shart emasligini tushunish uchun.</p>
<h3 id="metod-tariflaridadefination-lifetime-annotationlar"><a class="header" href="#metod-tariflaridadefination-lifetime-annotationlar">Metod ta'riflarida(defination) Lifetime Annotationlar</a></h3>
<p>Biz lifetime bo'lgan strukturada metodlarni qo'llaganimizda, biz 10-11 ro'yxatda ko'rsatilgan generik turdagi parametrlar bilan bir xil sintaksisdan foydalanamiz. Lifetime parametrlarini qayerda e'lon qilishimiz va ishlatishimiz ularning struktura maydonlari yoki metod parametrlari va qaytish(return) qiymatlari bilan bog'liqligiga bog'liq.</p>
<p>Struct maydonlarining lifetime nomlari har doim <code>impl</code> kalit so'zidan keyin e'lon qilinishi va keyin structning nomidan keyin ishlatilishi kerak, chunki bu lifetimelar strukturaning bir qismidir.</p>
<p><code>impl</code> blokidagi metod signaturelarida referencelar struct maydonlaridagi referencelar lifetimega bog'langan bo'lishi mumkin yoki ular mustaqil bo'lishi mumkin. Bundan tashqari, lifetime elision qoidalari ko'pincha metod signaturelarida lifetime annotationlar kerak bo'lmasligi uchun shunday qiladi. 10-24 ro'yxatda biz aniqlagan <code>ImportantExcerpt</code> nomli strukturadan foydalanib, ba'zi misollarni ko'rib chiqaylik.</p>
<p>Birinchidan, biz <code>daraja</code> deb nomlangan metoddan foydalanamiz, uning yagona parametri <code>self</code> ga reference va qaytariladigan qiymati <code>i32</code> bo‚Äòlib, hech narsaga reference emas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    qism: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn daraja(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn qismni_elon_qilish_qaytarih(&amp;self, elon_qilish: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Diqqat iltimos: {}&quot;, elon_qilish);
</span><span class="boring">        self.qism
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let roman = String::from(&quot;Meni yaxshi dasturchi edim. Bir necha yil oldin...&quot;);
</span><span class="boring">    let birinchi_jumla = roman.split('.').next().expect(&quot;'.' belgisini topib bo'lmadi.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        qism: birinchi_jumla,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p><code>impl</code> dan keyin lifetime parametr deklaratsiyasi va tur nomidan keyin foydalanish talab qilinadi, lekin biz birinchi elision qoida tufayli <code>self</code> ga referencening lifetimeni izohlashimiz shart emas.</p>
<p>Mana uchinchi umr bo'yi elision qoida qo'llaniladigan misol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    qism: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn daraja(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn qismni_elon_qilish_qaytarih(&amp;self, elon_qilish: &amp;str) -&gt; &amp;str {
        println!(&quot;Diqqat iltimos: {}&quot;, elon_qilish);
        self.qism
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let roman = String::from(&quot;Meni yaxshi dasturchi edim. Bir necha yil oldin...&quot;);
</span><span class="boring">    let birinchi_jumla = roman.split('.').next().expect(&quot;'.' belgisini topib bo'lmadi.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        qism: birinchi_jumla,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>Ikkita kirish(input) lifetime bor, shuning uchun Rust birinchi lifetime elision qoidasini qo'llaydi va <code>&amp;self</code> va <code>elon_qilish</code> ga ham o'z lifetimeni beradi. Keyin, parametrlardan biri <code>&amp;self</code> bo'lgani uchun qaytarish(return) turi <code>&amp;self</code> lifetimeni oladi va barcha lifetimelar hisobga olingan.</p>
<h3 id="statik-lifetime"><a class="header" href="#statik-lifetime">Statik Lifetime</a></h3>
<p>Muhokama qilishimiz kerak bo'lgan maxsus lifetime bu <code>'static</code> bo'lib, bu ta'sirlangan reference dasturning butun muddati davomida yashashi mumkinligini bildiradi. Barcha satr literallari <code>'static</code> lifetimega ega, biz ularga quyidagicha izoh berishimiz mumkin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;Mening statik lifetimem bor.&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Ushbu satrning matni to'g'ridan-to'g'ri dasturning binary faylida saqlanadi, u har doim mavjud. Shunday qilib, barcha satr literallarining lifetime <code>'static</code> dir.</p>
<p>Xato xabarlarida <code>'static</code> lifetimedan foydalanish bo'yicha takliflarni ko'rishingiz mumkin. Biroq, <code>'static</code> ni referencening lifetime sifatida belgilashdan oldin, sizda mavjud bo'lgan reference haqiqatan ham dasturingizning butun ish vaqti davomida yashaydimi yoki yo'qmi va buni xohlaysizmi, deb o'ylab ko'ring. Ko'pincha, <code>'static</code> lifetimeni ko'rsatadigan xato xabari dangling reference yaratishga urinish yoki mavjud bo'lgan lifetimelarning mos kelmasligi natijasida paydo bo'ladi. Bunday hollarda, yechim <code>'static</code> lifetimeni ko'rsatmasdan, bu muammolarni tuzatishdir.</p>
<h2 id="generik-tur-parametrlari-trait-boundlar-va-birgalikdagi-lifetime"><a class="header" href="#generik-tur-parametrlari-trait-boundlar-va-birgalikdagi-lifetime">Generik tur parametrlari, Trait boundlar va birgalikdagi lifetime</a></h2>
<p>Keling, generik turdagi parametrlarni, trait boundlarini va lifetimeni bitta funksiyada belgilash sintaksisini qisqacha ko'rib chiqaylik!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let natija = elon_bilan_eng_uzun(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Bugun kimningdir tug'ilgan kuni!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;Eng uzun satr {}&quot;, natija);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn elon_bilan_eng_uzun&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;E'lon! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>Bu 10-21 ro ªyxatdagi <code>eng_uzun</code> funksiya bo ªlib, u ikki qatorning uzunroq qismini qaytaradi. Ammo endi u <code>where</code> bandida ko'rsatilgandek <code>Display</code> traitini amalga oshiradigan har qanday tur tomonidan to'ldirilishi mumkin bo'lgan <code>T</code> generik turidagi <code>ann</code> nomli qo'shimcha parametrga ega. Ushbu qo'shimcha parametr <code>{}</code> yordamida chop etiladi, shuning uchun <code>Display</code> trait boundi(trait chegarasi) zarur. Lifetimelar generik tur bo'lganligi sababli, lifetime parametri <code>'a</code> va generik turdagi parametr <code>T</code> funksiya nomidan keyin burchakli qavslar ichida bir xil ro'yxatda joylashgan.</p>
<h2 id="xulosa-9"><a class="header" href="#xulosa-9">Xulosa</a></h2>
<p>Biz ushbu bobda juda ko'p narsalarni ko'rib chiqdik! Endi siz generik(umumiy) turdagi parametrlar, traitlar va trait boundlari(trait chegaralari) va generik lifetime parametrlari haqida bilganingizdan so'ng, siz ko'p turli vaziyatlarda ishlaydigan kodni takrorlashsiz yozishga tayyorsiz.
Generik turdagi parametrlar kodni turli turlarga qo'llash imkonini beradi. Traitlar va traitlar boundlari(chegara) turlar generik(umumiy) bo'lsa ham, ular kodga kerak bo'lgan xatti-harakatlarga ega bo'lishini ta'minlaydi. Ushbu moslashuvchan kodda hech qanday dangling referencelar bo'lmasligini ta'minlash uchun lifetime annotationlardan qanday foydalanishni o'rgandingiz. Va bu tahlillarning barchasi kompilyatsiya vaqtida sodir bo'ladi, bu runtimening ishlashiga ta'sir qilmaydi!</p>
<p>Ishoning yoki ishonmang, biz ushbu bobda muhokama qilgan mavzular bo'yicha ko'p narsalarni o'rganishimiz mumkin: 17-bobda traitlardan foydalanishning yana bir usuli bo'lgan trait ob'ektlari muhokama qilinadi. Bundan tashqari,lifetime annotationlarni o'z ichiga olgan murakkab stsenariylar ham mavjud, ular sizga faqat juda ilg'or stsenariylarda kerak bo'ladi; ular uchun siz <a href="../reference/index.html">Rust Reference</a> ni o'qishingiz kerak. Ammo keyin siz Rust-da testlarni qanday yozishni o'rganasiz, shunda kodingiz kerakli tarzda ishlayotganiga ishonch hosil qilishingiz mumkin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avtomatlashtirilgan-testlarni-yozish"><a class="header" href="#avtomatlashtirilgan-testlarni-yozish">Avtomatlashtirilgan testlarni yozish</a></h1>
<p>Edsger W. Dijkstra o'zining 1972 yildagi &quot;Kamtar dasturchi(The Humble Programmer,)&quot; inshosida &quot;Dasturni sinovdan o'tkazish xatolar(buglar) mavjudligini ko'rsatishning juda samarali usuli bo'lishi mumkin, ammo bu ularning yo'qligini ko'rsatish uchun umidsiz darajada yetarli emas&quot; dedi. Bu biz imkon qadar ko'proq sinab ko'rmasligimiz kerak degani emas!</p>
<p>Bizning dasturlarimizdagi to'g'rilik bizning kodimiz biz rejalashtirgan narsani qanchalik darajada bajarashi. Rust dasturlarning to'g'riligi haqida yuqori darajadagi e'tibor bilan yaratilgan, ammo to'g'riligi murakkab va isbotlash oson emas. Rust turidagi tizim bu yukning katta qismini o'z zimmasiga oladi, ammo turdagi tizim hamma narsani ushlay olmaydi. Shunday qilib, Rust avtomatlashtirilgan dasturiy ta'minot testlarini yozishni qo'llab-quvvatlaydi.</p>
<p>Aytaylik, <code>ikkita_qoshish</code> funksiyasini yozamiz, unga qaysi raqam uzatilsa, unga 2 qo'shiladi. Ushbu funksiya signaturesi integer(butun) sonni parametr sifatida qabul qiladi va natijada butun sonni qaytaradi. Biz ushbu funksiyani amalga oshirganimizda va kompilyatsiya qilganimizda, Rust, masalan, <code>String</code> qiymatini yoki ushbu funksiyaga noto'g'ri referenceni o'tkazmasligimizga ishonch hosil qilish uchun siz hozirgacha o'rgangan barcha turdagi tekshiruvlarni va borrowlarni tekshirishni amalga oshiradi. Ammo Rust bu funksiya biz ko'zlagan narsani aniq bajarishini tekshira olmaydi, ya'ni, masalan, parametr plus 10 yoki minus 50 emas, balki plus 2 parametrini qaytaradi! Bu yerda testlar kiradi.</p>
<p>Biz, masalan, <code>ikkita_qoshish</code> funksiyasiga <code>3</code> o'tganimizda, qaytarilgan qiymat <code>5</code> bo`lishini tasdiqlovchi testlarni yozishimiz mumkin. Mavjud har qanday to'g'ri xatti-harakat o'zgarmaganligiga ishonch hosil qilish uchun kodimizga o'zgartirish kiritganimizda biz ushbu testlarni bajarishimiz mumkin.</p>
<p>Sinov - bu murakkab mahorat: biz bu bobda yaxshi testlarni qanday yozish haqida har bir tafsilotni yorita olmasak-da, Rustning sinov qurilmalari mexanikasini muhokama qilamiz. Testlarni yozishda sizga mavjud bo'lgan izohlar(annotation) va makroslar, standart xatti-harakatlar va testlarni bajarish uchun taqdim etilgan variantlar, shuningdek, testlarni unit testlari va integratsiya testlariga qanday tashkil qilish haqida gaplashamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="testlarni-qanday-yozish-kerak"><a class="header" href="#testlarni-qanday-yozish-kerak">Testlarni qanday yozish kerak</a></h2>
<p>Testlar - bu sinovdan tashqari kod kutilgan tarzda ishlayotganligini tasdiqlovchi Rust funksiyalari. Test funksiyalari organlari odatda ushbu uchta harakatni bajaradi:</p>
<ol>
<li>Har qanday kerakli ma'lumotlarni yoki holatni o'rnating.</li>
<li>Test qilmoqchi bo'lgan kodni ishga tushiring.</li>
<li>Natijalar siz kutgan narsa ekanligini tasdiqlang.</li>
</ol>
<p>Keling, Rust ushbu amallarni bajaradigan testlarni yozish uchun taqdim etgan xususiyatlarni ko'rib chiqaylik, ular orasida <code>test</code> atributi, bir nechta makroslar va <code>should_panic</code> atributi mavjud.</p>
<h3 id="test-funksiyasining-anatomiyasi"><a class="header" href="#test-funksiyasining-anatomiyasi">Test funksiyasining anatomiyasi</a></h3>
<p>Eng sodda qilib aytganda, Rust-dagi test <code>test</code> atributi bilan izohlangan funksiyadir. Atributlar Rust kodining bo'laklari haqidagi metama'lumotlardir; bir misol, biz 5-bobda structlar bilan ishlatgan <code>derive</code> atributidir. Funksiyani test funksiyasiga o ªzgartirish uchun <code>fn</code> oldidan qatorga <code>#[test]</code> qo ªshing. <code>cargo test</code> buyrug'i bilan testlarni o'tkazganingizda, Rust izohli funksiyalarni ishga tushiradigan test dasturining binaryrini yaratadi va har bir test funksiyasidan o'tgan yoki muvaffaqiyatsizligi haqida hisobot beradi.</p>
<p>Har safar biz Cargo bilan yangi kutubxona loyihasini yaratganimizda, biz uchun test funksiyasi bo'lgan test moduli avtomatik ravishda yaratiladi. Ushbu modul sizga testlarni yozish uchun shablonni taqdim etadi, shuning uchun har safar yangi loyihani boshlaganingizda aniq struktura va sintaksisni izlashga hojat qolmaydi. Siz xohlagancha qo'shimcha test funksiyalari va test modullarini qo'shishingiz mumkin!</p>
<p>Har qanday kodni sinab ko'rishdan oldin shablon testi bilan tajriba o'tkazish orqali testlar qanday ishlashining ba'zi jihatlarini o'rganamiz. Keyin biz yozgan ba'zi kodlarni chaqiradigan va uning xatti-harakati to'g'riligini tasdiqlaydigan haqiqiy dunyo testlarini yozamiz.</p>
<p>Keling, ikkita raqamni qo'shadigan <code>qoshuvchi</code> nomli yangi kutubxona loyihasini yarataylik:</p>
<pre><code class="language-console">$ cargo new qoshuvchi --lib
     Created library `qoshuvchi` project
$ cd qoshuvchi
</code></pre>
<p><code>qoshuvchi</code> kutubxonangizdagi <em>src/lib.rs</em> faylining mazmuni 11-1 ro ªyxatdagi kabi ko ªrinishi kerak.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn ishlaydi() {
        let natija = 2 + 2;
        assert_eq!(natija, 4);
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-1: Test moduli va funksiyasi avtomatik ravishda <code>cargo new</code> tomonidan yaratilgan</span></p>
<p>Hozircha, keling, yuqoridagi ikkita qatorga e'tibor bermaylik va funksiyaga e'tibor qarataylik. <code>#[test]</code> izohiga e'tibor bering: bu atribut bu test funksiyasi ekanligini bildiradi, shuning uchun test ishtirokchisi bu funksiyani test sifatida ko'rishni biladi. Umumiy stsenariylarni o ªrnatish yoki umumiy operatsiyalarni bajarishda yordam beradigan <code>tests</code> modulida testdan tashqari funksiyalar ham bo ªlishi mumkin, shuning uchun biz har doim qaysi funksiyalar test ekanligini ko ªrsatishimiz kerak.</p>
<p>Misol funksiya tanasi 2 va 2 qo‚Äòshilishi natijasini o‚Äòz ichiga olgan <code>natija</code> 4 ga teng ekanligini tasdiqlash uchun <code>assert_eq!</code> makrosidan foydalanadi. Ushbu tasdiq odatiy test formatiga misol bo'lib xizmat qiladi. Ushbu sinovdan o'tishini ko'rish uchun uni ishga tushiramiz.</p>
<p><code>cargo test</code> buyrug'i 11-2 ro'yxatda ko'rsatilganidek, loyihamizdagi barcha testlarni amalga oshiradi.</p>
<pre><code class="language-console">$ cargo test
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshuvchi)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/qoshuvchi-92948b65e88960b4)

running 1 test
test tests::ishlaydi ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests qoshuvchi

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">Ro'yxat 11-2: Avtomatik ishlab chiqarilgan testni bajarishdan olingan natija</span></p>
<p>Cargo kompilyatsiya qilindi va sinovdan o'tdi. Biz <code>running 1 test</code> qatorini ko'ramiz. Keyingi qatorda <code>ishlaydi</code> deb nomlangan yaratilgan test funksiyasining nomi va bu testni bajarish natijasi <code>ok</code> ekanligini ko'rsatadi. Umumiy xulosa test natijasi <code>test result: ok.</code> barcha testlardan muvaffaqiyatli o ªtganligini va <code>1 passed;</code> deb yozilgan qismi muvaffaqiyatli o ªtganligini bildiradi; <code>0 failed</code> muvaffaqiyatsiz bo ªlgan testlar sonini ifodalaydi.</p>
<p>Muayyan misolda ishlamasligi uchun testni e'tiborsiz(ignor) deb belgilash mumkin; Biz buni ushbu bobning keyingi qismida <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">&quot;Agar aniq talab qilinmasa, ba'zi testlarni e'tiborsiz qoldirish&quot;</a><!-- ignore --> bo'limida ko'rib chiqamiz. Bu yerda biz buni qilmaganimiz sababli, xulosada  <code>0 ignored</code> 0-ta e ºtibor berilmagan ko ªrsatiladi. Shuningdek, biz argumentni faqat nomi satrga mos keladigan testlarni o'tkazish uchun <code>cargo test</code> buyrug'iga o'tkazishimiz mumkin; bu <em>filtrlash</em> deb ataladi va biz buni <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">&quot;Testlar to'plamini nomi bo'yicha ishga tushirish&quot;</a><!-- ignore --> bo'limida ko'rib chiqamiz. Shuningdek, biz bajarilayotgan testlarni filtrlamadik, shuning uchun xulosa oxirida <code>0 filtered out</code> 0-ta filtrlangan deb ko‚Äòrsatiladi.</p>
<p><code>0 measured</code> statistikasi samaradorlikni o'lchaydigan benchmark testlari uchundir.
Benchmark testlari, ushbu yozuvdan boshlab, faqat nightly Rust-da mavjud. Batafsil ma'lumot olish uchun <a href="../unstable-book/library-features/test.html">benchmark testlari haqidagi hujjatlarga</a> qarang.</p>
<p><code>Doc-tests adder</code>(Hujjat testlari qo ªshuvchisi) dan boshlanadigan test natijasining keyingi qismi har qanday hujjat sinovlari natijalariga mo ªljallangan. Bizda hali hech qanday hujjat sinovlari yo'q, lekin Rust API hujjatlarida ko'rinadigan har qanday kod misollarini to'plashi mumkin.
Bu xususiyat hujjatlaringiz va kodingizni sinxronlashtirishga yordam beradi! Hujjat testlarini qanday yozishni 14-bobning <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">‚ÄúHujjatlarga sharhlar test sifatida‚Äù</a><!-- ignore --> bo‚Äòlimida muhokama qilamiz. Hozircha biz <code>Doc-tests</code> chiqishini e'tiborsiz qoldiramiz.</p>
<p>Keling, testni o'z ehtiyojlarimizga moslashtirishni boshlaylik. Avval <code>ishlaydi</code> funksiyasining nomini <code>tadqiqot</code> kabi boshqa nomga o'zgartiring, masalan:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn tadqiqot() {
        assert_eq!(2 + 2, 4);
    }
}</code></pre>
<p>Keyin yana <code>cargo test</code> bajaring. Chiqish(output) endi <code>ishlaydi</code> o‚Äòrniga <code>tadqiqot</code>ni ko‚Äòrsatadi:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::tadqiqot ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Endi biz yana bir test qo'shamiz, lekin bu safar muvaffaqiyatsiz bo'lgan testni qilamiz! Test funktsiyasidagi biror narsa panic qo'zg'atganda, testlar muvaffaqiyatsiz tugaydi. Har bir test yangi threadda o'tkaziladi va asosiy(main) thread sinov chizig'i o'lganini ko'rsa, test muvaffaqiyatsiz deb belgilanadi. 9-bobda biz panic qo'zg'ashning eng oddiy yo'li <code>panic!</code> makrosini chaqirish haqida gapirdik. Yangi testni <code>boshqa</code> funksiya sifatida kiriting, shunda <em>src/lib.rs</em> faylingiz 11-3 ro ªyxatiga o ªxshaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn tadqiqot() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn boshqa() {
        panic!(&quot;Ushbu test muvaffaqiyatsizlikka uchradil&quot;);
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-3: Muvaffaqiyatsiz bo'ladigan ikkinchi testni qo'shish, chunki biz <code>panic!</code> makrosini chaqiramiz.</span></p>
<p><code>cargo test</code> yordamida testlarni qaytadan test qiling. Chiqish 11-4 ro'yxatga o'xshash bo'lishi kerak, bu bizning <code>tadqiqot</code> sinovimizdan o'tganligini va <code>boshqa</code> muvaffaqiyatsiz ekanligini ko'rsatadi.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::boshqa ... FAILED
test tests::tadqiqot ... ok

failures:

---- tests::boshqa stdout ----
thread 'tests::boshqa' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::boshqa

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p><span class="caption">Ro'yxat 11-4: Bitta test sinovdan o'tgan va bitta test muvaffaqiyatsizlikka uchragan sinov natijalari</span></p>
<p><code>OK</code> o'rniga <code>test tests::boshqa</code> qatori <code>FAILED</code>ni ko ªrsatadi. Shaxsiy natijalar va xulosa o'rtasida ikkita yangi bo'lim paydo bo'ladi: birinchisida har bir sinov muvaffaqiyatsizligining batafsil sababi ko'rsatiladi. Bunday holda, biz <em>src/lib.rs</em> faylidagi 10-qatordagi <code>panicked at 'Make this test fail'</code> da panic qo'ygani uchun <code>boshqa</code> muvaffaqiyatsizlikka uchraganligi haqidagi tafsilotlarni olamiz. Keyingi bo'limda barcha muvaffaqiyatsiz testlarning nomlari keltirilgan, bu juda ko'p sinovlar va ko'plab batafsil muvaffaqiyatsiz sinov natijalari mavjud bo'lganda foydalidir. Muvaffaqiyatsiz test nomidan uni osonroq debug qilish uchun ishlatishimiz mumkin; testlarni o'tkazish usullari haqida ko'proq <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">&quot;Testlar qanday o'tkazilishini nazorat qilish&quot;</a><!-- ignore
--> section bo'limida gaplashamiz.</p>
<p>Xulosa qatori oxirida ko'rsatiladi: umuman olganda, bizning test natijasimiz <code>FAILED</code> muvaffaqiyatsiz. Bizda bitta test sinovi bor edi va bitta sinov muvaffaqiyatsiz tugadi.</p>
<p>Sinov natijalari turli stsenariylarda qanday ko‚Äòrinishini ko‚Äòrganingizdan so‚Äòng, keling, testlarda foydali bo‚Äòlgan  <code>panic!</code>dan tashqari ba‚Äôzi makrolarni ko‚Äòrib chiqaylik.</p>
<h3 id="natijalarni-assert-makrosi-bilan-tekshirish"><a class="header" href="#natijalarni-assert-makrosi-bilan-tekshirish">Natijalarni <code>assert!</code> makrosi bilan tekshirish!</a></h3>
<p>Standart kutubxona tomonidan taqdim etilgan <code>assert!</code> makrosi testdagi ba ºzi shartlar <code>true</code>(to ªg ªri) bo ªlishini ta ºminlashni istasangiz foydali bo ªladi. Biz <code>assert!</code> makrosiga mantiqiy(boolean) qiymatga baholovchi argument beramiz. Qiymat <code>true</code> bo'lsa, hech narsa sodir bo'lmaydi va sinovdan o'tadi. Agar qiymat <code>false</code> bo‚Äòlsa, <code>assert!</code> makros testning muvaffaqiyatsiz bo‚Äòlishiga olib kelishi uchun <code>panic!</code> chaqiradi. <code>assert!</code> makrosidan foydalanish bizning kodimiz biz rejalashtirgan tarzda ishlayotganligini tekshirishga yordam beradi.</p>
<p>5-bob, 5-15-ro'yxarda biz 11-5-ro'yxardada takrorlangan <code>Kvadrat</code> strukturasi va <code>ushlab_tur</code> metodidan foydalandik. Keling, ushbu kodni <em>src/lib.rs</em> fayliga joylashtiramiz, so'ngra <code>assert!</code> makrosidan foydalanib, u uchun testlarni yozamiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Kvadrat {
    kenglik: u32,
    balandlik: u32,
}

impl Kvadrat {
    fn ushlab_tur(&amp;self, boshqa: &amp;Kvadrat) -&gt; bool {
        self.kenglik &gt; other.kenglik &amp;&amp; self.balandlik &gt; boshqa.balandlik
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-5: 5-bobdagi <code>Kvadrat</code> strukturasi va uning <code>ushlab_tur</code> metodidan foydalanish</span></p>
<p><code>ushlab_tur</code> metodi mantiqiy(boolean) qiymatini qaytaradi, ya'ni bu <code>assert!</code> makrosi uchun mukammal foydalanish holati. 11-6 ro'yxatda biz kengligi 8 va balandligi 7 bo'lgan <code>Kvadrat</code> misolini yaratish va uning kengligi 5 va balandligi 1 bo'lgan boshqa <code>Kvadrat</code> misolini ushlab turishi mumkinligini tekshirish orqali <code>ushlab_tur</code> metodini bajaradigan testni yozamiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Kvadrat {
</span><span class="boring">    kenglik: u32,
</span><span class="boring">    balandlik: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Kvadrat {
</span><span class="boring">    fn ushlab_tur(&amp;self, boshqa: &amp;Kvadrat) -&gt; bool {
</span><span class="boring">        self.kenglik &gt; boshqa.kenglik &amp;&amp; self.balandlik &gt; boshqa.balandlik
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn katta_kichikni_ushlab_turadi() {
        let kattaroq = Kvadrat {
            kenglik: 8,
            balandlik: 7,
        };
        let kichikroq = Kvadrat {
            kenglik: 5,
            balandlik: 1,
        };

        assert!(kattaroq.ushlab_tur(&amp;kichikroq));
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-6: Kattaroq kvadrat haqiqatan ham kichikroq kvadratni sig'dira oladimi yoki yo'qligini tekshiradigan <code>ushlab_tur</code> testi</span></p>
<p>E'tibor bering, biz <code>tests</code> moduliga yangi qator qo'shdik: <code>use super::*;</code>. <code>tests</code> moduli odatiy modul bo'lib, biz 7-bobda <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">&quot;Modul daraxtidagi elementga murojaat qilish yo'llari&quot;</a><!-- ignore --> bo'limida ko'rib chiqqan odatiy ko'rinish qoidalariga amal qiladi. <code>tests</code> moduli ichki modul bo'lgani uchun biz tashqi moduldagi sinovdan o'tayotgan kodni ichki modul doirasiga kiritishimiz kerak. Biz bu yerda globdan foydalanamiz, shuning uchun tashqi modulda biz aniqlagan har qanday narsa ushbu <code>tests</code> modulida mavjud bo'ladi.</p>
<p>Biz sinovimizga <code>katta_kichikni_ushlab_turadi</code> deb nom berdik va o‚Äòzimizga kerak bo‚Äòlgan ikkita <code>Kvadrat</code> misolini yaratdik.
Keyin biz <code>assert!</code> makrosini chaqirdik va uni <code>kattaroq.ushlab_tur(&amp;kichikroq)</code> deb chaqirish natijasini berdik. Bu ifoda <code>true</code> ni qaytarishi kerak, shuning uchun testimiz muvaffaqiyatli o'tishi kerak. Keling, bilib olaylik!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Test muvaffaqiyatli o'tadi! Keling, yana bir sinovni qo'shamiz, bu safar kichikroq kvadrat kattaroq kvadratni ushlab turolmaydi:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Kvadrat {
</span><span class="boring">    kenglik: u32,
</span><span class="boring">    balandlik: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Kvadrat {
</span><span class="boring">    fn ushlab_tur(&amp;self, boshqa: &amp;Kvadrat) -&gt; bool {
</span><span class="boring">        self.kenglik &gt; boshqa.kenglik &amp;&amp; self.balandlik &gt; boshqa.balandlik
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn katta_kichikni_ushlab_turadi() {
        // --snip--
<span class="boring">        let kattaroq = Kvadrat {
</span><span class="boring">            kenglik: 8,
</span><span class="boring">            balandlik: 7,
</span><span class="boring">        };
</span><span class="boring">        let kichikroq = Kvadrat {
</span><span class="boring">            kenglik: 5,
</span><span class="boring">            balandlik: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(kattaroq.ushlab_tur(&amp;kichikroq));
</span>    }

    #[test]
    fn kichik_kattani_ushlolmaydi() {
        let kattaroq = Kvadrat {
            kenglik: 8,
            balandlik: 7,
        };
        let kichikroq = Kvadrat {
            kenglik: 5,
            balandlik: 1,
        };

        assert!(!kichikroq.ushlab_tur(&amp;kattaroq));
    }
}</code></pre>
<p>Chunki bu holda <code>ushlab_tur</code> funksiyasining to'g'ri natijasi <code>false</code> bo'lsa, biz uni <code>assert!</code> makrosiga o'tkazishdan oldin bu natijani inkor etishimiz kerak. Natijada, agar <code>ushlab_tur</code> <code>false</code> qiymatini qaytarsa, testimiz o'tadi:</p>
<pre><code class="language-console">$ cargo test
   Compiling kvadrat v0.1.0 (file:///projects/kvadrat)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/kvadrat-6584c4561e48942e)

running 2 tests
test tests::katta_kichikni_ushlab_turadi ... ok
test tests::kichik_kattani_ushlolmaydi ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests kvadrat

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Ikkita sinovdan o'tadi! Keling, kodimizga xatolik kiritganimizda test natijalarimiz bilan nima sodir bo'lishini ko'rib chiqaylik. Kengliklarni solishtirganda katta belgisini kichikroq belgisi bilan almashtirish orqali <code>ushlab_tur</code> metodini amalga oshirishni o‚Äòzgartiramiz:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Kvadrat {
</span><span class="boring">    kenglik: u32,
</span><span class="boring">    balandlik: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Kvadrat {
    fn ushlab_tur(&amp;self, boshqa: &amp;Kvadrat) -&gt; bool {
        self.kenglik &lt; boshqa.kenglik &amp;&amp; self.balandlik &gt; boshqa.balandlik
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn katta_kichikni_ushlab_turadi() {
</span><span class="boring">        let kattaroq = Kvadrat {
</span><span class="boring">            kenglik: 8,
</span><span class="boring">            balandlik: 7,
</span><span class="boring">        };
</span><span class="boring">        let kichikroq = Kvadrat {
</span><span class="boring">            kenglik: 5,
</span><span class="boring">            balandlik: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(kattaroq.ushlab_tur(&amp;kichikroq));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn kichik_kattani_ushlolmaydi() {
</span><span class="boring">        let kattaroq = Kvadrat {
</span><span class="boring">            kenglik: 8,
</span><span class="boring">            balandlik: 7,
</span><span class="boring">        };
</span><span class="boring">        let kichikroq = Kvadrat {
</span><span class="boring">            kenglik: 5,
</span><span class="boring">            balandlik: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!kichikroq.ushlab_tur(&amp;kattaroq));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Sinovlarni o'tkazish endi quyidagilarga olib keladi:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Sinovlarimiz xatoni aniqladi! <code>kattaroq.kenglik</code> 8 va <code>kichikroq.kenglik</code> 5 bo'lganligi sababli, <code>ushlab_tur</code>da kengliklarni taqqoslash endi <code>false</code>ni qaytaradi: 8 5-dan kichik emas.</p>
<h3 id="tenglikni-assert_eq-va-assert_ne-makroslari-bilan-tekshirish"><a class="header" href="#tenglikni-assert_eq-va-assert_ne-makroslari-bilan-tekshirish">Tenglikni <code>assert_eq!</code> va <code>assert_ne!</code> makroslari bilan tekshirish</a></h3>
<p>Funksionallikni tekshirishning keng tarqalgan usuli - bu testdan o'tayotgan kod natijasi va kod qaytarilishini kutayotgan qiymat o'rtasidagi tenglikni tekshirish. Buni <code>assert!</code> makrosidan foydalanib, unga <code>==</code> operatori yordamida ifoda o'tkazishingiz mumkin. Biroq, bu shunday keng tarqalgan testki, standart kutubxona ushbu testni yanada qulayroq bajarish uchun bir juft makros-<code>assert_eq!</code> va <code>assert_ne!</code>-ni taqdim etadi. Ushbu makrolar mos ravishda tenglik yoki tengsizlik uchun ikkita argumentni solishtiradi. Agar tasdiqlash muvaffaqiyatsiz bo'lsa, ular ikkita qiymatni chop etadilar, bu esa <em>nima uchun</em> sinov muvaffaqiyatsiz tugaganini ko'rishni osonlashtiradi; aksincha, <code>assert!</code> makros <code>false</code> qiymatiga olib kelgan qiymatlarni chop etmasdan, <code>==</code> ifodasi uchun <code>false</code> qiymatini olganligini bildiradi.
11-7 ro'yxatda biz o'z parametriga <code>2</code> qo'shadigan <code>ikkita_qoshish</code> nomli funksiyani yozamiz, so'ngra bu funksiyani <code>assert_eq!</code> makrosidan foydalanib tekshiramiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn ikkita_qoshish(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ikkita_qosh() {
        assert_eq!(4, ikkita_qoshish(2));
    }
}</code></pre>
<p><span class="caption">Ro ªyxat 11-7: <code>assert_eq!</code> makrosidan foydalanib <code>ikkita_qoshish</code> funksiyasini sinab ko ªrish</span></p>
<p>Keling test o'tganligini tekshirib ko'raylik!</p>
<pre><code class="language-console">$ cargo test
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshuvchi)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/qoshuvchi-92948b65e88960b4)

running 1 test
test tests::ikkita_qosh ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests qoshuvchi

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Argument sifatida <code>4</code> ni <code>assert_eq!</code>ga o'tkazamiz, bu esa <code>ikkita_qoshish(2)</code> ni chaqirish natijasiga teng. Ushbu test qatori  <code>test tests::it_adds_two ... ok</code> va <code>ok</code> matni testimiz muvaffaqiyatli o'tganligini bildiradi!</p>
<p><code>assert_eq!</code> muvaffaqiyatsiz bo'lganda qanday ko'rinishini ko'rish uchun kodimizga xato kiritamiz. <code>ikkita_qoshish</code> funksiyasining bajarilishini o'rniga <code>3</code> qo'shish uchun o`zgartiramiz:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn ikkita_qoshish(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn ikkita_qosh() {
</span><span class="boring">        assert_eq!(4, ikkita_qoshish(2));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Testlarni qayta ishga tushiring:</p>
<pre><code class="language-console">$ cargo test
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshuvchi)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/qoshuvchi-92948b65e88960b4)

running 1 test
test tests::ikkita_qosh ... FAILED

failures:

---- tests::ikkita_qosh stdout ----
thread 'tests::ikkita_qosh' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::ikkita_qosh

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Bizning sinovimiz xatoni aniqladi! <code>ikkita_qosh</code> testi muvaffaqiyatsiz tugadi va xabarda muvaffaqiyatsizlikka uchragan tasdiqlash <code>assertion failed: `(left == right)`</code> va <code>left</code> va <code>right</code> qiymatlari nima. Bu xabar nosozliklarni(debugging) tuzatishni boshlashimizga yordam beradi: <code>left</code>(chap) argumenti <code>4</code> edi, lekin <code>ikkita_qoshish(2)</code> bo'lgan <code>right</code>(o'ng) argumenti <code>5</code> edi. Tasavvur qilishingiz mumkinki, bu bizda juda ko'p sinovlar o'tkazilayotganda ayniqsa foydali bo'ladi.</p>
<p>E'tibor bering, ba'zi dasturlash tillarda va test tizimlarida(framework) tenglikni tasdiqlash funksiyalari parametrlari <code>expected</code> va <code>actual</code> deb nomlanadi va biz argumentlarni ko'rsatish tartibi muhim ahamiyatga ega. Biroq, Rustda ular <code>left</code> va <code>right</code> deb nomlanadi va biz kutgan qiymat va kod ishlab chiqaradigan qiymatni belgilash tartibi muhim emas. Biz ushbu testdagi tasdiqni <code>assert_eq!(ikkita_qoshish(2), 4)</code> deb yozishimiz mumkin, natijada <code>assertion failed: `(left == right)`</code> ko'rsatiladigan bir xil xato xabari paydo bo'ladi.</p>
<p><code>assert_ne!</code> makros biz bergan ikkita qiymat teng bo'lmasa o'tadi va teng bo'lsa muvaffaqiyatsiz bo'ladi. Ushbu makro biz qiymat nima bo'lishini amin bo'lmagan holatlar uchun juda foydali bo'ladi, lekin biz qiymat nima bo'lmasligi kerakligini bilamiz.
Misol uchun, agar biz biron-bir tarzda uning kiritilishini o'zgartirishi kafolatlangan funksiyani sinab ko'rayotgan bo'lsak, lekin kirishni o'zgartirish metodi testlarimizni o'tkazadigan hafta kuniga bog'liq bo'lsa, tasdiqlash uchun eng yaxshi narsa, funksiyaning chiqishi kirishga teng emasligi bo'lishi mumkin.</p>
<p>Sirt ostida <code>assert_eq!</code> va <code>assert_ne!</code> makroslari mos ravishda <code>==</code> va <code>!=</code> operatorlaridan foydalanadi. Tasdiqlar bajarilmasa, bu makroslar debug formati yordamida o‚Äòz argumentlarini chop etadi, ya‚Äôni solishtirilayotgan qiymatlar <code>PartialEq</code> va <code>Debug</code> traitlarini bajarishi kerak. Barcha primitiv turlar va standart kutubxona turlarining aksariyati bu traittlarni amalga oshiradi. O'zingiz belgilagan structlar va enumlar uchun ushbu turlarning tengligini tasdiqlash uchun <code>PartialEq</code> ni qo'llashingiz kerak bo'ladi. Tasdiqlash muvaffaqiyatsizlikka uchraganida qiymatlarni chop etish uchun <code>Debug</code> ni ham qo'llashingiz kerak bo'ladi. 5-bobdagi 5-12 ro ªyxatda aytib o ªtilganidek, ikkala trait ham derivable traitli bo ªlganligi sababli, bu odatda struct yoki enum ta ºrifiga <code>#[derive(PartialEq, Debug)]</code> izohini qo ªshishdek oddiy. Ushbu va boshqa <a href="appendix-03-derivable-traits.html">&quot;Derivable Trait&quot;</a><!-- ignore -->lari haqida batafsil ma'lumot olish uchun C ilovasiga qarang.</p>
<h3 id="maxsus-nosozlik-xabarlarini-qoshish"><a class="header" href="#maxsus-nosozlik-xabarlarini-qoshish">Maxsus nosozlik xabarlarini qo'shish</a></h3>
<p>Shuningdek, <code>assert!</code>, <code>assert_eq!</code> va <code>assert_ne!</code> makroslariga ixtiyoriy argumentlar sifatida xato xabari bilan chop etiladigan maxsus xabarni qo'shishingiz mumkin. Kerakli argumentlardan so‚Äòng ko‚Äòrsatilgan har qanday argumentlar <code>format!</code> makrosiga uzatiladi (8-bobda <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">&quot;<code>+</code> operatori yoki <code>format!</code> makrosi bilan birlashtirish&quot;</a><!-- ignore --> bo‚Äòlimida muhokama qilingan), shuning uchun siz <code>{}</code> to'ldirgichlar va qiymatlarni o'z ichiga olgan format qatorini o'tkazishingiz mumkin. Maxsus xabarlar tasdiqlash nimani anglatishini hujjatlashtirish uchun foydalidir; test muvaffaqiyatsiz tugagach, kod bilan bog'liq muammo nimada ekanligini yaxshiroq tushunasiz.</p>
<p>Masalan, bizda odamlarni ism bilan kutib oladigan funksiya bor va biz funksiyaga kiritgan ism chiqishda(output) paydo bo‚Äòlishini sinab ko‚Äòrmoqchimiz:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn salomlashish(name: &amp;str) -&gt; String {
    format!(&quot;Salom {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn salomlash() {
        let natija = salomlashish(&quot;Azizbek&quot;);
        assert!(natija.contains(&quot;Azizbek&quot;));
    }
}</code></pre>
<p>Ushbu dasturga qo ªyiladigan talablar hali kelishib olinmagan va salomlashish boshidagi <code>Salom</code> matni o ªzgarishiga ishonchimiz komil. Talablar o'zgarganda testni yangilashni xohlamasligimizga qaror qildik, shuning uchun <code>salomlashish</code> funksiyasidan qaytarilgan qiymatga aniq tenglikni tekshirish o‚Äòrniga, biz faqat chiqishda kirish parametrining matni borligini tasdiqlaymiz.</p>
<p>Endi standart sinov xatosi qanday ko ªrinishini ko ªrish uchun <code>name</code>ni chiqarib tashlash uchun <code>salomlashish</code> ni o ªzgartirish orqali ushbu kodga xatolik kiritamiz:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn salomlashish(name: &amp;str) -&gt; String {
    String::from(&quot;Salom!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn salomlash() {
</span><span class="boring">        let natija = salomlashish(&quot;Azizbek&quot;);
</span><span class="boring">        assert!(natija.contains(&quot;Azizbek&quot;));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Ushbu testni bajarish quyidagi natijalarni beradi:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::salomlash ... FAILED

failures:

---- tests::salomlash stdout ----
thread 'tests::salomlash' panicked at 'assertion failed: result.contains(\&quot;Azizbek\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::salomlash

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Bu natija faqat tasdiqlash(assertion) muvaffaqiyatsizligini va tasdiqlash qaysi qatorda ekanligini ko'rsatadi. Foydaliroq xato xabari <code>salomlashish</code> funksiyasidan qiymatni chop etadi. Keling, <code>salomlashish</code> funksiyasidan olingan haqiqiy qiymat bilan to ªldirilgan maxsus xabar to'ldiruvchisi(plaseholder) bilan format qatoridan iborat maxsus xato xabarini qo ªshamiz:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn salomlashish(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Salom!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn salomlash() {
        let natija = salomlashish(&quot;Azizbek&quot;);
        assert!(
            natija.contains(&quot;Azizbek&quot;),
            &quot;Salomlashishda ism yo'q, qiymat `{}` edi&quot;,
            natija
        );
    }
<span class="boring">}</span></code></pre>
<p>Endi sinovni o'tkazganimizda, biz ko'proq ma'lumot beruvchi xato xabarini olamiz:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::salomlash ... FAILED

failures:

---- tests::salomlash stdout ----
thread 'tests::salomlash' panicked at 'Greeting did not contain name, value was `Salom!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::salomlash

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Sinov natijasida biz haqiqatda olgan qiymatni ko'rishimiz mumkin, bu biz kutgan narsaning o'rniga nima sodir bo'lganligini aniqlashga yordam beradi.</p>
<h3 id="should_panic-yordamida-panic-tekshirish"><a class="header" href="#should_panic-yordamida-panic-tekshirish"><code>should_panic</code> yordamida panic tekshirish</a></h3>
<p>Qaytish(return) qiymatlarini tekshirishdan tashqari, bizning kodimiz xato holatlarini biz kutganidek hal qilishini tekshirish muhimdir. Misol uchun, biz 9-bob, 9-13 ro'yxatda yaratgan <code>Taxmin</code> turini ko'rib chiqaylik. <code>Taxmin</code> dan foydalanadigan boshqa kod <code>Taxmin</code> misollarida faqat 1 dan 100 gacha bo'lgan qiymatlarni o'z ichiga olishi kafolatiga bog'liq. Ushbu diapazondan(chegaradan) tashqaridagi qiymatga ega <code>Taxmin</code> misolini yaratishga urinish panic qo'yishini ta'minlaydigan test yozishimiz mumkin.</p>
<p>Buni test funksiyamizga <code>should_panic</code> atributini qo‚Äòshish orqali qilamiz. Funktsiya ichidagi kod panic qo'zg'atsa, test o'tadi;funksiya ichidagi kod panic qo'ymasa, test muvaffaqiyatsiz tugaydi.</p>
<p>11-8 ro'yxatda <code>Taxmin::new</code> xatolik holatlari biz kutgan vaqtda sodir bo'lishini tekshiradigan test ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-8: Test <code>panic!</code> keltirib chiqarishini tekshirish</span></p>
<p>Biz <code>#[should_panic]</code> atributini <code>#[test]</code> atributidan keyin va u amal qiladigan test funksiyasidan oldin joylashtiramiz. Keling, ushbu testdan o'tgan natijani ko'rib chiqaylik:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Yaxshi ko'rinadi! Endi shartni olib tashlash orqali kodimizga xatolik kiritamiz,
agar qiymat 100 dan katta bo'lsa, <code>new</code> funksiya panic qo'zg'atadi:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Taxmin {
</span><span class="boring">    qiymat: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Taxmin {
    pub fn new(qiymat: i32) -&gt; Taxmin {
        if qiymat &lt; 1 {
            panic!(&quot;Taxmin qilingan qiymat 1 dan 100 gacha bo'lishi kerak, {} qabul qilinmaydi.&quot;, qiymat);
        }

        Taxmin { qiymat }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn _100_dan_ortiq() {
</span><span class="boring">        Taxmin::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Sinovni 11-8 ro'yxatda o'tkazganimizda, u muvaffaqiyatsiz bo'ladi:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::_100_dan_ortiq - should panic ... FAILED

failures:

---- tests::_100_dan_ortiq stdout ----
note: test did not panic as expected

failures:
    tests::_100_dan_ortiq

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Biz bu holatda unchalik foydali xabar olmaymiz, lekin test funksiyasini ko‚Äòrib chiqsak, u <code>#[should_panic]</code> bilan izohlanganini ko‚Äòramiz. Biz erishgan muvaffaqiyatsizlik test funksiyasidagi kod panic qo'zg'atmaganligini anglatadi.</p>
<p><code>should_panic</code> ishlatadigan testlar noaniq bo'lishi mumkin. Agar test biz kutgandan boshqa sababga ko'ra panic qo'zg'atsa ham, <code>should_panic</code> testi o'tadi. <code>should_panic</code> testlarini aniqroq qilish uchun biz <code>should_panic</code> atributiga ixtiyoriy <code>expected</code>  parametrini qo'shishimiz mumkin. Test dasturi xato xabarida taqdim etilgan matn mavjudligiga ishonch hosil qiladi. Masalan, 11-9 ro'yxatdagi <code>Taxmin</code> uchun o'zgartirilgan kodni ko'rib chiqing, bu erda <code>new</code> funksiya qiymat juda kichik yoki juda kattaligiga qarab turli xabarlar bilan panicga tushadi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-9: Belgilangan substringni o ªz ichiga olgan panic xabari bilan <code>panic!</code> sinovi</span></p>
<p>Bu testdan o‚Äòtadi, chunki biz <code>should_panic</code> atributining <code>expected</code> parametriga qo‚Äòygan qiymat <code>Taxmin::new</code> funksiyasi panicga tushadigan xabarning substringi hisoblanadi. Biz kutgan vahima haqidagi xabarni to ªliq ko ªrsatishimiz mumkin edi, bu holda <code>Taxmin qilingan qiymat 1 dan 100 gacha bo'lishi kerak, 200 qabul qilinmaydi.</code>. Siz belgilashni tanlagan narsa panic xabarining qanchalik noyob yoki dinamik ekanligiga va testingiz qanchalik aniq bo'lishini xohlayotganingizga bog'liq. Bunday holda, test funksiyasidagi kod <code>else if qiymat &gt; 100</code> holatini bajarishini ta`minlash uchun panic xabarining substringi kifoya qiladi.</p>
<p><code>expected</code>  xabari bilan <code>should_panic</code> testi muvaffaqiyatsiz tugashi bilan nima sodir bo'lishini ko'rish uchun <code>if qiymat &lt; 1</code> va <code>else if qiymat &gt; 100</code> bloklarini almashtirish orqali kodimizga yana xato kiritamiz:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Taxmin {
</span><span class="boring">    qiymat: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Taxmin  {
</span><span class="boring">    pub fn new(qiymat: i32) -&gt; Taxmin  {
</span>        if qiymat &lt; 1 {
            panic!(
                &quot;Taxmin qilingan qiymat 1 dan 100 gacha bo'lishi kerak, {} qabul qilinmaydi.&quot;,
                qiymat
            );
        } else if qiymat &gt; 100 {
            panic!(
                &quot;Taxmin qilingan qiymat 1 dan katta yoki teng bo'lishi kerak, {} qabul qilinmaydi.&quot;,
                qiymat
            );
        }
<span class="boring">
</span><span class="boring">        Taxmin  { qiymat }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;100 dan kichik yoki teng&quot;)]
</span><span class="boring">    fn _100_dan_ortiq() {
</span><span class="boring">        Taxmin ::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Bu safar biz <code>should_panic</code> testini o'tkazsak, u muvaffaqiyatsiz bo'ladi:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::_100_dan_ortiq - should panic ... FAILED

failures:

---- tests::_100_dan_ortiq stdout ----
thread 'tests::_100_dan_ortiq' panicked at 'Taxmin qilingan qiymat 1 dan katta yoki teng bo'lishi kerak, 200 qabul qilinmaydi.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Taxmin qilingan qiymat 1 dan katta yoki teng bo'lishi kerak, 200 qabul qilinmaydi.&quot;`,
 expected substring: `&quot;100 dan kichik yoki teng&quot;`

failures:
    tests::_100_dan_ortiq

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Muvaffaqiyatsizlik xabari shuni ko'rsatadiki, bu test biz kutgandek panic qo'zg'atdi, lekin panic xabarida kutilgan <code>Taxmin qilingan qiymat 100 dan kichik yoki unga teng bo'lishi kerak</code> qatori yo'q edi. Bu holatda biz olgan vahima xabari: <code>Taxmin qilingan qiymat 1 dan katta yoki teng bo'lishi kerak, 200 qabul qilinmaydi.</code>. Endi biz xatomiz qayerda ekanligini aniqlashni boshlashimiz mumkin!</p>
<h3 id="testlarda-resultt-e-dan-foydalanish"><a class="header" href="#testlarda-resultt-e-dan-foydalanish">Testlarda <code>Result&lt;T, E&gt;</code> dan foydalanish</a></h3>
<p>Bizning testlarimiz muvaffaqiyatsiz bo'lganda panic qo'zg'atadi. Biz <code>Result&lt;T, E&gt;</code> dan foydalanadigan testlarni ham yozishimiz mumkin! 11-1 ro ªyxatidagi test <code>Result&lt;T, E&gt;</code> dan foydalanish va panic o ªrniga <code>Err</code>ni qaytarish uchun qayta yozilgan:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn ishlaydi() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;ikki qo'shish ikki to'rtga teng emas&quot;))
        }
    }
}</code></pre>
<p><code>ishlaydi</code> funksiyasi endi <code>Result&lt;(), String&gt;</code> qaytish(return) turiga ega. Funksiya tanasida <code>assert_eq!</code> makrosini chaqirishdan ko'ra, testdan o'tganda <code>Ok(())</code> va test muvaffaqiyatsiz bo'lganda ichida <code>String</code> bilan <code>Err</code>ni qaytaramiz.</p>
<p>Testlarni <code>Result&lt;T, E&gt;</code> qaytaradigan qilib yozish testlar matnida savol belgisi operatoridan foydalanish imkonini beradi, bu testlarni yozishning qulay usuli bo'lishi mumkin, agar ulardagi har qanday operatsiya <code>Err</code> variantini qaytarsa, muvaffaqiyatsiz bo'lishi mumkin.</p>
<p><code>Result&lt;T, E&gt;</code> ishlatadigan testlarda <code>#[should_panic]</code> izohidan(annotation) foydalana olmaysiz. Amaliyot <code>Err</code> variantini qaytarishini tasdiqlash uchun <code>Result&lt;T, E&gt;</code> qiymatida savol belgisi operatoridan foydalanmang. Buning o ªrniga <code>assert!(value.is_err())</code> dan foydalaning.</p>
<p>Endi siz testlarni yozishning bir necha usullarini bilganingizdan so'ng, keling, testlarimizni o'tkazganimizda nima sodir bo'layotganini ko'rib chiqamiz va <code>cargo test</code> bilan foydalanishimiz mumkin bo'lgan turli xil variantlarni ko'rib chiqamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="testlar-qanday-otkazilishini-nazorat-qilish"><a class="header" href="#testlar-qanday-otkazilishini-nazorat-qilish">Testlar qanday o'tkazilishini nazorat qilish</a></h2>
<p>Xuddi <code>cargo run</code> kodingizni kompilyatsiya qilib, natijada olingan binaryni ishga tushirganidek, <code>cargo test</code> kodingizni test rejimida kompilyatsiya qiladi va natijada olingan binary testni ishga tushiradi. <code>cargo test</code> tomonidan ishlab chiqarilgan binary faylning standart xatti-harakati barcha testlarni parallel ravishda bajarish va sinov testlari paytida hosil bo'lgan chiqishni(output) olish, natijaning ko'rsatilishiga yo'l qo'ymaslik va sinov natijalari bilan bog'liq chiqishni o'qishni osonlashtirishdir. Biroq, siz ushbu standart xatti-harakatni o'zgartirish uchun buyruq qatori parametrlarini belgilashingiz mumkin.</p>
<p>Ba'zi buyruq qatori opsiyalari <code>cargo test</code> ga, ba'zilari esa natijada olingan binary testga o'tadi. Ushbu ikki turdagi argumentlarni ajratish uchun siz <code>cargo test</code> ga, so'ngra ajratuvchi <code>--</code> ga o'tadigan argumentlarni, so'ngra test binarysiga o'tadigan argumentlarni sanab o'tasiz. <code>cargo test --help</code>ni ishga tushirish <code>cargo test</code> bilan foydalanishingiz mumkin bo'lgan variantlarni ko'rsatadi va <code>cargo test -- --help</code>ni ishga tushirish ajratuvchidan(separator) keyin foydalanishingiz mumkin bo'lgan variantlarni ko'rsatadi.</p>
<h3 id="testlarni-parallel-yoki-ketma-ket-bajarish"><a class="header" href="#testlarni-parallel-yoki-ketma-ket-bajarish">Testlarni parallel yoki ketma-ket bajarish</a></h3>
<p>Bir nechta testlarni bajarganingizda, standart bo'yicha ular threadlar yordamida parallel ravishda ishlaydi, ya'ni ular tezroq ishlashni tugatadi va siz tezroq fikr-mulohaza olasiz. Testlar bir vaqtning o'zida ishlayotganligi sababli, sizning testlaringiz bir-biriga yoki umumiy holatga, jumladan, joriy ishchi jildi yoki muhit o'zgaruvchilari kabi umumiy muhitga bog'liq emasligiga ishonch hosil qilishingiz kerak.</p>
<p>Misol uchun, sizning har bir testingiz diskda <em>test-output.txt</em> nomli fayl yaratadigan va ushbu faylga ba'zi ma'lumotlarni yozadigan ba'zi kodlarni ishga tushiradi. Keyin har bir test ushbu fayldagi ma'lumotlarni o'qiydi va faylda har bir testda har xil bo'lgan ma'lum bir qiymat borligini tasdiqlaydi. Testlar bir vaqtning o'zida bajarilganligi sababli, bitta test faylni boshqa test yozish va o'qish oralig'ida faylni qayta yozishi mumkin. Ikkinchi test kod noto'g'ri bo'lgani uchun emas, balki parallel ravishda ishlayotganda testlar bir-biriga xalaqit bergani uchun muvaffaqiyatsiz bo'ladi. Bitta yechim har bir test boshqa faylga yozishiga ishonch hosil qilishdir; yana bir yechim testlarni birma-bir bajarishdir.</p>
<p>Agar siz testlarni parallel ravishda o'tkazishni xohlamasangiz yoki ishlatilgan threadlar sonini yanada aniqroq nazorat qilishni istasangiz, siz <code>--test threads</code> buyru'gini va foydalanmoqchi bo'lgan threadlar sonini test binaryga yuborishingiz mumkin. Quyidagi misolni ko'rib chiqing:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Biz dasturga parallelizmdan foydalanmaslikni aytib, test threadlari sonini <code>1</code> ga o'rnatdik. Testlarni bitta thread yordamida o'tkazish ularni parallel ravishda bajarishdan ko'ra ko'proq vaqt talab etadi, ammo agar ular umumiy holatga ega bo'lsa, testlar bir-biriga xalaqit bermaydi.</p>
<h3 id="funktsiya-natijalarini-korsatish"><a class="header" href="#funktsiya-natijalarini-korsatish">Funktsiya natijalarini ko'rsatish</a></h3>
<p>Odatiy bo'lib, agar testdan o'tgan bo'lsa, Rustning test kutubxonasi standart chiqishda chop etilgan barcha narsalarni yozib oladi. Misol uchun, agar testda <code>println!</code> ni chaqirsak va testdan o'tgan bo'lsa, terminalda <code>println!</code> chiqishini ko'rmaymiz; biz faqat testdan o'tganligini ko'rsatadigan qatorni ko'ramiz. Agar test muvaffaqiyatsiz tugasa, biz xato xabarining qolgan qismi bilan standart chiqishda chop etilganini ko'ramiz.</p>
<p>Misol tariqasida, 11-10 ro'yxatida o'z parametrining qiymatini chop etadigan va 10 ni qaytaradigan ahmoqona funksiya, shuningdek, o'tgan test va muvaffaqiyatsizlikka uchragan test mavjud.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn print_qiladi_va_10_qaytaradi(a: i32) -&gt; i32 {
    println!(&quot;Men {} qiymatini oldim&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_muvaffaqiyatli() {
        let qiymat = print_qiladi_va_10_qaytaradi(4);
        assert_eq!(10, qiymat);
    }

    #[test]
    fn test_muvaffaqiyatsiz() {
        let qiymat = print_qiladi_va_10_qaytaradi(8);
        assert_eq!(5, qiymat);
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-10: <code>println!</code>ni chaqiruvchi funksiya uchun testlar</span></p>
<p>Ushbu testlarni <code>cargo test</code> bilan bajarganimizda, biz quyidagi natijani ko'ramiz:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::test_muvaffaqiyatsiz ... FAILED
test tests::test_muvaffaqiyatli ... ok

failures:

---- tests::test_muvaffaqiyatsiz stdout ----
I got the value 8
thread 'tests::test_muvaffaqiyatsiz' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::test_muvaffaqiyatsiz

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>E'tibor bering, bu chiqishning hech bir joyida <code>Men 4 qiymatini oldim</code> ni ko'rmaymiz, ya'ni testdan o'tganda chop etiladi. Bu chiqish qo'lga olindi. Muvaffaqiyatsiz bo'lgan test natijasi, <code>Men 8-qiymatni oldim</code>, test xulosasi chiqishi bo'limida paydo bo'ladi, bu test muvaffaqiyatsizligi sababini ham ko'rsatadi.</p>
<p>Agar biz testlardan o'tish uchun yozilgan qiymatlarni ham ko'rishni istasak, Rust-ga <code>--show-output</code> bilan muvaffaqiyatli testlar natijasini ham ko'rsatishni aytishimiz mumkin.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>11-10 ro'yxatdagi testlarni yana <code>--show-output</code> buyrug'i bilan o'tkazganimizda, biz quyidagi natijani ko'ramiz:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="testlar-toplamini-nomi-boyicha-bajarishishga-tushirish"><a class="header" href="#testlar-toplamini-nomi-boyicha-bajarishishga-tushirish">Testlar to'plamini nomi bo'yicha bajarish(ishga tushirish)</a></h3>
<p>Ba'zan to'liq test to'plamini ishga tushirish uzoq vaqt talab qilishi mumkin. Agar siz ma'lum bir sohada kod ustida ishlayotgan bo'lsangiz, faqat ushbu kodga tegishli testlarni o'tkazishni xohlashingiz mumkin. Argument sifatida o ªtkazmoqchi bo ªlgan test(lar)ning nomi yoki nomlarini <code>cargo test</code> o ªtish orqali qaysi testlarni o ªtkazishni tanlashingiz mumkin.</p>
<p>Testlar kichik to‚Äòplamini qanday bajarishni ko‚Äòrsatish uchun avval 11-11 ro‚Äòyxatda ko‚Äòrsatilganidek, <code>ikkita_qoshish</code> funksiyamiz uchun uchta test yaratamiz va qaysi birini bajarishni tanlaymiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn ikkita_qoshish(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ikkita_qoshish_va_ikki() {
        assert_eq!(4, ikkita_qoshish(2));
    }

    #[test]
    fn uchta_qoshish_va_ikki() {
        assert_eq!(5, ikkita_qoshish(3));
    }

    #[test]
    fn yuz() {
        assert_eq!(102, ikkita_qoshish(100));
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-11: Uch xil nomga ega uchta test</span></p>
<p>Agar biz testlarni hech qanday argumentlarsiz o'tkazsak, avval ko'rganimizdek, barcha testlar parallel ravishda ishlaydi:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::uchta_qoshish_va_ikki ... ok
test tests::ikkita_qoshish_va_ikki ... ok
test tests::yuz ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="yagona-testlarni-otkazish"><a class="header" href="#yagona-testlarni-otkazish">Yagona testlarni o'tkazish</a></h4>
<p>Biz har qanday test funksiyasining nomini faqat shu testni o ªtkazish uchun <code>cargo test</code>ga o ªtkazishimiz mumkin:</p>
<pre><code class="language-console">$ cargo test yuz
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::yuz ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Faqat <code>yuz</code> nomli test o'tkazildi; qolgan ikkita test bu nomga mos kelmadi. Sinov natijasi, oxirida <code>2 filtered out</code> belgisini ko‚Äòrsatish orqali bizda boshqa testlar o‚Äòtkazilmaganligini bildiradi.</p>
<p>Biz bir nechta testlarning nomlarini shu tarzda aniqlay olmaymiz; faqat <code>cargo test</code>ga berilgan birinchi qiymatdan foydalaniladi. Ammo bir nechta testlarni o'tkazishning bir usuli bor.</p>
<h4 id="bir-nechta-testlarni-otkazish-uchun-filtrlash"><a class="header" href="#bir-nechta-testlarni-otkazish-uchun-filtrlash">Bir nechta testlarni o'tkazish uchun filtrlash</a></h4>
<p>Biz test nomining bir qismini belgilashimiz mumkin va nomi shu qiymatga mos keladigan har qanday test bajariladi. Masalan, ikkita testimiz nomi <code>qoshish</code> ni o‚Äòz ichiga olganligi sababli, biz <code>cargo test qoshish</code> ni ishga tushirish orqali ikkalasini ham ishga tushirishimiz mumkin:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::uchta_qoshish_va_ikki ... ok
test tests::ikkita_qoshish_va_ikki ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>Bu buyruq nomidagi <code>qoshish</code> bilan barcha testlarni o'tkazdi va <code>yuz</code> nomli testni filtrladi. Shuni ham yodda tutingki, test paydo bo'ladigan modul test nomining bir qismiga aylanadi, shuning uchun biz modul nomini filtrlash orqali moduldagi barcha testlarni bajarishimiz mumkin.</p>
<h3 id="maxsus-talab-qilinmasa-bazi-testlarni-etiborsiz-qoldirish"><a class="header" href="#maxsus-talab-qilinmasa-bazi-testlarni-etiborsiz-qoldirish">Maxsus talab qilinmasa, ba'zi testlarni e'tiborsiz qoldirish</a></h3>
<p>Ba'zida bir nechta maxsus testlarni bajarish juda ko'p vaqt talab qilishi mumkin, shuning uchun siz <code>cargo test</code> ning ko'p bosqichlarida ularni istisno qilishingiz mumkin. Siz o ªtkazmoqchi bo ªlgan barcha testlarni argument sifatida ro ªyxatga olish o ªrniga, bu yerda ko ªrsatilganidek, ularni istisno qilish uchun <code>ignore</code>(e ºtibor bermaslik) atributidan foydalanib, vaqt talab qiluvchi testlarga izoh qo ªyishingiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn ishlamoqda() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn qiyin_test() {
    // code that takes an hour to run
}</code></pre>
<p><code>#[test]</code>dan keyin biz chiqarib tashlamoqchi bo'lgan testga <code>#[ignore]</code> qatorini qo'shamiz. Endi testlarimizni o'tkazganimizda, <code>ishlamoqda</code> ishlaydi, lekin <code>qiyin_test</code> ishlamaydi:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test qiyin_test ... ignored
test ishlamoqda ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><code>qiyin_test</code> funksiyasi <code>ignore</code> ro'yxatiga kiritilgan. Agar biz faqat e'tiborga olinmagan(ignor qilingan) testlarni o'tkazmoqchi bo'lsak, biz <code>cargo test -- --ignored</code> dan foydalanishimiz mumkin:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test qiyin_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Qaysi sinovlar o'tkazilishini nazorat qilish orqali siz <code>cargo test</code> natijalari tez bo'lishiga ishonch hosil qilishingiz mumkin. <code>ignored</code> testlar natijalarini tekshirish mantiqiy bo'lgan nuqtada bo'lganingizda va natijalarni kutishga vaqtingiz bo'lsa, uning o'rniga <code>cargo test -- --ignored</code> ni ishga tushirishingiz mumkin. Agar siz barcha testlarni ular e'tiborsiz(ignor) qoldiriladimi yoki yo'qmi, o'tkazmoqchi bo'lsangiz, <code>cargo test -- --include-ignored</code> ni ishga tushirishingiz mumkin.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="test-tashkil-etish"><a class="header" href="#test-tashkil-etish">Test tashkil etish</a></h2>
<p>Bobning boshida aytib o'tilganidek, test murakkab intizom bo'lib, turli odamlar turli terminologiya va tashkilotdan foydalanadilar. Rust hamjamiyati testlarni ikkita asosiy toifaga ko'ra o'ylaydi: birlik testlari(unit test) va integratsiya testlari(integration test). <em>Unit testlari</em> kichikroq va ko'proq yo'naltirilgan bo'lib, bir vaqtning o'zida bitta modulni alohida sinovdan o'tkazadi va private interfeyslarni sinab ko'rishi mumkin. Integratsiya testlari kutubxonangizdan(library) butunlay tashqarida bo'lib, kodingizdan faqat public interfeysdan foydalangan holda va har bir test uchun bir nechta modullardan foydalangan holda boshqa har qanday tashqi kod kabi foydalaning.</p>
<p>Kutubxonangizning qismlari siz kutgan narsani alohida va birgalikda bajarishini ta'minlash uchun ikkala turdagi testlarni yozish muhimdir.</p>
<h3 id="unit-testlar"><a class="header" href="#unit-testlar">Unit Testlar</a></h3>
<p>Unit testlarining maqsadi kodning qayerda ekanligi va kutilganidek ishlamayotganligini tezda aniqlash uchun kodning har bir birligini(unit) qolgan kodlardan alohida tekshirishdan iborat. Unit testlarini har bir fayldagi <em>src</em> jildiga ular tekshirayotgan kod bilan joylashtirasiz. Konventsiya har bir faylda test funktsiyalarini o'z ichiga olgan <code>tests</code> nomli modul yaratish va modulga <code>cfg(test)</code> bilan izoh berishdan iborat.</p>
<h4 id="testlar-moduli-va-cfgtest"><a class="header" href="#testlar-moduli-va-cfgtest">Testlar moduli va <code>#[cfg(test)]</code></a></h4>
<p>Testlar modulidagi <code>#[cfg(test)]</code> izohi Rustga test kodini faqat <code>cargo test</code>ni bajarganingizda kompilyatsiya qilishni va ishga tushirishni aytadi, <code>cargo build</code>ni ishga tushirganingizda emas.
Bu siz faqat kutubxona qurmoqchi bo'lganingizda kompilyatsiya vaqtini tejaydi va natijada tuzilgan artefaktda joyni tejaydi, chunki testlar kiritilmagan. Integratsiya testlari boshqa jildga o‚Äòtgani uchun ularga <code>#[cfg(test)]</code> izohi kerak emasligini ko‚Äòrasiz. Biroq, unit testlari kod bilan bir xil fayllarda joylashganligi sababli, ular kompilyatsiya qilingan natijaga kiritilmasligini belgilash uchun <code>#[cfg(test)]</code> dan foydalanasiz.</p>
<p>Eslatib o'tamiz, biz ushbu bobning birinchi qismida yangi <code>qoshuvchi</code> loyihasini yaratganimizda, Cargo biz uchun ushbu kodni yaratdi:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn ishlaydi() {
        let natija = 2 + 2;
        assert_eq!(natija, 4);
    }
}</code></pre>
<p>Bu kod avtomatik ravishda yaratilgan test modulidir. <code>cfg</code> atributi <em>konfiguratsiya(configuration)</em> degan ma'noni anglatadi va Rustga quyidagi element faqat ma'lum bir konfiguratsiya opsiyasi berilganda kiritilishi kerakligini aytadi. Bunday holda, konfiguratsiya opsiyasi <code>test</code> bo'lib, u Rust tomonidan testlarni kompilyatsiya qilish va ishga tushirish uchun taqdim etiladi. <code>cfg</code> atributidan foydalanib, Cargo bizning test kodimizni faqat <code>cargo test</code> bilan faol ravishda o'tkazganimizdagina kompilyatsiya qiladi. Bunga <code>#[test]</code> bilan izohlangan funksiyalarga qo ªshimcha ravishda ushbu modulda bo ªlishi mumkin bo ªlgan har qanday yordamchi funksiyalar kiradi.</p>
<h4 id="private-funksiyalarni-testdan-otkazish"><a class="header" href="#private-funksiyalarni-testdan-otkazish">Private funksiyalarni testdan o'tkazish</a></h4>
<p>Sinov hamjamiyatida private(xususiy) funksiyalarni to'g'ridan-to'g'ri testdan o'tkazish kerakmi yoki yo'qmi degan bahs-munozaralar mavjud va boshqa tillar private funktsiyalarni test qilib ko'rishni qiyinlashtiradi yoki imkonsiz qiladi. Qaysi sinov mafkurasiga rioya qilishingizdan qat'i nazar, Rust maxfiylik qoidalari sizga private funksiyalarni test qilish imkonini beradi.
11-12 ro ªyxatdagi kodni <code>ichki_qoshuvchi</code> private funksiyasi bilan ko ªrib chiqing.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn ikkita_qoshish(a: i32) -&gt; i32 {
    ichki_qoshuvchi(a, 2)
}

fn ichki_qoshuvchi(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ichki() {
        assert_eq!(4, ichki_qoshuvchi(2, 2));
    }
}</code></pre>
<p><span class="caption">Ro'yxat 11-12: Private funksiyani test qilib ko'rish</span></p>
<p>Esda tutingki, <code>ichki_qoshuvchi</code> funksiyasi <code>pub</code> sifatida belgilanmagan. Testlar shunchaki Rust kodi va <code>tests</code> moduli shunchaki boshqa moduldir. <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">&quot;Modul daraxtidagi elementga murojaat qilish yo'llari&quot;</a><!-- ignore --> bo'limida muhokama qilganimizdek, bolalar modullaridagi elementlar o'zlarining asosiy modullaridagi elementlardan foydalanishlari mumkin. Ushbu testda biz <code>test</code> modulining ota-onasining barcha elementlarini  <code>use super::*</code> yordamida qamrab olamiz va keyin test <code>ichki_qoshuvchi</code> ni chaqirishi mumkin. Agar private(shaxsiy) funksiyalarni sinab ko'rish kerak deb o'ylamasangiz, Rustda sizni bunga majbur qiladigan hech narsa yo'q.</p>
<h3 id="integratsiya-testlari"><a class="header" href="#integratsiya-testlari">Integratsiya testlari</a></h3>
<p>Rust-da integratsiya testlari kutubxonangizdan butunlay tashqarida. Ular kutubxonangizdan boshqa kodlar kabi foydalanadilar, ya'ni ular faqat kutubxonangizning umumiy API qismi bo'lgan funksiyalarni chaqira oladi. Ularning maqsadi kutubxonangizning ko'p qismlari to'g'ri ishlashini tekshirishdir. O'z-o'zidan to'g'ri ishlaydigan kod birliklari integratsiyalashganda muammolarga duch kelishi mumkin, shuning uchun integratsiyalangan kodni sinovdan o'tkazish ham muhimdir. Integratsiya testlarini yaratish uchun sizga birinchi navbatda <em>tests</em> jildi kerak bo'ladi.</p>
<h4 id="tests-jildi"><a class="header" href="#tests-jildi"><em>tests</em> jildi</a></h4>
<p>Biz loyiha jildimizning yuqori darajasida, <em>src</em> yonida <em>tests</em> jildini yaratamiz. Cargo ushbu jildda integratsiya test fayllarini qidirishni biladi. Keyin biz xohlagancha test fayllarini yaratishimiz mumkin va Cargo har bir faylni alohida crate sifatida tuzadi.</p>
<p>Keling, integratsiya testini yarataylik. 11-12 ro'yxatdagi kod hali ham <em>src/lib.rs</em> faylida bo'lsa, <em>tests</em> jildini yarating va <em>tests/integratsiya_test.rs</em> nomli yangi fayl yarating. Sizning fayl tuzilishingiz tuzilishi quyidagicha ko'rinishi kerak:</p>
<pre><code class="language-text">qoshuvchi
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ tests
    ‚îî‚îÄ‚îÄ integratsiya_test.rs
</code></pre>
<p>11-13 ro'yxatdagi kodni <em>tests/integratsiya_test.rs</em> fayliga kiriting:</p>
<p><span class="filename">Fayl nomi: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}</code></pre>
<p><span class="caption">Ro'yxat 11-13: <code>qoshuvchi</code> cratesidagi funksiyaning integratsiya testi</span></p>
<p><code>tests</code> jildidagi har bir fayl alohida cratedir, shuning uchun biz kutubxonamizni har bir test cratesi doirasiga kiritishimiz kerak. Shuning uchun biz kodning yuqori qismiga unit testlarida kerak bo'lmagan  <code>use qoshuvchi</code> ni qo'shamiz.</p>
<p>Bizga <em>tests/integration_test.rs</em> da <code>#[cfg(test)]</code> bilan hech qanday kodga izoh berish shart emas. Cargo <code>tests</code> jildini maxsus ko'rib chiqadi va bu jilddagi fayllarni faqat biz <code>cargo test</code> buyrug'ini ishga tushirganimizda kompilyatsiya qiladi. Keling <code>cargo test</code> qilib ishlatamiz:</p>
<pre><code class="language-console">$ cargo test
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshuvchi)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/qoshuvchi-1082c4b063a8fbe6)

running 1 test
test tests::ichki ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integratsiya_test.rs (target/debug/deps/integratsiya_test-1082c4b063a8fbe6)

running 1 test
test ikkita_qoshish ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests qoshuvchi

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Chiqishning(output) uchta bo'limiga unit testlari, integratsiya testlari va doc testlari kiradi. E'tibor bering, agar bo'limdagi biron bir test muvaffaqiyatsiz bo'lsa, keyingi bo'limlar bajarilmaydi. Misol uchun, agar unit testi muvaffaqiyatsiz bo'lsa, integratsiya va doc testlari uchun hech qanday natija bo'lmaydi, chunki bu testlar faqat barcha unit testlari o'tgan taqdirdagina amalga oshiriladi.</p>
<p>Unit testlari uchun birinchi bo'lim biz ko'rganimiz bilan bir xil: har bir unit testi uchun bitta satr (biz 11 12 ro ªyxatga qo ªshgan <code>ichki</code> deb nomlangan) va keyin unit testlari uchun xulosa qator.</p>
<p>Integratsiya testlari bo'limi <code>Running tests/integration_test.rs</code> qatoridan boshlanadi. Keyin, ushbu integratsiya testidagi har bir test funksiyasi uchun qator va <code>Doc-tests adder</code> bo ªlimi boshlanishidan oldin integratsiya testi natijalari uchun xulosa qatori mavjud.</p>
<p>Har bir integratsiya test faylining o'z bo'limi bor, shuning uchun <em>tests</em> jildiga ko'proq fayllar qo'shsak, ko'proq integratsiya test bo'limlari bo'ladi.</p>
<p><code>cargo test</code> ga argument sifatida test funksiyasining nomini ko‚Äòrsatib, biz hali ham muayyan integratsiya test funksiyasini ishga tushirishimiz mumkin. Muayyan integratsiya test faylida barcha testlarni bajarish uchun <code>cargo test</code>ning <code>--test</code> argumentidan keyin fayl nomidan foydalaning:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshuvchi)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test ikkita_qoshish ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Bu buyruq faqat <em>tests/integration_test.rs</em> faylidagi testlarni bajaradi.</p>
<h4 id="integratsiya-testlarida-submodullar"><a class="header" href="#integratsiya-testlarida-submodullar">Integratsiya testlarida submodullar</a></h4>
<p>Ko'proq integratsiya testlarini qo'shsangiz, ularni tartibga solishga yordam berish uchun <em>tests</em> jildida ko'proq fayllar yaratishni xohlashingiz mumkin; masalan, siz test funktsiyalarini ular test qilib ko'rayotgan funksiyalari bo'yicha guruhlashingiz mumkin. Yuqorida aytib o'tilganidek, <em>tests</em> jildidagi har bir fayl o'zining alohida cratesi sifatida tuzilgan bo'lib, bu oxirgi foydalanuvchilar sizning cratengizdan qanday foydalanishini yanada yaqinroq taqlid qilish uchun alohida qamrovlarni yaratish uchun foydalidir. Biroq, bu shuni anglatadiki, <em>tests</em> jildidagi fayllar <em>src</em> dagi fayllarga o'xshamaydi, chunki kodni modul va fayllarga qanday ajratish haqida 7-bobda o'rgangansiz.</p>
<p><em>tests</em> jildidagi fayllarning har xil xatti-harakatlari bir nechta integratsiya test fayllarida foydali bo'ladigan yordamchi funktsiyalar to'plamiga ega bo'lganingizda sezilarli bo'ladi. Aytaylik, siz ularni umumiy modulga chiqarish uchun 7-bob, <a href="ch07-05-separating-modules-into-different-files.html">&quot;Modullarni turli fayllarga ajratish&quot;</a><!-- ignore --> bosqichlarini bajarishga harakat qilyapsiz. Misol uchun, agar biz <em>tests/common.rs</em> ni yaratsak va unga <code>setup</code> nomli funksiyani joylashtirsak, biz bir nechta test fayllaridagi bir nechta test funksiyalaridan chaqirmoqchi bo'lgan <code>setup</code> ga ba'zi kodlarni qo'shishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // kutubxonangiz testlariga xos sozlash(setup) kodi bu yerga tushadi
}</code></pre>
<p>Testlarni qayta ishga tushirganimizda, biz <em>common.rs</em> fayli uchun test chiqishida yangi bo'limni ko'ramiz, garchi bu faylda hech qanday test funksiyalari mavjud bo'lmasa ham, biz hech qanday joydan <code>setup</code> funksiyasini chaqirmagan bo'lsak ham:</p>
<pre><code class="language-console">$ cargo test
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshuvchi)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/qoshuvchi-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests qoshuvchi

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Test natijalarida <code>setup</code> ko'rinishida <code>running 0 tests</code> ko'rsatilishi biz xohlagan narsa emas. Biz shunchaki kodni boshqa integratsiya test fayllari bilan baham ko'rmoqchi edik.</p>
<p>Test natijasida <code>common</code> ko'rinishini oldini olish uchun <em>tests/common.rs</em> yaratish o'rniga biz <em>tests/common/mod.rs</em> ni yaratamiz. Loyiha jildi(fayl structurasi) endi shunday ko'rinadi:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ common
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs
    ‚îî‚îÄ‚îÄ integration_test.rs
</code></pre>
<p>Bu eski nomlash konventsiyasi bo'lib, Rust biz 7-bobning <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">&quot;Muqobil fayl yo'llari(path)&quot;</a><!-- ignore --> bo'limida aytib o'tganimizni ham tushunadi.
Biz <code>setup</code> funksiya kodini <em>tests/common/mod.rs</em> ga ko'chirsak va <em>tests/common.rs</em> faylini o'chirsak, test chiqishidagi bo'lim endi ko'rinmaydi. <em>tests</em> jildining pastki jildlaridagi fayllar alohida cratelar sifatida kompilyatsiya qilinmaydi yoki test chiqishida(output) bo'limlarga(section) ega emas.</p>
<p><em>tests/common/mod.rs</em> ni yaratganimizdan so'ng, biz uni modul sifatida har qanday integratsiya test faylidan foydalanishimiz mumkin. Bu yerda <em>tests/integration_test.rs</em> da <code>ikkita_qoshish</code> testidan <code>setup</code> funksiyasini chaqirish misoli keltirilgan:</p>
<p><span class="filename">Fayl nomi: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use qoshuvchi;

mod common;

#[test]
fn ikkita_qoshish() {
    common::setup();
    assert_eq!(4, qoshuvchi::ikkita_qosh(2));
}</code></pre>
<p>Esda tutingki, <code>mod common;</code> deklaratsiyasi biz 7-21 ro ªyxatda ko ªrsatgan modul deklaratsiyasi bilan bir xil. Keyin test funksiyasida biz <code>common::setup()</code> funksiyasini chaqirishimiz mumkin.</p>
<h4 id="binary-cratelar-uchun-integratsiya-testlari"><a class="header" href="#binary-cratelar-uchun-integratsiya-testlari">Binary Cratelar uchun integratsiya testlari</a></h4>
<p>Agar bizning loyihamiz faqat <em>src/main.rs</em> faylini o'z ichiga olgan va <em>src/lib.rs</em> fayliga ega bo'lmagan ikkilik crate(binary crate) bo'lsa, biz <em>tests</em> jildida integratsiya testlarini yarata olmaymiz va <em>src/main.rs</em> faylida belgilangan funksiyalarni <code>use</code> statementi bilan qamrab ololmaymiz. Faqat kutubxona cratelari(library crate) boshqa cratelar foydalanishi mumkin bo'lgan funksiyalarni ko'rsatadi; binary cratelar o'z-o'zidan ishlashi uchun mo'ljallangan.</p>
<p>Bu binary faylni ta'minlovchi Rust loyihalarida <em>src/lib.rs</em> faylida yashovchi logicni chaqiruvchi(call logic) oddiy <em>src/main.rs</em> fayliga ega bo'lishining sabablaridan biri. Ushbu structedan foydalanib, integratsiya testlari kutubxona cratesini muhim funksiyalarni mavjud qilish uchun <code>use</code> bilan sinab ko'rishi mumkin.
Agar muhim funksiya ishlayotgan bo'lsa, <em>src/main.rs</em> faylidagi kichik kod miqdori ham ishlaydi va bu kichik kod miqdorini sinab ko'rish kerak emas.</p>
<h2 id="xulosa-10"><a class="header" href="#xulosa-10">Xulosa</a></h2>
<p>Rust-ning test xususiyatlari(feature) kod qanday ishlashini belgilash usulini taqdim etadi va u siz kutganingizdek ishlashini ta'minlaydi, hatto siz o'zgartirishlar kiritsangiz ham. Unit testlari kutubxonaning turli qismlarini alohida bajaradi va private impelement qilish tafsilotlarini sinab ko'rishi mumkin. Integratsiya testlari kutubxonaning ko'p qismlari to'g'ri ishlashini tekshiradi va ular tashqi kod uni ishlatadigan tarzda kodni sinab ko'rish uchun kutubxonaning umumiy API'sidan foydalanadilar. Rustning type systemi va ownership qoidalari ba'zi xatolarning oldini olishga yordam bergan bo'lsa ham, testlar sizning kodingiz qanday ishlashi bilan bog'liq bo'lgan mantiqiy xatolarni kamaytirish uchun hali ham muhimdir.</p>
<p>Keling, ushbu bobda va oldingi boblarda olgan bilimlaringizni loyiha ustida ishlash uchun birlashtiraylik!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-loyihasi-buyruqlar-qatori-dasturini-yaratishcommand-line"><a class="header" href="#io-loyihasi-buyruqlar-qatori-dasturini-yaratishcommand-line">I/O loyihasi: Buyruqlar qatori dasturini yaratish(command line)</a></h1>
<p>Ushbu bob siz hozirgacha o'rgangan ko'plab ko'nikmalarning qisqacha mazmuni va yana bir nechta standart kutubxona xususiyatlarining o'rganilishidir. Biz hozirda mavjud bo'lgan Rust tushunchalarini mashq qilish uchun fayl va buyruq qatori kiritish/chiqarish(input/output) bilan o'zaro ta'sir qiluvchi buyruq qatori vositasini(command line tool) yaratamiz.</p>
<p>Rust-ning tezligi, xavfsizligi, bitta ikkilik chiqishi(single binary output) va platformalararo9cross-platform qo'llab-quvvatlashi uni buyruqlar qatori vositalarini(command line tools) yaratish uchun ideal tilga aylantiradi, shuning uchun loyihamiz uchun biz klassik buyruq qatori qidiruv vositasi <code>grep</code> ning o'z versiyasini yaratamiz (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint) qidirish. Foydalanishning eng oddiy holatida <code>grep</code> belgilangan faylni belgilangan qator uchun qidiradi. Buning uchun <code>grep</code> o'z argumenti sifatida fayl yo'li(file path) va satrni oladi. Keyin u faylni o'qiydi, o'sha faylda string argumentini o'z ichiga olgan qatorlarni topadi va bu satrlarni chop(print qiladi) etadi.</p>
<p>Yo'l davomida biz buyruq qatori vositasini boshqa ko'plab buyruq qatori vositalari ishlatadigan terminal xususiyatlaridan qanday foydalanishni ko'rsatamiz. Biz foydalanuvchiga vositamizning harakatini sozlash imkonini berish uchun atrof-muhit o'zgaruvchisining qiymatini(environment variable) o'qiymiz.
Shuningdek, biz xato xabarlarini standart chiqish (<code>stdout</code>) o'rniga standart xato konsoli oqimiga (<code>stderr</code>) chop qilamiz, shuning uchun, masalan, foydalanuvchi ekranda xato xabarlarini ko'rayotganda muvaffaqiyatli chiqishni faylga yo'naltirishi mumkin.</p>
<p>Rust hamjamiyatining bir a'zosi Andrew Gallant allaqachon <code>grep</code> ning <code>ripgrep</code> deb nomlangan to'liq xususiyatli, juda tez versiyasini yaratgan. Taqqoslash uchun, bizning versiyamiz ancha sodda bo'ladi, ammo bu bob sizga <code>ripgrep</code> kabi real loyihani tushunish uchun zarur bo'lgan asosiy bilimlarni beradi.</p>
<p>Bizning <code>grep</code> loyihamiz siz hozirgacha o'rgangan bir qator tushunchalarni birlashtiradi:</p>
<ul>
<li>Kodni tashkil qilish (<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">7-bobda</a><!--
  ignore --> modullar haqida bilib olganlaringizdan foydalangan holda)</li>
<li>Vectorlar va stringlardan foydalanish (to'plamlar(collection), <a href="ch08-00-common-collections.html">8-bob</a><!-- ignore -->)</li>
<li>Xatolarni qayta ishlash(handling error) (<a href="ch09-00-error-handling.html">9-bob</a><!-- ignore -->)</li>
<li>Kerakli hollarda traitlar va lifetimelardan foydalanish (<a href="ch10-00-generics.html">10-bob</a><!-- ignore
  -->)</li>
<li>Testlar yozish (<a href="ch11-00-testing.html">11-bob</a><!-- ignore -->)</li>
</ul>
<p>Shuningdek, biz <a href="ch13-00-functional-features.html">13</a><!-- ignore --> va <a href="ch17-00-oop.html">17</a><!-- ignore -->-boblarda batafsil yoritilgan closurelar, iteratorlar va trait obyektlarini qisqacha tanishtiramiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="buyruqlar-qatori-argumentlarini-qabul-qilish"><a class="header" href="#buyruqlar-qatori-argumentlarini-qabul-qilish">Buyruqlar qatori argumentlarini qabul qilish</a></h2>
<p>Keling, har doimgidek, <code>cargo new</code> bilan yangi loyiha yarataylik. Loyihamizni tizimingizda mavjud bo ªlgan <code>grep</code> konsol dasturidan farqlash uchun uni <code>minigrep</code> deb ataymiz.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Birinchi vazifa <code>minigrep</code> ni ikkita buyruq qatori argumentlarini qabul qilishdir: fayl yo'li va izlash uchun satr. Ya'ni, biz o'z dasturimizni <code>cargo run</code> bilan ishga tushirishni xohlaymiz, quyidagi argumentlar <code>cargo</code> uchun emas, balki dasturimizga tegishli ekanligini ko'rsatadigan ikkita tire(qo'shaloq chiziq), qidirish uchun satr va qidiruv uchun faylga yo'l. ichida, shunga o'xshash:</p>
<pre><code class="language-console">$ cargo run -- qidiruv-matni namuna-fayl.txt
</code></pre>
<p>Hozirda <code>cargo new</code> tomonidan yaratilgan dastur biz bergan argumentlarni qayta ishlay olmaydi. <a href="https://crates.io/">crates.io</a>-dagi ba'zi mavjud kutubxonalar buyruq qatori argumentlarini qabul qiladigan dastur yozishda yordam berishi mumkin, ammo siz ushbu kontseptsiyani endigina o'rganayotganingiz uchun keling, bu imkoniyatni o'zimiz amalga oshiraylik.</p>
<h3 id="argument-qiymatlarini-oqish"><a class="header" href="#argument-qiymatlarini-oqish">Argument qiymatlarini o'qish</a></h3>
<p><code>minigrep</code> ga biz o'tadigan buyruq qatori argumentlarining qiymatlarini o'qishni yoqish uchun bizga Rust standart kutubxonasida taqdim etilgan <code>std::env::args</code> funksiyasi kerak bo'ladi. Bu funksiya <code>minigrep</code> ga uzatilgan buyruq qatori argumentlarining iteratorini qaytaradi. Biz iteratorlarni <a href="ch13-00-functional-features.html">13-bobda</a><!-- ignore
--> to'liq ko'rib chiqamiz. Hozircha siz iteratorlar haqida faqat ikkita ma'lumotni bilishingiz kerak: iteratorlar bir qator qiymatlarni ishlab chiqaradi va biz uni vector kabi to'plamga(collection) aylantirish uchun iteratorda <code>collect</code> metodini chaqirishimiz mumkin,iterator ishlab chiqaradigan barcha elementlarni o'z ichiga oladi.</p>
<p>12-1 ro'yxatidagi kod <code>minigrep</code> dasturingizga unga berilgan har qanday buyruq qatori argumentlarini o'qish va keyin qiymatlarni vectorga yig'ish imkonini beradi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 12-1: buyruq qatori argumentlarini vectorga yig'ish va ularni chop etish</span></p>
<p>Birinchidan, biz <code>std::env</code> modulini <code>use</code> statementi bilan qamrab olamiz, shunda uning <code>args</code> funksiyasidan foydalanamiz. <code>std::env::args</code> funksiyasi modullarning ikki darajasida joylashganligiga e'tibor bering. Biz <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">7-bobda</a><!-- ignore --> muhokama qilganimizdek, istalgan funksiya bir nechta modulda joylashgan bo‚Äòlsa, biz funksiyani emas, balki ota-modulni qamrab olishni tanladik. Shunday qilib, biz <code>std::env</code> dan boshqa funksiyalardan bemalol foydalanishimiz mumkin. Bu, shuningdek, <code>use std::env::args</code> ni qo‚Äòshib, so‚Äòngra funksiyani faqat <code>args</code> bilan chaqirishdan ko‚Äòra kamroq noaniqdir, chunki <code>args</code> joriy modulda aniqlangan funksiya bilan osongina xato qilishi mumkin.</p>
<blockquote>
<h3 id="args-funksiyasi-va-notogri-unicode"><a class="header" href="#args-funksiyasi-va-notogri-unicode"><code>args</code> funksiyasi va notog'ri Unicode</a></h3>
<p>E'tibor bering, agar biron bir argumentda noto'g'ri Unicode bo'lsa, <code>std::env::args</code>
panic qo'zg'atadi. Agar dasturingiz noto'g'ri Unicode o'z ichiga olgan argumentlarni qabul qilishi kerak bo'lsa,
o'rniga <code>std::env::args_os</code> dan foydalaning. Bu funksiya <code>String</code> qiymatlari o‚Äòrniga <code>OsString</code>
qiymatlarini ishlab chiqaruvchi iteratorni qaytaradi. Biz bu yerda soddalik uchun
<code>std::env::args</code> dan foydalanishni tanladik, chunki <code>OsString</code> qiymatlari platformalar
uchun farq qiladi va ular bilan ishlash <code>String</code> qiymatlariga qaraganda murakkabroq.</p>
</blockquote>
<p><code>main</code> ning birinchi qatorida biz <code>env::args</code> deb nomlaymiz va iteratorni iterator tomonidan ishlab chiqarilgan barcha qiymatlarni o'z ichiga olgan vectorga aylantirish uchun darhol <code>collect</code> dan foydalanamiz. Biz ko'p turdagi to'plamlarni(collection) yaratish uchun <code>collect</code> funksiyasidan foydalanishimiz mumkin, shuning uchun biz stringlar vectorini xohlashimizni ko'rsatish uchun <code>args</code> turiga aniq izoh beramiz. Rust-da turlarga juda kamdan-kam izoh qo'yishimiz kerak bo'lsa-da, <code>collect</code> funksiyasi siz tez-tez izohlashingiz kerak bo'lgan funksiyadir, chunki Rust siz xohlagan to'plam turini aniqlay olmaydi.</p>
<p>Nihoyat, debug makrosi yordamida vectorni chop etamiz. Keling, kodni avval argumentsiz, keyin esa ikkita argument bilan ishga tushirishga harakat qilaylik:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
]
</code></pre>
<pre><code class="language-console">$ cargo run -- anor mevalar
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep anor mevalar`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
    &quot;anor&quot;,
    &quot;mevalar&quot;,
]
</code></pre>
<p>E'tibor bering, vectordagi birinchi qiymat <code>&quot;target/debug/minigrep&quot;</code> bo'lib, bu bizning ikkilik(binary) faylimiz nomidir. Bu C dagi argumentlar ro'yxatining xatti-harakatiga mos keladi, bu dasturlarga ularni bajarishda chaqirilgan nomdan foydalanishga imkon beradi. Agar siz uni xabarlarda chop qilmoqchi bo'lsangiz yoki dasturni chaqirish uchun qanday buyruq qatori taxalluslari(alias) ishlatilganiga qarab dasturning harakatini o'zgartirmoqchi bo'lsangiz, dastur nomiga kirish ko'pincha qulaydir. Ammo ushbu bobning maqsadlari uchun biz buni e'tiborsiz qoldiramiz va faqat bizga kerak bo'lgan ikkita argumentni saqlaymiz.</p>
<h3 id="argument-qiymatlarini-ozgaruvchilarda-saqlash"><a class="header" href="#argument-qiymatlarini-ozgaruvchilarda-saqlash">Argument qiymatlarini o'zgaruvchilarda saqlash</a></h3>
<p>Dastur hozirda buyruq qatori argumentlari sifatida ko'rsatilgan qiymatlarga kirish imkoniyatiga ega. Endi biz ikkita argumentning qiymatlarini o'zgaruvchilarda saqlashimiz kerak, shuning uchun biz dasturning qolgan qismida qiymatlardan foydalanishimiz mumkin. Biz buni 12-2 ro'yxatda qilamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let sorov = &amp;args[1];
    let fayl_yoli = &amp;args[2];

    println!(&quot;{} qidirilmoqda&quot;, sorov);
    println!(&quot;{} faylida&quot;, fayl_yoli);
}</code></pre>
<p><span class="caption">Ro'yxat 12-2: So'rov argumenti va fayl yo'li argumentini saqlash uchun o'zgaruvchilar yaratish</span></p>
<p>Biz vectorni chop etganimizda ko'rganimizdek, dastur nomi vectordagi birinchi qiymatni <code>args[0]</code> oladi, shuning uchun biz <code>1</code> indeksidan argumentlarni boshlaymiz. <code>minigrep</code>ning birinchi argumenti biz qidirayotgan satrdir, shuning uchun biz birinchi argumentga referenceni <code>sorov</code> o‚Äòzgaruvchisiga qo‚Äòyamiz. Ikkinchi argument fayl yo'li bo'ladi, shuning uchun biz <code>fayl_yoli</code> o'zgaruvchisiga ikkinchi argumentga reference qilamiz.</p>
<p>Kod biz xohlagandek ishlayotganini isbotlash uchun biz ushbu o'zgaruvchilarning qiymatlarini vaqtincha chop qilamiz. <code>test</code> va <code>namuna.txt</code> argumentlari bilan ushbu dasturni qayta ishga tushiramiz:</p>
<pre><code class="language-console">$ cargo run -- test namuna.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
test qidirilmoqda
namuna.txt faylida
</code></pre>
<p>Ajoyib, dastur ishlayapti! Bizga kerak bo'lgan argumentlarning qiymatlari to'g'ri o'zgaruvchilarga saqlanmoqda. Keyinchalik ba'zi potentsial noto'g'ri vaziyatlarni hal qilish uchun xatolarni qayta ishlash usullarini qo'shamiz, masalan, foydalanuvchi hech qanday argument keltirmasa; Hozircha biz bu holatni e'tiborsiz qoldiramiz va uning o'rniga fayllarni o'qish imkoniyatlarini qo'shish ustida ishlaymiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="faylni-oqish"><a class="header" href="#faylni-oqish">Faylni o'qish</a></h2>
<p>Endi biz  <code>fayl_yoli</code> argumentida ko ªrsatilgan faylni o ªqish funksiyasini qo ªshamiz. Birinchidan, uni sinab ko'rish uchun bizga namuna fayli kerak: biz bir nechta takroriy so'zlar bilan bir nechta satrlarda kichik hajmdagi matnli fayldan foydalanamiz. 12-3 ro'yxatda Olma haqida she'r bor, u yaxshi ishlaydi! Loyihangizning root darajasida <em>olma.txt</em> nomli fayl yarating va ‚ÄúOlma‚Äù she‚Äôrini kiriting.</p>
<p><span class="filename">Fayl nomi: olma.txt</span></p>
<pre><code class="language-text">Tanishaylik, men - olma,
Nomimga quloq solma.
Olaver, ikkilanmay,
Ishtahang bo'lsin karnay

Reklamaga hojat yo'q
Ta'mim rosa yoqimli.
Ortganini quritsang,
Qishda yeysan qoqimni

Men sizlarni olmangiz,
Xomligimda olmangiz!
Asilbekga o'xshab so'ng,
Voy qornim deb qolmangiz!

Bog'larda chiroymanda, 
Vitaminga boymanda!
Pishganimda yemasangiz,
Qolasizda armonda!
</code></pre>
<p><span class="caption">Ro'yxat 12-3: Olma haqidagi she'r yaxshi sinov ishini yaratadi</span></p>
<p>Matn joyida bo'lgan holda <em>src/main.rs</em> ni tahrirlang va 12-4 ro'yxatda ko'rsatilganidek, faylni o'qish uchun kod qo'shing.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let sorov = &amp;args[1];
</span><span class="boring">    let fayl_yoli = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, sorov);
</span>    println!(&quot;{} faylida&quot;, fayl_yoli);

    let tarkib = fs::read_to_string(fayl_yoli)
        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);

    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
}</code></pre>
<p><span class="caption">Ro'yxat 12-4: Ikkinchi argument tomonidan ko'rsatilgan fayl mazmunini o'qish</span></p>
<p>Birinchidan, biz standart kutubxonaning tegishli qismini <code>use</code> statementi bilan keltiramiz: fayllar bilan ishlash uchun bizga <code>std::fs</code> kerak.</p>
<p><code>main</code> da yangi <code>fs::read_to_string</code> statementi <code>fayl_yoli</code>ni oladi, bu faylni ochadi va fayl mazmunining <code>std::io::Result&lt;String&gt;</code> ni qaytaradi.</p>
<p>Shundan so'ng, fayl o'qilgandan keyin <code>tarkib</code> qiymatini chop etadigan vaqtinchalik <code>println!</code> statementini yana qo'shamiz, shuning uchun dasturning hozirgacha ishlayotganligini tekshirishimiz mumkin.</p>
<p>Keling, ushbu kodni birinchi buyruq qatori argumenti sifatida istalgan qator bilan ishga tushiramiz (chunki biz hali qidiruv qismini amalga oshirmaganmiz) va ikkinchi argument sifatida <em>olma.txt</em> fayli:</p>
<pre><code class="language-console">$ cargo run -- men olma.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
men qidirilmoqda
olma.txt faylidan
Fayl tarkibi:
Tanishaylik, men - olma,
Nomimga quloq solma.
Olaver, ikiklanmay,
Ishtahang bo'lsin karnay

Reklamaga hojat yo'q
Ta'mim rosa yoqimli.
Ortganini quritsang,
Qishda yeysan qoqimni

Men sizlarni olmangiz,
Xomligimda olmangiz!
Asilbekga o'xshab so'ng,
Voy qornim deb qolmangiz!

Bog'larda chiroymanda, 
Vitaminga boymanda!
Pishganimda yemasangiz,
Qolasizda armonda!

</code></pre>
<p>Ajoyib! Ushbu kod fayl mazmunini o'qiydi va fayl mazmunini chop etdi. Ammo kodda bir nechta kamchiliklar mavjud. Ayni paytda <code>main</code> funksiya bir nechta mas'uliyatga ega: umuman olganda, har bir funksiya faqat bitta vazifa uchun javobgar bo'lsa, funksiyalar aniqroq va ularni saqlash osonroq bo'ladi. Boshqa muammo shundaki, biz xatolarni imkon qadar yaxshi hal qilmayapmiz. Dastur hali ham kichik, shuning uchun bu kamchiliklar katta muammo emas, lekin dastur o'sib ulg'aygan sayin ularni toza tuzatish qiyinroq bo'ladi. Dasturni ishlab chiqishda refaktorlashni erta boshlash yaxshi amaliyotdir, chunki kichikroq hajmdagi kodlarni qayta ishlash ancha oson. Biz buni keyin qilamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modullilikni-va-xatolarni-boshqarishni-yaxshilash-uchun-refaktoring"><a class="header" href="#modullilikni-va-xatolarni-boshqarishni-yaxshilash-uchun-refaktoring">Modullilikni va xatolarni boshqarishni yaxshilash uchun refaktoring</a></h2>
<p>Dasturimizni yaxshilash uchun dastur tuzilishi va uning yuzaga kelishi mumkin bo'lgan xatolarni qanday hal qilishi bilan bog'liq bo'lgan to'rtta muammoni tuzatamiz. Birinchidan, bizning <code>main</code> funksiyamiz endi ikkita vazifani bajaradi: u argumentlarni tahlil qiladi va fayllarni o'qiydi. Dasturimiz o'sib borishi bilan <code>main</code> funksiya boshqaradigan alohida vazifalar soni ortadi. Funksiyaga mas'uliyat yuklagan sari, uning qismlaridan birini buzmasdan fikr yuritish, sinab ko'rish va o'zgartirish qiyinroq bo'ladi. Har bir funksiya bitta vazifa uchun javobgar bo'lishi uchun funksionallikni ajratish yaxshiroqdir.</p>
<p>Bu muammo ikkinchi muammo bilan ham bog'liq: <code>sorov</code> va <code>fayl_yoli</code> bizning dasturimiz uchun konfiguratsiya o'zgaruvchilari bo'lsa-da, dastur mantig'ini bajarish uchun <code>tarkib</code> kabi o'zgaruvchilardan foydalaniladi. <code>main</code> qancha uzun bo'lsa, biz ko'proq o'zgaruvchilarni qamrab olishimiz kerak bo'ladi; bizda qancha ko'p o'zgaruvchilar mavjud bo'lsa, ularning har birining maqsadini kuzatib borish shunchalik qiyin bo'ladi. Maqsadlari aniq bo'lishi uchun konfiguratsiya o'zgaruvchilarini bitta tuzilishga guruhlash yaxshidir.</p>
<p>Uchinchi muammo shundaki, biz faylni o‚Äòqib chiqmaganda xato xabarini chop etish uchun <code>expect</code> tugmasidan foydalanganmiz, biroq xato xabari ‚ÄúFaylni o‚Äòqishi kerak edi‚Äù degan yozuvni chiqaradi. Faylni o'qish bir necha usul bilan muvaffaqiyatsiz bo'lishi mumkin: masalan, fayl yetishmayotgan bo'lishi mumkin yoki bizda uni ochishga ruxsat yo'q.
Hozirda, vaziyatdan qat'i nazar, biz hamma narsa uchun bir xil xato xabarini chop qilamiz, bu esa foydalanuvchiga hech qanday ma'lumot bermaydi!</p>
<p>To‚Äòrtinchidan, biz turli xil xatolarni qayta ishlash uchun <code>expect</code> dan qayta-qayta foydalanamiz va agar foydalanuvchi dasturimizni yetarlicha argumentlarni ko'rsatmasdan ishga tushirsa, Rustdan <code>index out of bounds</code>(&quot;chegaradan tashqari indeks&quot;) xatosini oladi va bu muammoni aniq tushuntirmaydi. Xatolarni qayta ishlash mantig'ini o'zgartirish kerak bo'lsa, kelajakdagi saqlovchilar(maintainerlar) kod bilan maslahatlashish uchun faqat bitta joyga ega bo'lishlari uchun barcha xatolarni qayta ishlash kodi bir joyda bo'lsa yaxshi bo'lar edi. Xatolarni qayta ishlash uchun barcha kodlar bir joyda bo'lsa, biz oxirgi foydalanuvchilarimiz uchun mazmunli bo'lgan xabarlarni chop etishimizni ta'minlaydi.</p>
<p>Keling, loyihamizni qayta tiklash orqali ushbu to'rtta muammoni hal qilaylik.</p>
<h3 id="binary-loyihalar-uchun-vazifalarni-ajratish"><a class="header" href="#binary-loyihalar-uchun-vazifalarni-ajratish">Binary loyihalar uchun vazifalarni ajratish</a></h3>
<p>Bir nechta vazifalar uchun javobgarlikni <code>main</code> funksiyaga taqsimlashning tashkiliy muammosi ko'plab ikkilik(binary) loyihalar uchun umumiydir. Natijada, Rust hamjamiyati <code>main</code> kattalasha boshlaganda ikkilik dasturning alohida muammolarini ajratish bo'yicha ko'rsatmalar ishlab chiqdi. Bu jarayon quyidagi bosqichlardan iborat:</p>
<ul>
<li>
<p>Dasturingizni <em>main.rs</em> va <em>lib.rs</em> ga bo'ling va dasturingiz mantig'ini <em>lib.rs</em> ga o'tkazing.</p>
</li>
<li>
<p>Agar buyruq satrini tahlil qilish mantig'i kichik bo'lsa, u <em>main.rs</em> da qolishi mumkin.</p>
</li>
<li>
<p>Buyruqlar qatorini tahlil qilish mantig'i murakkablasha boshlagach, uni <em>main.rs</em> dan chiqarib, <em>lib.rs</em> ga o'tkazing.</p>
</li>
</ul>
<p>Ushbu jarayondan keyin <code>main</code> funksiyada qoladigan mas'uliyatlar quyidagilar bilan cheklanishi kerak:</p>
<ul>
<li>Argument qiymatlari bilan buyruq satrini tahlil qilish mantig'ini chaqirish</li>
<li>Boshqa har qanday konfiguratsiyani sozlash</li>
<li><em>lib.rs</em> da <code>run</code> funksiyasini chaqirish</li>
<li><code>run</code> xatoni qaytarsa, xatoni hal qilish</li>
</ul>
<p>Ushbu pattern vazifalarni ajratish bilan bog'liq: <em>main.rs</em> dasturni ishga tushirishni boshqaradi va <em>lib.rs</em> topshirilgan vazifaning barcha mantig'ini boshqaradi. <code>main</code> funksiyani to ªg ªridan-to ªg ªri test qilib ko ªra olmasligingiz sababli, ushbu structura dasturingizning barcha mantig'ini <em>lib.rs</em> funksiyalariga ko ªchirish orqali test qilib ko ªrish imkonini beradi. <em>main.rs</em> da qolgan kod uni o'qish orqali uning to'g'riligini tekshirish uchun yetarlicha kichik bo'ladi. Keling, ushbu jarayonni kuzatib, dasturimizni qayta ishlaymiz.</p>
<h4 id="argument-tahlilchisiniparser-chiqarish"><a class="header" href="#argument-tahlilchisiniparser-chiqarish">Argument tahlilchisini(parser) chiqarish</a></h4>
<p>Argumentlarni tahlil qilish(parsing qilish) funksiyasini <code>main</code> buyruq satrini tahlil qilish mantig'ini <em>src/lib.rs</em> ga ko'chirishga tayyorlash uchun chaqiradigan funksiyaga ajratamiz. Ro'yxat 12-5 <code>main</code> ning yangi boshlanishini ko'rsatadi, u <code>parse_config</code> yangi funksiyasini chaqiradi, biz buni hozircha <em>src/main.rs</em> da aniqlaymiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (sorov, fayl_yoli) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, sorov);
</span><span class="boring">    println!(&quot;{} faylida&quot;, fayl_yoli);
</span><span class="boring">
</span><span class="boring">    let tarkib = fs::read_to_string(fayl_yoli)
</span><span class="boring">        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let sorov = &amp;args[1];
    let fayl_yoli = &amp;args[2];

    (sorov, fayl_yoli)
}</code></pre>
<p><span class="caption">Ro'yxat 12-5: <code>main</code> dan <code>parse_config</code> funksiyasini chiqarish</span></p>
<p>Biz hali ham buyruq qatori argumentlarini vectorga yig‚Äòmoqdamiz, lekin 1-indeksdagi argument qiymatini <code>sorov</code> o‚Äòzgaruvchisiga va 2 indeksidagi argument qiymatini <code>main</code> funksiyasi ichidagi <code>fayl_yoli</code> o‚Äòzgaruvchisiga belgilash o‚Äòrniga, butun vectorni <code>parse_config</code> funksiyasiga o‚Äòtkazamiz. Keyin <code>parse_config</code> funksiyasi qaysi argument qaysi o'zgaruvchiga kirishini aniqlaydigan mantiqni ushlab turadi va qiymatlarni <code>main</code>ga qaytaradi. Biz hali ham <code>sorov</code> va <code>fayl_yoli</code> o'zgaruvchilarini <code>main</code>da yaratamiz, lekin <code>main</code> endi buyruq qatori argumentlari va o'zgaruvchilari qanday mos kelishini aniqlash vazifasiga ega emas.</p>
<p>Ushbu qayta ishlash bizning kichik dasturimiz uchun ortiqcha bo'lib tuyulishi mumkin, ammo biz kichik, bosqichma-bosqich refactoring qilmoqdamiz. Ushbu o'zgartirishni amalga oshirgandan so'ng, argumentni tahlil qilish hali ham ishlayotganligini tekshirish uchun dasturni qayta ishga tushiring. Muammolar yuzaga kelganda sabablarini aniqlashga yordam berish uchun taraqqiyotingizni tez-tez tekshirib turish yaxshidir.</p>
<h4 id="konfiguratsiya-qiymatlarini-guruhlash"><a class="header" href="#konfiguratsiya-qiymatlarini-guruhlash">Konfiguratsiya qiymatlarini guruhlash</a></h4>
<p><code>parse_config</code> funksiyasini yanada yaxshilash uchun yana bir kichik qadam tashlashimiz mumkin.
Ayni paytda biz tupleni qaytarmoqdamiz, lekin keyin darhol bu tupleni yana alohida qismlarga ajratamiz. Bu, ehtimol, bizda hali to'g'ri mavhumlik yo'qligining belgisidir.</p>
<p>Yaxshilash uchun joy borligini ko'rsatadigan yana bir ko'rsatkich <code>parse_config</code> ning <code>config</code> qismidir, bu biz qaytaradigan ikkita qiymat bir-biriga bog'liqligini va ikkalasi ham bitta konfiguratsiya qiymatining bir qismi ekanligini anglatadi. Biz hozirda bu mantiqni ma'lumotlar strukturasida yetkazmayapmiz, bundan tashqari ikkita qiymatni tuplega guruhlash; Buning o'rniga biz ikkita qiymatni bitta strukturaga joylashtiramiz va har bir struktura maydoniga mazmunli nom beramiz. Buni qilish ushbu kodning kelajakdagi saqlovchilariga(maintainerlarga) turli qadriyatlar bir-biriga qanday bog'liqligini va ularning maqsadi nima ekanligini tushunishni osonlashtiradi.</p>
<p>12-6 ro'yxatda <code>parse_config</code> funksiyasining yaxshilanishi ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
    println!(&quot;{} faylida&quot;, config.fayl_yoli);

    let tarkib = fs::read_to_string(config.fayl_yoli)
        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span>}

struct Config {
    sorov: String,
    fayl_yoli: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let sorov = args[1].clone();
    let fayl_yoli = args[2].clone();

    Config { sorov, fayl_yoli }
}</code></pre>
<p><span class="caption">Ro'yxat 12-6: <code>Config</code> strukturasining namunasini qaytarish uchun <code>parse_config</code> ni qayta tahrirlash</span></p>
<p>Biz <code>sorov</code> va <code>fayl_yoli</code> nomli maydonlarga ega bo'lishi uchun aniqlangan <code>Config</code> nomli structi qo'shdik. Endi <code>parse_config</code> signaturesi <code>Config</code> qiymatini qaytarishini bildiradi. Biz <code>args</code>dagi <code>String</code> qiymatlariga reference qilingan satr bo‚Äòlaklarini qaytargan <code>parse_config</code> korpusida endi <code>Config</code> ga tegishli <code>String</code> qiymatlarini o‚Äòz ichiga olgan holda belgilaymiz. <code>main</code>dagi <code>args</code> o ªzgaruvchisi argument qiymatlarining owneri(ega) bo ªlib, faqat <code>parse_config</code> funksiyasiga ularni borrowga(qarz olish) ruxsat beradi, ya ºni <code>Config</code> <code>args</code> qiymatlariga ownership(egalik) qilmoqchi bo ªlsa, Rustning borrowing(qarz olish) qoidalarini buzgan bo ªlamiz.</p>
<p><code>String</code> ma'lumotlarini boshqarishning bir qancha usullari mavjud; Eng oson, garchi unchalik samarasiz bo'lsa ham, route qiymatlar bo'yicha <code>clone</code> metodini chaqirishdir.
Bu <code>Config</code> nusxasi uchun ma'lumotlarning to'liq nusxasini oladi, bu esa satr(string) ma'lumotlariga referenceni saqlashdan ko'ra ko'proq vaqt va xotirani oladi. Biroq, ma'lumotlarni klonlash bizning kodimizni juda sodda qiladi, chunki biz referencelarning lifetimeni(ishlash muddati) boshqarishimiz shart emas; bu holatda, soddalikka erishish uchun ozgina ishlashdan voz kechish foydali savdodir.</p>
<blockquote>
<h3 id="clone-dan-foydalanishning-ozaro-kelishuvlari"><a class="header" href="#clone-dan-foydalanishning-ozaro-kelishuvlari"><code>clone</code> dan foydalanishning o'zaro kelishuvlari</a></h3>
<p>Ko'pgina Rustaceanlar orasida <code>clone</code> dan foydalanish vaqti xarajati tufayli ownership
muammolarini hal qilish uchun foydalanmaslik tendentsiyasi mavjud.
<a href="ch13-00-functional-features.html">13-bobda</a><!-- ignore --> siz ushbu turdagi vaziyatda samaraliroq
usullardan qanday foydalanishni o'rganasiz. Ammo hozircha rivojlanishni
davom ettirish uchun bir nechta satrlarni nusxalash ma'qul, chunki siz bu nusxalarni
faqat bir marta qilasiz va fayl yo'li va so'rovlar qatori juda kichik. Birinchi o'tishda
kodni giperoptimallashtirishga urinishdan ko'ra, biroz samarasiz ishlaydigan dasturga
ega bo'lish yaxshiroqdir. Rust bilan tajribangiz ortgan sayin, eng samarali
yechimdan boshlash osonroq bo'ladi, ammo hozircha <code>clone</code> deb
nomlash juda maqbuldir.</p>
</blockquote>
<p>Biz <code>main</code>ni yangiladik, shuning uchun u <code>parse_config</code> tomonidan qaytarilgan <code>Config</code> namunasini <code>config</code> nomli o‚Äòzgaruvchiga joylashtiradi va biz avval alohida <code>sorov</code> va <code>fayl_yoli</code> o‚Äòzgaruvchilaridan foydalangan kodni yangiladik, shuning uchun u endi <code>Config</code> strukturasidagi maydonlardan foydalanadi.</p>
<p>Endi bizning kodimiz <code>sorov</code> va <code>fayl_yoli</code> bir-biriga bog'liqligini va ularning maqsadi dastur qanday ishlashini sozlash ekanligini aniqroq bildiradi. Ushbu qiymatlardan foydalanadigan har qanday kod ularni maqsadlari uchun nomlangan maydonlardagi <code>config</code> misolida topishni biladi.</p>
<h4 id="config-uchun-konstruktor-yaratish"><a class="header" href="#config-uchun-konstruktor-yaratish"><code>Config</code> uchun konstruktor yaratish</a></h4>
<p>Hozircha biz <code>main</code> dan buyruq qatori argumentlarini tahlil qilish uchun javob beradigan mantiqni chiqarib oldik va uni <code>parse_config</code> funksiyasiga joylashtirdik. Bu bizga <code>sorov</code> va <code>fayl_yoli</code> qiymatlari o'zaro bog'liqligini va bu munosabatlar bizning kodimizda ko'rsatilishi kerakligini ko'rishga yordam berdi. Keyin biz <code>sorov</code> va <code>fayl_yoli</code> ning tegishli maqsadini nomlash va <code>parse_config</code> funksiyasidan qiymatlar nomlarini stuct maydoni nomi sifatida qaytarish uchun <code>Config</code> structini qo'shdik.</p>
<p>Endi <code>parse_config</code> funksiyasining maqsadi <code>Config</code> misolini yaratish bo‚Äòlganligi sababli, biz <code>parse_config</code> ni oddiy funksiyadan <code>Config</code> structi bilan bog'langan <code>new</code> funksiyaga o‚Äòzgartirishimiz mumkin. Ushbu o'zgarish kodni yanada idiomatik qiladi. Biz standart kutubxonada <code>String</code> kabi turlarning namunalarini <code>String::new</code> ni chaqirish orqali yaratishimiz mumkin. Xuddi shunday, <code>parse_config</code>ni <code>Config</code> bilan bog‚Äòlangan <code>new</code> funksiyaga o‚Äòzgartirib, <code>Config::new</code> ni chaqirish orqali <code>Config</code> misollarini yaratishimiz mumkin bo‚Äòladi. 12-7 ro'yxat biz qilishimiz kerak bo'lgan o'zgarishlarni ko'rsatadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
</span><span class="boring">    println!(&quot;{} faylida&quot;, config.fayl_yoli);
</span><span class="boring">
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)
</span><span class="boring">        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    sorov: String,
</span><span class="boring">    fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let sorov = args[1].clone();
        let fayl_yoli = args[2].clone();

        Config { sorov, fayl_yoli }
    }
}</code></pre>
<p><span class="caption">Ro'yxat 12-7: <code>parse_config</code> ni <code>Config::new</code> ga o'zgartirish</span></p>
<p>Biz <code>parse_config</code> deb chaqirgan <code>main</code>ni yangilab, <code>Config::new</code> deb chaqirdik. Biz <code>parse_config</code> nomini <code>new</code> ga o‚Äòzgartirdik va uni <code>new</code> funksiyani <code>Config</code> bilan bog‚Äòlaydigan <code>impl</code> blokiga o‚Äòtkazdik. Ishlayotganiga ishonch hosil qilish uchun ushbu kodni qayta kompilyatsiya qilib ko'ring.</p>
<h3 id="qayta-ishlash-xatolarini-tuzatish"><a class="header" href="#qayta-ishlash-xatolarini-tuzatish">Qayta ishlash xatolarini tuzatish</a></h3>
<p>Endi biz xatolarimizni tuzatish ustida ishlaymiz. Eslatib o'tamiz, <code>args</code> vectoridagi qiymatlarga 1 yoki indeks 2 da kirishga urinish vector uchtadan kam elementni o'z ichiga olgan bo'lsa, dastur panic paydo bo'ladi. Dasturni hech qanday argumentlarsiz ishga tushirishga harakat qiling; u shunday ko'rinadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code>(indeks chegaradan tashqarida: len 1, lekin indeks 1) qatori dasturchilar uchun mo ªljallangan xato xabaridir. Bu bizning oxirgi foydalanuvchilarga nima qilish kerakligini tushunishga yordam bermaydi. Keling, buni hozir tuzatamiz.</p>
<h4 id="xato-xabarini-yaxshilash"><a class="header" href="#xato-xabarini-yaxshilash">Xato xabarini yaxshilash</a></h4>
<p>Ro'yxat 12-8da biz <code>new</code> funksiyasiga chek qo'shamiz, bu 1 va 2 indekslarga kirishdan oldin bo'lakning yetarlicha uzunligini tasdiqlaydi. Agar bo'lak yetarlicha uzun bo'lmasa, dastur panic chiqaradi va yaxshiroq xato xabarini ko'rsatadi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
</span><span class="boring">    println!(&quot;{} faylida&quot;, config.fayl_yoli);
</span><span class="boring">
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)
</span><span class="boring">        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    sorov: String,
</span><span class="boring">    fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;argumentlar yetarli emas&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let sorov= args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { sorov, fayl_yoli }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-8: Argumentlar soni uchun chek qo'shish</span></p>
<p>Bu kod biz 9-13 ro ªyxatda yozgan <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation"><code>Taxmin::new</code> funksiyasiga o ªxshaydi,</a><!-- ignore --> bu yerda <code>qiymat</code> argumenti amaldagi qiymatlar oralig ªidan tashqarida bo ªlganida <code>panic!</code> deb chaqirdik. Bu yerda bir qator qiymatlar mavjudligini tekshirish o‚Äòrniga, biz <code>args</code> uzunligi kamida 3 ekanligini va funksiyaning qolgan qismi ushbu shart bajarilgan deb taxmin qilingan holda ishlashini tekshiramiz. Agar <code>args</code> uchta elementdan kam bo ªlsa, bu shart to ªg ªri bo ªladi va dasturni darhol tugatish uchun <code>panic!</code> makrosini chaqiramiz.</p>
<p><code>new</code> da qo ªshimcha bir necha qator kodlar mavjud bo ªlsa, keling, xatolik qanday ko ªrinishini ko ªrish uchun dasturni argumentlarsiz yana ishga tushiramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'argumentlar yetarli emas', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Bu chiqish yaxshiroq: endi bizda oqilona xato xabari bor. Biroq, bizda foydalanuvchilarga berishni istamaydigan begona ma'lumotlar ham bor. Ehtimol, biz 9-13 ro ªyxatda qo ªllagan texnikamizdan foydalanish bu yerda eng yaxshisi emas: <code>panic!</code> chaqiruvi <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">9-bobda muhokama qilinganidek</a><!-- ignore -->, foydalanish muammosidan ko ªra dasturlash muammosiga ko ªproq mos keladi. Buning o'rniga biz 9-bobda o'rgangan boshqa texnikadan foydalanamiz - muvaffaqiyat yoki xatoni ko'rsatadigan <a href="ch09-02-recoverable-errors-with-result.html"><code>Result</code>ni</a><!-- ignore -->  qaytarish.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="panic-orniga-resultni-qaytarish"><a class="header" href="#panic-orniga-resultni-qaytarish"><code>panic!</code> o‚Äòrniga <code>Result</code>ni qaytarish</a></h4>
<p>Buning o'rniga, muvaffaqiyatli holatda <code>Config</code> misolini o'z ichiga olgan va xatolik holatida muammoni tasvirlaydigan <code>Result</code> qiymatini qaytarishimiz mumkin. Shuningdek, biz funksiya nomini <code>new</code>dan <code>build</code>ga o'zgartiramiz, chunki ko'plab dasturchilar <code>new</code> funksiyalar hech qachon ishlamay qolmasligini kutishadi. <code>Config::build</code> <code>main</code> bilan bog'langanda, muammo borligini bildirish uchun <code>Result</code> turidan foydalanishimiz mumkin.Keyin biz <code>main</code> ni <code>Err</code> variantini <code>panic!</code> chaqiruvi keltirib chiqaradigan <code>thread 'main'</code> va <code>RUST_BACKTRACE</code> haqidagi matnsiz foydalanuvchilarimiz uchun amaliyroq xatoga aylantirishimiz mumkin.</p>
<p>12-9 ro'yxatda biz hozir <code>Config::build</code> deb nomlanayotgan funksiyaning qaytish(result) qiymatiga va <code>Result</code>ni qaytarish uchun zarur bo'lgan funksiyaning tanasiga qilishimiz kerak bo'lgan o'zgarishlar ko'rsatilgan. E'tibor bering, biz <code>main</code>ni ham yangilamagunimizcha, bu kompilyatsiya qilinmaydi, biz buni keyingi ro'yxatda qilamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
</span><span class="boring">    println!(&quot;{} faylida&quot;, config.fayl_yoli);
</span><span class="boring">
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)
</span><span class="boring">        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    sorov: String,
</span><span class="boring">    fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;argumentlar yetarli emas&quot;);
        }

        let sorov = args[1].clone();
        let fayl_yoli = args[2].clone();

        Ok(Config { sorov, fayl_yoli })
    }
}</code></pre>
<p><span class="caption">Ro'yxat 12-9: <code>Config::build</code> dan <code>Result</code>ni qaytarish</span></p>
<p>Bizning <code>build</code> funksiyamiz muvaffaqiyatli holatda <code>Config</code> misoli va xato holatida <code>&amp;'static str</code> bilan <code>Result</code>ni qaytaradi. Bizning xato qiymatlarimiz har doim <code>'static</code> lifetimega ega bo'lgan satr harflari(string literal) bo'ladi. Biz funksiyaning asosiy qismiga ikkita o'zgartirish kiritdik: agar foydalanuvchi yetarli argumentlarni o'tkazmasa, <code>panic!</code> deb chaqirish o'rniga, biz endi <code>Err</code> qiymatini qaytaramiz va <code>Config</code> qaytish(return) qiymatini <code>OK</code> bilan o'rab oldik. Ushbu o'zgarishlar funksiyani yangi turdagi signaturega moslashtiradi.</p>
<p><code>Config::build</code> dan <code>Err</code> qiymatini qaytarish <code>main</code> funksiyaga <code>build</code> funksiyasidan qaytarilgan <code>Result</code> qiymatini boshqarish imkonini beradi va xato holatida jarayondan tozaroq chiqish imkonini beradi.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="configbuild-ga-murojaat-qilish-va-xatolarni-qayta-ishlash"><a class="header" href="#configbuild-ga-murojaat-qilish-va-xatolarni-qayta-ishlash"><code>Config::build</code> ga murojaat qilish va xatolarni qayta ishlash</a></h4>
<p>Xato holatini hal qilish va foydalanuvchi uchun qulay xabarni chop etish uchun biz 12-10 ro ªyxatda ko ªrsatilganidek, <code>Config::build</code> tomonidan qaytariladigan <code>Result</code>ni qayta ishlash uchun <code>main</code>ni yangilashimiz kerak. Shuningdek, biz <code>panic!</code> dan nolga teng bo‚Äòlmagan xato kodi bilan buyruq qatori dasturidan chiqish va uning o‚Äòrniga uni qo‚Äòlda amalga oshirish mas‚Äôuliyatini o‚Äòz zimmamizga olamiz. Nolga teng bo'lmagan chiqish holati - bu bizning dasturimizni chaqirgan jarayonga dastur xato holati bilan chiqqanligi haqida signal berish uchun konventsiya.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Argumentlarni tahlil qilish muammosi: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
</span><span class="boring">    println!(&quot;{} faylida&quot;, config.fayl_yoli);
</span><span class="boring">
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)
</span><span class="boring">        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    sorov: String,
</span><span class="boring">    fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-10: Agar <code>Config</code> build bo'lmasa, xato kodi bilan chiqish</span></p>
<p>Ushbu ro'yxatda biz hali batafsil ko'rib chiqmagan metoddan foydalandik: standart kutubxona tomonidan <code>Result&lt;T, E&gt;</code> da aniqlangan <code>unwrap_or_else</code>.
<code>unwrap_or_else</code> dan foydalanish bizga <code>panic!</code> qo'ymaydigan xatoliklarni aniqlash imkonini beradi. Agar <code>Result</code> <code>Ok</code> qiymati bo'lsa, bu metodning harakati <code>unwrap</code> ga o'xshaydi: u <code>Ok</code> o'ralayotgan(wrap) ichki qiymatni qaytaradi. Biroq, agar qiymat <code>Err</code> qiymati bo'lsa, bu metod kodni <em>closure</em>(yopish) ga chaqiradi, bu biz belgilab beradigan anonim funksiya bo'lib, <code>unwrap_or_else</code> ga argument sifatida o'tkazamiz. Biz <a href="ch13-00-functional-features.html">13-bobda</a><!-- ignore --> closure(yopilish)larni batafsil ko'rib chiqamiz.  Hozircha siz shuni bilishingiz kerakki, <code>unwrap_or_else</code> <code>Err</code> ning ichki qiymatidan o‚Äòtadi, bu holda biz 12-9-listga qo‚Äòshgan <code>&quot;argumentlar yetarli emas&quot;</code> statik qatori bo‚Äòlib, bizning yopishimiz uchun Vertikal quvurlar(pipe) o'rtasida paydo bo'ladigan <code>Err</code> argumenti. Yopishdagi(closure) kod ishlayotganida <code>err</code> qiymatidan foydalanishi mumkin.</p>
<p>Biz standart kutubxonadan <code>process</code>ni qamrab olish uchun yangi <code>use</code> qatorini qo‚Äòshdik. Xato holatida ishga tushiriladigan yopishdagi kod faqat ikkita qatordan iborat: biz <code>err</code> qiymatini chop qilamiz va keyin <code>process::exit</code>ni chaqiramiz. <code>process::exit</code> funksiyasi dasturni darhol to'xtatadi va chiqish holati kodi sifatida berilgan raqamni qaytaradi. Bu biz 12-8 ro ªyxatda qo ªllagan <code>panic!</code> asosidagi ishlovga o ªxshaydi, ammo biz endi barcha qo ªshimcha natijalarni olmaymiz. Keling, sinab ko'raylik:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Argumentlarni tahlil qilish muammosi: argumentlar yetarli emas
</code></pre>
<p>Ajoyib! Ushbu chiqish bizning foydalanuvchilarimiz uchun juda qulay.</p>
<h3 id="main-dan-mantiqni-ajratib-olish"><a class="header" href="#main-dan-mantiqni-ajratib-olish"><code>main</code> dan mantiqni ajratib olish</a></h3>
<p>Endi biz konfiguratsiyani tahlil qilishni qayta tiklashni tugatdik, keling, dastur mantig'iga murojaat qilaylik. <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">&quot;Binary loyihalar uchun vazifalarni ajratish&quot;</a><!-- ignore --> da aytib o'tganimizdek, biz konfiguratsiyani o'rnatish yoki xatolarni qayta ishlash bilan bog'liq bo'lmagan <code>main</code> funksiyadagi barcha mantiqni ushlab turadigan <code>run</code> nomli funksiyani chiqaramiz. Ishimiz tugagach, <code>main</code> qisqa va tekshirish orqali tekshirish oson bo'ladi va biz boshqa barcha mantiqlar uchun testlarni yozishimiz mumkin bo'ladi.</p>
<p>12-11 ro'yxatda ajratilgan <code>run</code> funksiyasi ko'rsatilgan. Hozircha biz funksiyani chiqarishni kichik, bosqichma-bosqich yaxshilashni amalga oshirmoqdamiz. Biz hali ham <em>src/main.rs</em> da funksiyani aniqlayapmiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Argumentlarni tahlil qilish muammosi: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
    println!(&quot;{} faylida&quot;, config.fayl_yoli);

    run(config);
}

fn run(config: Config) {
    let tarkib = fs::read_to_string(config.fayl_yoli)
        .expect(&quot;Faylni o'qiy olishi kerak edi&quot;);

    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    sorov: String,
</span><span class="boring">    fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-11: Dastur mantig'ining qolgan qismini o'z ichiga olgan <code>run</code> funksiyasini chiqarish</span></p>
<p><code>run</code> funksiyasi endi faylni o‚Äòqishdan boshlab <code>main</code> dan qolgan barcha mantiqni o‚Äòz ichiga oladi. <code>run</code> funksiyasi argument sifatida <code>Config</code> misolini oladi.</p>
<h4 id="run-funksiyasidan-xatolarni-qaytarishreturn"><a class="header" href="#run-funksiyasidan-xatolarni-qaytarishreturn"><code>run</code> funksiyasidan xatolarni qaytarish(return)</a></h4>
<p>Qolgan dastur mantig ªi <code>run</code> funksiyasiga ajratilgan bo ªlsa, biz 12 9-ro'yxatdagi <code>Config::build</code> bilan qilganimiz kabi, xatolarni boshqarishni yaxshilashimiz mumkin. Dasturni <code>expect</code> deb chaqirish orqali panic qo‚Äòyish o‚Äòrniga, <code>run</code> funksiyasi biror narsa noto‚Äòg‚Äòri ketganda <code>Result&lt;T, E&gt;</code>ni qaytaradi. Bu bizga foydalanuvchilarga qulay tarzda xatolarni <code>main</code>ga qayta ishlash mantig'ini yanada mustahkamlash imkonini beradi. 12-12 ro ªyxatda <code>run</code> signaturesi va asosiy qismiga qilishimiz kerak bo ªlgan o ªzgarishlar ko ªrsatilgan.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Argumentlarni tahlil qilish muammosi: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
</span><span class="boring">    println!(&quot;{} faylida&quot;, config.fayl_yoli);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let tarkib = fs::read_to_string(config.fayl_yoli)?;

    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    sorov: String,
</span><span class="boring">    fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-12: <code>run</code> funksiyasini <code>Result</code>ni qaytarish uchun o'zgartirish</span></p>
<p>Biz bu yerda uchta muhim o'zgarishlarni amalga oshirdik. Birinchidan, biz <code>run</code> funksiyasining qaytish turini <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>ga o'zgartirdik. Bu funksiya avval birlik(binary) turini qaytardi, <code>()</code> va biz buni <code>Ok</code> holatida qaytarilgan qiymat sifatida saqlaymiz.</p>
<p>Xato turi uchun biz <em>trait obyekti</em> <code>Box&lt;dyn Error&gt;</code>dan foydalandik (va biz <code>std::error::Error</code> ni yuqori qismida <code>use</code> statementi bilan qamrab oldik). Biz <a href="ch17-00-oop.html">17-bobda</a><!-- ignore --> trait objectlarni ko'rib chiqamiz. Hozircha shuni bilingki, <code>Box&lt;dyn Error&gt;</code> funksiya <code>Error</code> traitini amalga oshiradigan turni qaytarishini bildiradi, lekin qaytariladigan qiymatning qaysi turini belgilashimiz shart emas. Bu bizga turli xil xato holatlarida har xil turdagi xato qiymatlarini qaytarish uchun moslashuvchanlikni beradi. <code>dyn</code> kalit so'zi(keywordi) &quot;dynamic(dinamik)&quot; so'zining qisqartmasi.</p>
<p>Ikkinchidan, biz <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">9-bobda</a><!-- ignore --> aytib o'tganimizdek, <code>?</code> operatori foydasiga <code>expect</code> chaqiruvini olib tashladik. Xatoda <code>panic!</code> o‚Äòrniga, <code>?</code> murojat qiluvchiga ishlov berish uchun joriy funksiyadan xato qiymatini qaytaradi.</p>
<p>Uchinchidan, <code>run</code> funksiyasi endi muvaffaqiyatli holatda <code>Ok</code> qiymatini qaytaradi.
Biz signatureda <code>run</code> funksiyasining muvaffaqiyat turini <code>()</code> deb e‚Äôlon qildik, ya‚Äôni birlik turi qiymatini <code>Ok</code> qiymatiga o‚Äòrashimiz(wrap) kerak. Bu <code>Ok(())</code> sintaksisi dastlab biroz g‚Äòalati ko‚Äòrinishi mumkin, ammo <code>()</code> dan foydalanish biz <code>run</code>ni faqat uning yon ta‚Äôsiri uchun chaqirayotganimizni bildirishning idiomatik usulidir; u bizga kerakli qiymatni qaytarmaydi.</p>
<p>Ushbu kodni ishga tushirganingizda, u kompilyatsiya qilinadi, lekin ogohlantirishni ko'rsatadi:</p>
<pre><code class="language-console">$ cargo run men olma.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
men qidirilmoqda
olma.txt faylida
Fayl tarkibi:
Tanishaylik, men - olma,
Nomimga quloq solma.
Olaver, ikiklanmay,
Ishtahang bo'lsin karnay

Reklamaga hojat yo'q
Ta'mim rosa yoqimli.
Ortganini quritsang,
Qishda yeysan qoqimni

Men sizlarni olmangiz,
Xomligimda olmangiz!
Asilbekga o'xshab so'ng,
Voy qornim deb qolmangiz!

Bog'larda chiroymanda, 
Vitaminga boymanda!
Pishganimda yemasangiz,
Qolasizda armonda!
</code></pre>
<p>Rust bizga kodimiz <code>Result</code> qiymatini e'tiborsiz qoldirganligini va <code>Result</code> qiymati xatolik yuz berganligini ko'rsatishi mumkinligini aytadi. Ammo biz xatolik bor yoki yo'qligini tekshirmayapmiz va kompilyator bu yerda xatoliklarni hal qilish uchun kodga ega bo'lishimiz kerakligini eslatadi! Keling, bu muammoni hozir tuzatamiz.</p>
<h4 id="maindagi-run-dan-qaytarilgan-xatolarni-qayta-ishlash"><a class="header" href="#maindagi-run-dan-qaytarilgan-xatolarni-qayta-ishlash"><code>main</code>dagi <code>run</code> dan qaytarilgan xatolarni qayta ishlash</a></h4>
<p>Biz xatolarni tekshirib ko'ramiz va ularni 12-10-sonli ro'yxatdagi <code>Config::build</code> bilan ishlatganimizga o'xshash metod yordamida hal qilamiz, lekin bir oz farq bilan:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Argumentlarni tahlil qilish muammosi: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
    println!(&quot;{} faylida&quot;, config.fayl_yoli);

    if let Err(e) = run(config) {
        println!(&quot;Dastur xatosi: {e}&quot;);
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    sorov: String,
</span><span class="boring">    fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>run</code> <code>Err</code> qiymatini qaytaradimi yoki yo‚Äòqligini tekshirish uchun <code>unwrap_or_else</code> o‚Äòrniga <code>if let</code> dan foydalanamiz va agar qaytarsa <code>process::exit(1)</code>ni chaqiramiz. <code>run</code> funksiyasi <code>Config::build</code> <code>Config</code> misolini qaytarganidek, biz <code>unwrap</code>ni xohlagan qiymatni qaytarmaydi. Muvaffaqiyatli holatda <code>run</code>  <code>()</code> ni qaytargani uchun biz faqat xatoni aniqlash haqida qayg'uramiz, shuning uchun o'ralgan(wrap) qiymatni qaytarish uchun <code>unwrap_or_else</code> shart emas, bu faqat <code>()</code> bo`ladi.</p>
<p><code>if let</code> va <code>unwrap_or_else</code> funksiyalarining tanasi ikkala holatda ham bir xil: biz xatoni chop qilamiz va chiqamiz.</p>
<h3 id="kodni-kutubxonalibrary-cratesiga-bolish"><a class="header" href="#kodni-kutubxonalibrary-cratesiga-bolish">Kodni kutubxona(library) cratesiga bo'lish</a></h3>
<p>Bizning <code>minigrep</code> loyihamiz hozircha yaxshi ko'rinmoqda! Endi biz <em>src/main.rs</em> faylini ajratamiz va <em>src/lib.rs</em> fayliga bir nechta kodni joylashtiramiz. Shunday qilib, biz kodni sinab ko'rishimiz va kamroq mas'uliyatli <em>src/main.rs</em> fayliga ega bo'lishimiz mumkin.</p>
<p>Keling, <code>main</code> funksiya bo'lmagan barcha kodlarni <em>src/main.rs</em> dan <em>src/lib.rs</em> ga o'tkazamiz:</p>
<ul>
<li><code>run</code> funksiyasi definitioni</li>
<li>Tegishli <code>use</code> statementlari</li>
<li><code>Config</code> ning definitioni</li>
<li><code>Config::build</code> definitioni</li>
</ul>
<p><em>src/lib.rs</em> ning mazmuni 12-13 ro ªyxatda ko ªrsatilgan signaturelarga ega bo ªlishi kerak (qisqalik uchun funksiyalarning qismlarini olib tashladik). E'tibor bering, biz 12-14 ro'yxatdagi <em>src/main.rs</em> ni o'zgartirmagunimizcha, bu kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub sorov: String,
    pub fayl_yoli: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;Fayl tarkibi:\n{tarkib}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
<p><span class="caption">Ro'yxat 12-13: <code>Config</code> va <code>run</code> ni <em>src/lib.rs</em> ichiga ko'chirish</span></p>
<p>Biz <code>pub</code> kalit so‚Äòzidan erkin foydalandik: <code>Config</code> da, uning maydonlari va <code>build</code> metodida va <code>run</code> funksiyasida. Endi bizda testdan o'tkazishimiz mumkin bo'lgan ommaviy(public) API mavjud kutubxona cratesi bor!</p>
<p>Endi biz <em>src/lib.rs</em> ga ko'chirilgan kodni 12-14 ro'yxatda ko'rsatilganidek <em>src/main.rs</em> dagi binary crate doirasiga olib kirishimiz kerak.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Argumentlarni tahlil qilish muammosi: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;{} qidirilmoqda&quot;, config.sorov);
</span><span class="boring">    println!(&quot;{} faylida&quot;, config.fayl_yoli);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Dastur xatosi: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
<p><span class="caption">Ro'yxat 12-14: <em>src/main.rs</em> da <code>minigrep</code> kutubxona cratesidan foydalanish</span></p>
<p>Kutubxona cratesidan <code>Config</code> turini binary crate ko'lamiga olib kirish uchun <code>use minigrep::Config</code> qatorini qo'shamiz va <code>run</code> funksiyasiga crate nomimiz bilan prefix qo'shamiz. Endi barcha funksiyalar ulanishi va ishlashi kerak. Dasturni <code>cargo run</code> bilan ishga tushiring va hamma narsa to'g'ri ishlashiga ishonch hosil qiling.</p>
<p>Vouv! Bu juda ko'p ish edi, lekin biz kelajakda muvaffaqiyatga erishdik. Endi xatolarni hal qilish ancha oson va biz kodni modulliroq qildik. Deyarli barcha ishlarimiz bundan buyon <em>src/lib.rs</em> da amalga oshiriladi.</p>
<p>Keling, eski kod bilan qiyin bo'lgan, ammo yangi kod bilan oson bo'lgan narsani qilish orqali ushbu yangi modullikdan foydalanaylik: biz bir nechta testlarni yozamiz!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="testga-asoslangan-ishlab-chiqish-bilan-kutubxonaning-funksionalligini-rivojlantirish"><a class="header" href="#testga-asoslangan-ishlab-chiqish-bilan-kutubxonaning-funksionalligini-rivojlantirish">Testga asoslangan ishlab chiqish bilan kutubxonaning funksionalligini rivojlantirish</a></h2>
<p>Endi biz mantiqni <em>src/lib.rs</em> ga chiqardik va argumentlarni yig‚Äòish va xatolarni qayta ishlashni <em>src/main.rs</em> da qoldirdik, kodimizning asosiy funksionalligi uchun testlarni yozish ancha osonlashdi. Biz turli xil argumentlar bilan funksiyalarni to'g'ridan-to'g'ri chaqirishimiz va buyruq satridan binaryga murojaat qilmasdan qaytish(return) qiymatlarini tekshirishimiz mumkin.</p>
<p>Ushbu bo'limda biz quyidagi bosqichlar bilan test-driven development (TDD) jarayonidan foydalangan holda <code>minigrep</code> dasturiga qidiruv mantig'ini qo'shamiz:</p>
<ol>
<li>Muvaffaqiyatsiz bo'lgan testni yozing va siz kutgan sabab tufayli muvaffaqiyatsiz bo'lishiga ishonch hosil qilish uchun uni ishga tushiring.</li>
<li>Yangi testdan o'tish uchun yetarli kodni yozing yoki o'zgartiring.</li>
<li>Siz qo'shgan yoki o'zgartirgan kodni qayta tiklang(refaktoring) va testlar o'tishda davom etayotganiga ishonch hosil qiling.</li>
<li>Repeat from step 1!</li>
</ol>
<p>Garchi bu dasturiy ta'minotni yozishning ko'p usullaridan biri bo'lsa-da, TDD kod dizaynini boshqarishga yordam beradi. Testdan o'tishni ta'minlaydigan kodni yozishdan oldin testni yozish jarayon davomida yuqori sinov qamrovini saqlashga yordam beradi.</p>
<p>Biz fayl tarkibidagi so'rovlar qatorini qidirishni amalga oshiradigan va so'rovga mos keladigan qatorlar ro'yxatini tuzadigan funksiyani amalga oshirishni sinovdan o'tkazamiz. Biz bu funksiyani <code>qidiruv</code> funksiyasiga qo‚Äòshamiz.</p>
<h3 id="muvaffaqiyatsiz-test-yozish"><a class="header" href="#muvaffaqiyatsiz-test-yozish">Muvaffaqiyatsiz test yozish</a></h3>
<p>Bizga endi ular kerak emasligi sababli, dasturning harakatini tekshirish uchun foydalanilgan <em>src/lib.rs</em> va <em>src/main.rs</em> dan <code>println!</code> statementlarini olib tashlaymiz. Keyin, <em>src/lib.rs</em> da, <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">11-bobda</a><!-- ignore --> qilganimizdek, test funksiyasiga ega <code>tests</code> modulini qo'shing. Test funksiyasi biz <code>qidirish</code> funksiyasiga ega bo'lishini xohlagan xatti-harakatni belgilaydi: u so'rov va izlash uchun matnni oladi va u so'rovni o'z ichiga olgan matndan faqat satrlarni qaytaradi. 12-15 ro'yxatda ushbu test ko'rsatilgan, u hali kompilyatsiya bo'lmaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn birinchi_natija() {
        let sorov = &quot;marali&quot;;
        let tarkib = &quot;\
Rust:
xavfsiz, tez, samarali.
Uchtasini tanlang.&quot;;

        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
    }
}</code></pre>
<p><span class="caption">12-15 ro ªyxat: <code>qidiruv</code> funksiyasi uchun muvaffaqiyatsiz test yaratish</span></p>
<p>Bu test <code>marali</code> qatorini qidiradi.Biz izlayotgan matn uchta qatordan iborat bo‚Äòlib, ulardan faqat bittasi <code>marali</code>ni o‚Äòz ichiga oladi (E‚Äôtibor bering, qo‚Äòsh qo‚Äòshtirnoqning ochilishidan keyingi teskari chiziq Rustga ushbu satr literalining boshiga yangi qator belgisini qo‚Äòymaslikni bildiradi). <code>qidiruv</code> funksiyasidan qaytarilgan qiymat faqat biz kutgan qatorni o'z ichiga oladi, deb ta'kidlaymiz.</p>
<p>Biz hali bu testni bajara olmaymiz va uning muvaffaqiyatsizligini kuzata olmaymiz, chunki test hatto kompilyatsiya ham qilmaydi: <code>qidiruv</code> funksiyasi hali mavjud emas! TDD tamoyillariga muvofiq, biz 12-16 ro ªyxatda ko ªrsatilganidek, har doim bo ªsh vektorni qaytaruvchi <code>qidiruv</code> funksiyasining definitionni qo ªshish orqali testni kompilyatsiya qilish va ishga tushirish uchun yetarli kodni qo ªshamiz. Keyin test kompilyatsiya qilinishi va muvaffaqiyatsiz bo'lishi kerak, chunki bo'sh vektor <code>&quot;xavfsiz, tez, samarali.&quot;</code> qatorini o'z ichiga olgan vektorga mos kelmaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn qidiruv&lt;'a&gt;(sorov: &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn birinchi_natija() {
</span><span class="boring">        let sorov = &quot;marali&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-16: <code>qidiruv</code> funksiyasini yetarli darajada aniqlash, shuning uchun testimiz kompilyatsiya bo'ladi</span></p>
<p>E'tibor bering, biz <code>qidiruv</code> signaturesida <code>'a</code> aniq lifetimeni belgilashimiz va bu lifetimeni <code>tarkib</code> argumenti va qaytarish(return) qiymati bilan ishlatishimiz kerak. <a href="ch10-03-lifetime-syntax.html">10-bobda</a><!-- ignore -->  esda tutingki, lifetime parametrlari qaysi argumentning lifetime(ishlash muddati) qaytariladigan qiymatning lifetime bilan bog'liqligini belgilaydi. Bunday holda, qaytarilgan vektorda <code>tarkib</code> argumentining bo'laklariga (<code>sorov</code> argumenti o'rniga) reference qiluvchi string bo'laklari bo'lishi kerakligini ko'rsatamiz.</p>
<p>Boshqacha qilib aytganda, biz Rustga aytamizki, <code>qidiruv</code> funksiyasi tomonidan qaytarilgan ma ºlumotlar <code>tarkib</code> argumentida <code>qidiruv</code> funksiyasiga o ªtgan ma ºlumotlar shuncha vaqtgacha yashaydi. Bu muhim! Murojaatlar haqiqiy bo'lishi uchun bo'laklar(slice) bo'yicha reference qilingan ma'lumotlar ham haqiqiy bo'lishi kerak; agar kompilyator biz <code>tarkib</code> emas, balki <code>sorov</code> ning satr bo'laklarini(string slice) yaratmoqda deb hisoblasa, u xavfsizlik tekshiruvini noto'g'ri bajaradi.</p>
<p>Agar biz lifetime izohlarni(annotation) unutib, ushbu funksiyani kompilyatsiya qilishga harakat qilsak, biz ushbu xatoni olamiz:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:29:50
   |
29 | pub fn qidiruv(sorov: &amp;str, tarkib: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                       ----          ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `sorov` or `tarkib`
help: consider introducing a named lifetime parameter
   |
29 | pub fn qidiruv&lt;'a&gt;(sorov: &amp;'a str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |               ++++         ++               ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to previous error
warning: build failed, waiting for other jobs to finish...
error: could not compile `minigrep` (lib test) due to previous error
</code></pre>
<p>Rust bizga ikkita argumenning qaysi biri kerakligini bila olmaydi, shuning uchun biz buni aniq aytishimiz kerak. <code>tarkib</code> barcha matnimizni o'z ichiga olgan argument bo'lgani uchun va biz ushbu matnning mos keladigan qismlarini qaytarmoqchi bo'lganimiz sababli, biz <code>tarkib</code> lifetime sintaksisi yordamida qaytarish qiymatiga ulanishi kerak bo'lgan argument ekanligini bilamiz.</p>
<p>Boshqa dasturlash tillari signaturedagi qiymatlarni qaytarish uchun argumentlarni ulashni talab qilmaydi, ammo bu amaliyot vaqt o'tishi bilan osonlashadi. Siz ushbu misolni 10-bobdagi <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">‚ÄúMa‚Äôlumotnomalarni lifetime bilan tekshirish‚Äù</a><!-- ignore --> bo‚Äòlimi bilan solishtirishingiz mumkin.</p>
<p>Endi testni bajaramiz:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 1 test
test tests::birinchi_natija ... FAILED

successes:

successes:

failures:

---- tests::birinchi_natija stdout ----
thread 'tests::birinchi_natija' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;xavfsiz, tez, samarali.&quot;]`,
 right: `[]`', src/lib.rs:46:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::birinchi_natija

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Ajoyib, test biz kutganimizdek muvaffaqiyatsiz tugadi. Keling, testdan o'tamiz!</p>
<h3 id="testdan-otish-uchun-kod-yozish"><a class="header" href="#testdan-otish-uchun-kod-yozish">Testdan o'tish uchun kod yozish</a></h3>
<p>Hozirda testimiz muvaffaqiyatsiz tugadi, chunki biz har doim bo'sh vektorni qaytaramiz. Buni tuzatish va <code>qidiruv</code> ni amalga oshirish uchun dasturimiz quyidagi bosqichlarni bajarishi kerak:</p>
<ul>
<li><code>tarkib</code> ning har bir satrini takrorlang.</li>
<li>Berilgan satrda siz izlayotgan qator mavjudligini tekshiring.</li>
<li>Agar shunday bo'lsa, uni biz qaytaradigan qiymatlar ro'yxatiga qo'shing.</li>
<li>Agar bunday bo'lmasa, hech narsa qilmang.</li>
<li>Mos keladigan natijalar ro'yxatini qaytaring.</li>
</ul>
<p>Keling, satrlarni takrorlashdan boshlab, har bir bosqichda ishlaylik.</p>
<h4 id="lines-metodi-bilan-qatorlar-boylab-takrorlash"><a class="header" href="#lines-metodi-bilan-qatorlar-boylab-takrorlash"><code>lines</code> metodi bilan qatorlar bo'ylab takrorlash</a></h4>
<p>Rust 12-17 ro'yxatda ko'rsatilganidek, qulay tarzda <code>lines</code> deb nomlangan satrlarni qatorma-qator takrorlash uchun foydali metodga ega. E'tibor bering, bu hali kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn qidiruv&lt;'a&gt;(sorov: &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in tarkib.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn birinchi_natija() {
</span><span class="boring">        let sorov = &quot;marali&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-17: <code>tarkib</code>dagi har bir qatorni takrorlash
</span></p>
<p><code>lines</code> metodi iteratorni qaytaradi.Biz iteratorlar haqida <a href="ch13-02-iterators.html">13-bobda</a><!-- ignore --> chuqurroq gaplashamiz, lekin esda tutingki, siz iteratordan foydalanishning bunday usulini <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">3-5-ro'yxatda</a><!-- ignore --> ko'rgansiz, bu yerda biz to'plamdagi har bir elementda ba'zi kodlarni ishlatish uchun iterator bilan <code>for</code> siklidan foydalanganmiz.</p>
<h4 id="sorov-uchun-har-bir-qatorni-qidirish"><a class="header" href="#sorov-uchun-har-bir-qatorni-qidirish">So'rov uchun har bir qatorni qidirish</a></h4>
<p>Keyinchalik, joriy qatorda so'rovlar qatori mavjudligini tekshiramiz. Yaxshiyamki, satrlarda biz uchun buni amalga oshiradigan <code>contains</code> deb nomlangan foydali metod mavjud! 12-18 ro ªyxatda ko ªrsatilganidek, <code>qidiruv</code> funksiyasidagi <code>contains</code> metodiga murojatni qo ªshing. E'tibor bering, bu hali kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn qidiruv&lt;'a&gt;(sorov: &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in tarkib.lines() {
        if line.contains(sorov) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn birinchi_natija() {
</span><span class="boring">        let sorov = &quot;marali&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-18: satrda <code>sorov</code> dagi satr mavjudligini ko'rish uchun funksiya qo'shiladi</span></p>
<p>Ayni paytda biz funksionallikni yaratmoqdamiz. Uni kompilyatsiya qilish uchun biz funksiya signaturesida ko'rsatganimizdek, tanadan qiymatni qaytarishimiz kerak.</p>
<h4 id="mos-keladigan-qatorlarni-saqlash"><a class="header" href="#mos-keladigan-qatorlarni-saqlash">Mos keladigan qatorlarni saqlash</a></h4>
<p>Ushbu funksiyani tugatish uchun bizga qaytarmoqchi bo'lgan mos keladigan satrlarni saqlash metodi kerak. Buning uchun biz <code>for</code> siklidan oldin o'zgaruvchan vector yasashimiz va vectorda <code>line</code>ni saqlash uchun <code>push</code> metodini chaqirishimiz mumkin. <code>for</code> siklidan so'ng, 12-19 ro'yxatda ko'rsatilganidek, vectorni qaytaramiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn qidiruv&lt;'a&gt;(sorov: &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut natijalar = Vec::new();

    for line in tarkib.lines() {
        if line.contains(sorov) {
            natijalar.push(line);
        }
    }

    natijalar
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn birinchi_natija() {
</span><span class="boring">        let sorov = &quot;marali&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 12-19: Biz ularni qaytarishimiz uchun mos keladigan satrlarni saqlash</span></p>
<p>Endi <code>qidiruv</code> funksiyasi faqat <code>sorov</code> ni o'z ichiga olgan qatorlarni qaytarishi kerak va bizning testimiz o'tishi kerak. Keling, testni bajaramiz:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.37s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::birinchi_natija ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-54f36c611e701f9d)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Testimiz muvaffaqiyatli o'tdi, shuning uchun u ishlayotganini bilamiz!</p>
<p>Shu nuqtada, biz bir xil funksionallikni saqlab qolish uchun testlarni o'tkazgan holda qidiruv funksiyasini amalga oshirishni qayta tiklash imkoniyatlarini ko'rib chiqishimiz mumkin. Qidiruv funksiyasidagi kod juda yomon emas, lekin u iteratorlarning ba'zi foydali xususiyatlaridan foydalanmaydi. Biz <a href="ch13-02-iterators.html">13-bobda</a><!-- ignore --> ushbu misolga qaytamiz, u yerda iteratorlarni batafsil o'rganamiz va uni qanday yaxshilashni ko'rib chiqamiz.</p>
<h4 id="run-funksiyasidagi-qidiruv-funksiyasidan-foydalanish"><a class="header" href="#run-funksiyasidagi-qidiruv-funksiyasidan-foydalanish"><code>run</code> funksiyasidagi <code>qidiruv</code> funksiyasidan foydalanish</a></h4>
<p>Endi <code>qidiruv</code> funksiyasi ishlayotgan va testdan o‚Äòtgan bo‚Äòlsa, <code>run</code> funksiyamizdan <code>qidiruv</code> ni chaqirishimiz kerak. Biz <code>config.sorov</code> qiymatini va fayldan o'qiydigan <code>tarkib</code>-ni  <code>qidiruv</code> funksiyasiga o'tkazishimiz kerak. Keyin <code>run</code> <code>qidiruv</code>dan qaytarilgan har bir qatorni chop etadi:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let tarkib = fs::read_to_string(config.fayl_yoli)?;

    for line in qidiruv(&amp;config.sorov, &amp;tarkib) {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn qidiruv&lt;'a&gt;(sorov: &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut natijalar = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in tarkib.lines() {
</span><span class="boring">        if line.contains(sorov) {
</span><span class="boring">            natijalar.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    natijalar
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn birinchi_natija() {
</span><span class="boring">        let sorov = &quot;marali&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Biz <code>qidiruv</code> dan har bir qatorni qaytarish va uni chop etish uchun <code>for</code> siklidan foydalanmoqdamiz.</p>
<p>Endi butun dastur ishlashi kerak! Keling, buni sinab ko'raylik, avval Olma she'ridagi &quot;karnay&quot; ning aynan bir satrini qaytarishi kerak bo'lgan so'z bilan:</p>
<pre><code class="language-console">$ cargo run -- karnay olma.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/minigrep karnay olma.txt`
Ishtahang bo'lsin karnay
</code></pre>
<p>Ajoyib! Keling, bir nechta qatorga mos keladigan so'zni sinab ko'raylik, masalan, &quot;olma&quot;:</p>
<pre><code class="language-console">$ cargo run -- olma olma.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep olma olma.txt`
Tanishaylik, men - olma,
Nomimga quloq solma.
Men sizlarni olmangiz,
Xomligimda olmangiz!
Voy qornim deb qolmangiz!
</code></pre>
<p>Va nihoyat, she‚Äôrning hech bir joyida bo‚Äòlmagan so‚Äòzni izlaganimizda, masalan, ‚Äúmashina‚Äù kabi satrlar chiqmasligiga ishonch hosil qilaylik:</p>
<pre><code class="language-console">$ cargo run -- mashina olma.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/minigrep mashina olma.txt`

</code></pre>
<p>Ajoyib! Biz klassik dasturning o'z mini versiyasini yaratdik va ilovalarni qanday tuzish haqida ko'p narsalarni o'rgandik. Shuningdek, biz faylni kiritish(input) va chiqarish(output), lifetime, test va buyruq satrini tahlil qilish haqida bir oz o'rgandik.</p>
<p>Ushbu loyihani yakunlash uchun biz atrof-muhit(environment) o'zgaruvchilari bilan qanday ishlashni va standart xatoga qanday chop etishni qisqacha ko'rsatamiz, bu ikkalasi ham buyruq qatori dasturlarini yozishda foydalidir..</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="environmentatrof-muhit-ozgaruvchilari-bilan-ishlash"><a class="header" href="#environmentatrof-muhit-ozgaruvchilari-bilan-ishlash">Environment(atrof-muhit) o'zgaruvchilari bilan ishlash</a></h2>
<p>Biz <code>minigrep</code>ni qo‚Äòshimcha xususiyatni qo‚Äòshish orqali yaxshilaymiz: foydalanuvchi environment orqali yoqishi mumkin bo‚Äòlgan katta-kichik harflarni hisobga olmay qidirish imkoniyati.Biz bu xususiyatni buyruq qatori opsiyasiga aylantirishimiz va foydalanuvchilar uni har safar qo‚Äòllashni xohlaganlarida kiritishlarini talab qilishimiz mumkin, lekin buning o ªrniga uni environment qilib, biz foydalanuvchilarga environmentni bir marta o ªrnatish va barcha qidiruvlarini terminal sessiyasida katta-kichik harflarga sezgir bo ªlmasligiga ruxsat beramiz.</p>
<h3 id="katta-kichik-harflarni-sezmaydigan-qidiruv-funksiyasi-uchun-muvaffaqiyatsiz-test-yozish"><a class="header" href="#katta-kichik-harflarni-sezmaydigan-qidiruv-funksiyasi-uchun-muvaffaqiyatsiz-test-yozish">Katta-kichik harflarni sezmaydigan <code>qidiruv</code> funksiyasi uchun muvaffaqiyatsiz test yozish</a></h3>
<p>Biz birinchi navbatda yangi <code>harflarga_etiborsiz_qidirish</code> funksiyasini qo'shamiz, u muhit o'zgaruvchisi qiymatga ega bo'lganda chaqiriladi. Biz TDD jarayonini kuzatishda davom etamiz, shuning uchun birinchi qadam yana muvaffaqiyatsiz testni yozishdir.  Biz yangi <code>harflarga_etiborsiz_qidirish</code> funksiyasi uchun yangi test qo‚Äòshamiz va 12-20 ro‚Äòyxatda ko‚Äòrsatilganidek, ikkita test o‚Äòrtasidagi farqlarni aniqlashtirish uchun eski testimiz nomini <code>birinchi_natija</code> <code>harflarga_etiborli</code>ga o‚Äòzgartiramiz.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov : String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov  = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov , fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    for line in qidiruv(&amp;config.sorov , &amp;tarkib) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn qidiruv&lt;'a&gt;(sorov : &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut natijalar = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in tarkib.lines() {
</span><span class="boring">        if line.contains(sorov ) {
</span><span class="boring">            natijalar.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    natijalar
</span><span class="boring">}
</span><span class="boring">
</span>
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn harflarga_etiborli() {
        let sorov  = &quot;marali&quot;;
        let tarkib = &quot;\
Rust:
xavfsiz, tez, samarali.
Uchtasini tanlang.
Duct tape.&quot;;

        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov , tarkib));
    }

    #[test]
    fn harflarga_etiborsiz() {
        let sorov  = &quot;rUsT&quot;;
        let tarkib = &quot;\
Rust:
xavfsiz, tez, samarali.
Uchtasini tanlang.
Menga ishoning.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Menga ishoning.&quot;],
            harflarga_etiborsiz_qidirish(sorov , tarkib)
        );
    }
}</code></pre>
<p><span class="caption">Ro'yxat 12-20: Biz qo'shmoqchi bo'lgan katta-kichik harflarni sezgir bo'lmagan funksiya uchun yangi muvaffaqiyatsiz test qo'shish</span></p>
<p>Note that we‚Äôve edited the old test‚Äôs <code>contents</code> too. We‚Äôve added a new line
with the text <code>&quot;Duct tape.&quot;</code> using a capital D that shouldn‚Äôt match the query
<code>&quot;duct&quot;</code> when we‚Äôre searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don‚Äôt accidentally break the case-sensitive
search functionality that we‚Äôve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.</p>
<p>The new test for the case-<em>insensitive</em> search uses <code>&quot;rUsT&quot;</code> as its query. In
the <code>search_case_insensitive</code> function we‚Äôre about to add, the query <code>&quot;rUsT&quot;</code>
should match the line containing <code>&quot;Rust:&quot;</code> with a capital R and match the line
<code>&quot;Trust me.&quot;</code> even though both have different casing from the query. This is
our failing test, and it will fail to compile because we haven‚Äôt yet defined
the <code>search_case_insensitive</code> function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the <code>search</code> function in Listing 12-16 to see the test compile and fail.</p>
<h3 id="implementing-the-search_case_insensitive-function"><a class="header" href="#implementing-the-search_case_insensitive-function">Implementing the <code>search_case_insensitive</code> Function</a></h3>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost
the same as the <code>search</code> function. The only difference is that we‚Äôll lowercase
the <code>query</code> and each <code>line</code> so whatever the case of the input arguments,
they‚Äôll be the same case when we check whether the line contains the query.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-21: Defining the <code>search_case_insensitive</code>
function to lowercase the query and the line before comparing them</span></p>
<p>First, we lowercase the <code>query</code> string and store it in a shadowed variable with
the same name. Calling <code>to_lowercase</code> on the query is necessary so no
matter whether the user‚Äôs query is <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, or <code>&quot;rUsT&quot;</code>,
we‚Äôll treat the query as if it were <code>&quot;rust&quot;</code> and be insensitive to the case.
While <code>to_lowercase</code> will handle basic Unicode, it won‚Äôt be 100% accurate. If
we were writing a real application, we‚Äôd want to do a bit more work here, but
this section is about environment variables, not Unicode, so we‚Äôll leave it at
that here.</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice, because calling
<code>to_lowercase</code> creates new data rather than referencing existing data. Say the
query is <code>&quot;rUsT&quot;</code>, as an example: that string slice doesn‚Äôt contain a lowercase
<code>u</code> or <code>t</code> for us to use, so we have to allocate a new <code>String</code> containing
<code>&quot;rust&quot;</code>. When we pass <code>query</code> as an argument to the <code>contains</code> method now, we
need to add an ampersand because the signature of <code>contains</code> is defined to take
a string slice.</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> to lowercase all
characters. Now that we‚Äôve converted <code>line</code> and <code>query</code> to lowercase, we‚Äôll
find matches no matter what the case of the query is.</p>
<p>Let‚Äôs see if this implementation passes the tests:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Great! They passed. Now, let‚Äôs call the new <code>search_case_insensitive</code> function
from the <code>run</code> function. First, we‚Äôll add a configuration option to the
<code>Config</code> struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors because we aren‚Äôt initializing
this field anywhere yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We added the <code>ignore_case</code> field that holds a Boolean. Next, we need the <code>run</code>
function to check the <code>ignore_case</code> field‚Äôs value and use that to decide
whether to call the <code>search</code> function or the <code>search_case_insensitive</code>
function, as shown in Listing 12-22. This still won‚Äôt compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-22: Calling either <code>search</code> or
<code>search_case_insensitive</code> based on the value in <code>config.ignore_case</code></span></p>
<p>Finally, we need to check for the environment variable. The functions for
working with environment variables are in the <code>env</code> module in the standard
library, so we bring that module into scope at the top of <em>src/lib.rs</em>. Then
we‚Äôll use the <code>var</code> function from the <code>env</code> module to check to see if any value
has been set for an environment variable named <code>IGNORE_CASE</code>, as shown in
Listing 12-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 12-23: Checking for any value in an environment
variable named <code>IGNORE_CASE</code></span></p>
<p>Here, we create a new variable <code>ignore_case</code>. To set its value, we call the
<code>env::var</code> function and pass it the name of the <code>IGNORE_CASE</code> environment
variable. The <code>env::var</code> function returns a <code>Result</code> that will be the
successful <code>Ok</code> variant that contains the value of the environment variable if
the environment variable is set to any value. It will return the <code>Err</code> variant
if the environment variable is not set.</p>
<p>We‚Äôre using the <code>is_ok</code> method on the <code>Result</code> to check whether the environment
variable is set, which means the program should do a case-insensitive search.
If the <code>IGNORE_CASE</code> environment variable isn‚Äôt set to anything, <code>is_ok</code> will
return false and the program will perform a case-sensitive search. We don‚Äôt
care about the <em>value</em> of the environment variable, just whether it‚Äôs set or
unset, so we‚Äôre checking <code>is_ok</code> rather than using <code>unwrap</code>, <code>expect</code>, or any
of the other methods we‚Äôve seen on <code>Result</code>.</p>
<p>We pass the value in the <code>ignore_case</code> variable to the <code>Config</code> instance so the
<code>run</code> function can read that value and decide whether to call
<code>search_case_insensitive</code> or <code>search</code>, as we implemented in Listing 12-22.</p>
<p>Let‚Äôs give it a try! First, we‚Äôll run our program without the environment
variable set and with the query <code>to</code>, which should match any line that contains
the word ‚Äúto‚Äù in all lowercase:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now, let‚Äôs run the program with <code>IGNORE_CASE</code>
set to <code>1</code> but with the same query <code>to</code>.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>If you‚Äôre using PowerShell, you will need to set the environment variable and
run the program as separate commands:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>This will make <code>IGNORE_CASE</code> persist for the remainder of your shell
session. It can be unset with the <code>Remove-Item</code> cmdlet:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>We should get lines that contain ‚Äúto‚Äù that might have uppercase letters:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excellent, we also got lines containing ‚ÄúTo‚Äù! Our <code>minigrep</code> program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.</p>
<p>Some programs allow arguments <em>and</em> environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case sensitivity
through either a command line argument or an environment variable. Decide
whether the command line argument or the environment variable should take
precedence if the program is run with one set to case sensitive and one set to
ignore case.</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="xato-xabarlarini-standart-chiqish-oqimi-orniga-xato-oqimiga-yozish"><a class="header" href="#xato-xabarlarini-standart-chiqish-oqimi-orniga-xato-oqimiga-yozish">Xato xabarlarini standart chiqish oqimi o'rniga xato oqimiga yozish</a></h2>
<p>Ayni paytda biz <code>println!</code> funksiyasidan foydalangan holda terminalga barcha 
chiqishlarimizni yozib olamiz. Ko'pgina terminallarda ikkita chiqish turi 
mavjud: umumiy ma'lumot uchun standart chiqish oqimi ( <code>stdout</code> ) 
va xato xabarlari uchun standart xato oqimi (<code>stderr</code>).
Ushbu farq foydalanuvchilarga dasturning muvaffaqiyatli chiqishini faylga yo'naltirishni 
tanlashga imkon beradi, ammo shu bilan birga xato 
xabarlarini ekranga chiqaradi.</p>
<p><code>println!</code> funktsiyasi (makrosi) faqat standart chiqishda chop etish mumkin,
shuning uchun biz standart xatolar oqimiga chop etish uchun boshqa misollarda 
ko'rib chiqaylik.</p>
<h3 id="xatolar-yozilgan-joyni-tekshirish"><a class="header" href="#xatolar-yozilgan-joyni-tekshirish">Xatolar yozilgan joyni tekshirish</a></h3>
<p>Birinchidan, keling, <code>minigrep</code>-dan chop etilgan kontent hozirda standart chiqishga
qanday yozilishini, shu jumladan biz standart xato oqimiga yozmoqchi bo'lgan har qanday
xato xabarlarini ko'rib chiqaylik. Biz buni standart chiqish oqimini faylga yo'naltirish
va ataylab xatoga yo'l qo'yish orqali qilamiz. Biz standart xatolar oqimiga yo'naltirmaganimiz uchun,
standart xatolar oqimiga yuborilgan har qanday tarkib ekranda paydo bo'lishda davom etadi.</p>
<p>Buyruq qatorining (cmd) dasturlari xato xabarlarini standart xato oqimiga yuborishi kutilmoqda,
shuning uchun biz standart chiqish oqimini faylga yo'naltirsak ham, ekrandagi xato xabarlarini
ko'rishimiz mumkin. Bizning dasturimiz hozirda to'g'ri ishlamayapti:
biz xato xabari chiqishini faylga saqlayotganini ko'ramiz.</p>
<p>Ushbu xatti-harakatni namoyish qilish uchun biz dasturni <code>&gt;</code> va <em>output.txt</em> fayl nomi
bilan ishga tushiramiz. Biz standart chiqish oqimini yo'naltirishni xohlaymiz.
Biz hech qanday dalil (argument) keltirmaymiz, bu xatoga olib kelishi kerak:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p><code>&gt;</code> sintaksisi qobiqqa (shellga) <em>output.txt</em>-ga ekran o'rniga standart chiqish (standard output) tarkibini yozishni buyuradi.
Biz ekranda ko'rishni kutgan xato xabarini ko'rmadik, shuning uchun u faylda bo'lishi kerak.
Yuqorida keltirilgan <em>output.txt</em>-ning holati:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Ha, bizning xato xabarimiz standart chiqishda (standard outputga) ko'rsatiladi. 
Bunday xato xabarlarini standart xatolar oqimiga kiritish ancha foydali,
shuning uchun faqat muvaffaqiyatli ishga tushirish ma'lumotlari faylga kiradi.
Biz buni keyinchalik o'zgartiramiz.</p>
<h3 id="xatolarni-standard-xato-oqimiga-chop-etish-print-qilish"><a class="header" href="#xatolarni-standard-xato-oqimiga-chop-etish-print-qilish">Xatolarni standard xato oqimiga chop etish (print qilish)</a></h3>
<p>Xato xabarlarini chiqarish usulini o'zgartirish uchun biz 12-24-ro'yxatdagi koddan 
foydalanamiz. Ushbu bobda ilgari qilgan refaktoring tufayli xato xabarlarini chop
etadigan barcha kodlar bitta <code>main</code> funktsiyada joylashgan. Rust standart kutubxonasi <code>eprintln!</code> makrosini
taqdim etadi va bu makro standart xato oqimiga kiradi, shuning uchun <code>println!</code> bilan chaqirilgan joyda,
keling uning o'rniga <code>eprintln!</code> makrosini ishlatamiz.</p>
<p><span class="filename">Fayl: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {e}&quot;);
        process::exit(1);
    }
}</code></pre>
<p><span class="caption">Ro'yxat 12-24: <code>println!</code> yordamida Standard Output o'rniga Standard Error - da xato xabarlarini yozish!</span></p>
<p>Keling, dasturni xuddi shu tarzda, hech qanday dalilsiz (argumentsiz) qayta ishga
tushiramiz va standart chiqishni (outputni) <code>&gt;</code> bilan qayta yo'naltiramiz:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Endi biz ekranda xatoni ko'rishimiz mumkin va <em>output.txt</em> esa bo'sh.
Bu esa aynan buyruq qatoridan (cmd-dan) biz kutgan holat.</p>
<p>Keling, dasturni xatoga olib kelmaydigan argumentlar bilan qayta ishga tushiramiz,
ammo baribir standart chiqish faylga yo'naltiradi, misol:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>Biz terminalga hech qanday chiqishni ko'rmaymiz. Va <em>output.txt</em> esa
quydagi natijalarni o'z ichiga oladi:</p>
<p><span class="filename">Fayl: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Yani, biz vaziyatga qarab, muvaffaqiyatli chiqish (output) uchun 
standart chiqish oqimidan va xatolarni chiqarish uchun standart xato oqimidan foydalanamiz.</p>
<h2 id="xulosa-11"><a class="header" href="#xulosa-11">Xulosa</a></h2>
<p>Ushbu bobda siz hozirgacha o'rgangan ba'zi asosiy tushunchalar takrorlangan va 
Rustda muntazam I/O operatsiyalarini qanday bajarish kerakligi aytilgan.
Buyruq qatori argumentlari (command line argumentlari), fayllar,
atrof-muhit o'zgaruvchilari va <code>println!</code> makrosi yordamida xatolarni
ishlatgan holda, endi siz buyruq qatori (CLI) dasturlarini yozishga tayyormiz.
Oldingi boblardagi tushunchalar bilan birgalikda sizning kodingiz yaxshi tartibga solinadi,
ma'lumotlarni tegishli tuzilmalarda samarali saqlaydi, xatolarni yaxshi qayta ishlaydi va yaxshi
sinovdan o'tkaziladi.</p>
<p>Keyinchalik, biz funktsional tillar ta'sirida bo'lgan Rust-ning
ba'zi xususiyatlarini ko'rib chiqamiz: yopilishlar (closures) va iteratorlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funksional-til-xususiyatlari-iteratorlar-va-closurelar"><a class="header" href="#funksional-til-xususiyatlari-iteratorlar-va-closurelar">Funksional til xususiyatlari: iteratorlar va closurelar</a></h1>
<p>Rust dizayni ko'plab mavjud tillar va texnikalardan ilhomlangan va muhim ta'sirlardan biri <em>funksional dasturlash</em>.
Funksional uslubda dasturlash ko'pincha funksiyalarni argumentlar orqali uzatish, ularni boshqa funksiyalardan qaytarish, keyinchalik bajarish uchun o'zgaruvchilarga tayinlash va hokazolar orqali qiymat sifatida foydalanishni o'z ichiga oladi.</p>
<p>Ushbu bobda biz funksional dasturlash nima yoki yo'qligi masalasini muhokama qilmaymiz, aksincha, Rustning ko'p tillardagi funksiyalarga o'xshash ba'zi xususiyatlarini muhokama qilamiz.</p>
<p>Aniqroq aytganda, biz quyidagilarni ko'rib chiqamiz:</p>
<ul>
<li><em>Closurelar</em>, o ªzgaruvchida saqlashingiz mumkin bo ªlgan funksiyaga o ªxshash konstruksiya</li>
<li><em>Iteratorlar</em>, bir qator elementlarni qayta ishlash usuli</li>
<li>12-bobdagi I/O loyihasini yaxshilash uchun closure va iteratorlardan qanday foydalanish kerak</li>
<li>Closure va iteratorlarning ishlashi (Spoiler ogohlantirishi: ular siz o'ylagandan ham tezroq!)</li>
</ul>
<p>Biz allaqachon Rustning boshqa ba'zi xususiyatlarini ko'rib chiqdik, masalan, pattern matching va enumlar, ular ham funksional uslubga ta'sir qiladi. Closure va iteratorlarni o'zlashtirish idiomatik, tezkor Rust kodini yozishning muhim qismi bo'lganligi sababli, biz ushbu bobni ularga bag'ishlaymiz.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="closurelar-environmentni-qamrab-oladigan-anonim-funksiyalar"><a class="header" href="#closurelar-environmentni-qamrab-oladigan-anonim-funksiyalar">Closurelar: Environmentni qamrab oladigan anonim funksiyalar</a></h2>
<p>Rustning closureri - bu o'zgaruvchida saqlashingiz yoki boshqa funksiyalarga argument sifatida o'tishingiz mumkin bo'lgan anonim funktsiyalar. Closureni bir joyda yaratishingiz va keyin uni boshqa kontekstda baholash uchun boshqa joyga murojaat qilishingiz mumkin. Funksiyalardan farqli o'laroq, closurelar ular belgilangan doiradagi qiymatlarni olishlari mumkin.
Ushbu closure xususiyatlari kodni qayta ishlatish va xatti-harakatlarni moslashtirishga(behavior customization) qanday imkon berishini ko'rsatamiz.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="environmentni-closurelar-bilan-qolga-olish"><a class="header" href="#environmentni-closurelar-bilan-qolga-olish">Environmentni closurelar bilan qo'lga olish</a></h3>
<p>Avvalo, keyinchalik foydalanish uchun ular belgilangan muhitdan(environment) qiymatlarni olish uchun closurelardan qanday foydalanishimiz mumkinligini ko'rib chiqamiz.Bu senariy: Ko'pincha bizning futbolka kompaniyamiz reklama ro'yxatidagi kimgadir eksklyuziv, cheklangan nashrdagi futbolkani sovg'a sifatida taqdim etadi. Pochta ro'yxatidagi odamlar ixtiyoriy ravishda o'z profillariga sevimli ranglarini qo'shishlari mumkin. Agar bepul futbolka uchun tanlangan kishi o'zining sevimli ranglar to'plamiga ega bo'lsa, u rangdagi futbolkani oladi. Agar biror kishi sevimli rangni ko'rsatmagan bo'lsa, u kompaniyada eng ko'p bo'lgan rangni oladi.</p>
<p>Buni amalga oshirishning ko'plab usullari mavjud. Ushbu misol uchun biz <code>Qizil</code> va <code>Moviy</code> variantlariga ega <code>FutbolkaRangi</code> nomli enumdan foydalanamiz (oddiylik uchun mavjud ranglar sonini cheklaydi). Biz kompaniya inventarini <code>Inventarizatsiya</code> strukturasi bilan ifodalaymiz, unda <code>futbolkalar</code> deb nomlangan maydon mavjud bo‚Äòlib, unda hozirda mavjud bo‚Äòlgan futbolka ranglarini ifodalovchi <code>Vec&lt;FutbolkaRangi&gt;</code> mavjud.
<code>Inventarizatsiya</code> da belgilangan <code>yutuq</code> metodi bepul futbolka g‚Äòolibining ixtiyoriy futbolka rangini afzal ko‚Äòradi va odam oladigan futbolka rangini qaytaradi. Ushbu sozlash 13-1 ro'yxatda ko'rsatilgan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum FutbolkaRangi {
    Qizil,
    Moviy,
}

struct Inventarizatsiya {
    futbolkalar: Vec&lt;FutbolkaRangi&gt;,
}

impl Inventarizatsiya {
    fn yutuq(&amp;self, foydalanuvchi_afzalligi: Option&lt;FutbolkaRangi&gt;) -&gt; FutbolkaRangi {
        foydalanuvchi_afzalligi.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; FutbolkaRangi {
        let mut qizil_raqam = 0;
        let mut moviy_raqam = 0;

        for rang in &amp;self.futbolkalar {
            match rang {
                FutbolkaRangi::Qizil =&gt; qizil_raqam += 1,
                FutbolkaRangi::Moviy =&gt; moviy_raqam += 1,
            }
        }
        if qizil_raqam &gt; moviy_raqam {
            FutbolkaRangi::Qizil
        } else {
            FutbolkaRangi::Moviy
        }
    }
}

fn main() {
    let store = Inventarizatsiya {
        futbolkalar: vec![FutbolkaRangi::Moviy, FutbolkaRangi::Qizil, FutbolkaRangi::Moviy],
    };

    let user_pref1 = Some(FutbolkaRangi::Qizil);
    let yutuq1 = store.yutuq(user_pref1);
    println!(
        &quot;{:?} afzalligi bilan foydalanuvchi {:?} oladi&quot;,
        user_pref1, yutuq1
    );

    let user_pref2 = None;
    let yutuq2 = store.yutuq(user_pref2);
    println!(
        &quot;{:?} afzalligi bilan foydalanuvchi {:?} oladi&quot;,
        user_pref2, yutuq2
    );
}</code></pre>
<p><span class="caption">Ro'yxat 13-1: Futbolka kompaniyasining sovg'a holati</span></p>
<p><code>main</code> bo ªlimida belgilangan <code>dokon</code> ikkita moviy futbolka va bitta qizil futbolka qolgan. Qizil ko'ylakni afzal ko'rgan foydalanuvchi va hech qanday imtiyozsiz foydalanuvchi uchun <code>yutuq</code> metodini chaqiramiz.</p>
<p>Shunga qaramay, ushbu kod ko'p jihatdan amalga oshirilishi mumkin va bu yerda, closurelarga e'tibor qaratish uchun biz siz allaqachon o'rgangan tushunchalarga yopishib oldik, closuredan foydalanadigan <code>yutuq</code> metodidan tashqari. <code>yutuq</code> metodida biz <code>Option&lt;FutbolkaRangi&gt;</code> turidagi parametr sifatida foydalanuvchi imtiyozini olamiz va <code>foydalanuvchi_afzalligi</code> da <code>unwrap_or_else</code> metodini chaqiramiz. <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>Option&lt;T&gt;</code> da <code>unwrap_or_else</code></a><!-- ignore --> metodi standart kutubxona tomonidan aniqlanadi. Buning uchun bitta argument kerak bo‚Äòladi: <code>T</code> qiymatini qaytaruvchi hech qanday argumentsiz closure (<code>Option&lt;T&gt;</code> enumning <code>Some</code> variantida, bizning holatimizda <code>FutbolkaRangi</code>da tugaydigan qiymat turiga aylantiriladi). Agar <code>Option&lt;T&gt;</code> <code>Some</code> varianti bo'lsa, <code>unwrap_or_else</code> qiymatini <code>Some</code> ichidan qaytaradi. Agar <code>Option&lt;T&gt;</code> <code>None</code> varianti bo'lsa, <code>unwrap_or_else</code> closureni chaqiradi va closure orqali qaytarilgan qiymatni qaytaradi.</p>
<p>Biz closure ifodasini belgilaymiz <code>|| self.most_stocked()</code>ni <code>unwrap_or_else</code> argumenti sifatida. Bu hech qanday parametrlarni o'zi qabul qilmaydigan closuredir (agar closure parametrlari bo'lsa, ular ikkita vertikal chiziq orasida paydo bo'ladi). Closurening asosiy qismi <code>self.most_stocked()</code> ni chaqiradi. Biz bu yerda closureni aniqlayapmiz va <code>unwrap_or_else</code> ni amalga oshirish, agar natija kerak bo‚Äòlsa, keyinroq closureni baholaydi.</p>
<p>Ushbu kodni ishga tushirsak quyidagi natijani chop etadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>Qiziqarli tomoni shundaki, biz joriy <code>Inventarizatsiya</code> misolida <code>self.most_stocked()</code> deb nomlanuvchi closuredan o‚Äòtdik. Standart kutubxona biz belgilagan <code>Inventarizatsiya</code> yoki <code>FutbolkaRangi</code> turlari yoki biz ushbu senariyda foydalanmoqchi bo'lgan mantiq haqida hech narsa bilishi shart emas edi. Closure <code>self</code>  <code>Inventarizatsiya</code> misoliga o'zgarmas(immutable) referenceni oladi va uni biz belgilagan kod bilan <code>unwrap_or_else</code> metodiga uzatadi. Funksiyalar esa o'z muhitini(environmentini) shu tarzda ushlab tura olmaydi.</p>
<h3 id="closure-typi-inference-va-annotation"><a class="header" href="#closure-typi-inference-va-annotation">Closure typi Inference va Annotation</a></h3>
<p>Funksiyalar va closurelar o'rtasida ko'proq farqlar mavjud. Closurelar odatda parametrlar turlarini yoki <code>fn</code> funksiyalari kabi qaytarish qiymatini(return value) izohlashni talab qilmaydi. Funksiyalar uchun tur annotationlari talab qilinadi, chunki turlar foydalanuvchilarga ochiq interfeysning bir qismidir. Ushbu interfeysni qat'iy belgilash, har bir kishi funksiya qanday turdagi qiymatlardan foydalanishi va qaytarishi(return) haqida kelishib olishini ta'minlash uchun muhimdir. Boshqa tomondan, closurelar bu kabi ochiq interfeysda ishlatilmaydi: ular o'zgaruvchilarda saqlanadi va ularni nomlamasdan va kutubxonamiz foydalanuvchilariga ko'rsatmasdan foydalaniladi.</p>
<p>Closurelar odatda qisqa va har qanday ixtiyoriy senariyda emas, faqat tor kontekstda tegishli. Ushbu cheklangan kontekstlarda kompilyator ko'pgina o'zgaruvchilarning turlarini qanday aniqlashga qodir bo'lganiga o'xshab, parametrlarning turlarini va qaytish turini taxmin qilishi mumkin (kompilyatorga closure turi annotationlari ham kerak bo'lgan kamdan-kam holatlar mavjud).</p>
<p>O'zgaruvchilarda bo'lgani kabi, agar biz aniqlik va ravshanlikni oshirishni xohlasak, zarur bo'lgandan ko'ra batafsilroq bo'lish uchun turdagi annotationlarni qo'shishimiz mumkin. Closure uchun turlarga izoh(annotation) qo'yish 13-2 ro'yxatda ko'rsatilgan definitionga o'xshaydi. Ushbu misolda biz closureni aniqlaymiz va uni 13-1 ro'yxatda bo'lgani kabi argument sifatida topshirgan joyda closureni belgilash o'rniga uni o'zgaruvchida saqlaymiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 13-2: Ixtiyoriy turdagi annotationlarni qo'shish
closureda parametr va qaytariladigan qiymat turlari</span></p>
<p>Turga annotationlar qo ªshilishi bilan closure sintaksisi funksiyalar sintaksisiga ko ªproq o ªxshaydi. Bu yerda biz taqqoslash uchun parametriga 1 qo'shadigan funksiyani va bir xil xatti-harakatlarga ega bo'lgan closureni aniqlaymiz. Tegishli qismlarni bir qatorga qo'yish uchun bir nechta bo'shliqlar qo'shdik. Bu pipelardan foydalanish va ixtiyoriy bo'lgan sintaksis miqdori bundan mustasno, closure sintaksisi funksiya sintaksisiga qanchalik o'xshashligini ko'rsatadi:</p>
<pre><code class="language-rust ignore">fn  bitta_v1_qoshish    (x: u32) -&gt; u32 { x + 1 }
let bitta_v2_qoshish =  |x: u32| -&gt; u32 { x + 1 };
let bitta_v3_qoshish =  |x|             { x + 1 };
let bitta_v4_qoshish =  |x|               x + 1  ;</code></pre>
<p>Birinchi qatorda funksiya ta ºrifi(definition), ikkinchi qatorda esa to ªliq izohlangan closure definitioni ko ªrsatilgan. Uchinchi qatorda biz closure definitiondan turdagi annotationlarni olib tashlaymiz. To'rtinchi qatorda biz qavslarni olib tashlaymiz, ular ixtiyoriy, chunki closure tanas(body) faqat bitta ifodaga(expression) ega. Bularning barchasi to'g'ri definitionlar bo'lib, ular chaqirilganda bir xil xatti-harakatlarni keltirib chiqaradi. <code>bitta_v3_qoshish</code> va <code>bitta_v4_qoshish</code> qatorlari kompilyatsiya qilish uchun closurelarni baholashni talab qiladi, chunki turlar ulardan foydalanishdan kelib chiqadi. Bu <code>let v = Vec::new();</code> ga o'xshash bo'lib, Rust turini aniqlay olishi uchun <code>Vec</code> ga turiga izohlar(annotation) yoki ba'zi turdagi qiymatlar kiritilishi kerak.</p>
<p>Closure definitionlari uchun kompilyator ularning har bir parametri va ularning qaytish(return) qiymati uchun bitta aniq turdagi xulosa chiqaradi. Masalan, 13-3 ro'yxatda parametr sifatida qabul qilingan qiymatni qaytaradigan qisqa closure definitioni ko'rsatilgan. Ushbu closure ushbu misol maqsadlaridan tashqari juda foydali emas. E'tibor bering, biz definitionga hech qanday annotation qo'shmaganmiz.
Hech qanday turdagi annotationlar mavjud emasligi sababli, biz bu yerda birinchi marta <code>String</code> bilan qilgan har qanday turdagi closureni chaqirishimiz mumkin. Agar biz <code>namuna_closure</code> ni butun(integer) son bilan chaqirishga harakat qilsak, xatoga yo'l qo'yamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let namuna_closure = |x| x;

    let s = namuna_closure(String::from(&quot;salom&quot;));
    let n = namuna_closure(5);
<span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 13-3: Ikki xil turga ega bo'lgan closureni chaqirishga urinish</span></p>
<p>Kompilyator bizga quyidagi xatoni beradi:</p>
<pre><code class="language-console">$ cargo run
   Compiling namuna_closure v0.1.0 (file:///projects/namuna_closure)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = namuna_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected struct `String`, found integer
  |             arguments to this function are incorrect
  |
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let namuna_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `namuna_closure` due to previous error
</code></pre>
<p>Birinchi marta <code>namuna_closure</code> <code>String</code> qiymati bilan chaqirilganda, kompilyator <code>x</code> turini va  closurening qaytish turini <code>String</code> deb hisoblaydi. Keyin bu turlar(type) <code>namuna_closure</code> bo'limida yopiladi va biz bir xil closure(yopilish) bilan boshqa turdan foydalanishga uringanimizda xatoga duch kelamiz.</p>
<h3 id="malumot-olish-yoki-egalikownership-huquqini-kochirish"><a class="header" href="#malumot-olish-yoki-egalikownership-huquqini-kochirish">Malumot olish yoki Egalik(Ownership) huquqini ko'chirish</a></h3>
<p>Closurelar o'z muhitidan qiymatlarni uchta usulda olishlari mumkin, ular to'g'ridan-to'g'ri funksiya parametr olishi mumkin bo'lgan uchta usulga mos keladi: immutably borrowing (o'zgarmas borrowing(qarz olish)), mutably borrowing (o'zgaruvchan borrowing(qarz olish)) va egalik qilish(ownership). Closure funksiya tanasi(body) olingan qiymatlar bilan nima qilishiga qarab ulardan qaysi birini ishlatishni hal qiladi.</p>
<p>13-4 ro'yxatda biz <code>list</code> deb nomlangan vectorga immutable(o'zgarmas) referencei qamrab oluvchi closureni aniqlaymiz, chunki u qiymatni chop etish uchun faqat immutable referencega muhtoj:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Closureni belgilashdan oldin: {:?}&quot;, list);

    let faqat_borrow = || println!(&quot;Closuredan: {:?}&quot;, list);

    println!(&quot;Closureni chaqirishdan oldin: {:?}&quot;, list);
    faqat_borrow();
    println!(&quot;Chaqirilgandan keyin closure: {:?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 13-4: Buni closureni aniqlash va chaqirish
immutable referenceni ushlaydi</span></p>
<p>Ushbu misol, shuningdek, o'zgaruvchining closure definitioniga bog'lanishi mumkinligini ko'rsatadi va biz keyinchalik o'zgaruvchi nomi va qavslar yordamida o'zgaruvchi nomi funksiya nomiga o'xshab yopishni chaqirishimiz mumkin.</p>
<p>Biz bir vaqtning o'zida bir nechta immutable(o'zgarmas) referencelarga ega bo'lishimiz mumkin bo'lgan <code>list</code> uchun, <code>list</code> closure definitionidan oldin, closure definitionidan keyin, lekin closure chaqirilishidan oldin va closure chaqirilgandan keyin hali ham koddan foydalanish mumkin. Ushbu kod kompilyatsiya bo'ladi, ishlaydi va chop etadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling namuna_closure v0.1.0 (file:///projects/namuna_closure)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/namuna_closure`
Closureni belgilashdan oldin: [1, 2, 3]
Closureni chaqirishdan oldin: [1, 2, 3]
Closuredan: [1, 2, 3]
Chaqirilgandan keyin closure: [1, 2, 3]
</code></pre>
<p>Keyinchalik, 13-5 ro'yxatda biz closure bodysini <code>list</code> vectoriga element qo'shishi uchun o'zgartiramiz. Closure endi mutable(o'zgaruvchan) referenceni oladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Closureni aniqlashdan oldin: {:?}&quot;, list);

    let mut ozgaruvchan_borrow = || list.push(7);

    ozgaruvchan_borrow();
    println!(&quot;Chaqirilgandan keyin closure: {:?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 13-5: Mutable(o'zgaruvchan) referenceni ushlaydigan closureni aniqlash va chaqirish</span></p>
<p>Ushbu kod kompilyatsiya bo'ladi, ishlaydi va chop etadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling namuna_closure v0.1.0 (file:///projects/namuna_closure)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/namuna_closure`
Closureni aniqlashdan oldin: [1, 2, 3]
Chaqirilgandan keyin closure: [1, 2, 3, 7]
</code></pre>
<p>E'tibor bering, <code>ozgaruvchan_borrow</code> closurening ta'rifi(definition) va chaqiruvi o'rtasida endi <code>println!</code> belgisi yo'q: <code>ozgaruvchan_borrow</code> aniqlanganda, u <code>list</code>ga o'zgaruvchan(mutable) referenceni oladi. Closure chaqirilgandan keyin biz closureni qayta ishlatmaymiz, shuning uchun mutable borrow(o'zgaruvchan qarz) tugaydi. Closure definationi va closure chaqiruvi o'rtasida chop etish uchun immutable(o'zgarmas) borrowga ruxsat berilmaydi, chunki mutable borrow mavjud bo'lganda boshqa borrowlarga ruxsat berilmaydi. Qaysi xato xabari borligini bilish uchun u yerga <code>println!</code> qo'shib ko'ring!</p>
<p>Agar closurening asosiy qismi ownershipga(egalik) muhtoj bo'lmasa ham, uni environmentda foydalanadigan qiymatlarga ownershiplik qilishga harakat qilmoqchi bo'lsangiz, parametrlar ro'yxatidan oldin <code>move</code> kalit so'zidan foydalanishingiz mumkin.</p>
<p>Ushbu uslub asosan ma'lumotlarni yangi threadga tegishli bo'lishi uchun ko'chirish uchun yangi threadga closureni o'tkazishda foydalidir. Biz 16-bobda parallellik(concurrency) haqida gapirganda, thereadlarni va nima uchun ulardan foydalanishni xohlashingizni batafsil muhokama qilamiz, ammo hozircha <code>move</code> kalit so'ziga muhtoj bo'lgan closure yordamida yangi threadni yaratishni qisqacha ko'rib chiqamiz. 13-6 ro'yxat vektorni asosiy thredda emas, balki yangi threadda chop etish uchun o'zgartirilgan 13-4 ro'yxatini ko'rsatadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Closureni aniqlashdan oldin: {:?}&quot;, list);

    thread::spawn(move || println!(&quot;{:?} threaddan&quot;, list))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 13-6: <code>list</code>ga ownershiplik  qilish uchun threadni yopishni majburlash uchun <code>move</code> dan foydalanish</span></p>
<p>Biz argument sifatida ishlash uchun threadni yopish(closure) imkonini berib, yangi threadni yaratamiz. Closure tanasi(body) listni chop etadi. Ro ªyxat 13-4, closure faqat o ªzgarmas(immutable) reference yordamida <code>list</code>ni yozib oldi, chunki bu uni chop etish uchun zarur bo ªlgan <code>list</code>ga kirishning eng kam miqdori. Ushbu misolda, closure tanasi(body) hali ham faqat o'zgarmas(immutable) referencega muhtoj bo'lsa ham, biz closure definationing boshiga <code>move</code> kalit so'zini qo'yish orqali <code>list</code> closurega ko'chirilishi kerakligini ko'rsatishimiz kerak. Yangi thread asosiy threadning qolgan qismi tugashidan oldin tugashi yoki asosiy thread birinchi bo'lib tugashi mumkin. Agar asosiy thread <code>list</code>ga ownershiplikni saqlab qolgan bo ªlsa-da, lekin yangi thread paydo bo ªlishidan oldin tugasa va <code>list</code>ni tashlab qo ªysa, threaddagi immutable(o ªzgarmas) reference yaroqsiz bo ªladi. Shuning uchun, kompilyator <code>list</code>ni yangi threadga berilgan closurega ko'chirishni talab qiladi, shuning uchun reference haqiqiy bo'ladi. Kompilyatorda qanday xatolarga yo'l qo'yganingizni ko'rish uchun closure aniqlangandan so'ng, <code>move</code> kalit so'zini olib tashlang yoki asosiy threaddagi <code>list</code> dan foydalaning!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="qabul-qilingan-qiymatlarni-closuredan-va-fn-traitlaridan-kochirish"><a class="header" href="#qabul-qilingan-qiymatlarni-closuredan-va-fn-traitlaridan-kochirish">Qabul qilingan qiymatlarni closuredan va <code>Fn</code> traitlaridan ko'chirish</a></h3>
<p>Closure ma'lumotnomani qo'lga kiritgandan so'ng(shunday qilib, agar biror narsa bo'lsa, closurega ko'chirilgan narsaga ta'sir qiladi) yoki closure aniqlangan environmentdan qiymatga ownershiplikni qo'lga kiritgandan so'ng,(agar biror narsa bo'lsa, closuredan ko'chirilgan narsaga ta'sir qiladi) closurening asosiy qismidagi kod closure keyinroq baholanganda referencelar yoki qiymatlar bilan nima sodir bo'lishini belgilaydi. </p>
<p>Closure tanasi(body) quyidagilardan birini amalga oshirishi mumkin: olingan qiymatni closuredan tashqariga ko'chirish(move), olingan qiymatni mutatsiyalash, qiymatni ko'chirish yoki mutatsiyalash yoki boshlash uchun environmentdan hech narsa olmaslik.</p>
<p>Yopishning environmentdan handlelarni ushlash(capture) va boshqarish usuli closure implementlarining qaysi traitlariga ta'sir qiladi va traitlar funksiyalar va structlar qanday closure turlaridan foydalanishi mumkinligini ko'rsatishi mumkin. Closurelar ushbu <code>Fn</code> belgilarining bittasi, ikkitasi yoki uchtasini avtomatik ravishda qo'shimcha usulda, closure tanasi qiymatlarni(value) qanday boshqarishiga qarab implement qilinadi:</p>
<ol>
<li><code>FnOnce</code> bir marta chaqirilishi mumkin bo'lgan closurelar uchun amal qiladi. Barcha closurelar hech bo'lmaganda ushbu traitni amalga oshiradi(implement qiladi), chunki barcha closurelar chaqirilishi mumkin. Qabul qilingan qiymatlarni(value) tanasidan tashqariga ko'chiradigan closure faqat <code>FnOnce</code> ni implement qiladi va boshqa <code>Fn</code> traitlarining hech birini implement qilmaydi, chunki uni faqat bir marta chaqirish mumkin.</li>
<li><code>FnMut</code> qo'lga kiritilgan qiymatlarni(value) tanasidan tashqariga olib chiqmaydigan, lekin olingan qiymatlarni o'zgartirishi mumkin bo'lgan closurelarga nisbatan qo'llaniladi.Ushbu closurelarni bir necha marta chaqirish mumkin. </li>
<li><code>Fn</code> qo'lga kiritilgan qiymatlarni tanasidan tashqariga chiqarmaydigan va olingan qiymatlarni o'zgartirmaydigan closurelar, shuningdek, environmentdan hech narsani ushlab(capture) turmaydigan closurelar uchun amal qiladi. Ushbu closurelar environmentni o'zgartirmasdan bir necha marta chaqirilishi mumkin, bu bir vaqtning o'zida bir necha marta closureni chaqirish kabi holatlarda muhimdir.</li>
</ol>
<p>Keling, 13-1 ro'yxatda biz qo'llagan <code>Option&lt;T&gt;</code> bo'yicha <code>unwrap_or_else</code> metodining definitionini ko'rib chiqaylik:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Eslatib o ªtamiz, <code>T</code> <code>Option</code>ning <code>Some</code> variantidagi qiymat turini ifodalovchi umumiy turdir(generic type). Bu <code>T</code> turi, shuningdek, <code>unwrap_or_else</code> funksiyasining qaytish(return) turidir: masalan, <code>Option&lt;String&gt;</code>da <code>unwrap_or_else</code> ni chaqiruvchi kod, <code>String</code> oladi.</p>
<p>Keyin, <code>unwrap_or_else</code> funksiyasi qo'shimcha <code>F</code> umumiy turdagi parametrga ega ekanligiga e'tibor bering. <code>F</code> turi <code>f</code> nomli parametrning turi(type) bo'lib, biz <code>unwrap_or_else</code> ga chaqiruv(call) qilganimizda ta`minlovchi closuredir.</p>
<p>Generic <code>F</code> turida belgilangan belgi <code>FnOnce() -&gt; T</code> bo'lib, bu <code>F</code> bir marta chaqirilishi, hech qanday argumentga ega bo'lmasligi va <code>T</code> qaytarilishini bildiradi. Trait bound-da <code>FnOnce</code> dan foydalanish <code>unwrap_or_else</code> faqat bir marta <code>f</code> ni chaqirishi mumkin bo'lgan cheklovni ifodalaydi. <code>unwrap_or_else</code> matnida biz <code>Option</code> <code>Some</code> bo‚Äòlsa, <code>f</code> chaqirilmasligini ko‚Äòrishimiz mumkin. Agar <code>Option</code> <code>None</code> bo'lsa, <code>f</code> bir marta chaqiriladi. Barcha closurelar <code>FnOnce</code> ni implement qilganligi sababli, <code>unwrap_or_else</code> eng har xil turdagi closurelarni qabul qiladi va imkon qadar moslashuvchan.</p>
<blockquote>
<p>Eslatma: Funksiyalar uchta <code>Fn</code> traitlarini ham implement qilishi mumkin. Agar biz
qilmoqchi bo'lgan narsa environmentdan qiymat olishni(*capture value) talab qilmasa,
biz <code>Fn</code> traitlaridan birini implement qiladigan narsa kerak bo'lganda closure o'rniga
funksiya nomidan foydalanishimiz mumkin. Masalan, <code>Option&lt;Vec&lt;T&gt;&gt;</code> qiymatida,
agar qiymat <code>None</code> bo'lsa, yangi, bo'sh vektorni olish uchun <code>unwrap_or_else(Vec::new)</code> ni
chaqirishimiz mumkin.</p>
</blockquote>
<p>Endi keling, slicelarda aniqlangan standart kutubxona metodini ko‚Äòrib chiqamiz, bu <code>unwrap_or_else</code>dan qanday farq qilishini va nima uchun  <code>sort_by_key</code> trait bound uchun <code>FnOnce</code> o‚Äòrniga <code>FnMut</code> dan foydalanishini ko‚Äòraylik. Closure ko'rib chiqilayotgan qismdagi joriy elementga reference ko'rinishida bitta argument oladi va order qilinishi mumkin bo'lgan <code>K</code> turidagi qiymatni qaytaradi. Ushbu funksiya har bir elementning ma'lum bir atributi bo'yicha sliceni saralashni xohlaganingizda foydalidir. 13-7 ro'yxatda bizda <code>Kvadrat</code> misollar listi mavjud va biz ularni <code>kenglik</code> atributi bo'yicha pastdan yuqoriga tartiblash uchun <code>sort_by_key</code> dan foydalanamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Kvatrat {
    kengligi: u32,
    balandligi: u32,
}

fn main() {
    let mut list = [
        Kvatrat { kengligi: 10, balandligi: 1 },
        Kvatrat { kengligi: 3, balandligi: 5 },
        Kvatrat { kengligi: 7, balandligi: 12 },
    ];

    list.sort_by_key(|r| r.kengligi);
    println!(&quot;{:#?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 13-7: Kvadratlarlarni kengligi bo'yicha tartiblash uchun <code>sort_by_key</code> dan foydalaning</span></p>
<p>Ushbu kod quyidagi natijani chop etadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling Kvadrats v0.1.0 (file:///projects/Kvadrats)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/Kvadratlar`
[
    Kvadrat {
        kengligi: 3,
        balandligi: 5,
    },
    Kvadrat {
        kengligi: 7,
        balandligi: 12,
    },
    Kvadrat {
        kengligi: 10,
        balandligi: 1,
    },
]
</code></pre>
<p><code>sort_by_key</code> <code>FnMut</code> closureni olish uchun aniqlanganining sababi shundaki, u closureni bir necha marta chaqiradi: slicedagi har bir element uchun bir marta. <code>|r| r.kengligi</code> o'z environmentidan hech narsani ushlamaydi(capture), mutatsiyaga uchramaydi yoki boshqa joyga ko'chirmaydi, shuning uchun u trait bound bo'lgan talablarga javob beradi.</p>
<p>Bundan farqli o'laroq, 13-8 ro'yxat faqat <code>FnOnce</code> traitini amalga oshiradigan closure misolini ko'rsatadi, chunki u qiymatni environmentdan tashqariga ko'chiradi. Kompilyator bu closureni <code>sort_by_key</code> bilan ishlatishimizga ruxsat bermaydi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    kengligi: u32,
    balandligi: u32,
}

fn main() {
    let mut list = [
        Rectangle { kengligi: 10, balandligi: 1 },
        Rectangle { kengligi: 3, balandligi: 5 },
        Rectangle { kengligi: 7, balandligi: 12 },
    ];

    let mut saralash_operatsiyalari = vec![];
    let qiymat = String::from(&quot;chaqirilgan kalit orqali&quot;);

    list.sort_by_key(|r| {
        saralash_operatsiyalari.push(qiymat);
        r.kengligi
    });
    println!(&quot;{:#?}&quot;, list);
}</code></pre>
<p><span class="caption">Ro'yxat 13-8: <code>sort_by_key</code> yordamida <code>FnOnce</code> closuredan foydalanishga urinish</span></p>
<p>Bu <code>list</code>ni saralashda <code>sort_by_key</code> necha marta chaqirilishini hisoblashning o ªylab topilgan (bu ishlamaydi) usulidir. Ushbu kod closure environmentidan  <code>qiymat</code>‚Äîa <code>String</code> ni <code>saralash_operatsiyalari</code> vektoriga surish(push) orqali hisoblashni amalga oshirishga harakat qiladi. Closure <code>qiymat</code>ni ushlaydi, so‚Äòngra <code>qiymat</code> ownershipligini <code>saralash_operatsiyalari</code> vektoriga o‚Äòtkazish orqali <code>qiymat</code>ni closuredan chiqaradi. Ushbu closureni bir marta chaqirish mumkin; uni ikkinchi marta chaqirishga urinish ishlamaydi, chunki <code>qiymat</code> endi <code>saralash_operatsiyalari</code> ga push qilinadigan environmentda(muhitda) bo'lmaydi! Shuning uchun, bu closure faqat <code>FnOnce</code> ni amalga oshiradi(implement qiladi). Ushbu kodni kompilyatsiya qilmoqchi bo'lganimizda, biz <code>qiymat</code> ni closuredan chiqarib bo'lmaydigan xatoni olamiz, chunki closure <code>FnMut</code> ni implement qilishi kerak:</p>
<pre><code class="language-console">$ cargo run
   Compiling kvadratlar v0.1.0 (file:///projects/kvadratlar)
error[E0507]: cannot move out of `qiymat`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let qiymat = String::from(&quot;chaqirilgan kalit orqali&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         saralash_operatsiyalari.push(qiymat);
   |                              ^^^^^ move occurs because `qiymat` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `kvadratlar` due to previous error
</code></pre>
<p>Xato <code>qiymat</code>ni environmentdan tashqariga olib chiqadigan closure tanasidagi(body) chiziqqa(line) ishora qiladi. Buni tuzatish uchun biz closure tanasini qiymatlarni environmentdan ko'chirmasligi uchun o'zgartirishimiz kerak. <code>sort_by_key</code> necha marta chaqirilishini hisoblash uchun hisoblagichni(counter) environment saqlash va uning qiymatini closure tanasida oshirish buni hisoblashning yanada sodda usuli hisoblanadi. 13-9 ro'yxatdagi closure <code>sort_by_key</code> bilan ishlaydi, chunki u faqat <code>raqam_saralash_operatsiyalari</code> counteriga mutable(o'zgaruvchan) referenceni oladi va shuning uchun uni bir necha marta chaqirish mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Kvadrat {
    kengligi: u32,
    balandligi: u32,
}

fn main() {
    let mut list = [
        Kvadrat { kengligi: 10, balandligi: 1 },
        Kvadrat { kengligi: 3, balandligi: 5 },
        Kvadrat { kengligi: 7, balandligi: 12 },
    ];

    let mut raqam_saralash_operatsiyalari = 0;
    list.sort_by_key(|r| {
        raqam_saralash_operatsiyalari += 1;
        r.kengligi
    });
    println!(&quot;{:#?}, {raqam_saralash_operatsiyalari} operatsiyalarida tartiblangan&quot;, list);
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 13-9: <code>sort_by_key</code> bilan <code>FnMut</code> closuredan foydalanishga ruxsat berilgan</span></p>
<p><code>Fn</code> traitlari closurelardan foydalanadigan funksiyalar yoki turlarni belgilash yoki ishlatishda muhim ahamiyatga ega. Keyingi bo'limda biz iteratorlarni muhokama qilamiz. Ko'pgina iterator metodlari closure argumentlarini oladi, shuning uchun biz davom etayotganda ushbu closure tafsilotlarini(details) yodda tuting!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iteratorlar-yordamida-elementlar-ketma-ketligini-qayta-ishlash"><a class="header" href="#iteratorlar-yordamida-elementlar-ketma-ketligini-qayta-ishlash">Iteratorlar yordamida elementlar ketma-ketligini qayta ishlash</a></h2>
<p>Iterator pattern sizga navbat bilan elementlarning ketma-ketligi bo'yicha ba'zi vazifalarni(task) bajarishga imkon beradi. Iterator har bir elementni takrorlash va ketma-ketlik qachon tugashini aniqlash mantiqi uchun javobgardir. Iteratorlardan foydalanganda, bu mantiqni(logic) o'zingiz takrorlashingiz shart emas.</p>
<p>Rust-da iteratorlar <em>dangasa</em>, ya'ni iteratorni ishlatish uchun ishlatadigan metodlarni chaqirmaguningizcha ular hech qanday ta'sir ko'rsatmaydi. Masalan, 13-10-Ro'yxatdagi kod <code>Vec&lt;T&gt;</code> da belgilangan <code>iter</code> metodini chaqirish orqali <code>v1</code> vektoridagi elementlar ustidan iterator yaratadi. Ushbu kod o'z-o'zidan hech qanday foydali ish qilmaydi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 13-10: iterator yaratish</span></p>
<p>Iterator <code>v1_iter</code> o'zgaruvchisida saqlanadi. Biz iteratorni yaratganimizdan so'ng, biz uni turli usullarda ishlatishimiz mumkin. 3-bobdagi 3-5 ro'yxatda biz arrayning har bir elementida ba'zi kodlarni bajarish uchun <code>for</code> loop siklidan foydalangan holda uni takrorladik. Korpus ostida bu bilvosita yaratgan va keyin iteratorni ishlatgan, ammo biz hozirgacha uning qanday ishlashini ko'rib chiqdik.</p>
<p>13-11 Ro'yxatdagi misolda biz iteratorni yaratishni <code>for</code> loop siklidagi iteratordan foydalanishdan ajratamiz. <code>for</code> loop sikli <code>v1_iter</code> da iterator yordamida chaqirilganda, iteratordagi har bir element loop siklning bir iteratsiyasida ishlatiladi, bu esa har bir qiymatni chop etadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;{} : Olingan&quot;, val);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 13-11: <code>for</code> loop siklida iteratordan foydalanish</span></p>
<p>Standart kutubxonalari tomonidan taqdim etilgan iteratorlarga ega bo'lmagan tillarda siz xuddi shu funksiyani o'zgaruvchini 0 indeksidan boshlab yozishingiz mumkin, qiymat olish uchun vektorga indekslash uchun ushbu o'zgaruvchidan foydalanish va vektordagi elementlarning umumiy soniga yetgunga qadar sikldagi o'zgaruvchi qiymatini oshirish.</p>
<p>Iteratorlar siz uchun barcha mantiqni(logic) boshqaradi, siz chalkashtirib yuborishingiz mumkin bo'lgan takroriy kodni qisqartiradi. Iteratorlar vektorlar kabi indekslash mumkin bo'lgan ma'lumotlar tuzilmalari(data structure) emas, balki turli xil ketma-ketliklar(sequence) bilan bir xil mantiqdan foydalanish uchun ko'proq moslashuvchanlikni beradi. Keling, iteratorlar buni qanday qilishini ko'rib chiqaylik.</p>
<h3 id="iterator-traiti-va-next-metodi"><a class="header" href="#iterator-traiti-va-next-metodi"><code>Iterator</code> traiti va <code>next</code> metodi</a></h3>
<p>Barcha iteratorlar standart kutubxonada(standard library) aniqlangan <code>Iterator</code> nomli traitni implement qiladilar. Traitning definitioni quyidagicha ko'rinadi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // default implement qilingan  metodlar bekor qilindi
}
<span class="boring">}</span></code></pre></pre>
<p>E ºtibor bering, bu definitionda ba ºzi yangi sintaksislar qo ªllangan: <code>type Item</code> va <code>Self::Item</code> bu trait bilan <em>bog ªlangan turni(associated type)</em> belgilaydi. Bog'langan turlar haqida 19-bobda batafsil gaplashamiz. Hozircha siz bilishingiz kerak bo'lgan narsa shuki, ushbu kodda aytilishicha, <code>Iterator</code> traitini implement qilish uchun siz <code>Item</code> turini ham belgilashingiz kerak bo'ladi va bu <code>Item</code> turi <code>next</code> metodining qaytarish(return) turida qo'llaniladi. Boshqacha qilib aytganda, <code>Item</code> turi iteratordan qaytarilgan tur bo'ladi.</p>
<p><code>Iterator</code> traiti amalga oshiruvchilardan(implementorlar) faqat bitta metodni belgilashni talab qiladi: <code>next</code> metod, u bir vaqtning o'zida <code>Some</code> ga o'ralgan(wrapped) iteratorning bir elementini qaytaradi va takrorlash(iteratsiya) tugagach, <code>None</code>ni qaytaradi.</p>
<p>Biz iteratorlarda <code>next</code> metodini to'g'ridan-to'g'ri chaqirishimiz mumkin; Ro'yxat 13-12 vektordan yaratilgan iteratorda <code>next</code> ga takroriy chaqiruvlardan qanday qiymatlar qaytarilishini ko'rsatadi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstratsiyasi() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 13-12: iteratorda <code>next</code> metodini chaqirish</span></p>
<p>Esda tutingki, biz <code>v1_iter</code> ni o'zgaruvchan(mutable) qilishimiz kerak edi: iteratorda <code>next</code> metodini chaqirish iterator ketma-ketlikda(sequence) qayerdaligini kuzatish uchun foydalanadigan ichki holatni(internal state) o'zgartiradi. Boshqacha qilib aytganda, bu kod iteratorni <em>iste'mol qiladi(consumes)</em> yoki ishlatadi. <code>next</code> ga har bir chaqiruv(call) iteratordan biror elementni olib tashlaydi. Biz <code>for</code> loop siklidan foydalanganda <code>v1_iter</code>ni o‚Äòzgaruvchan(mutable) qilishimiz shart emas edi, chunki sikl <code>v1_iter</code> ga ownership(egalik) qildi va uni sahna ortida o‚Äòzgaruvchan qildi.</p>
<p>Shuni ham yodda tutingki, biz <code>next</code> ga chaiqruvlardan oladigan qiymatlar vektordagi qiymatlarga o'zgarmas(immutable) referencelardir. <code>iter</code> metodi immutable(o'zgarmas) referencelar ustida iterator hosil qiladi. Agar biz <code>v1</code> ga ownershiplik(egalik) qiluvchi va tegishli qiymatlarni qaytaruvchi iterator yaratmoqchi bo'lsak, <code>iter</code> o‚Äòrniga <code>into_iter</code> ni chaqirishimiz mumkin. Xuddi shunday, agar biz mutable(o'zgaruvchan) referencelarni takrorlashni xohlasak, <code>iter</code> o'rniga <code>iter_mut</code> ni chaqirishimiz mumkin.</p>
<h3 id="iteratorni-consume-qiladigan-metodlar"><a class="header" href="#iteratorni-consume-qiladigan-metodlar">Iteratorni consume qiladigan metodlar</a></h3>
<p><code>Iterator</code> traiti standart kutubxona(standard library) tomonidan taqdim etilgan default implementationlar bilan bir qator turli metodlarga ega; ushbu metodlar haqida <code>Iterator</code> traiti uchun standart kutubxona API texnik hujjatlarini ko'rib chiqish orqali bilib olishingiz mumkin. Ushbu metodlarning ba'zilari o'z definitionlarida <code>next</code> metodni chaqiradi, shuning uchun <code>Iterator</code> tratini implement qilishda <code>next</code> metodni qo'llash talab qilinadi.</p>
<p><code>next</code> ni chaqiruvchi metoflar <em>consuming adaptorlar</em> deb ataladi, chunki ularni chaqirish iteratordan foydalanadi. Bitta misol, iteratorga ownership(egalik) qiladigan va <code>next</code> deb qayta-qayta chaqirish orqali elementlarni takrorlaydigan, shu bilan iteratorni consume qiladigan <code>sum</code> metodidir. U takrorlanayotganda, u har bir elementni ishlayotgan jamiga qo'shadi va takrorlash tugagach, jamini qaytaradi. 13-13 ro'yxatda <code>sum</code> metodidan foydalanishni ko'rsatadigan test mavjud:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 13-13: iteratordagi barcha elementlarning umumiy miqdorini olish uchun <code>sum</code> metodini chaqirish</span></p>
<p>Bizga <code>sum</code> chaqiruvidan keyin <code>v1_iter</code> dan foydalanishga ruxsat berilmagan, chunki <code>sum</code> biz chaqiruvchi iteratorga ownershiplik(egalik) qiladi.</p>
<h3 id="boshqa-iteratorlarni-yaratuvchi-metodlar"><a class="header" href="#boshqa-iteratorlarni-yaratuvchi-metodlar">Boshqa iteratorlarni yaratuvchi metodlar</a></h3>
<p><em>Iterator adaptorlari</em> iteratorni consume(iste'mol) qilmaydigan <code>Iterator</code> traiti bo'yicha aniqlangan metoddir. Buning o'rniga, ular asl iteratorning ba'zi jihatlarini o'zgartirib, turli iteratorlarni ishlab chiqaradilar.</p>
<p>13-14 ro'yxatda iterator adapter metodini <code>map</code> deb chaqirish misoli ko'rsatilgan, bunda elementlar takrorlanganda(iteratsiya) har bir elementga chaqiruv(call) qilish yopiladi.
<code>map</code> metodi o'zgartirilgan elementlarni ishlab chiqaradigan yangi iteratorni qaytaradi. Bu yerda closure vektorning har bir elementi 1 ga oshiriladigan yangi iteratorni yaratadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 13-14: Yangi iterator yaratish uchun iterator adapteriga <code>map</code> chaqiruv qilish  qilish</span></p>
<p>Biroq, bu kod ogohlantirish(warning) ishlab chiqaradi:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default


warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>13-14 ro'yxatdagi kod hech narsa qilmaydi; biz belgilagan closure hech qachon chaqirilmaydi. Ogohlantirish(warning) bizga nima uchun eslatib turadi: iterator adapterlari dangasa va biz bu yerda iteratorni consume(ishlatish) qilishimiz kerak.</p>
<p>Ushbu ogohlantirishni tuzatish va iteratorni consume qilish uchun biz 12-bobda <code>env::args</code> bilan 12-1 ro'yxatda qo'llagan <code>collect</code> metodian foydalanamiz. Ushbu metod iteratorni consume qiladi va natijada olingan qiymatlarni ma'lumotlar to'plamiga(data type) to'playdi.</p>
<p>13-15 ro'yxatda biz vektorga <code>map</code>-ga chaqiruvdan qaytgan iterator bo'yicha takrorlash natijalarini yig'amiz. Ushbu vektor 1 ga oshirilgan asl vektorning har bir elementini o'z ichiga oladi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 13-15: Yangi iterator yaratish uchun <code>map</code> metodini chaqirish va keyin yangi iteratorni consume qilish va vektor yaratish uchun <code>collect</code> metodini chaqirish</span></p>
<p><code>map</code> yopilganligi sababli, biz har bir elementda bajarmoqchi bo'lgan har qanday operatsiyani belgilashimiz mumkin. Bu <code>Iterator</code> traiti ta ºminlaydigan iteratsiya xatti-harakatlarini(behavior) qayta ishlatishda closurelar sizga qandaydir behaviorlarni sozlash imkonini berishining ajoyib namunasidir.</p>
<p>Murakkab harakatlarni(complex action) o'qilishi mumkin bo'lgan tarzda bajarish uchun iterator adapterlariga bir nechta chaiquvlarni zanjirlashingiz(chain) mumkin. Ammo barcha iteratorlar dangasa bo'lgani uchun, iterator adapterlariga chaqiruvlardan natijalarni olish uchun consuming adapter metodlaridan birini chaqirishingiz kerak.</p>
<h3 id="environmentni-qamrab-oladigancapture-closurelardan-foydalanish"><a class="header" href="#environmentni-qamrab-oladigancapture-closurelardan-foydalanish">Environmentni qamrab oladigan(capture) closurelardan foydalanish</a></h3>
<p>Ko'pgina iterator adapterlari closurelarni argument sifatida qabul qiladilar va odatda biz iterator adapterlariga argument sifatida ko'rsatadigan closurelar ularning environmentini oladigan closurelar bo'ladi.</p>
<p>Ushbu misol uchun biz closureni oladigan <code>filter</code> metodidan foydalanamiz. Closure iteratordan element oladi va <code>bool</code> ni qaytaradi. Agar closure <code>true</code> qiymatini qaytarsa, qiymat <code>filtr</code> tomonidan ishlab chiqarilgan iteratsiyaga kiritiladi. Agar closure <code>false</code> bo'lsa, qiymat kiritilmaydi.</p>
<p>13-16 ro ªyxatda biz <code>Poyabzal</code> structi misollari to ªplamini iteratsiya qilish  uchun uning environmentidan <code>poyabzal_olchami</code> o ªzgaruvchisini ushlaydigan(capture) closure bilan <code>filtr</code>dan foydalanamiz. U faqat belgilangan o'lchamdagi poyabzallarni qaytaradi.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Poyabzal {
    olchami: u32,
    uslub: String,
}

fn olcham_boyicha_poyabzal(poyabzal: Vec&lt;Poyabzal&gt;, poyabzal_olchami: u32) -&gt; Vec&lt;Poyabzal&gt; {
    poyabzal.into_iter().filter(|s| s.size == poyabzal_olchami).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn olcham_boyicha_filterlash() {
        let poyabzal = vec![
            Poyabzal {
                olchami: 10,
                uslub: String::from(&quot;krossovka&quot;),
            },
            Poyabzal {
                olchami: 13,
                uslub: String::from(&quot;sandal&quot;),
            },
            Poyabzal {
                olchami: 10,
                uslub: String::from(&quot;etik&quot;),
            },
        ];

        let in_my_size = olcham_boyicha_poyabzal(poyabzal, 10);

        assert_eq!(
            in_my_size,
            vec![
                Poyabzal {
                    olchami: 10,
                    uslub: String::from(&quot;krossovka&quot;)
                },
                Poyabzal {
                    olchami: 10,
                    uslub: String::from(&quot;etik&quot;)
                },
            ]
        );
    }
}</code></pre>
<p><span class="caption">Ro ªyxat 13-16: <code>poyabzal_olchami</code>ni ushlaydigan closure bilan<code>filter</code> metodidan foydalanish</span></p>
<p><code>olcham_boyicha_poyabzal</code> funksiyasi parametr sifatida poyabzal vektori va poyabzal o'lchamiga egalik qiladi. U faqat belgilangan o'lchamdagi poyabzallarni o'z ichiga olgan vektorni qaytaradi.</p>
<p><code>olcham_boyicha_poyabzal</code> bodysida(tanasida) vektorga ownershiplik(egalik) qiluvchi iterator yaratish uchun <code>into_iter</code> ni chaqiramiz. Keyin biz ushbu iteratorni faqat closure <code>true</code>ni qaytaradigan elementlarni o'z ichiga olgan yangi iteratorga moslashtirish uchun <code>filter</code> ni chaqiramiz.</p>
<p>Closure muhitdan <code>poyabzal_olchami</code> parametrini oladi va qiymatni har bir poyabzal o'lchami bilan solishtiradi, faqat belgilangan o'lchamdagi poyabzallarni saqlaydi. Nihoyat, <code>collect</code> ni chaqirish moslashtirilgan iterator tomonidan qaytarilgan qiymatlarni funksiya tomonidan qaytariladigan vektorga to'playdi.</p>
<p>Test shuni ko'rsatadiki, biz <code>olcham_boyicha_poyabzal</code> deb ataganimizda, biz faqat biz ko'rsatgan qiymat bilan bir xil o'lchamdagi poyabzallarni qaytarib olamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="io-loyihamizni-takomillashtirish"><a class="header" href="#io-loyihamizni-takomillashtirish">I/O loyihamizni takomillashtirish</a></h2>
<p>Iteratorlar haqidagi yangi bilimlar bilan biz koddagi joylarni aniqroq va ixchamroq qilish uchun iteratorlardan foydalangan holda 12-bobdagi I/O(input/output)  loyihasini yaxshilashimiz mumkin. Keling, iteratorlar <code>Config::build</code> va <code>qidiruv</code> funksiyalarini amalga implement qilishni qanday yaxshilashi mumkinligini ko'rib chiqaylik.</p>
<h3 id="iterator-yordamida-cloneni-olib-tashlash"><a class="header" href="#iterator-yordamida-cloneni-olib-tashlash">Iterator yordamida <code>clone</code>ni olib tashlash</a></h3>
<p>12-6 ro ªyxatda biz <code>String</code> qiymatlari bo ªlagini olgan kodni qo ªshdik va bo ªlimga indekslash va qiymatlarni klonlash orqali <code>Config</code> strukturasining namunasini yaratdik,  <code>Config</code> strukturasiga ushbu qiymatlarga ownershiplik(egalik) qilish imkonini berdi. 13-17 ro'yxatda biz 12-23 ro'yxatdagi kabi <code>Config::build</code> funksiyasining bajarilishini takrorladik:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;argumentlar yetarli emas&quot;);
        }

        let sorov = args[1].clone();
        let fayl_yoli = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            sorov,
            fayl_yoli,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    let natijalar = if config.ignore_case {
</span><span class="boring">        harflarga_etiborsiz_qidirish(&amp;config.sorov, &amp;tarkib)
</span><span class="boring">    } else {
</span><span class="boring">        qidiruv(&amp;config.sorov, &amp;tarkib)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in natijalar {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn qidiruv&lt;'a&gt;(sorov: &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut natijalar = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in tarkib.lines() {
</span><span class="boring">        if line.contains(sorov) {
</span><span class="boring">            natijalar.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    natijalar
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn harflarga_etiborsiz_qidirish&lt;'a&gt;(
</span><span class="boring">    sorov: &amp;str,
</span><span class="boring">    tarkib: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let sorov = sorov.to_lowercase();
</span><span class="boring">    let mut natijalar = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in tarkib.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;sorov) {
</span><span class="boring">            natijalar.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    natijalar
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn harflarga_etiborli() {
</span><span class="boring">        let sorov = &quot;duct&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn harflarga_etiborsiz() {
</span><span class="boring">        let sorov = &quot;rUsT&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.
</span><span class="boring">Menga ishoning.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Menga ishoning.&quot;],
</span><span class="boring">            harflarga_etiborsiz_qidirish(sorov, tarkib)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 13-17: <code>Config::build</code> funksiyasining 12-23-Ro'yxatdan takrorlanishi</span></p>
<p>O'shanda biz samarasiz <code>clone</code> chaqiruvlari(call) haqida qayg'urmaslikni aytdik, chunki kelajakda ularni olib tashlaymiz. Xo'sh, bu vaqt hozir!</p>
<p>Bizga bu yerda <code>clone</code> kerak edi, chunki bizda <code>args</code> parametrida  <code>String</code> elementlari bo‚Äòlgan slice bor, lekin <code>build</code> funksiyasi <code>args</code>ga ega emas. <code>Config</code> namunasiga ownershiplikni(egalik) qaytarish uchun <code>Config</code>ning <code>sorov</code> va <code>fayl_yoli</code> maydonlaridagi qiymatlarni klonlashimiz kerak edi, shunda <code>Config</code> namunasi o‚Äòz qiymatlariga ega bo‚Äòlishi mumkin.</p>
<p>Iteratorlar haqidagi yangi bilimlarimiz bilan biz <code>build</code> funksiyasini o ªzgartirib, bir sliceni olish o ªrniga iteratorga argument sifatida ownershiplik qilishimiz mumkin.
Biz slice uzunligini tekshiradigan kod o'rniga iterator funksiyasidan foydalanamiz va ma'lum joylarga ko'rsatamiz. Bu <code>Config::build</code> funksiyasi nima qilayotganini aniqlaydi, chunki iterator qiymatlarga kira oladi.</p>
<p><code>Config::build</code> iteratorga ownershiplik qilib, borrow qilingan indekslash operatsiyalaridan foydalanishni to'xtatgandan so'ng, biz <code>clone</code> deb chaqirish va yangi ajratish(allocation) o'rniga <code>String</code> qiymatlarini iteratordan <code>Config</code>ga ko'chirishimiz mumkin.</p>
<h4 id="qaytarilganreturn-iteratordan-togridan-togri-foydalanish"><a class="header" href="#qaytarilganreturn-iteratordan-togridan-togri-foydalanish">Qaytarilgan(return) iteratordan to'g'ridan-to'g'ri foydalanish</a></h4>
<p>I/O loyihangizning <em>src/main.rs</em> faylini oching, u quyidagicha ko'rinishi kerak:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Argumentlarni tahlil qilish muammosi: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Dastur xatosi: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p>Biz birinchi navbatda 12-24-Ro'yhatdagi <code>main</code> funksiyaning boshlanishini 13-18-Ro'yxatdagi kodga almashtiramiz, bu safar iteratordan foydalanadi. Biz <code>Config::build</code>ni ham yangilamagunimizcha, bu kompilyatsiya qilinmaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Argumentlarni tahlil qilish muammosi: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Dastur xatosi: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Ro'yxat 13-18: <code>env::args</code> ning return(qaytish) qiymatini `Config::build`` ga o'tkazish</span></p>
<p><code>env::args</code> funksiyasi iteratorni qaytaradi! Iterator qiymatlarini(value) vectorga yig'ib, keyin sliceni(bo'lak) <code>Config::build</code>  ga o'tkazish o'rniga, endi biz <code>env::args</code> dan qaytarilgan(return) iteratorga ownershiplik(egalik) huquqini to'g'ridan-to'g'ri <code>Config::build</code> ga o'tkazmoqdamiz.</p>
<p>Keyinchalik, <code>Config::build</code> definitioni yangilashimiz kerak. I/O loyihangizning <em>src/lib.rs</em> faylida keling, <code>Config::build</code> signaturesni 13-19-raqamli ro ªyxatga o ªxshatib o ªzgartiraylik. Bu hali ham kompilyatsiya qilinmaydi, chunki biz funksiya bodysini(tanasi) yangilashimiz kerak.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-19: Updating the signature of <code>Config::build</code>
to expect an iterator</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>, and that type implements
the <code>Iterator</code> trait and returns <code>String</code> values.</p>
<p>We‚Äôve updated the signature of the <code>Config::build</code> function so the parameter
<code>args</code> has a generic type with the trait bounds <code>impl Iterator&lt;Item = String&gt;</code>
instead of <code>&amp;[String]</code>. This usage of the <code>impl Trait</code> syntax we discussed in
the <a href="ch10-02-traits.html#traits-as-parameters">‚ÄúTraits as Parameters‚Äù</a><!-- ignore --> section of Chapter 10
means that <code>args</code> can be any type that implements the <code>Iterator</code> type and
returns <code>String</code> items.</p>
<p>Because we‚Äôre taking ownership of <code>args</code> and we‚Äôll be mutating <code>args</code> by
iterating over it, we can add the <code>mut</code> keyword into the specification of the
<code>args</code> parameter to make it mutable.</p>
<h4 id="using-iterator-trait-methods-instead-of-indexing"><a class="header" href="#using-iterator-trait-methods-instead-of-indexing">Using <code>Iterator</code> Trait Methods Instead of Indexing</a></h4>
<p>Next, we‚Äôll fix the body of <code>Config::build</code>. Because <code>args</code> implements the
<code>Iterator</code> trait, we know we can call the <code>next</code> method on it! Listing 13-20
updates the code from Listing 12-23 to use the <code>next</code> method:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file path&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-20: Changing the body of <code>Config::build</code> to use
iterator methods</span></p>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Second, we call <code>next</code> to get the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns a
<code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means
not enough arguments were given and we return early with an <code>Err</code> value. We do
the same thing for the <code>file_path</code> value.</p>
<h3 id="making-code-clearer-with-iterator-adaptors"><a class="header" href="#making-code-clearer-with-iterator-adaptors">Making Code Clearer with Iterator Adaptors</a></h3>
<p>We can also take advantage of iterators in the <code>search</code> function in our I/O
project, which is reproduced here in Listing 13-21 as it was in Listing 12-19:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub sorov: String,
</span><span class="boring">    pub fayl_yoli: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;argumentlar yetarli emas&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let sorov = args[1].clone();
</span><span class="boring">        let fayl_yoli = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { sorov, fayl_yoli })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let tarkib = fs::read_to_string(config.fayl_yoli)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn qidiruv&lt;'a&gt;(sorov: &amp;str, tarkib: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut natijalar = Vec::new();

    for line in tarkib.lines() {
        if line.contains(sorov) {
            natijalar.push(line);
        }
    }

    natijalar
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn birinchi_natija() {
</span><span class="boring">        let sorov = &quot;marali&quot;;
</span><span class="boring">        let tarkib = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">xavfsiz, tez, samarali.
</span><span class="boring">Uchtasini tanlang.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;xavfsiz, tez, samarali.&quot;], qidiruv(sorov, tarkib));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-21: The implementation of the <code>search</code>
function from Listing 12-19</span></p>
<p>We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn‚Äôt have to manage
concurrent access to the <code>results</code> vector. Listing 13-22 shows this change:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a query string&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a file path&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 13-22: <code>qidiruv</code> funksiyasini impelement qilishda iterator adapter metodlaridan foydalanish</span></p>
<p>Eslatib o'tamiz, <code>qidiruv</code> funksiyasining maqsadi <code>tarkib</code> dagi <code>sorov</code> ni o'z ichiga olgan barcha qatorlarni qaytarishdir(return). 13-16 Ro ªyxatdagi <code>filter</code> misoliga o ªxshab, bu kod <code>filter</code> adapteridan faqat <code>line.contains(sorov)</code> uchun <code>true</code> qaytaradigan satrlarni saqlash uchun foydalanadi. Keyin mos keladigan qatorlarni <code>collect</code> bilan boshqa vectorga yig'amiz. Juda oddiyroq! <code>harflarga_etiborsiz_qidirish</code> funksiyasida ham iterator metodlaridan foydalanish uchun xuddi shunday o'zgartirish kiriting.</p>
<h3 id="looplar-yoki-iteratorlar-ortasida-tanlash"><a class="header" href="#looplar-yoki-iteratorlar-ortasida-tanlash">Looplar yoki iteratorlar o'rtasida tanlash</a></h3>
<p>Keyingi mantiqiy savol - o'z kodingizda qaysi uslubni tanlashingiz kerakligi va nima uchun: 13-21-Ro'yxatdagi asl dastur yoki 13-22-Ro'yxatdagi iteratorlardan foydalangan holda versiya. Aksariyat Rust dasturchilari iterator uslubidan foydalanishni afzal ko'rishadi. Avvaliga o'rganish biroz qiyinroq, lekin siz turli xil iterator adapterlari va ular nima qilishini his qilganingizdan so'ng, iteratorlarni tushunish osonroq bo'ladi. Kod aylanishning turli bitlari va yangi vectorlarni yaratish o'rniga, loop siklning yuqori darajadagi(high-level) maqsadiga e'tibor qaratadi. Bu ba'zi oddiy kodlarni abstrakt qiladi, shuning uchun ushbu kodga xos bo'lgan tushunchalarni, masalan, iteratordagi har bir element o'tishi kerak bo'lgan filtrlash shartini ko'rish osonroq bo'ladi.</p>
<p>Ammo ikkita dastur haqiqattan ham ekvivalentmi? Intuitiv taxmin shundan iboratki, low-leveldagi loop tezroq bo'ladi. Keling, performance haqida gapiraylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ishlash-samaradorliginiperformance-solishtirish-looplar-va-iteratorlar"><a class="header" href="#ishlash-samaradorliginiperformance-solishtirish-looplar-va-iteratorlar">Ishlash samaradorligini(Performance) solishtirish: Looplar va iteratorlar</a></h2>
<p>Looplar yoki iteratorlardan foydalanishni aniqlash uchun siz qaysi implement qilish tezroq ekanligini bilishingiz kerak: <code>qidiruv</code> funksiyasining aniq <code>for</code> lop sikliga ega versiyasi yoki iteratorli versiya.</p>
<p>Ser Arthur Conan Doylening <em>Sherlok Xolmsning sarguzashtlari(The Adventures of Sherlock Holmes)</em> asarining to‚Äòliq mazmunini <code>String</code>ga yuklash va mazmundan <em>the</em> so‚Äòzini izlash orqali sinovdan o‚Äòtkizdik. Mana, <code>for</code> loop siklidan foydalangan holda <code>qidiruv</code> versiyasi va iteratorlardan foydalangan holda sinov natijalari:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Iterator versiyasi biroz tezroq edi! Biz bu yerda benchmark kodini tushuntirmaymiz, chunki bu ikkita versiyaning ekvivalentligini isbotlash emas, balki ushbu ikki dasturning ishlash jihatidan qanday taqqoslanishi haqida umumiy tushunchaga ega bo'lishdir.</p>
<p>Batafsilroq tahlil qilish uchun siz <code>tarkib</code> sifatida har xil o ªlchamdagi turli matnlarni, <code>sorov</code> sifatida turli uzunlikdagi turli so ªz va so ªzlarni va boshqa har xil o ªzgarishlardan foydalanishni tekshirishingiz kerak. Gap shundaki: iteratorlar, garchi yuqori darajadagi(high-level) abstraksiya bo'lsa ham, xuddi quyi darajadagi(lower-level) kodni o'zingiz yozganingizdek, taxminan bir xil kodga kompilyatsiya qilinadi. Iteratorlar Rustning <em>zero-cost(nol xarajatli) abstraksiyalaridan</em> biri bo‚Äòlib, bu orqali biz abstraktsiyadan foydalanish qo‚Äòshimcha runtime yukini talab qilmaydi. Bu C++ tilining asl dizayneri va amalga oshiruvchisi(implementori) Bjarne Stroustrupning ‚ÄúC++ asoslari (Foundations of C++)‚Äù (2012) asarida <em>zero-overhead</em> belgilashiga o‚Äòxshaydi:</p>
<blockquote>
<p>Umuman olganda, C++ ilovalari zero overhead(nol qo'shimcha xarajatlar) printsipiga bo'ysunadi:
Siz foydalanmayotgan narsangiz uchun pul to'lamaysiz. Va yana: Siz foydalanadigan narsadan yaxshiroq
kodlash mumkin emas.</p>
</blockquote>
<p>Yana bir misol sifatida, quyidagi kod audio dekoderdan olingan. Dekodlash algoritmi oldingi namunalarning chiziqli(linear) funksiyasi asosida kelajakdagi qiymatlarni baholash uchun linear prediction(taxmin qilish) qilish matematik operatsiyasidan foydalanadi. Ushbu kod uchta o'zgaruvchi bo'yicha matematikani amalga oshirish uchun iterator zanjiridan foydalanadi: ma'lumotlarning <code>bufer</code> qismi, 12 <code>koeffitsient</code> massivi va <code>qlp_shift</code> da ma'lumotlarni o'zgartirish uchun miqdor. Biz ushbu misolda o'zgaruvchilarni e'lon qildik, lekin ularga hech qanday qiymat bermadik; Garchi bu kod o'z kontekstidan tashqarida unchalik katta ma'noga ega bo'lmasa-da, bu Rust yuqori darajadagi g'oyalarni low-leveldagi kodga qanday tarjima qilishining qisqacha, haqiqiy misolidir.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let koeffitsient: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let taxmin_qilish = koeffitsient.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = taxmin_qilish as i32 + delta;
}</code></pre>
<p><code>taxmin_qilish</code> qiymatini hisoblash uchun ushbu kod <code>koeffitsient</code> dagi 12 ta qiymatning har birini iteratsiya(takrorlaydi) qiladi va koeffitsient qiymatlarini <code>bufer</code>dagi oldingi 12 ta qiymat bilan bog‚Äòlash uchun <code>zip</code> metodidan foydalanadi. Keyin, har bir juftlik uchun biz qiymatlarni ko'paytiramiz, barcha natijalarni yig'amiz va <code>qlp_shift</code> bitlari yig'indisidagi bitlarni o'ngga siljitamiz.</p>
<p>Audio dekoderlar kabi ilovalardagi hisob-kitoblar ko'pincha performenceni(ish samaradorligi) birinchi o'ringa qo'yadi. Bu yerda biz iterator yaratamiz, ikkita adapterdan foydalanamiz va keyin qiymatni consume(iste'mol) qilamiz. Ushbu Rust kodi qaysi assembly kodini kompilyatsiya qiladi? Xo'sh, ushbu yozuvdan boshlab, u siz qo'lda yozadigan assemblyga kopilatsiya qiladi. <code>koeffitsient</code> dagi qiymatlar ustidagi iteratsiyaga mos keladigan loop sikl umuman yo‚Äòq: Rust 12 ta iteratsiya(takrorlash) borligini biladi, shuning uchun u loop siklni <code>unrolls</code> qiladi. <em>Unrolling</em> - bu optimallashtirish bo'lib, u loop siklni boshqarish kodining qo'shimcha yukini olib tashlaydi va buning o'rniga loop siklning har bir iteratsiyasi uchun takroriy kod hosil qiladi.</p>
<p>Barcha koeffitsientlar registrlarda saqlanadi, ya'ni qiymatlarga kirish juda tez. Runtimeda massivga kirishda chegaralar yo'q.
Rust qo'llashi mumkin bo'lgan barcha optimallashtirishlar natijada olingan kodni juda samarali qiladi. Endi siz buni bilganingizdan so'ng, siz iteratorlar va closurelardan qo'rqmasdan foydalanishingiz mumkin! Ular kodni yuqori darajadagi(high-level) ko'rinishga olib keladi, lekin buning uchun runtime ishlashi uchun jazo qo'llamaydi.</p>
<h2 id="xulosa-12"><a class="header" href="#xulosa-12">Xulosa</a></h2>
<p>Closure va iteratorlar - bu funksional dasturlash tili g'oyalaridan ilhomlangan Rust xususiyatlari(feature). Ular Rustning low-leveldagi ishlashda high-leveldagi g'oyalarni aniq ifodalash qobiliyatiga hissa qo'shadilar. Closure va iteratorlarni implement qilish runtimening ishlashiga ta'sir qilmaydi. Bu Rustning zero-cost(nol xarajatli) abstraksiyalarni taqdim etishga intilish maqsadining bir qismidir.</p>
<p>Endi biz I/O loyihamizning ifodaliligini yaxshilaganimizdan so‚Äòng, keling, loyihani dunyo bilan baham ko‚Äòrishimizga yordam beradigan <code>cargo</code>ning yana bir qancha xususiyatlarini ko‚Äòrib chiqaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-va-cratesio-haqida-koproq"><a class="header" href="#cargo-va-cratesio-haqida-koproq">Cargo va Crates.io haqida ko'proq</a></h1>
<p>Hozirgacha biz kodimizni yaratish(build), ishga tushirish(run) va sinab ko'rish(test) uchun faqat Cargo-ning eng asosiy xususiyatlaridan foydalanganmiz, ammo u ko'proq narsani qila oladi. Ushbu bobda biz sizga quyidagi amallarni bajarishni ko'rsatish uchun uning boshqa, yanada ilg'or xususiyatlarini muhokama qilamiz:</p>
<ul>
<li>Reliz profillari bilan buildarni customizatsiya qilish</li>
<li>Kutubxonalarni(library) <a href="https://crates.io/">crates.io</a><!-- ignore -->  saytida nashr eting</li>
<li>Workspacelar bilan yirik loyihalarni tashkil qiling</li>
<li><a href="https://crates.io/">crates.io</a><!-- ignore -->  dan binary(ikkilik) fayllarni o'rnating</li>
<li>Maxsus buyruqlar yordamida cargoni kengaytiring</li>
</ul>
<p>Cargo biz ushbu bobda ko'rib chiqiladigan funksiyalardan ham ko'proq narsani qila oladi, shuning uchun uning barcha xususiyatlarini to'liq tushuntirish uchun uning <a href="https://doc.rust-lang.org/cargo/">texnik hujjatlariga</a> qarang.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reliz-profillari-bilan-buildarni-customizatsiya-qilish"><a class="header" href="#reliz-profillari-bilan-buildarni-customizatsiya-qilish">Reliz profillari bilan buildarni customizatsiya qilish</a></h2>
<p>Rust-da <em>release profillari</em> turli xil konfiguratsiyalarga ega bo'lgan oldindan belgilangan va sozlanishi mumkin bo'lgan profillar bo'lib, ular dasturchiga kodni kompilyatsiya qilish uchun turli xil variantlarni ko'proq nazorat qilish imkonini beradi. Har bir profil boshqalardan mustaqil ravishda configuratsiya qilingan.</p>
<p>Cargo ikkita asosiy profilga ega: <code>cargo build</code>ni ishga tushirganingizda <code>dev</code> cargo profili va <code>cargo build --release</code>ni ishga tushirganingizda <code>release</code> cargo profilidan foydalanadi. <code>dev</code> profili ishlab chiqish(development) uchun yaxshi standart sozlamalar bilan belgilangan va <code>release</code> profili relizlar uchun yaxshi standart parametrlarga ega.</p>
<p>Ushbu profil nomlari sizning buildlaringiz natijalaridan tanish bo'lishi mumkin:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p><code>dev</code> va <code>release</code> - bu kompilyator tomonidan ishlatiladigan turli xil profillar.</p>
<p>Loyihaning <em>Cargo.toml</em> fayliga <code>[profile.*]</code> bo ªlimlarini aniq qo ªshmagan bo ªlsangiz, Cargo har bir profil uchun standart(default) sozlamalarga ega.
Moslashtirmoqchi(customizatsiya) bo ªlgan har qanday profil uchun <code>[profile.*]</code> bo ªlimlarini qo ªshish orqali siz default sozlamalarning har qanday quyi to ªplamini bekor qilasiz. Masalan, <code>dev</code> va <code>release</code> profillari uchun <code>opt-level</code> sozlamalari uchun default qiymatlar:</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p><code>opt-level</code> sozlama Rust kodingizga qo'llaniladigan optimallashtirishlar sonini nazorat qiladi, 0 dan 3 gacha. Ko'proq optimallashtirishni qo'llash kompilyatsiya vaqtini uzaytiradi, shuning uchun agar siz tez-tez ishlab chiqayotgan bo'lsangiz va kodingizni kompilyatsiya qilsangiz, natijada olingan kod sekinroq ishlayotgan bo'lsa ham, tezroq kompilyatsiya qilishni kamroq optimallashtirishni xohlaysiz. Shunday qilib, <code>dev</code> uchun default <code>opt-level</code> <code>0</code> dir. Kodni releasega chiqarishga tayyor bo'lganingizda, kompilyatsiya qilish uchun ko'proq vaqt sarflaganingiz ma'qul. Siz release rejimida faqat bir marta kompilyatsiya qilasiz, lekin kompilyatsiya qilingan dasturni ko'p marta ishga tushirasiz, shuning uchun release rejimi tradelari tezroq ishlaydigan kod uchun kompilyatsiya vaqtini uzaytiradi. Shuning uchun <code>release</code> profili uchun default <code>opt-level</code> <code>3</code> dir.</p>
<p>Siz <em>Cargo.toml</em> da boshqa qiymat qo ªshish orqali default sozlamani bekor qilishingiz mumkin. Misol uchun, agar biz development profilida optimallashtirish darajasi 1 dan foydalanmoqchi bo'lsak, loyihamizning <em>Cargo.toml</em> fayliga ushbu ikki qatorni qo'shishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Bu kod default <code>0</code> sozlamasini bekor qiladi. Now when we run <code>cargo build</code>,
Cargo <code>dev</code> profili uchun default sozlamalardan hamda <code>opt-level</code>ga moslashtirishimizdan foydalanadi. Biz <code>opt-level</code>ni <code>1</code> ga o‚Äòrnatganimiz sababli, Cargo defaultdan ko‚Äòra ko‚Äòproq optimallashtirishni qo‚Äòllaydi, lekin release builddagi kabi emas.</p>
<p>Har bir profil uchun konfiguratsiya opsiyalari va standart sozlamalarning to'liq ro'yxati uchun Cargo <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">texnik hujjatlariga</a> qarang.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="crateni-cratesio-ga-nashr-qilish"><a class="header" href="#crateni-cratesio-ga-nashr-qilish">Crateni Crates.io-ga nashr qilish</a></h2>
<p>Biz <a href="https://crates.io/">crates.io</a><!-- ignore --> paketlaridan loyihamizga dependency sifatida foydalandik, lekin siz o ªz paketlaringizni nashr(publish) qilish orqali kodingizni boshqa odamlar bilan ham baham ko ªrishingiz mumkin. <a href="https://crates.io/">crates.io</a><!-- ignore --> saytidagi crate registri paketlaringizning manba kodini tarqatadi, shuning uchun u birinchi navbatda open source kodni saqlaydi.</p>
<p>Rust va Cargoda publish etilgan paketingizni odamlar topishi va undan foydalanishini osonlashtiradigan funksiyalar mavjud. Biz ushbu xususiyatlarning ba'zilari haqida keyin gaplashamiz va keyin paketni qanday nashr(publish) qilishni tushuntiramiz.</p>
<h3 id="foydali-hujjatlargadocumentation-sharhlarcomment-qoyish"><a class="header" href="#foydali-hujjatlargadocumentation-sharhlarcomment-qoyish">Foydali hujjatlarga(documentation) sharhlar(comment) qo'yish</a></h3>
<p>Paketlaringizni to'g'ri hujjatlashtirish boshqa foydalanuvchilarga ulardan qanday va qachon foydalanishni bilishga yordam beradi, shuning uchun texnik hujjatlarni yozish uchun vaqt sarflashga arziydi. 3-bobda biz Rust kodini ikkita slash <code>//</code> yordamida qanday izohlashni(comment) muhokama qildik. Rust shuningdek, HTML hujjatlarini yaratadigan <em>documentation comment</em> deb nomlanuvchi hujjatlar uchun o'ziga xos izohga ega. HTML sizning cratengiz qanday <em>impelemnent qilinganidan</em> farqli o'laroq, sizning cratengizdan qanday <em>foydalanishni</em> bilishga qiziqqan dasturchilar uchun mo'ljallangan umumiy API elementlari uchun hujjat sharhlari mazmunini ko'rsatadi.</p>
<p>Hujjatlarga sharhlar ikkita o'rniga uchta slashdan foydalaniladi, <code>///</code> va matnni formatlash uchun Markdown notationni qo'llab-quvvatlaydi. Hujjatlarga sharhlarni ular hujjatlashtirilayotgan element oldiga qo'ying. 14-1 Ro'yxatda <code>my_crate</code> nomli cratedagi <code>bir_qoshish</code> funksiyasi uchun hujjat sharhlari ko'rsatilgan.</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Berilgan raqamga bitta qo'shadi.
///
/// # Misollar
///
/// ```
/// let argument = 5;
/// let javob = my_crate::bir_qoshish(argument);
///
/// assert_eq!(6, javob);
/// ```
pub fn bir_qoshish(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p><span class="caption">Ro'yxat 14-1: Funksiya uchun hujjat sharhi(documentation comment</span></p>
<p>Bu yerda biz <code>bir_qoshish</code> funksiyasi nima qilishini tavsiflab beramiz, <code>Misollar</code> sarlavhasi bilan bo‚Äòlimni boshlaymiz, so‚Äòngra <code>bir_qoshish</code>  funksiyasidan qanday foydalanishni ko‚Äòrsatadigan kodni taqdim etamiz. Biz ushbu hujjat sharhidan HTML hujjatlarini <code>cargo doc</code>ni ishga tushirish orqali yaratishimiz mumkin. Bu buyruq Rust bilan tarqatilgan <code>rustdoc</code> toolini ishga tushiradi va yaratilgan HTML hujjatlarini <em>target/doc</em> jildiga joylashtiradi.</p>
<p>Qulaylik uchun <code>cargo doc --open</code> ni ishga tushirish joriy crate hujjatlari uchun HTML-ni yaratadi (shuningdek, cratengizning barcha dependencilari uchun hujjatlar) va natijani veb-brauzerda ochadi. <code>bir_qoshish</code> funksiyasiga o‚Äòting va 14-1-rasmda ko‚Äòrsatilganidek, hujjat sharhlaridagi matn qanday ko‚Äòrsatilishini ko‚Äòrasiz:</p>
<img alt="Rendered HTML documentation for the `bir_qoshish` function of `my_crate`" src="img/trlpuz1.png" class="center" />
<p><span class="caption">14-1-Rasm: <code>bir_qoshish</code> funksiyasi uchun HTML hujjatlari</span></p>
<h4 id="tez-tez-ishlatiladigan-bolimlar"><a class="header" href="#tez-tez-ishlatiladigan-bolimlar">Tez-tez ishlatiladigan bo'limlar</a></h4>
<p>Biz HTML-da <code>Misollar</code> sarlavhali bo'lim yaratish uchun 14-1 ro'yxatdagi <code># Misollar</code> Markdown sarlavhasidan foydalandik. Mualliflar o'z hujjatlarida tez-tez foydalanadigan boshqa bo'limlar:</p>
<ul>
<li><strong>Panics</strong>: Hujjat yozilayotan funksiya senariylari panic qo'zg'atishi mumkin. O'z dasturlari panic qo'zg'ashini istamaydigan funksiyaning murojaat qiluvchilari bunday holatlarda funksiyani chaqirmasliklariga ishonch hosil qilishlari kerak.</li>
<li><strong>Errors</strong>: Agar funksiya <code>Result</code> ni qaytarsa, yuzaga kelishi mumkin bo'lgan xatolar turlarini tavsiflash va bu xatolar qaytarilishiga qanday sharoitlar sabab bo'lishi mumkinligi murojaat qiluvchilar uchun foydali bo'lishi mumkin, shuning uchun ular turli xil xatolarni turli yo'llar bilan hal qilish uchun kod yozishlari mumkin.</li>
<li><strong>Safety</strong>: Agar funksiya murojaat qilish uchun <code>unsafe</code>  bo'lsa (biz 19-bobda xavfsizlikni muhokama qilamiz), funksiya nima uchun xavfli ekanligini tushuntiruvchi bo'lim bo'lishi kerak va funksiya murojaat qiluvchilar qo'llab-quvvatlashini kutayotgan o'zgarmaslarni qamrab oladi.</li>
</ul>
<p>Ko'pgina hujjatlar sharhlari ushbu bo'limlarning barchasiga muhtoj emas, ammo bu sizning kodingiz foydalanuvchilari bilishni qiziqtiradigan jihatlarni eslatish uchun yaxshi nazorat ro'yxati.</p>
<h4 id="texnik-hujjatlarga-sharhlar-test-sifatida"><a class="header" href="#texnik-hujjatlarga-sharhlar-test-sifatida">Texnik hujjatlarga sharhlar test sifatida</a></h4>
<p>Hujjatlarga sharhlaringizga(documentation comment) misol kod bloklarini qo'shish kutubxonangizdan(library) qanday foydalanishni ko'rsatishga yordam beradi va bu qo'shimcha bonusga ega bo'ladi: <code>cargo test</code> ishga tushirish hujjatlaringizdagi kod misollarini test sifatida ishga tushiradi! Hech narsa misollar bilan hujjatlashtirishdan yaxshiroq emas. Lekin hech narsa ishlamaydigan misollardan ko'ra yomonroq emas, chunki hujjatlar yozilgandan beri kod o'zgargan. Agar biz 14-1 ro ªyxatdagi <code>bir_qoshish</code> funksiyasi uchun hujjatlar bilan <code>cargo test</code> o ªtkazsak, test natijalarida quyidagi bo ªlimni ko ªramiz:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - bir_qoshish (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Endi funksiyani yoki misolni, misoldagi <code>assert_eq!</code> panic qo'zg'atadigan tarzda o'zgartirsak va yana <code>cargo test</code> ishga tushirsak, hujjat testlari misol va kod bir-biri bilan sinxronlanmaganligini aniqlaymiz.!</p>
<h4 id="oz-ichiga-olgan-elementlarni-sharhlash"><a class="header" href="#oz-ichiga-olgan-elementlarni-sharhlash">O'z ichiga olgan elementlarni sharhlash</a></h4>
<p>Hujjat sharhining uslubi <code>//!</code> hujjatni sharhlardan keyingi elementlarga emas, balki sharhlarni o'z ichiga olgan elementga qo'shadi. Biz odatda bu doc izohlaridan cratening ildiz(root) faylida (odatda <em>src/lib.rs</em>) yoki modul ichida crateni yoki butun modulni hujjatlash uchun foydalanamiz.</p>
<p>Masalan, <code>bir_qoshish</code> funksiyasini o'z ichiga olgan <code>my_crate</code> cratesi maqsadini tavsiflovchi hujjatlarni qo'shish uchun biz <em>src/lib.rs</em> faylining boshiga <code>//!</code> bilan boshlanadigan hujjat sharhlarini qo`shamiz, 14-2 ro'yxatda ko'rsatilganidek:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Mening Crateyim
//!
//! `my_crate` - muayyan hisob-kitoblarni bajarishni qulayroq qilish uchun
//! yordamchi dasturlar to'plami.

/// Berilgan raqamga bitta qo'shadi.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Misollar
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let argument = 5;
</span><span class="boring">/// let javob = my_crate::bir_qoshish(argument);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, javob);
</span><span class="boring">/// ```
</span><span class="boring">pub fn bir_qoshish(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 14-2: Umuman olganda, <code>my_crate</code> cratesi uchun hujjatlar</span></p>
<p>E'tibor bering, <code>//!</code> bilan boshlanadigan oxirgi qatordan keyin hech qanday kod yo'q. Fikrlarni <code>///</code> o'rniga <code>//!</code> bilan boshlaganimiz sababli, biz ushbu sharhdan keyingi elementni emas, balki ushbu sharhni o'z ichiga olgan elementni hujjatlashtirmoqdamiz. Bunday holda, bu element crate ildizi(root) bo'lgan <em>src/lib.rs</em> faylidir. Ushbu sharhlar butun crateni tasvirlaydi.</p>
<p><code>cargo doc --open</code>ni ishga tushirganimizda, bu izohlar 14-2-rasmda ko‚Äòrsatilganidek, <code>my_crate</code> hujjatlarining birinchi sahifasida cratedagi public itemlar ro‚Äòyxati ustida ko'rsatiladi:</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trlpuz2.png" class="center" />
<p><span class="caption">14-2-rasm: <code>my_crate</code> uchun taqdim etilgan hujjatlar, jumladan, crateni bir butun sifatida tavsiflovchi sharh</span></p>
<p>Elementlar ichidagi hujjat sharhlari, ayniqsa, cratelar va modullarni tavsiflash uchun foydalidir. Foydalanuvchilarga cratening tashkil etilishini tushunishlariga yordam berish uchun konteynerning umumiy maqsadini tushuntirish uchun ulardan foydalaning.</p>
<h3 id="pub-use-bilan-qulay-public-apini-eksport-qilish"><a class="header" href="#pub-use-bilan-qulay-public-apini-eksport-qilish"><code>pub use</code> bilan qulay Public APIni eksport qilish</a></h3>
<p>Public API structi crateni nashr qilishda muhim ahamiyatga ega. Sizning cratengizdan foydalanadigan odamlar structureni sizdan ko'ra kamroq bilishadi va agar sizning cratengiz katta modul ierarxiyasiga ega bo'lsa, ular foydalanmoqchi bo'lgan qismlarni topishda qiyinchiliklarga duch kelishlari mumkin.</p>
<p>7-bobda biz <code>pub</code> kalit so‚Äòzi yordamida itemlarni qanday qilib hammaga ochiq(public) qilish va <code>use</code> kalit so‚Äòzi bilan obyektlarni qamrovga(scope) kiritishni ko‚Äòrib chiqdik.Biroq, crateni ishlab chiqishda sizga mantiqiy bo'lgan structure foydalanuvchilaringiz uchun unchalik qulay bo'lmasligi mumkin. Siz structlaringizni bir nechta darajalarni o'z ichiga olgan ierarxiyada tartibga solishni xohlashingiz mumkin, ammo keyin siz ierarxiyada chuqur aniqlagan turdan foydalanmoqchi bo'lgan odamlar ushbu tur mavjudligini aniqlashda muammolarga duch kelishlari mumkin.
Ular, shuningdek, <code>use</code> <code>my_crate::FoydaliTur;</code> o'rniga <code>use</code> <code>my_crate::biror_modul::boshqa_modul::FoydaliTur;</code> ni kiritishlari kerakligidan bezovtalanishi mumkin.</p>
<p>Yaxshi xabar shundaki, agar sturcture boshqa kutubxonadan(library) foydalanishi uchun <em>qulay bo'lmasa</em>, ichki organizationgizni o'zgartirishingiz shart emas: Buning o'rniga, <code>pub use</code> dan foydalanib, private structuredan farq qiladigan public structure yaratish uchun itemlarni qayta eksport qilishingiz mumkin. Qayta eksport qilish public ob'ektni bir joyda oladi va uni boshqa joyda hammaga ochiq(public) qiladi, go'yo u boshqa joyda aniqlangandek.</p>
<p>Masalan, badiiy tushunchalarni modellashtirish uchun <code>rassom</code> nomli kutubxona(library) yaratdik, deylik.
Ushbu kutubxona ichida ikkita modul mavjud: 14-3 ro ªyxatda ko ªrsatilganidek, <code>AsosiyRang</code> va <code>IkkilamchiRang</code> nomli ikkita raqamni o ªz ichiga olgan <code>turlar</code> moduli va <code>aralashtirish</code> nomli funksiyani o ªz ichiga olgan <code>yordamchi</code> moduli:
<span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Rassom
//!
//! Badiiy tushunchalarni modellashtirish uchun kutubxona.

pub mod turlar {
    /// RYB rang modeliga muvofiq asosiy ranglar.
    pub enum AsosiyRang {
        Qizil,
        Sariq,
        Kok,
    }

    /// RYB rang modeliga muvofiq ikkinchi darajali ranglar.
    pub enum IkkilamchiRang {
        Qovoqrang,
        Yashil,
        Siyohrang,
    }
}

pub mod yordamchi {
    use crate::turlar::*;

    /// Ikkilamchi rang yaratish uchun ikkita asosiy rangni teng
    /// miqdorda birlashtiradi.
    pub fn aralashtirish(c1: AsosiyRang, c2: AsosiyRang) -&gt; IkkilamchiRang {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
<p><span class="caption">Ro ªyxat 14-3: <code>turlar</code> va <code>yordamchi</code> modullariga ajratilgan <code>rassom</code> kutubxonasi</span></p>
<p>14-3-rasmda <code>cargo doc</code> tomonidan yaratilgan ushbu crate uchun hujjatlarning bosh sahifasi qanday ko'rinishi ko'rsatilgan:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">14-3-rasm: <code>turlar</code> va <code>yordamchi</code> modullari ro‚Äòyxati keltirilgan <code>rassom</code> hujjatlarining bosh sahifasi</span></p>
<p>E'tibor bering, <code>AsosiyRang</code> va <code>IkkilamchiRang</code> turlari birinchi sahifada ko'rsatilmagan va <code>aralashtirish</code> funksiyasi ham mavjud emas. Ularni ko'rish uchun <code>turlar</code> va <code>yordamchi</code> ni bosishimiz kerak.</p>
<p>Ushbu kutubxonaga bog'liq bo'lgan boshqa cratega <code>rassom</code> dan elementlarni qamrab oladigan, hozirda aniqlangan modul stryucturedan ko'rsatadigan <code>use</code> statementlari kerak bo'ladi. 14-4 ro ªyxatda <code>rassom</code> cratesidagi <code>AsosiyRang</code> va <code>aralashtirish</code> elementlaridan foydalanadigan crate misoli ko ªrsatilgan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::turlar::AsosiyRang;
use rassom::yordamchi::aralashtirish;

fn main() {
    let qizil = AsosiyRang::Qizil;
    let yellow = AsosiyRang::Sariq;
    aralashtirish(qizil, sariq);
}</code></pre>
<p><span class="caption">Ro ªyxat 14-4: <code>rassom</code> crate itemlaridan foydalanilgan, ichki stuctureni eksport qilingan crate</span></p>
<p><code>rassom</code> cratesidan foydalanadigan 14-4-Ro'yxatdagi kod muallifi <code>AsosiyRang</code> <code>turlar</code> modulida, <code>aralashtirish</code> esa <code>yordamchi</code> modulida ekanligini aniqlashi kerak edi. <code>rassom</code> cratening modul stucturesi undan foydalanadiganlarga qaraganda <code>rassom</code> crate ustida ishlayotgan developerlarga ko'proq mos keladi. The internal
structure doesn‚Äôt contain any useful information for someone trying to
understand how to use the <code>art</code> crate, but rather causes confusion because
developers who use it have to figure out where to look, and must specify the
module names in the <code>use</code> statements.
Ichki stuctureda <code>rassom</code> cratesidan qanday foydalanishni tushunishga urinayotganlar uchun foydali ma'lumotlar mavjud emas, aksincha, chalkashliklarga sabab bo'ladi, chunki undan foydalanadigan developerlar qayerga qarash kerakligini aniqlashlari kerak va <code>use</code> statementlarida modul nomlarini ko'rsatishi kerak.</p>
<p>Ichki organizationni public API‚Äôdan olib tashlash uchun biz 14-5 ro‚Äòyxatda ko‚Äòrsatilganidek, top leveldagi elementlarni qayta eksport qilish uchun <code>pub use</code> statementlarini qo‚Äòshish uchun 14-3 ro‚Äòyxatdagi <code>rassom</code> crate kodini o‚Äòzgartirishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Rassom
//!
//! Badiiy tushunchalarni modellashtirish uchun kutubxona.

pub use self::turlar::AsosiyRang;
pub use self::turlar::IkkilamchiRang;
pub use self::yordamchi::aralashtirish;

pub mod turlar {
    // --snip--
<span class="boring">    /// RYB rang modeliga muvofiq asosiy ranglar.
</span><span class="boring">    pub enum AsosiyRang {
</span><span class="boring">        Qizil,
</span><span class="boring">        Sariq,
</span><span class="boring">        Kok,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// RYB rang modeliga muvofiq ikkinchi darajali ranglar.
</span><span class="boring">    pub enum IkkilamchiRang {
</span><span class="boring">        Qovoqrang,
</span><span class="boring">        Yashil,
</span><span class="boring">        Siyohrang,
</span><span class="boring">    }
</span>}

pub mod yordamchi {
    // --snip--
<span class="boring">    use crate::turlar::*;
</span><span class="boring">
</span><span class="boring">    /// Ikkilamchi rang yaratish uchun ikkita asosiy rangni teng
</span><span class="boring">    /// miqdorda birlashtiradi.
</span><span class="boring">    pub fn aralashtirish(c1: AsosiyRang, c2: AsosiyRang) -&gt; IkkilamchiRang {
</span><span class="boring">        IkkilamchiRang::Qovoqrang
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Ro'yxat 14-5: Elementlarni qayta eksport qilish uchun <code>pub use</code> statementlarini qo'shish</span></p>
<p>Ushbu crate uchun <code>cargo doc</code> yaratadigan API hujjatlari Endi 14-4-rasmda ko'rsatilganidek, re-exportlarni birinchi sahifada listga oling va bog'lang, bu <code>AsosiyRang</code> va <code>IkkilamchiRang</code> turlarini va <code>aralashtirish</code> funksiyasini topishni osonlashtiradi.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpluz14.png" class="center" />
<p><span class="caption">14-4-rasm: re-exportlar ro'yxati keltirilgan <code>rassom</code> hujjatlarining birinchi sahifasi</span></p>
<p><code>rassom</code> crate foydalanuvchilari hali ham 14-4 ro ªyxatda ko ªrsatilganidek, 14-3 ro ªyxatdagi ichki(internal) structureni ko ªrishlari va foydalanishlari mumkin yoki ular 14-6 ro ªyxatda ko ªrsatilganidek, 14-5 ro ªyxatdagi qulayroq structuredan foydalanishlari mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rassom::aralashtirish;
use rassom::AsosiyRang;

fn main() {
    // --snip--
<span class="boring">    let qizil = AsosiyRang::qizil;
</span><span class="boring">    let sariq = AsosiyRang::Sariq;
</span><span class="boring">    mix(qizil, sariq);
</span>}</code></pre>
<p><span class="caption">Ro'yxat 14-6: <code>rassom</code> cratesidan re-export(qayta eksport) qilingan itemlarni ishlatadigan dastur</span></p>
<p>Ko'plab ichki modullar mavjud bo'lsa, <code>pub use</code> bilan top leveldagi turlarni qayta eksport(re-export) qilish cratedan foydalanadigan foydalanuvchilar tajribasida sezilarli o'zgarishlarga olib kelishi mumkin. <code>pub use</code> ning yana bir keng tarqalgan qo ªllanilishi bu crate deifinationlarini cratengizning public API qismiga aylantirish uchun joriy cratedagi dependency definitionlarini qayta eksport qilishdir.</p>
<p>Foydali public API stucturesini yaratish fandan ko'ra ko'proq san'atdir va siz foydalanuvchilaringiz uchun eng mos keladigan APIni topish uchun takrorlashingiz mumkin. <code>pub use</code> ni tanlash sizga cratengizni ichki stuctureda moslashuvchanlikni beradi va bu ichki stuctureni foydalanuvchilarga taqdim etgan narsadan ajratadi. O'rnatgan ba'zi cratelar kodlarini ko'rib chiqing, ularning ichki tuzilishi(internal structure) public APIdan farq qiladimi yoki yo'qmi.</p>
<h3 id="cratesio-da-account-sozlash"><a class="header" href="#cratesio-da-account-sozlash">Crates.io da account sozlash</a></h3>
<p>Har qanday cratelarni nashr qilishdan oldin <a href="https://crates.io/">crates.io</a><!-- ignore --> saytida hisob(account) yaratishingiz va API tokenini olishingiz kerak.
Buning uchun <a href="https://crates.io/">crates.io</a><!-- ignore --> saytidagi bosh sahifaga tashrif buyuring va GitHub hisob qaydnomasi(account) orqali tizimga kiring. (GitHub hisobi hozirda talab hisoblanadi, ammo sayt kelajakda hisob yaratishning boshqa usullarini qo'llab-quvvatlashi mumkin.), Tizimga kirganingizdan so'ng,<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> sahifasidagi hisob sozlamalariga tashrif buyuring va API kalitingizni(key) oling. Keyin API kalitingiz bilan <code>cargo login</code> buyrug'ini bajaring, masalan:</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Bu buyruq Cargoga API tokeningiz haqida xabar beradi va uni <em>~/.cargo/credentials</em> da saqlaydi. E'tibor bering, bu token <em>secret</em>: uni boshqa hech kim bilan baham ko'rmang. Agar biron-bir sababga ko'ra uni kimdir bilan baham ko'rsangiz, uni bekor qilishingiz va <a href="https://crates.io/">crates.io</a><!-- ignore --> saytida yangi token yaratishingiz kerak.</p>
<h3 id="yangi-cratega-metadata-qoshish"><a class="header" href="#yangi-cratega-metadata-qoshish">Yangi cratega metadata qo'shish</a></h3>
<p>Aytaylik, sizda nashr qilmoqchi bo'lgan cratengiz bor. Nashr qilishdan oldin cratening <em>Cargo.toml</em> faylining <code>[package]</code> bo ªlimiga metama ºlumotlar qo ªshishingiz kerak bo ªladi.</p>
<p>Sizning cratengizga noyob nom kerak bo'ladi. Mahalliy(local) miqyosda crate ustida ishlayotganingizda, cratega xohlaganingizcha nom berishingiz mumkin. Biroq, <a href="https://crates.io/">crates.io</a><!-- ignore --> saytidagi crate nomlari birinchi kelganda, birinchi navbatda beriladi. Crate nomi olingandan so'ng, boshqa hech kim bu nom bilan crateni nashr eta olmaydi. Crateni nashr etishga urinishdan oldin foydalanmoqchi bo'lgan nomni qidiring. Agar nom ishlatilgan bo'lsa, nashr qilish uchun yangi nomdan foydalanish uchun boshqa nom topib, <em>Cargo.toml</em> faylida <code>[package]</code> bo'limi ostidagi <code>name</code> maydonini tahrirlashingiz kerak bo'ladi:</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;kalkulyator&quot;
</code></pre>
<p>Noyob nom tanlagan bo'lsangiz ham, ushbu nuqtada crateni nashr qilish uchun <code>cargo publish</code> ni ishga tushirganingizda, siz ogohlantirish va keyin xatolikni olasiz:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Bu xato, chunki sizda ba'zi muhim ma'lumotlar yetishmayapti: tavsif(description) va litsenziya talab qilinadi, shunda foydalanuvchilar sizning cratengiz nima qilishini va undan qanday shartlar ostida foydalanishlari mumkinligini bilishlari mumkin. <em>Cargo.toml</em> ga bir yoki ikki jumladan iborat tavsif(description) qo'shing, chunki u qidiruv natijalarida cratengiz bilan birga ko'rinadi. <code>license</code> maydoni uchun siz <em>litsenziya identifikatorining qiymatini</em> berishingiz kerak. <a href="http://spdx.org/licenses/">Linux
Foundation‚Äôs Software Package Data Exchange (SPDX)</a> ushbu qiymat uchun foydalanishingiz mumkin bo'lgan identifikatorlarni sanab o'tadi. Masalan, MIT litsenziyasidan foydalangan holda cratengizni litsenziyalaganingizni ko'rsatish uchun <code>MIT</code> identifikatorini qo'shing:</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;kalkulyator&quot;
license = &quot;MIT&quot;
</code></pre>
<p>Agar siz SPDX da ko'rinmaydigan litsenziyadan foydalanmoqchi bo'lsangiz, ushbu litsenziya matnini faylga joylashtirishingiz, faylni loyihangizga kiritishingiz kerak, va keyin <code>license</code> kalitidan foydalanish o ªrniga o ªsha fayl nomini ko ªrsatish uchun <code>license-file</code> dan foydalaning.</p>
<p>Loyihangiz uchun qaysi litsenziya to'g'ri kelishi haqidagi ko'rsatmalar ushbu kitob doirasidan tashqarida. Rust hamjamiyatidagi(community) ko'p odamlar o'z loyihalarini Rust bilan bir xil tarzda <code>MIT OR Apache-2.0</code> qo'sh litsenziyasidan foydalangan holda litsenziyalashadi. Ushbu amaliyot shuni ko'rsatadiki, loyihangiz uchun bir nechta litsenziyaga ega bo'lish uchun <code>OR</code> bilan ajratilgan bir nechta litsenziya identifikatorlarini ham belgilashingiz mumkin.</p>
<p>Noyob nom, versiya, tavsif(description) va litsenziya qo ªshilgan holda nashr etishga tayyor bo ªlgan loyiha uchun <em>Cargo.toml</em> fayli quyidagicha ko ªrinishi mumkin:</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;kalkulyator&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;Sanoq tizimlari bilan ishlaydigan kalkulyator&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo hujjatlarida</a> boshqalar sizning cratengizni osongina topishi va undan foydalanishi uchun siz belgilashingiz mumkin bo'lgan boshqa metama'lumotlar tasvirlangan.</p>
<h3 id="cratesio-da-nashr-qilish"><a class="header" href="#cratesio-da-nashr-qilish">Crates.io-da nashr qilish</a></h3>
<p>Endi siz hisob(account) yaratdingiz, API tokeningizni saqladingiz, cratengiz uchun nom tanladingiz va kerakli metama ºlumotlarni ko ªrsatdingiz, siz nashr(publish) qilishga tayyorsiz! Crateni nashr qilish boshqalar foydalanishi uchun <a href="https://crates.io/">crates.io</a><!-- ignore --> saytiga ma'lum bir versiyani yuklaydi.</p>
<p>Ehtiyot bo'ling, chunki nashr <em>doimiydir(permanent)</em>. Versiyani hech qachon qayta yozib bo'lmaydi va kodni o'chirib bo'lmaydi.<a href="https://crates.io/">crates.io</a><!-- ignore --> -ning asosiy maqsadlaridan biri doimiy kod arxivi bo'lib xizmat qilishdir, shunda <a href="https://crates.io/">crates.io</a><!-- ignore -->-dan cratelarga bog'liq bo'lgan barcha loyihalar o'z ishini davom ettiradi. Versiyani o'chirishga ruxsat berish bu maqsadni amalga oshirishni imkonsiz qiladi. Biroq, siz nashr(publish) etishingiz mumkin bo'lgan crate versiyalari soniga cheklov yo'q.</p>
<p><code>cargo publish</code> buyrug'ini qayta ishga tushiring. Endi u muvaffaqiyatli bo'lishi kerak:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging kalkulyator v0.1.0 (file:///projects/kalkulyator)
   Verifying kalkulyator v0.1.0 (file:///projects/kalkulyator)
   Compiling kalkulyator v0.1.0
(file:///projects/kalkulyator/target/package/kalkulyator-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading kalkulyator v0.1.0 (file:///projects/kalkulyator)
</code></pre>
<p>Tabriklaymiz! Siz endi kodingizni Rust hamjamiyatiga(community) ulashdingiz va
har kim o'z loyihasiga dependency sifatida cratengizni osongina qo'shishi mumkin.</p>
<h3 id="mavjud-cratening-yangi-versiyasini-nashr-qilish"><a class="header" href="#mavjud-cratening-yangi-versiyasini-nashr-qilish">Mavjud cratening yangi versiyasini nashr qilish</a></h3>
<p>Cratengizga o ªzgartirishlar kiritib, yangi versiyani chiqarishga tayyor bo ªlgach, <em>Cargo.toml</em> faylida ko ªrsatilgan <code>version</code> qiymatini o ªzgartirasiz va qayta nashr qilasiz. Siz kiritgan o'zgartirishlar turiga qarab keyingi versiya raqami qanday bo'lishini aniqlash uchun <a href="http://semver.org/">semantik versiya qoidalaridan</a> foydalaning.
Keyin yangi versiyani yuklash uchun <code>cargo publish</code>ni ishga tushiring.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="cratesio-dan-cargo-yank-bilan-eskirgan-versiyalar"><a class="header" href="#cratesio-dan-cargo-yank-bilan-eskirgan-versiyalar">Crates.io-dan <code>cargo yank</code> bilan eskirgan versiyalar</a></h3>
<p>Cratening oldingi versiyalarini olib tashlamasangiz ham, kelajakdagi loyihalarni ularni yangi dependency sifatida qo'shishning oldini olishingiz mumkin. Bu crate versiyasi bir yoki boshqa sabablarga ko'ra buzilganda foydalidir. Bunday vaziyatlarda Cargo crate versiyasini <em>yanking(tortib)</em> olishni qo'llab-quvvatlaydi.</p>
<p>Versiyani yanking o'zgartirish yangi loyihalarning ushbu versiyaga bog'lanishiga to'sqinlik qiladi, lekin shunga qaramay, unga bog'liq bo'lgan barcha mavjud loyihalarni ishlashni davom ettirishga imkon beradi. Aslini olganda, yank degani <em>Cargo.lock</em> bilan barcha loyihalar buzilmasligini va kelajakda yaratilgan <em>Cargo.lock</em> fayllari yanked versiyasidan foydalanmasligini anglatadi.</p>
<p>Cratening versiyasini tortib olish uchun siz avval nashr qilgan crate jildida  <code>cargo yank</code> ni ishga tushiring va qaysi versiyani yank qilishni belgilang. Misol uchun, agar biz <code>kalkulyator</code> nomli 1.0.1 versiyasini chop etgan bo'lsak va biz uni yank qilib olmoqchi bo'lsak, <code>kalkulyator</code> loyihasi jildida biz quyidagi amllarni bajaramiz:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank kalkulyator@1.0.1
</code></pre>
<p>Buyruqga <code>--undo</code> ni qo'shish orqali siz <code>yank</code> ni bekor qilishingiz va loyihalarni versiyaga qarab qaytadan boshlashga ruxsat berishingiz mumkin:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank kalkulyator@1.0.1
</code></pre>
<p>Yank <em>hech qanday kodni o'chirmaydi</em>. U, masalan, tasodifan yuklangan secretlarni o'chira olmaydi. Agar bu sodir bo'lsa, siz ushbu secretlarni darhol tiklashingiz kerak.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-workspacelar"><a class="header" href="#cargo-workspacelar">Cargo Workspacelar</a></h2>
<p>12-bobda biz bianry crate va kutubxona cratesini o'z ichiga olgan paketni yaratdik. Loyihangiz rivojlanib borgan sari, kutubxona(library) cratesi kattalashib borishini va paketingizni bir nechta kutubxona cratelariga bo'lishni xohlayotganingizni ko'rishingiz mumkin. Cargo tandemda ishlab chiqilgan bir nechta tegishli paketlarni boshqarishga yordam beradigan <em>workspaces</em> deb nomlangan xususiyatni taklif etadi.</p>
<h3 id="workspace-yaratish"><a class="header" href="#workspace-yaratish">Workspace yaratish</a></h3>
<p><em>workspace</em> - bu bir xil <em>Cargo.lock</em> va output(chiqish) jildiga ega bo'lgan paketlar to'plami. Keling, workspcedan foydalangan holda loyiha yarataylik - biz workspacening tuzilishiga e'tibor qaratishimiz uchun arzimas koddan foydalanamiz. Workspaceni tuzishning bir necha yo'li mavjud, shuning uchun biz faqat bitta umumiy usulni ko'rsatamiz. Binary(ikkilik) va ikkita kutubxonani o'z ichiga olgan workspacega ega bo'lamiz. Asosiy funksionallikni ta'minlaydigan binary ikkita kutubxonaga bog'liq bo'ladi. Bitta kutubxona <code>bitta_qoshish</code> funksiyasini, ikkinchi kutubxona esa <code>ikkita_qoshish</code> funksiyasini taqdim etadi.
Ushbu uchta crate bir xil workspacening bir qismi bo'ladi. Biz workspaceni uchun yangi jild yaratishdan boshlaymiz:</p>
<pre><code class="language-console">$ mkdir qoshish
$ cd qoshish
</code></pre>
<p>Keyinchalik, <em>qoshuvchi</em> jildida biz butun workspaceni sozlaydigan <em>Cargo.toml</em> faylini yaratamiz. Bu faylda <code>[package]</code> bo ªlimi bo ªlmaydi.
Buning o'rniga, u binary(ikkilik) crate yordamida paketga yo'lni ko'rsatib, workspacega a'zolar qo'shish imkonini beruvchi <code>[workspace]</code> bo'limidan boshlanadi; bu holda, bu yo'l <em>qoshuvchi</em>:</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;qoshuvchi&quot;,
]
</code></pre>
<p>Keyin, <em>qoshuvchi</em> jilida <code>cargo new</code> ni ishga tushirish orqali <code>qoshuvchi</code> binary cratesini yaratamiz:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new qoshuvchi
     Created binary (application) `qoshuvchi` package
</code></pre>
<p>Ushbu nuqtada biz <code>cargo build</code> ni ishga tushirish orqali worksoaceni qurishimiz mumkin. Sizning <em>qoshuvchi</em> jildingiz quyidagicha ko'rinishi kerak:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ qoshuvchi
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<p>Workspaceda kompilyatsiya qilingan artefaktlar joylashtiriladigan top leveldagi bitta <em>target</em> jildi mavjud; <code>qoshuvchi</code> paketi o'zining <em>target</em> jildiga ega emas. Agar biz <em>qoshuvchi</em> jildi ichidan <code>cargo build</code>ni ishga tushirsak ham, kompilyatsiya qilingan artefaktlar hali ham <em>qoshish/qoshuvchi/target</em> emas, balki <em>qoshish/target</em> da tugaydi. Cargo workspacedagi <em>target</em> jildini shunday tuzadi, chunki workspacedagi cratelar bir-biriga bog'liq bo'lishi kerak. Agar har bir crate o'zining <em>target</em> jildiga ega bo'lsa, har bir crate artefaktlarni o'zining <em>target</em> jildiga joylashtirish uchun workspacedagi boshqa cratelarning har birini qayta kompilyatsiya qilishi kerak edi. Bitta <em>target</em> jildini baham ko'rish(share) orqali cratelar keraksiz rebuildingdan qochishi mumkin.</p>
<h3 id="workspaceda-ikkinchi-paketni-yaratish"><a class="header" href="#workspaceda-ikkinchi-paketni-yaratish">Workspaceda ikkinchi paketni yaratish</a></h3>
<p>Keyinchalik, workspaceda boshqa a'zolar(member) paketini yaratamiz va uni <code>bitta_qoshish</code> deb nomlaymiz. <code>members</code> ro'yxatida <em>bitta_qoshish</em> yo'lini belgilash uchun top leveldagi <em>Cargo.toml</em> ni o'zgartiring:</p>
<p><span class="filename">Fayl nomi: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;qoshuvchi&quot;,
    &quot;bitta_qoshish&quot;,
]
</code></pre>
<p>Keyin <code>bitta_qoshish</code> nomli yangi kutubxonalibrary cratesini yarating:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf bitta_qoshish
cargo new bitta_qoshish --lib
copy output below
-->
<pre><code class="language-console">$ cargo new bitta_qoshish --lib
     Created library `bitta_qoshish` package
</code></pre>
<p>Sizning <em>qoshish</em> jildingizda endi quyidagi jild va fayllar bo‚Äòlishi kerak:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ bitta_qoshish
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ qoshuvchi
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<p><em>bitta_qoshish/src/lib.rs</em> fayliga <code>bitta_qoshish</code> funksiyasini qo'shamiz:</p>
<p><span class="filename">Fayl nomi: bitta_qoshish/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn bitta_qoshish(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Endi biz kutubxonamizga ega bo'lgan <code>bitta_qoshish</code> paketiga bog'liq bo'lgan <code>qoshuvchi</code> paketiga ega bo'lishimiz mumkin. Birinchidan, biz <em>qoshuvchi/Cargo.toml</em> ga <code>bitta_qoshish</code> yo'liga bog'liqlikni qo'shishimiz kerak.</p>
<p><span class="filename">Fayl nomi: qoshuvchi/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
bitta_qoshish = { path = &quot;../bitta_qoshish&quot; }
</code></pre>
<p>Cargo workspacedagi cratelar bir-biriga bog'liq bo'ladi deb o'ylamaydi, shuning uchun biz qaramlik munosabatlari(relationship) haqida aniq bo'lishimiz kerak.</p>
<p>Keyin, keling, <code>qoshuvchi</code> cratedagi <code>bitta_qoshish</code> funksiyasidan (<code>bitta_qoshish</code> cratesidan) foydalanamiz. <em>qoshuvchi/src/main.rs</em> faylini oching va yangi <code>bitta_qoshish</code> kutubxona cratesini qamrab olish uchun tepaga <code>use</code> qatorini qo'shing. Keyin 14-7 ro ªyxatdagi kabi <code>bitta_qoshish</code> funksiyasini chaqirish uchun <code>main</code> funksiyani o ªzgartiring.</p>
<p><span class="filename">Fayl nomi: qoshuvchi/src/main.rs</span></p>
<pre><code class="language-rust ignore">use bitta_qoshish;

fn main() {
    let raqam = 10;
    println!(&quot;Salom, Rust! {raqam} plyus bir {} ga teng!&quot;, bitta_qoshish::bitta_qoshish(raqam));
}</code></pre>
<p><span class="caption">Ro ªyxat 14-7: <code>bitta_qoshish</code> kutubxonasi cratesidan <code>qoshish</code> cratesidan foydalanish</span></p>
<p>Keling, yuqori darajadagi <em>qoshish</em> jildida <code>cargo build</code>ni ishga tushirish orqali workspaceni build qilaylik!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling bitta_qoshish v0.1.0 (file:///projects/qoshish/bitta_qoshish)
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshish/qoshuvchi)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>Binary crateni <em>qoshish</em> jildidan ishga tushirish uchun biz <code>-p</code> argumenti va <code>cargo run</code> bilan paket nomidan foydalanib workspaceda qaysi paketni ishga tushirishni belgilashimiz mumkin:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p qoshuvchi
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/qoshuvchi`
Salom, Rust! 10 plyus bir 11 ga teng!
</code></pre>
<p>Bu kodni <em>qoshuvchi/src/main.rs</em> da ishga tushiradi, bu <code>bitta_qoshish</code> cratesiga bog'liq.</p>
<h4 id="workspacedagi-tashqiexternal-paketga-bogliqlik"><a class="header" href="#workspacedagi-tashqiexternal-paketga-bogliqlik">Workspacedagi tashqi(external) paketga bog'liqlik</a></h4>
<p>E'tibor bering, workspaceda har bir crate jildida <em>Cargo.lock</em> emas, balki top leveldagi faqat bitta <em>Cargo.lock</em> fayli mavjud. Bu barcha cratelar barcha depencilarning(bog'liqlik) bir xil versiyasidan foydalanishini ta'minlaydi. Agar biz <em>qoshuvchi/Cargo.toml</em> va <em>bitta_qoshish/Cargo.toml</em> fayllariga <code>rand</code> paketini qo'shsak, Cargo ikkalasini ham <code>rand</code> ning bitta versiyasida hal qiladi va buni bitta <em>Cargo.lock</em>da qayd etadi. Workspacedagi barcha cratelarni bir xil depensilardan foydalanishga aylantirish, cratelarning har doim bir-biriga mos kelishini anglatadi. Keling, <em>bitta_qoshish/Cargo.toml</em> faylidagi <code>[dependencies]</code> bo'limiga <code>rand</code> cratesini qo'shamiz, shunda biz <code>bitta_qoshish</code> cratesida <code>rand</code> cratesidan foydalanishimiz mumkin:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Fayl nomi: bitta_qoshish/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>Endi biz <em>bitta_qoshish/src/lib.rs</em> fayliga <code>use rand;</code> ni qo'shishimiz mumkin va <em>qoshish</em> jildida <code>cargo build</code>-ni ishga tushirish orqali butun workspaceni build qilish <code>rand</code> cratesini olib keladi va kompilyatsiya qiladi. Biz bitta ogohlantirish olamiz, chunki biz qamrab olgan <code>rand</code> ni nazarda tutmayapmiz:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling bitta_qoshish v0.1.0 (file:///projects/qoshish/bitta_qoshish)
warning: unused import: `rand`
 --&gt; bitta_qoshish/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `bitta_qoshish` (lib) generated 1 warning
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshish/qoshuvchi)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>Top leveldagi <em>Cargo.lock</em> endi <code>bitta_qoshish</code> <code>rand</code> ga bog'liqligi(dependency) haqida ma'lumotni o'z ichiga oladi. Biroq, workspacening biror joyida <code>rand</code> ishlatilsa ham, ularning <em>Cargo.toml</em> fayllariga <code>rand</code> qo'shmagunimizcha, biz uni workspacedagi boshqa cratelarda ishlata olmaymiz. Masalan, agar biz <code>qoshuvchi</code> paketi uchun <em>qoshuvchi/src/main.rs</em> fayliga <code>use rand;</code> qo'shsak, xatoga duch kelamiz:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling qoshuvchi v0.1.0 (file:///projects/qoshish/qoshuvchi)
error[E0432]: unresolved import `rand`
 --&gt; qoshuvchi/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>Buni tuzatish uchun <code>qoshuvchi</code> paketi uchun <em>Cargo.toml</em> faylini tahrirlang va <code>rand</code> ham unga dependency(bog'liqligini) ekanligini ko'rsating. <code>qoshuvchi</code> paketini yaratish <em>Cargo.lock</em> dagi <code>qoshuvchi</code> uchun depensiar ro'yxatiga <code>rand</code> qo'shadi, lekin <code>rand</code> ning qo'shimcha nusxalari yuklab olinmaydi. Cargo <code>rand</code> paketidan foydalangan holda workspacedagi har bir cratedagi har bir crate bir xil versiyadan foydalanishini ta ºminladi, bu bizga joyni tejaydi va workspacedagi cratelar bir-biriga mos kelishini ta ºminlaydi.</p>
<h4 id="workspacega-test-qoshish"><a class="header" href="#workspacega-test-qoshish">Workspacega test qo'shish</a></h4>
<p>Yana bir yaxshilanish uchun, keling, <code>bitta_qoshish</code> cratesidagi <code>bitta_qoshish::bitta_qoshish</code> funksiyasi testini qo'shamiz:</p>
<p><span class="filename">Fayl nomi: bitta_qoshish/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn bitta_qoshish(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ishlamoqda() {
        assert_eq!(3, bitta_qoshish(2));
    }
}</code></pre>
<p>Top-leveldagi <em>qoshish</em> jildida <code>cargo test</code>-ni ishga tushiring. Shunga o'xshash tuzilgan workspaceda <code>cargo test</code> ni o'tkazish workspacedagi barcha cratelar uchun testlarni o'tkazadi:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling bitta_qoshish v0.1.0 (file:///projects/qoshish/bitta_qoshish)
   Compiling adder v0.1.0 (file:///projects/qoshish/qoshuvchi)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/bitta_qoshish-f0253159197f7841)

running 1 test
test tests::ishlamoqda ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/qoshuvchi-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests bitta_qoshish

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Chiqishning(output) birinchi qismida <code>bitta_qoshish</code> cratesidagi <code>ishlamoqda</code> testi muvaffaqiyatli o'tganligi ko'rsatilgan. Keyingi bo'limda <code>qoshuvchi</code> cratesida nol testlar topilganligi ko'rsatilgan, so'ngra oxirgi bo'lim <code>bitta_qoshish</code> cratesida nol hujjat testlari topilganligini ko'rsatadi.</p>
<p>Bundan tashqari, biz top leveldagi jilddan <code>-p</code> flagidan foydalanib va biz test qilib ko'rmoqchi bo'lgan crate nomini ko'rsatib, workspacedagi ma'lum bir crate uchun testlarni o'tkazishimiz mumkin:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p bitta_qoshish
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p bitta_qoshish
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/bitta_qoshish-b3235fea9a156f74)

running 1 test
test tests::ishlamoqda ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests bitta_qoshish

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Bu chiqishda <code>cargo test</code> ko ªrsatilgan, faqat <code>bitta_qoshish</code> cratesi uchun stestlar o ªtkazilgan va <code>qoshuvchi</code> cratesi testlari o ªtkazilmagan.</p>
<p>Agar siz workspacedagi cratelarni <a href="https://crates.io/">crates.io</a>-ga nashr(publish) qilsangiz, workspacedagi har bir crate alohida nashr etilishi kerak bo'ladi.
<code>cargo test</code> singari, biz <code>p</code> flagidan foydalanib va nashr qilmoqchi bo'lgan crate nomini ko'rsatib, workspacemizda ma'lum bir crateni nashr qilishimiz mumkin.</p>
<p>Qo'shimcha mashq qilish uchun ushbu workspacega <code>bitta_qoshish</code> cratesga o'xshash <code>ikkita_qoshish</code> cratesini qo'shing!</p>
<p>Loyihangiz o'sib ulg'aygan sayin, workspacedan foydalanishni o'ylab ko'ring: bitta katta kod blokidan ko'ra kichikroq, individual komponentlarni tushunish osonroq. Bundan tashqari, cratelarni workspaceda saqlash, agar ular bir vaqtning o'zida tez-tez almashtirilsa, cratelar orasidagi muvofiqlashtirishni osonlashtirishi mumkin.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="binaryikkilik-fayllarni-cargo-install-bilan-ornatish"><a class="header" href="#binaryikkilik-fayllarni-cargo-install-bilan-ornatish">Binary(ikkilik) fayllarni <code>cargo install</code> bilan o'rnatish</a></h2>
<p><code>cargo install</code> buyrug'i binary cratelarni mahalliy(local) sifatida o'rnatish va ishlatish imkonini beradi. Bu tizim paketlarini almashtirish uchun mo'ljallanmagan; Bu Rust dasturchilari uchun <a href="https://crates.io/">crates.io</a><!-- ignore --> saytida boshqalar baham ko'rgan toollarni o'rnatishning qulay usuli bo'lishi kerak. E'tibor bering, siz faqat binary targetlarga ega bo'lgan paketlarni o'rnatishingiz mumkin. <em>binary target</em> bu o'z-o'zidan ishga tushirilmaydigan, lekin mos bo'lgan kutubxona(library) targetdidan farqli o'laroq, src/main.rs fayli yoki cratening bir qismi sifatida bajariladigan boshqa faylni o'z ichiga olgan bajariladigan dastur. Boshqa dasturlarga kiritish uchun. Odatda, cratelar <em>README</em> faylida crate va kutubxona ekanligi, binary targetli yoki har ikkalasi haqida ma'lumotga ega.</p>
<p><code>cargo install</code> bilan o'rnatilgan barcha binary fayllar o'rnatish ildizining(root) <em>bin</em> jildida saqlanadi. Rust-ni <em>rustup.rs</em> yordamida o'rnatgan bo'lsangiz va hech qanday maxsus konfiguratsiyaga ega bo'lmasangiz, bu jild <em>$HOME/.cargo/bin</em> bo'ladi. <code>cargo install</code> bilan o ªrnatgan dasturlarni ishga tushirish uchun jildingiz <code>$PATH</code>da ekanligiga ishonch hosil qiling.</p>
<p>Masalan, 12-bobda biz fayllarni qidirish uchun <code>ripgrep</code> deb nomlangan <code>grep</code> toolining Rust ilovasi mavjudligini eslatib o'tdik. Keling <code>ripgrep</code> ni o'rnatish uchun biz quyidagilarni ishga tushirishimiz mumkin:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>Chiqishning ikkinchidan oxirgi qatori o'rnatilgan binary faylning joylashuvi va nomini ko'rsatadi, bu <code>ripgrep</code> holatida <code>rg</code>dir. O'rnatish jildi <code>$PATH</code> da bo'lsa, avval aytib o'tilganidek, siz <code>rg --help</code> ni ishga tushirishingiz va fayllarni qidirish uchun tezroq, rustda kuchidan foydalanib yozilgan tooldan foydalanishni boshlashingiz mumkin!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="maxsus-buyruqlar-bilan-cargoni-kengaytirish"><a class="header" href="#maxsus-buyruqlar-bilan-cargoni-kengaytirish">Maxsus buyruqlar bilan cargoni kengaytirish</a></h2>
<p>Cargo cargoni o'zini o'zgartirmasdan, uni yangi kichik buyruqlar bilan kengaytirishingiz uchun mo'ljallangan. Agar <code>$PATH</code>-dagi binary fayl <code>cargo-birnarsa</code> deb nomlangan bo'lsa, uni <code>cargo birnarsasi</code>ni ishga tushirish orqali uni Cargo kichik buyrug'i kabi ishga tushirishingiz mumkin. Bu kabi maxsus buyruqlar <code>cargo --list</code> ishga tushirilganda ham ro'yxatga olinadi. Kengaytmalarni(extension) o'rnatish va keyin ularni xuddi o'rnatilgan Cargo toollari kabi ishga tushirish uchun <code>cargo install</code> dan foydalanish imkoniyati Cargo dizaynining o'ta qulay afzalligidir!</p>
<h2 id="xulosa-13"><a class="header" href="#xulosa-13">Xulosa</a></h2>
<p>Cargo va <a href="https://crates.io/">crates.io</a><!-- ignore --> bilan kod almashish Rust ekotizimini turli xil vazifalar uchun foydali qiladigan dizaynning bir qismidir. Rustning standart kutubxonasi(standard library) kichik va barqaror(stable), lekin cratelarni almashish(share), ishlatish va tildagidan farqli vaqt jadvalida yaxshilash oson. <a href="https://crates.io/">crates.io</a><!-- ignore--> saytida sizga foydali bo'lgan kodni baham(share) ko'rishdan uyalmang, ehtimol u boshqa birovga ham foydali bo'lishi mumkin!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointerlar"><a class="header" href="#smart-pointerlar">Smart Pointerlar</a></h1>
<p><em>Pointer</em> bu xotirada biror manzilni o'z ichiga olgan o'zgaruvchi uchun umumiy
tushuncha. Ushbu manzil biror boshqa ma'lumotga ishora qiladi. Rustda eng keng
tarqalgan pointer turi bu siz 4-bobda o'rgangan reference hisoblanadi.
Referencelar <code>&amp;</code> belgisi bilan ko'rsatiladi va qaratilgan qiymatni qarzga oladi.
Ularning ma'lumotga murojaat qilishdan boshqa hech qanday maxsus qobiliyati
bo'lmaydi.</p>
<p><em>Smart pointerlar</em> esa pointer kabi ishlaydigan, lekin qo'shimcha
metama'lumotlar va imkoniyatlarga ega ma'lumot tuzilmalaridir. Smart pointerlar
tushunchasi faqatgina Rustda yagona emas: smart pointerlar C++da paydo bo'lgan
va boshqa tillarda ham mavjud. Rust standart kutubxonasi taqdim etadigan turli
xil smart pointerlarga ega bo'lib, ular referencelardan tashqari funksionallikni
ta'minlaydi. Umumiy tushunchani o'rganish uchun biz smart pointerlarning bir
nechta turli misollarini ko'rib chiqamiz, jumladan <em>reference hisoblash</em> smart
pointer turi. Ushbu pointer sizga egalar sonini kuzatish orqali ma'lumotning bir
nechta egalari bo'lish imkonini beradi va egalari qolmaganda ma'lumotni
tozalaydi.</p>
<p>Rust o'zining egalik va qarz olish tushunchasi bilan referencelar va smart
pointerlar o'rtasida qo'shimcha farqga ega: referencelar faqat ma'lumotlarni
qarzga olsa, ko'p hollarda smart pointerlar ma'lumotga <em>egalik</em> qiladilar.</p>
<p>Garchi biz ularni o‚Äòsha paytda shunday deb atamagan bo‚Äòlsak-da, biz ushbu
kitobda bir nechta smart pointerlarga duch keldik, jumladan, 8-bobdagi <code>String</code>
va <code>Vec&lt;T&gt;</code>. Bu ikkala tur ham smart pointer hisoblanadi, chunki u biror
xotiraga egalik qiladi va sizga uni manipulyatsiya qilish imkonini beradi.
Shuningdek, ularda metama'lumot va qo'shimcha imkoniyatlar yoki kafolatlar
bo'ladi. Masalan, <code>String</code> o'z sig'imini metama'lumot sifatida saqlaydi va uning
ma'lumoti har doim UTF-8 bo'lishini ta'minlash uchun qo'shimcha xususiyatga ega.</p>
<p>Smart pointerlar odatda structlar yordamida amalga oshiriladi. Oddiy structdan
farqli o'laroq, smart pointerlar <code>Deref</code> va <code>Drop</code> traitlarini amalga oshiradi.
<code>Deref</code> traiti smart pointer struct-ning instancesiga reference kabi o'zini
tutish imkonini beradi, shunday qilib siz ikkala referencelar yoki smart
pointerlar bilan ishlash uchun kod yozishingiz mumkin. <code>Drop</code> traiti smart
pointerning instancesi scopedan chiqib ketganda ishga tushadigan kodni
moslashtirish imkonini beradi. Ushbu bobda biz ikkala traitni muhokama qilamiz
va nima uchun ular smart pointerlar uchun muhimligini ko'rsatamiz.</p>
<p>Smart pointer patterni Rustda tez-tez ishlatiladigan umumiy dizayn patterni
ekanligini hisobga olsak, bu bobda mavjud bo'lgan barcha smart pointerlar qamrab
olinmaydi. Ko'pgina kutubxonalarda o'zlarining smart pointerlari mavjud va siz
hatto o'zingiznikini yozishingiz mumkin. Biz standart kutubxonadagi eng keng
tarqalgan smart pointerlarni ko'rib chiqamiz:</p>
<ul>
<li><code>Box&lt;T&gt;</code> heapga qiymatlarni joylashtirish uchun</li>
<li><code>Rc&lt;T&gt;</code>, bir nechta egalik qilish imkonini beruvchi referencelar hisoblash
turi</li>
<li><code>Ref&lt;T&gt;</code> va <code>RefMut&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> orqali kiriladi, bu qarz olish
qoidalariga kompilyatsiya vaqti o'rniga runtimeda rioya qilishga majburlovchi
tur</li>
</ul>
<p>Bundan tashqari, biz <em>ichki o'zgaruvchanlik</em> patternini ko'rib chiqamiz, bunda
o'zgarmas tur ichki qiymatni o'zgartirish uchun APIni ochib beradi. Shuningdek,
biz <em>reference davrlarini</em> muhokama qilamiz: ular xotirani oqishiga olib kelishi
va ularni qanday oldini olish mumkin.</p>
<p>Keling sho'ng'iymiz!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="heapdagi-malumotlarni-korsatish-uchun-boxt-dan-foydalanish"><a class="header" href="#heapdagi-malumotlarni-korsatish-uchun-boxt-dan-foydalanish">Heapdagi ma'lumotlarni ko'rsatish uchun <code>Box&lt;T&gt;</code> dan foydalanish</a></h2>
<p>Eng sodda smart pointer bu <em>box</em> bo'lib, uning turi <code>Box&lt;T&gt;</code> deb yoziladi.
Boxlar sizga ma'lumotlarni stackda emas, balki heapda saqlashga imkon beradi.
Stackda esa heapdagi ma'lumotlariga pointer qoladi. Stack va heap o'rtasidagi
farqni ko'rib chiqish uchun 4-bobga qarang.</p>
<p>Boxlar o'z ma'lumotlarini stackda emas, balki heapda saqlashdan tashqari,
ishlash bo'yicha qo'shimcha xarajatlarga ega emas. Lekin ularda ko'p qo'shimcha
imkoniyatlar ham yo'q. Siz ulardan ko'pincha quyidagi holatlarda foydalanasiz:</p>
<ul>
<li>Agar sizda kompilyatsiya vaqtida o'lchami noma'lum bo'lgan tur mavjud bo'lsa
va siz aniq o'lchamni talab qiladigan kontekstda ushbu turdagi qiymatdan
foydalanmoqchi bo'lsangiz</li>
<li>Agar sizda katta hajmdagi ma ºlumotlar mavjud bo ªlsa va siz egalik huquqini
o ªtkazganingizda ma ºlumotlardan nusxa olinmasligiga ishonch hosil qilmoqchi
bo'lsangiz</li>
<li>Agar siz biror qiymatga egalik qilmoqchi bo'lsangiz va siz uni ma'lum bir
turda bo'lishiga emas, balki ma'lum bir traitni implement qiluvchi tur
bo'lishi haqida qayg'ursangiz</li>
</ul>
<p>Birinchi holatni
<a href="ch15-01-box.html#rekursiv-turlarni-boxlar-bilan-qollash">‚ÄúRekursiv turlarni Boxlar bilan qo'llash‚Äù</a><!-- ignore -->
bo‚Äòlimida ko‚Äòrsatamiz. Ikkinchi holatda, katta hajmdagi ma'lumotlarga egalik
huquqini o'tkazish uzoq vaqt talab qilishi mumkin, chunki ma'lumotlar stackdan
ko'chiriladi. Bunday vaziyatda ishlashni yaxshilash uchun biz katta hajmdagi
ma'lumotlarni heapda box ichida saqlashimiz mumkin. Shundan so'ng, pointer
ma'lumotlarining faqat kichik miqdori stackdan ko'chiriladi, heapdagi u
reference qilingan ma'lumotlar esa bir joyda qoladi. Uchinchi holat <em>trait object</em>
sifatida tanilgan va butun 17-bob shu mavzuga bag'ishlangan,
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‚ÄúTurli turdagi qiymatlarga ruxsat beruvchi Trait Objectlaridan foydalanish‚Äù</a><!-- ignore -->
o'sha mavzu. Shunday qilib, bu erda o'rgangan narsalaringizni 17-bobda yana
qo'llaysiz!</p>
<h3 id="heapda-malumotlarni-saqlash-uchun-boxt-dan-foydalanish"><a class="header" href="#heapda-malumotlarni-saqlash-uchun-boxt-dan-foydalanish">Heapda ma'lumotlarni saqlash uchun <code>Box&lt;T&gt;</code> dan foydalanish</a></h3>
<p><code>Box&lt;T&gt;</code> uchun heap xotiradan foydalanish holatini muhokama qilishdan oldin, biz
sintaksisni va <code>Box&lt;T&gt;</code> ichida saqlangan qiymatlar bilan qanday o'zaro aloqa
qilishni ko'rib chiqamiz.</p>
<p>15-1 ro'yxatda <code>i32</code> qiymatini heapda saqlash uchun boxdan qanday foydalanish
ko'rsatilgan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 15-1: <code>i32</code> qiymatini box yordamida heapda
saqlash</span></p>
<p>Biz <code>b</code> o'zgaruvchini heapda joylashgan <code>5</code>ga point qiluvchi <code>Box</code> qiymatiga ega
bo'lishi uchun e'lon qilamiz. Ushbu dastur <code>b = 5</code> ni chop etadi; bu holda biz
boxdagi ma'lumotlarga, stackda bo'lgani kabi kirishimiz mumkin. <code>main</code>ning
oxiridagi <code>b</code> kabi boxlar scopedan chiqib ketganda, xuddi egalik qilingan
qiymatlarga o'xshab, u ham xotiradan o'chiriladi. O'chirilish ham box (stackda
saqlanuvchi) uchun va u point qiluvchi ma'lumotlar (heapda saqlanuvchi) uchun
ham sodir bo'ladi.</p>
<p>Heapda bitta qiymat saqlash unchalik foydali emas, shuning uchun boxlarni o'zini
bu tarzda ko'pincha ishlatmaysiz. Ko'pincha holatlarda bitta <code>i32</code> kabi
qiymatlarni stackda saqlash maqsadga muvofiq bo'ladi. Keling, boxlar, agar bizda
boxlar bo'lmasa, ruxsat berilmaydigan turlarni e'lon qilishga imkon beradigan
holatni ko'rib chiqaylik.</p>
<h3 id="rekursiv-turlarni-boxlar-bilan-qollash"><a class="header" href="#rekursiv-turlarni-boxlar-bilan-qollash">Rekursiv turlarni Boxlar bilan qo'llash</a></h3>
<p><em>Rekursiv tur</em>ning qiymati o'zining bir qismi sifatida bir xil turdagi boshqa
qiymatga ega bo'lishi mumkin. Rekursiv turlar muammo tug'diradi, chunki
kompilyatsiya vaqtida Rust tur qancha joy egallashini bilishi kerak. Biroq,
rekursiv turdagi qiymatlarni joylashtirish nazariy jihatdan cheksiz davom etishi
mumkin, shuning uchun Rust qiymat uchun qancha joy kerakligini bilmaydi. Boxlar
ma'lum o'lchamga ega bo'lganligi sababli, biz rekursiv tur ta'rifiga box
kiritish orqali rekursiv turlarni qo'llashimiz mumkin.</p>
<p>Rekursiv turga misol sifatida keling, <em>cons list</em>ni o'rganamiz. Bu funktsional
dasturlash tillarida keng tarqalgan ma'lumotlar turi hisoblanadi. Biz e'lon
qiladigan cons list turi rekursiyadan tashqari sodda; shuning uchun biz
ishlaydigan misoldagi tushunchalar rekursiv turlarni o'z ichiga olgan murakkab
vaziyatlarga tushganingizda foydali bo'ladi.</p>
<h4 id="cons-list-haqida-batafsil-malumot"><a class="header" href="#cons-list-haqida-batafsil-malumot">Cons List haqida batafsil ma'lumot</a></h4>
<p><em>Cons list</em> Lisp dasturlash tili va uning dialektlaridan kelib chiqqan va
ichma-ich juftliklardan tashkil topgan ma ºlumotlar strukturasi bo ªlib, linked
listning Lispdagi versiyasi hisoblanadi. Uning nomi Lispdagi <code>cons</code>
funktsiyasidan (‚Äúconstruct function‚Äù uchun qisqartma) kelib chiqqan bo'lib,
uning ikkita argumentidan yangi juftlik yaratadi. Qiymat va boshqa juftlikdan
iborat bo'lgan juftlikda <code>cons</code> ni chaqirish orqali biz rekursiv juftliklardan
iborat bo'lgan cons list tuzishimiz mumkin.</p>
<p>Misol uchun, bu yerda 1, 2, 3 ro'yxatini o'z ichiga olgan cons listining
psevdokod ko'rinishi, har bir juft qavs ichida:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Cons listdagi har bir element ikkita elementni o'z ichiga oladi: shu elementning
qiymati va keyingi element. Ro'yxatning oxirgi elementida keyingi elementsiz
faqat <code>Nil</code> deb nomlangan qiymatdan iborat bo'ladi. Cons list <code>cons</code>
funksiyasini rekursiv chaqirish orqali hosil qilinadi. Rekursiyaning tubidagi
holatini bildiruvchi qoidaga aylangan nom <code>Nil</code> hisoblanadi. E'tibor bering, bu
6-bobdagi ‚Äúnull‚Äù yoki ‚Äúnil‚Äù tushunchasi bilan bir xil emas, ya'ni noto'g'ri yoki
yo'q qiymat.</p>
<p>Cons list ma'lumotlar tuzilmasi Rust-da tez-tez ishlatilmaydi. Ko'pincha Rust-da
sizga elementlar ro'yxati kerak bo'lsa, <code>Vec&lt;T&gt;</code> foydalanish uchun yaxshiroq
tanlovdir. Boshqa, murakkabroq rekursiv <em>ma'lumot turlaridan</em> foyladanish bir
qancha vaziyatlarda foydalidir, ammo ushbu bobdagi cons listdan boshlab, boxlar
qanday qilib, rekursiv ma'lumot turini e'lon qilishga imkon berishini
o'rganishimiz mumkin.</p>
<p>Ro'yxat 15-2 cons list uchun enum ko'rinishini o'z ichiga oladi. E'tibor bering,
ushbu kod hali kompilyatsiya qilinmaydi, chunki <code>List</code> turi ma'lum hajmga ega
emas, biz buni tushuntiramiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Ro'yxat 15-2: <code>i32</code> qiymatlarining cons list ma'lumotlar
tuzilmasida ifodalash uchun enumni e'lon qilishga birinchi urish</span></p>
<blockquote>
<p>Eslatma: Biz ushbu misol maqsadlari uchun faqat <code>i32</code> qiymatlarini o'z ichiga
olgan cons listni amalga oshirmoqdamiz. Biz 10-bobda muhokama qilganimizdek,
har qanday turdagi qiymatlarni saqlashi mumkin bo'lgan cons list turini
generiklar yordamida e'lon qilishimiz mumkin edi.</p>
</blockquote>
<p><code>List</code> turidan foydalanib <code>1, 2, 3</code> ro ªyxatini saqlash 15-3 ro'yxat kabi
bo'ladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<p><span class="caption">15-3 ro ªyxat: <code>1, 2, 3</code> ro ªyxatini saqlash uchun <code>List</code>
enumidan foydalanish</span></p>
<p>Birinchi <code>Cons</code> qiymati <code>1</code> va boshqa <code>List</code> qiymatiga ega. Bu <code>List</code> qiymati
<code>2</code> va boshqa <code>List</code> qiymatiga ega bo'lgan boshqa <code>Cons</code> qiymatidir. Ushbu
<code>List</code> qiymati <code>3</code> ni o'z ichiga olgan yana bitta <code>Cons</code> qiymati va <code>List</code>
qiymati, nihoyat <code>Nil</code>, ro'yxat oxirini bildiruvchi rekursiv bo'lmagan variant.</p>
<p>Agar biz 15-3 ro'yxatdagi kodni kompilyatsiya qilishga harakat qilsak, biz 15-4
ro'yxatda ko'rsatilgan xatoni olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

For more information about this error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to previous error
</code></pre>
<p><span class="caption">Ro'yxat 15-4: Rekursiv enumni e'lon qilishga urinishda
yuzaga keladigan xato</span></p>
<p>Xato ushbu tur ‚Äúcheksiz o'lchamga ega‚Äù ekanligini ko'rsatadi. Buning sababi
shundaki, biz <code>List</code>ni rekursiv variant bilan e'lon qildik: u bevosita o'zining
boshqa qiymatini saqlaydi. Natijada, Rust <code>List</code> qiymatini saqlash uchun qancha
joy kerakligini aniqlay olmaydi. Keling, nima uchun bu xatoga duch kelganimizni
qismlarga ajratamiz. Birinchidan, Rust rekursiv bo'lmagan turdagi qiymatni
saqlash uchun qancha joy kerakligini qanday hal qilishini ko'rib chiqamiz.</p>
<h4 id="rekursiv-bolmagan-turning-olchamini-hisoblash"><a class="header" href="#rekursiv-bolmagan-turning-olchamini-hisoblash">Rekursiv bo'lmagan turning o'lchamini hisoblash</a></h4>
<p>6-bobda enum ta'riflarini muhokama qilganimizdagi 6-2 ro'yxatda e'lon qilingan
<code>Xabar</code> enumini eslang:</p>
<pre><pre class="playground"><code class="language-rust">enum Xabar {
    Chiqish,
    Kochirish { x: i32, y: i32 },
    Yozish(String),
    RangTanlash(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><code>Xabar</code> qiymati uchun qancha joy ajratish kerakligini aniqlash uchun Rust har
bir variantni ko'rib chiqadi va qaysi variantga ko'proq joy kerakligini
aniqlaydi. Rust <code>Xabar::Chiqish</code> uchun hech qanday joy kerak emasligini,
<code>Xabar::Kochirish</code> ikkita <code>i32</code> qiymatini saqlash uchun yetarli joy kerakligini
aniqlaydi va hokazo. Faqat bitta variant qo'llanilishi sababli, <code>Xabar</code>
qiymatiga kerak bo'ladigan eng ko'p joy-bu uning eng katta variantini saqlash
uchun zarur bo'lgan joy hisoblanadi.</p>
<p>Rust 15-2 ro ªyxatdagi <code>List</code> enum kabi rekursiv turga qancha bo ªsh joy
kerakligini aniqlashga harakat qilganda nima sodir bo ªlishini bu bilan
taqqoslang. Kompilyator <code>i32</code> turidagi qiymat va <code>List</code> turidagi qiymatga ega
bo'lgan <code>Cons</code> variantini ko'rib chiqishdan boshlaydi. Shuning uchun, <code>Cons</code>
uchun <code>i32</code> va <code>List</code> o'lchamiga teng bo'sh joy kerak bo'ladi. <code>List</code> turiga
qancha xotira kerakligini aniqlash uchun kompilyator <code>Cons</code> variantidan boshlab
variantlarni ko'rib chiqadi. <code>Cons</code> variantida <code>i32</code> turidagi qiymat va <code>List</code>
turidagi qiymat mavjud va bu jarayon 15-1-rasmda ko'rsatilganidek, cheksiz davom
etadi.</p>
<img alt="Cheksiz Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">15-1-rasm: Cheksiz <code>Cons</code> variantlaridan iborat cheksiz
<code>List</code></span></p>
<h4 id="olchami-malum-bolgan-rekursiv-turni-elon-qilish-uchun-boxt-dan-foydalanish"><a class="header" href="#olchami-malum-bolgan-rekursiv-turni-elon-qilish-uchun-boxt-dan-foydalanish">O'lchami ma'lum bo'lgan rekursiv turni e'lon qilish uchun <code>Box&lt;T&gt;</code> dan foydalanish</a></h4>
<p>Rust rekursiv e'lon qilingan turlar uchun qancha joy ajratish kerakligini
aniqlay olmaganligi sababli, kompilyator ushbu foydali taklif bilan xatolik
beradi:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>Ushbu taklifda &quot;indirection&quot; qiymatni to'g'ridan-to'g'ri saqlash o'rniga, biz
pointerni qiymatga saqlash orqali qiymatni bilvosita saqlash uchun ma'lumotlar
strukturasini o'zgartirishimiz kerakligini anglatadi.</p>
<p><code>Box&lt;T&gt;</code> pointer bo'lgani uchun Rust har doim <code>Box&lt;T&gt;</code> uchun qancha joy
kerakligini biladi: pointerning o'lchami u ko'rsatayotgan ma'lumotlar miqdoriga
qarab o'zgarmaydi. Bu shuni anglatadiki, biz to'g'ridan-to'g'ri boshqa <code>List</code>
qiymati o'rniga <code>Cons</code> variantiga <code>Box&lt;T&gt;</code> qo'yishimiz mumkin. <code>Box&lt;T&gt;</code> keyingi
<code>List</code> qiymatiga ishora qiladi, bu qiymat <code>Cons</code> varianti ichida emas, balki
heapda bo'ladi. G'oyaga ko'ra, bizda hali ham boshqa ro'yxatlarni o'z ichiga
olgan ro'yxatlar bilan yaratilgan ro'yxat mavjud, ammo bu amalga oshirish endi
elementlarni bir-birining ichiga emas, balki bir-birining yoniga joylashtirishga
o'xshaydi.</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage of
the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</p>
<p>Biz 15-2 ro'yxatidagi <code>List</code> enumni va 15-3 ro'yxatidagi <code>List</code>ning
qo'llanishini 15-5 ro'yxatidagi kodga o'zgartirishimiz mumkin, bu kompilyatsiya
bo'ladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><span class="caption">Ro'yxat 15-5: Ma ºlum o ªlchamga ega bo ªlish uchun <code>Box&lt;T&gt;</code>
dan foydalanadigan <code>List</code>ni e'lon qilinishi</span></p>
<p><code>Cons</code> variantiga <code>i32</code> o'lchamiga va boxdagi pointer ma'lumotlarini saqlash
uchun bo'sh joy kerak. <code>Nil</code> varianti hech qanday qiymatlarni saqlamaydi,
shuning uchun u <code>Cons</code> variantiga qaraganda kamroq joy talab qiladi. Endi
bilamizki, har qanday <code>List</code> qiymati <code>i32</code> o‚Äòlchamini va boxdagi pointer
ma‚Äôlumotlari hajmini egallaydi. Boxdan foydalanib, biz cheksiz, rekursiv
zanjirni buzdik, shuning uchun kompilyator <code>List</code> qiymatini saqlash uchun
kerakli hajmni aniqlay oladi. 15-2-rasmda <code>Cons</code> varianti hozir qanday
ko'rinishi ko'rsatilgan.</p>
<img alt="Cheksiz bo'lmagan Cons list" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">15-2-rasm: Cheksiz o'lchamli bo'lmagan <code>List</code>, chunki
<code>Cons</code> endi <code>Box</code> saqlaydi</span></p>
<p>Boxlar faqat bilvosita va heapda joylashuvni ta'minlaydi; ularda biz boshqa
smart pointerlarda ko'radigan boshqa maxsus imkoniyatlar yo'q. Ular, shuningdek,
ushbu maxsus imkoniyatlarga ega bo'lgan ishlash xarajatlariga ega emaslar,
shuning uchun ular bizga kerak bo'lgan yagona xususiyat bo'lgan cons list kabi
holatlarda foydali bo'lishi mumkin. Biz 17-bobda boxlar uchun ko'proq
foydalanish holatlarini ko'rib chiqamiz.</p>
<p><code>Box&lt;T&gt;</code> turi smart pointerdir, chunki u <code>Deref</code> xususiyatini amalga oshiradi,
bu esa <code>Box&lt;T&gt;</code> qiymatlariga reference kabi qarashga imkonini beradi. <code>Box&lt;T&gt;</code>
qiymati scopedan chiqib ketganda, box ko'rsatayotgan heapdagi ma'lumotlar ham
<code>Drop</code> xususiyatini amalga oshirish tufayli tozalanadi. Ushbu ikki xususiyat biz
ushbu bobning qolgan qismida muhokama qiladigan boshqa smart pointer turlari
tomonidan taqdim etilgan funksionallik uchun yanada muhimroq bo'ladi. Keling,
ushbu ikki xususiyatni batafsil ko'rib chiqaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="smart-pointerlarni-deref-xususiyati-bilan-oddiy-havolalar-kabi-ishlatish"><a class="header" href="#smart-pointerlarni-deref-xususiyati-bilan-oddiy-havolalar-kabi-ishlatish">Smart Pointerlarni <code>Deref</code> Xususiyati Bilan Oddiy Havolalar Kabi Ishlatish</a></h2>
<p><code>Deref</code> xususiyatini qo'llash, <em>dereference operatori</em>ning <code>*</code> (ko'paytirish
yoki glob operatori bilan adashtirmaslik kerak) xulq-atvorini sozlashga imkon
beradi. Smart pointerlarni <code>Deref</code> xususiyati bilan oddiy havolalar kabi
qo'llasangiz, siz havolalar ustida ishlaydigan kod yozishingiz, shuningdek,
ushbu kodni smart pointerlar bilan ishlatishingiz mumkin bo'ladi.</p>
<p>Keling, avvalo, dereference operatori oddiy havolalar bilan qanday ishlashini
ko'rib chiqaylik. Keyin biz <code>Box&lt;T&gt;</code> kabi maxsus turni e'lon qilishga harakat
qilamiz va dereference operatori nega bizning yangi e'lon qilgan turimizdagi
havola kabi ishlamayotganini ko'ramiz. Biz <code>Deref</code> xususiyatini amalga oshirish
smart pointerlarning havolalarga o'xshash tarzda ishlashiga qanday imkon
berishini ko'rib chiqamiz. Keyin biz Rustning <em>deref coercion</em> xususiyatini va
u bizga havolalar yoki smart pointerlar bilan ishlashga qanday imkon berishini
ko'rib chiqamiz.</p>
<blockquote>
<p>Eslatma: biz qurmoqchi bo'lgan <code>MyBox&lt;T&gt;</code> turi va haqiqiy <code>Box&lt;T&gt;</code> o‚Äòrtasida
bitta katta farq bor: bizning versiyamiz o‚Äòz ma‚Äôlumotlarini heapda saqlamaydi.
Biz ushbu misolda e'tiborimizni <code>Deref</code>ga qaratmoqdamiz, shuning uchun 
ma'lumotlarning qayerda saqlanishi pointerga o'xshash xatti-harakatlardan 
kamroq ahamiyatga ega.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="pointerni-qiymatga-boglash"><a class="header" href="#pointerni-qiymatga-boglash">Pointerni Qiymatga bog'lash</a></h3>
<p>Muntazam havola pointerning bir turi bo'lib, pointerni boshqa joyda saqlangan
qiymatga o'q kabi tasavvur qilishning bir usuli. 15-6 ro'yxatda biz <code>i32</code>
qiymatiga havola yaratamiz va keyin qiymatga havolani bog'lash uchun dereference
operatoridan foydalanamiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 15-6: <code>i32</code> qiymatiga havola orqali murojat qilish
uchun dereference operatoridan foydalanish</span></p>
<p><code>x</code> o'zgaruvchisi <code>i32</code> turidagi <code>5</code> qiymatiga ega. Biz <code>y</code> ni <code>x</code> ning
havolasiga tenglashtiramiz. Biz <code>x</code> <code>5</code> ga teng ekanligini solishtirishimiz
mumkin. Ammo, agar biz <code>y</code> dagi qiymatni solishtirmoqchi bo'lsak, kompilyator
haqiqiy qiymatni solishtirishi uchun <code>*y</code> dan foydalanib, u havola qilgan
qiymatga (ya'ni, <em>dereference</em>) murojaat qilishimiz kerak. <code>y</code> da dereference
qo'llaganimizdan so'ng, <code>y</code> ishora qilib turgan butun son qiymatiga kirish
imkoniga ega bo'lamiz, bu <code>5</code> bilan solishtirishimizga imkon beradi.</p>
<p>Agar <code>assert_eq!(5, y);</code> yozishga harakat qilganimizda, ushbu kompilyatsiya
xatoligini olgan bo'lar edik:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = help: the following other types implement trait `PartialEq&lt;Rhs&gt;`:
            f32
            f64
            i128
            i16
            i32
            i64
            i8
            isize
          and 6 others
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Raqam va raqamga havola bilan solishtirishga yo'l qo'yilmaydi, chunki ular har
xil turlar. Biz havola qilingan qiymatga murojaat qilish uchun dereference
operatoridan foydalanishimiz kerak.</p>
<h3 id="boxt-ni-havola-kabi-ishlatish"><a class="header" href="#boxt-ni-havola-kabi-ishlatish"><code>Box&lt;T&gt;</code> ni Havola Kabi Ishlatish</a></h3>
<p>15-6 ro'yxatdagi kodni havola o'rniga <code>Box&lt;T&gt;</code> ishlatgan holda qayta yozishimiz
mumkin; 15-7 ro'yxatdagi funksiyalarida <code>Box&lt;T&gt;</code> da ishlatiladigan dereference
operatori 15-6 ro'yxatidagi havolada ishlatilgan dereference operatori
bilan bir xil tarzda ishlatiladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 15-7: <code>Box&lt;i32&gt;</code> da dereference operatorini
ishlatish</span></p>
<p>15-7 va 15-6 ro'yxat o'rtasidagi asosiy farq shundaki, biz bu yerda <code>y</code> ni <code>x</code>
qiymatiga havola emas, balki <code>x</code> ning ko'chirilgan qiymatiga ishora qiluvchi
<code>Box&lt;T&gt;</code> ning misoli qilib belgiladik. Oxirgi solishtiruvda biz dereference
operatoridan <code>Box&lt;T&gt;</code> ko'rsatgichiga murojat qilish uchun xuddi <code>y</code> havola
bo'lganida qilganimizdek bajarishimiz mumkin. Keyin biz <code>Box&lt;T&gt;</code> ning o'ziga xos
xususiyatlarini o'rganamiz, bu bizga o'z turimizni e'lon qilish orqali
dereference operatoridan foydalanishga imkon beradi. </p>
<h3 id="ozimizning-aqlli-korsatgichimizni-elon-qilish"><a class="header" href="#ozimizning-aqlli-korsatgichimizni-elon-qilish">O'zimizning Aqlli Ko'rsatgichimizni E'lon Qilish</a></h3>
<p>Keling, aqlli ko'rsatgichlar havolalardan qanday farq qilishini bilish uchun
standart kutubxona tomonidan taqdim etilgan <code>Box&lt;T&gt;</code> turiga o'xshash aqlli
ko'rsatgichni yarataylik. Keyin biz dereference operatoridan foydalanish
qobiliyatini qanday qo'shishni ko'rib chiqamiz.</p>
<p><code>Box&lt;T&gt;</code> turi oxir-oqibat bitta elementga ega bo'lgan tuple struct sifatida
aniqlanadi, 15-8 ro'yxatda xuddi shu tarzda <code>MyBox&lt;T&gt;</code> turini belgilaydi.
Shuningdek, <code>Box&lt;T&gt;</code> da belgilangan <code>new</code> funksiyaga mos keladigan <code>new</code>
funksiyani aniqlaymiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 15-8: <code>MyBox&lt;T&gt;</code> turini aniqlash</span></p>
<p>Biz <code>MyBox</code> nomli structni aniqlaymiz va <code>T</code> generic parametrini e'lon qilamiz,
chunki biz turimiz istalgan turdagi qiymatlarni ushlab turishini xohlaymiz.
<code>MyBox</code> turi <code>T</code> turidagi bitta elementga ega bo'lgan tuple structdir.
<code>MyBox::new</code> funksiyasi <code>T</code> turidagi bitta parametrni oladi va berilgan qiymatni
ushlab turuvchi <code>MyBox</code> misolini qaytaradi.</p>
<p>15-7 ro'yxatdagi <code>main</code> funksiyasini 15-8 ro'yxatiga qo'shib, <code>Box&lt;T&gt;</code> o'rniga
biz belgilagan <code>MyBox&lt;T&gt;</code>turidan foydalanish uchun o'zgartirishga harakat
qilaylik. 15-9 ro'yxatdagi kod kompilyatsiya qilinmaydi, chunki Rust <code>MyBox</code> ni
qanday qilib dereference qilishni bilmaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
<p><span class="caption">Ro'yxat 15-9: <code>MyBox&lt;T&gt;</code> dan xuddi havolalar va <code>Box&lt;T&gt;</code>
dan foydalanganimiz kabi foydalanishga urinish</span></p>
<p>Natijada kompilyatsiya xatosi:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Bizning <code>MyBox&lt;T&gt;</code> turini dereference qilib bo'lmaydi, chunki biz bu qobiliyatni
o'z turimizda qo'llamaganmiz. <code>*</code> operatori yordamida dereference qilishni
yoqish uchun biz <code>Deref</code> traitini qo`llaymiz.</p>
<h3 id="deref-traitni-amalga-oshirish-orqali-turga-havola-kabi-munosabatda-bolish"><a class="header" href="#deref-traitni-amalga-oshirish-orqali-turga-havola-kabi-munosabatda-bolish"><code>Deref</code> Traitni Amalga Oshirish Orqali Turga Havola Kabi Munosabatda Bo'lish</a></h3>
<p>10-bobning <a href="ch10-02-traits.html#turga-xos-traitni-amalga-oshirish">‚ÄúTurga xos Traitni amalga
oshirish‚Äù</a><!-- ignore --> bo ªlimida muhokama
qilinganidek, traitni amalga oshirish uchun biz traitning talab qilinadigan
usullarini amalga oshirishimiz kerak. Standart kutubxona tomonidan taqdim
etilgan <code>Deref</code> xususiyati bizdan <code>self</code> qarz oladigan va ichki ma'lumotlarga
havolani qaytaradigan <code>deref</code> nomli metodni qo'llashimizni talab qiladi. 15-10
ro'yxat <code>MyBox</code> ta'rifiga qo'shish uchun <code>Deref</code> amalga oshirilishini o'z ichiga
oladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 15-10: <code>MyBox&lt;T&gt;</code> uchun <code>Deref</code> ni amalga
oshirish</span></p>
<p><code>Type Target = T;</code> sintaksisi foydalanish uchun <code>Deref</code> xususiyati uchun
bog`langan turni belgilaydi. Bog'langan turlar generic parametrni e'lon
qilishning biroz boshqacha usulidir, ammo hozircha ular haqida
tashvishlanishingiz shart emas; biz ularni 19-bobda batafsil yoritamiz.</p>
<p>Biz <code>deref</code> metodining tanasini <code>&amp;self.0</code> bilan to'ldiramiz, shuning uchun
<code>deref</code> biz <code>*</code> operatori bilan kirmoqchi bo'lgan qiymatga havolani qaytaradi;
5-bobning <a href="ch05-01-defining-structs.html#har-xil-turlarni-yaratish-uchun-nomli-maydonlarsiz-tuplelardan-foydalanish">‚ÄúHar xil turlarni yaratish uchun nomli maydonlarsiz tuplelardan
foydalanish‚Äù</a><!-- ignore --> bo ªlimidan <code>.0</code> tuple structidagi
birinchi qiymatga kirishini esga oling. <code>MyBox&lt;T&gt;</code> qiymatida <code>*</code> ni chaqiruvchi
15-9 ro'yxatdagi <code>main</code> funksiya endi kompilyatsiya qilinadi va solishtiruvlar
o`tadi!</p>
<p><code>Deref</code> traitisiz kompilyator faqat <code>&amp;</code> havolalarini dereference qilishi mumkin.
<code>deref</code> metodi kompilyatorga <code>Deref</code> ni qo'llaydigan har qanday turdagi qiymatni
olish va <code>deref</code> usulini chaqirish va <code>&amp;</code> havolasini olish imkoniyatini beradi.</p>
<p>15-9 ro'yxatda <code>*y</code> ga kirganimizda, Rust sahna ortida ushbu kodni ishga
tushirdi:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust <code>*</code> operatorini <code>deref</code> metodini chaqirish va keyin oddiy dereference bilan
almashtiradi, shuning uchun <code>deref</code> metodini chaqirish kerakligi haqida
o'ylamasligimiz kerak. Ushbu Rust xususiyati bizga oddiy havola yoki <code>Deref</code> ni
qo'llaydigan turga ega bo'ladimi, bir xil ishlaydigan kod yozish imkonini
beradi.</p>
<p><code>deref</code> metodi qiymatga havolani qaytarishining sababi va <code>*(y.deref())</code> qavslar
tashqarisidagi oddiy dereference hali ham zarur bo'lishi ownership tizimi bilan
bog'liq. Agar <code>deref</code> usuli qiymatga havola o'rniga to'g'ridan-to'g'ri qiymatni
qaytargan bo'lsa, qiymat <code>o'zidan</code> o'chiriladi. Biz <code>MyBox&lt;T&gt;</code> ichidagi ichki
qiymatga egalik qilishni istamaymiz, bu holatda yoki ko'p hollarda biz
dereference operatoridan foydalanamiz.</p>
<p>Esda tutingki, <code>*</code> operatori <code>deref</code> metodini chaqirish va keyin <code>*</code> operatorini
faqat bir marta chaqirish bilan almashtiriladi, har safar kodimizda <code>*</code> dan
foydalanamiz. <code>*</code> operatorini almashtirish cheksiz takrorlanmasligi sababli, biz
15-9 ro'yxatdagi <code>assert_eq!</code> dagi <code>5</code> ga mos keladigan <code>i32</code> turidagi
ma'lumotlarga ega bo`lamiz.</p>
<h3 id="funksiya-va-metodlar-bilan-yashirin-deref-coercionlar"><a class="header" href="#funksiya-va-metodlar-bilan-yashirin-deref-coercionlar">Funksiya va Metodlar bilan Yashirin Deref Coercion'lar</a></h3>
<p><em>Deref coercion</em> havolani <code>Deref</code> xususiyatini boshqa turga havolada amalga
oshiradigan turga aylantiradi. Masalan, deref coercion <code>&amp;String</code> ni <code>&amp;str</code> ga
aylantirishi mumkin, chunki <code>String</code> <code>Deref</code> traitini amalga oshiradi va u
<code>&amp;str</code> ni qaytaradi. Deref coercion - bu Rust funksiyalar va metodlarga
argumentlar bo'yicha bajaradigan qulaylik va faqat <code>Deref</code> traitini amalga
oshiradigan turlarda ishlaydi. Bu funksiya yoki metod ta'rifidagi parametr turiga
mos kelmaydigan funksiya yoki metodga argument sifatida ma'lum bir turdagi
qiymatga havolani uzatganimizda avtomatik ravishda sodir bo ªladi. <code>Deref</code>
metodiga chaqiruvlar ketma-ketligi biz taqdim etgan turni parametr kerak
bo'lgan turga aylantiradi.</p>
<p>Rustga deref coercion qo'shildi, shuning uchun dasturchilar funktsiya va metod
chaqiruvlarini yozish uchun <code>&amp;</code> va <code>*</code> bilan ko'p aniq havolalar va
dereferencelarni qo'shishlari shart emas. Deref coercion xususiyati bizga
havolalar yoki aqlli ko'rsatkichlar uchun ishlashi mumkin bo'lgan ko'proq kod
yozish imkonini beradi. </p>
<p>Deref coercionni amalda ko'rish uchun biz 15-8 ro'yxatda belgilagan <code>MyBox&lt;T&gt;</code>
turini hamda 15-10 ro'yxatiga qo'shgan <code>Deref</code> ni amalga oshirishdan
foydalanamiz. Ro'yxat 15-11 string slice parametriga ega bo'lgan funksiyaning
ta'rifini ko'rsatadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn salom(nom: &amp;str) {
    println!(&quot;Salom, {nom}!&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Ro'yxat 15-11: <code>&amp;str</code> tipidagi <code>nom</code> parametriga ega
<code>salom</code> funksiyasi</span></p>
<p>Biz <code>salom</code> funksiyasini argument sifatida string slice bilan chaqirishimiz
mumkin, masalan, <code>salom(&quot;Rust&quot;);</code>. Deref coercion 15-12 ro'yxatda
ko'rsatilganidek, <code>MyBox&lt;String&gt;</code> turidagi qiymatga havola bilan <code>salom</code> ni
chaqirish imkonini beradi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn salom(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salom, {nom}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    salom(&amp;m);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 15-12: <code>MyBox&lt;String&gt;</code> qiymatiga havola bilan
<code>salom</code> deb chaqirish, bu deref coercion tufayli ishlaydi</span></p>
<p>Bu yerda biz <code>&amp;m</code> argumenti bilan <code>salom</code> funksiyasini chaqiramiz, bu
<code>MyBox&lt;String&gt;</code> qiymatiga havola. Biz <code>Deref</code> traitini <code>MyBox&lt;T&gt;</code> uchun
15-10 ro'yxatda amalga oshirganimiz uchun Rust <code>deref</code> ni chaqirish orqali
<code>&amp;MyBox&lt;String&gt;</code> ni <code>&amp;String</code> ga aylantirishi mumkin. Standart kutubxona <code>String</code>
da <code>Deref</code> ning amalga oshirilishini ta'minlaydi, bu string slice qaytaradi va
bu <code>Deref</code> uchun API hujjatlarida. Rust <code>&amp;String</code> ni <code>&amp;str</code> ga aylantirish uchun
yana <code>deref</code> ni chaqiradi, bu <code>salom</code> funksiyasi ta`rifiga mos keladi.</p>
<p>Agar Rust deref coercionni amalga oshirmagan bo'lganida, biz <code>&amp;MyBox&lt;String&gt;</code>
tipidagi qiymat bilan <code>salom</code> ni chaqirish uchun 15-12 ro'yxatdagi kod
o'rniga 15-13 ro'yxatdagi kodini yozishimiz kerak edi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn salom(nom: &amp;str) {
</span><span class="boring">    println!(&quot;Salom, {nom}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    salom(&amp;(*m)[..]);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 15-13: Agar Rustda deref coercion bo'lmaganida,
biz yozishimiz kerak bo'lgan kod</span></p>
<p><code>(*m)</code> <code>MyBox&lt;String&gt;</code> ni <code>String</code> ga yo'naltiradi. Keyin <code>&amp;</code> va <code>[..]</code> <code>salom</code>
belgisiga mos kelishi uchun butun stringga teng bo'lgan <code>String</code> string sliceni
oladi. Deref coercionsiz ushbu kodni o'qish, yozish va tushunish ushbu belgilar
bilan qiyinroq. Deref coercion Rustga ushbu konversiyalarni biz uchun avtomatik
tarzda boshqarishga imkon beradi.</p>
<p>&quot;Deref&quot; traiti jalb qilingan turlar uchun aniqlanganda, Rust turlarni tahlil
qiladi va parametr turiga mos keladigan havolani olish uchun kerak bo'lganda
<code>Deref::deref</code> dan foydalanadi. <code>Deref::deref</code> qo'shilishi kerak bo'lgan vaqtlar
soni kompilyatsiya vaqtida hal qilinadi, shuning uchun deref coerciondan
foydalanganlik uchun ishga tushirish vaqtida jarima yo'q!</p>
<h3 id="deref-coercion-ozgaruvchanlik-bilan-qanday-ozaro-tasir-qilishi"><a class="header" href="#deref-coercion-ozgaruvchanlik-bilan-qanday-ozaro-tasir-qilishi">Deref Coercion O'zgaruvchanlik bilan Qanday O'zaro Ta'sir Qilishi</a></h3>
<p>O'zgarmas havolalarda <code>*</code> operatorini rad qilish uchun <code>Deref</code> traitidan
foydalanishga o'xshab, o'zgaruvchan havolalarda <code>*</code> operatorini rad
qilish uchun <code>DerefMut</code> traitidan foydalanishingiz mumkin.</p>
<p>Rust ushbu uchta holatda tur va traitni amalga oshirishlarni topsa, deref
coercionni amalga oshiradi</p>
<ul>
<li><code>&amp;T</code> dan <code>&amp;U</code> gacha, <code>T: Deref&lt;Target=U&gt;</code></li>
<li><code>&amp;mut T</code> dan <code>&amp;mut U</code> gacha <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li><code>&amp;mut T</code> dan <code>&amp;U</code> gacha <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>Birinchi ikkita holat bir-biri bilan bir xil, faqat ikkinchisi o'zgaruvchanlikni
amalga oshiradi. Birinchi holatda aytilishicha, agar sizda <code>&amp;T</code> bo'lsa va <code>T</code>
<code>Deref</code> ni <code>U</code> turiga qo'llasa, shaffof tarzda <code>&amp;U</code> ni olishingiz mumkin.
Ikkinchi holatda aytilishicha, xuddi shunday deref coercion o'zgaruvchan
havolalar uchun sodir bo'ladi.</p>
<p>Uchinchi holat qiyinroq: Rust o'zgarmasga o'zgaruvchan havolani ham majbur
qiladi. Ammo buning teskarisi <em>mumkin emas</em>: o'zgarmas havolalar hech qachon
o'zgaruvchan havolalarga majburlamaydi. Qarz olish qoidalari tufayli, agar sizda
o'zgaruvchan havola bo'lsa, bu o'zgaruvchan havola ma'lumot uchun yagona havola
bo'lishi kerak (aks holda dastur kompilyatsiya qilinmaydi). Bitta o'zgaruvchan
havolani bitta o'zgarmas havolaga aylantirish hech qachon qarz olish qoidalarini
buzmaydi. O'zgarmas havolani o'zgaruvchan havolaga aylantirish uchun dastlabki
o'zgarmas havola ushbu ma'lumotga yagona o'zgarmas havola bo'lishini talab
qiladi, ammo qarz olish qoidalari bunga kafolat bermaydi. Shu sababli, Rust
o'zgarmas havolani o'zgaruvchan havolaga aylantirish mumkin deb taxmin qila
olmaydi.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="drop-trait-bilan-tozalash-uchun-kodni-yuritish"><a class="header" href="#drop-trait-bilan-tozalash-uchun-kodni-yuritish"><code>Drop</code> Trait bilan tozalash uchun kodni yuritish</a></h2>
<p>Agar qiymat o‚Äòz doirasidan chiqqanda uni o‚Äòzgartirish imkonini beradigan ikkinchi muhim sanalgan smart pointer namunasidan biri bu <code>Drop</code>dir. Siz <code>Drop</code> traitini implementatsiya qilish uchun xohlagan turdan foydalanishingiz mumkin, va kodni fayl yoki tarmoqlarni ulash resurslarini yaratish uchun ham ishlatilishi mumkin </p>
<p><code>Drop</code>ni smart pointerlar kontekstida ishlatishimizning sababi <code>Drop</code> traiti smart pointerni implementatsiyasida deyarli har doim ishlatiladi. Masalan, qachonki <code>Box&lt;T&gt;</code> tashlab yuborilganda u quti ko‚Äòrsatayotgan heapdan joy ajratadi.</p>
<p>Ayrim dasturlash tillarida ayrim turlar uchun dasturchi xotirani bo‚Äòshatish uchun yoki har safar  resurslar o‚Äòsha tur instancedan ishlatib bo‚Äòlmagungacha kodni chaqirishi kerak. Fayl handlelari, soketlar va locklar bunga misol bo‚Äòla oladi. Agar ular kodni chaqirishni unitsalar, tizimda haddan tashqari yuklanish yuzaga keladi va tizim ishdan chiqadi. Rustda agar qiymat o‚Äòz doirasidan chiqqanda siz kodning ma‚Äôlum bir qismi ishga tushirishni belgilashingiz mumkin, kompilyator avtomatik ravishda kodni kiritadi. Natijada, ma‚Äôlum bir turdagi instance tugagan dasturning hamma joyiga tozalovchi kodni joylashtirishdan xavotir olmasangiz ham bo‚Äòladi va siz resurslarni sizib ketishini oldini olgan bo‚Äòlasiz!</p>
<p>Siz <code>Drop</code> traiti implementatsiyasi yordamida agar qiymat doirasidan chiqqan holda kodni run qilish uchun belgilashingiz mumkin. <code>Drop</code> traiti sizdan <code>self</code>dan referens oluvchi <code>drop</code> nomli metodni implementatsiya qilishni talab qiladi. Rustda <code>drop</code> qachon chaqirilishini ko‚Äòrish uchun, <code>drop</code>ni <code>println!</code> yordamida implementatsiya qilib ko‚Äòraylik.</p>
<p>15-14 ni ko‚Äòrib chiqadigan bo‚Äòlsak, Rustda qachon <code>drop</code> funksiyasi ishlashini ko‚Äòrish uchun faqat o‚Äòziga tegishli bo‚Äòlgan<code>CustomSmartPointer</code> structi faqat agar instance o‚Äòz doirasidan chiqqanda <code>Dropping CustomSmartPointer!</code> ni print qiladi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;CustomSmartPointerni `{}` ma'lumot bilan Drop qilish!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;menga tegishli&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;boshqaga tegishli&quot;),
    };
    println!(&quot;CustomSmartPointerlar yaratildi.&quot;);
}</code></pre></pre>
<p><span class="caption">15-14ni ko'rib chiqish: <code>CustomSmartPointer</code> structi biz tozalash uchun qo‚Äôygan kodda <code>Drop</code> traitining implementatsiyasi</span></p>
<p><code>Drop</code> traiti o‚Äòz ichiga preludeni oladi, shuning uchun biz uni scopeni ichiga olishimiz shart emas. Biz <code>CustomSmartPointer</code>da <code>Drop</code>ni implementatsiya qilamiz va <code>drop</code> metodi implementatisyasi uchun <code>println!</code>ni chaqiramiz. <code>drop</code> funksiyasining tana (body) qismi bu sizning turdagi instance o‚Äòz doirasidan (scope) chiqib ketgandagi ayrim bir logikaga ega koddir. Rustda qachon <code>drop</code> chaqirilishini ko‚Äòrish uchun biz ozgina tekstni print qilamiz.</p>
<p><code>main</code>da biz 2ta <code>CustomSmartPointer</code> instancelarini yaratamiz va keyin <code>CustomSmartPointers yaratildi</code>ni print qilamiz. <code>main</code>ning oxirida <code>CustomSmartPointer</code> doiradan (scope) chiqib ketadi va Rust yakuniy xabarni print qilib, biz kodga qo‚Äòygan <code>drop</code> metodini chaqiradi. E‚Äôtibor bering biz <code>drop</code> metodini to‚Äòg‚Äòridan-to‚Äòg‚Äòri chaqririshimiz shart emas.</p>
<p>Agar biz dasturni run qilsak, quyidagi outputni ko‚Äòramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust avtomatik ravishda bizning o‚Äòrnimizga biz ko‚Äòrsatgan kodni instance doiradan (scope) chiqqanda <code>drop</code>ni chaqirdi. O‚Äòzgaruvchilar yaratilish paytida teskari tartibda tushib qoldiriladi (drop qilinadi), shuning uchun <code>d</code> <code>c</code>dan oldin tushib qoldirildi (drop qilindi). Ushbu misolning maqsadi sizga <code>drop</code> metodining qanday ishlashining vizual ko‚Äòrinishini berishdir; odatda xabarni print qilishning o‚Äòrniga siz sizning turingizni ishga tushirish (run qilish) uchun tozalash kodini ko‚Äòrsatasiz. </p>
<h3 id="stdmemdrop-yordamida-qiymatni-erta-drop-qilish"><a class="header" href="#stdmemdrop-yordamida-qiymatni-erta-drop-qilish"><code>std::mem::drop</code> yordamida Qiymatni Erta Drop qilish</a></h3>
<p>Afsuski, avtomatik <code>drop</code> funksiyasini o‚Äòchirish oson emas.  Odatda <code>drop</code>ni o‚Äòchirish zarur emas; <code>Drop</code>ning asosiy mohiyati uning avtomatik ravishda hal qilishidir. Ba‚Äôzi paytlarda siz qiymatni erta tozalashga duch kelishingiz mumkin. Lockalarni boshqaruvchi smart pointerlarni ishlatishga bir misol bo‚Äòla oladi:  bir doirada (scope)da boshqa kodni olish uchun siz lockni chaqiradigan <code>drop</code> metodini majburiy ravishda ishlatishingiz mumkin. Rust sizga <code>Drop</code> traitidagi <code>drop</code> metodini qo‚Äòlda tushurishga qo‚Äòymaydi; agar siz qiymatni o‚Äòz doirani (scope) tugashidan oldin majburiy drop bo‚Äòlishini xohlasangiz. uning uchun siz standart kutubxona tomonidan taqdim etilgan <code>std::mem::drop</code>ni ishlatishingiz mumkin.</p>
<p>Agar biz 15-14dagi ilovaga qo‚Äòlda <code>Drop</code> traitining <code>drop</code> metodi yordamida <code>main</code>ga o‚Äòzgaritirish kiratigan bo‚Äòlsak, 15-15 ilovada ko‚Äòrsatilgan kompilyator xatosini ko‚Äòramiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;CustomSmartPointerni `{}` ma'lumot bilan Drop qilish!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;ma'lumot&quot;),
    };
    println!(&quot;CustomSmartPointer yaratildi.&quot;);
    c.drop();
    println!(&quot;main tugashidan oldin CustomSmartPointer drop qilindi.&quot;);
}</code></pre>
<p><span class="caption"> 15-15 ro'yxat: <code>Drop</code> traitidagi <code>drop</code> metodi orqali qo'lda erta tozalashga harakat qilish</span></p>
<p>Ushbu kodni komplilyatsiya qilganimizda quyidagi xatolikni ko‚Äòramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
</code></pre>
<p>Ushbu xatolikdagi xabarda <code>drop</code>ni to‚Äòg‚Äòridan-to‚Äòg‚Äòri chaqira olmasligizni ko‚Äòrsatadi. Xatolikdagi xabar instanceni tozalovchi umumiy dasturlash atamasi bo‚Äòlgan funksiya, ya‚Äôni <code>destructor</code>ni ishlatadi. <code>destructor</code> <code>constructor</code>ga o‚Äòxshash bo‚Äòlib, instancelarni yaratadi. Rustda <code>drop</code> funksiyasi alohida bir destructordir. </p>
<p>Rust bizga <code>drop</code>ni to‚Äòg‚Äòridan-to‚Äòg‚Äòri chaqrishga qo‚Äòymaydi chunki Rust qiymatni avtomatik ravishda baribir <code>main</code>ni oxirida <code>drop</code>ni chaqiradi. Ushbu holat <em>double free</em> xatoligini keltirib chiqarishi mumkin chunki Rust bitta qiymatni ikki marta tozalashga xarakat qiladi.</p>
<p>Agar qiymat o‚Äòz doirasidan (scope) chiqqanda biz <code>drop</code>ni avtomatik kiritishini o‚Äòchirib qo‚Äòya olmaymiz va <code>drop</code> metodini to‚Äòg‚Äòridan-to‚Äòg‚Äòri chaqira olmaymiz. Shuning uchun agar bizga majburiy ravishda qiymat tozalanishini xoxlasak, biz <code>std::mem::drop</code>funksiyasini ishlatamiz</p>
<p><code>std::mem::drop</code> funksiyasi <code>Drop</code> traitidagi <code>drop</code> metodidan farq qiladi. Biz buni majburan tozalash (drop) qilishni xohlagan qiymatni argument sifatida berish deb ataymiz. Funksiya preludeda, va 15-16 ro'yxatda ko‚Äòrsatilgandek biz 15-15 ro'yxatdagi <code>main</code>da <code>drop</code> funkisyasini chaqirish uchun o‚Äòzgartirish kiritishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;CustomSmartPointerni `{}` ma'lumot bilan Drop qilish!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;ma'lumot&quot;),
    };
    println!(&quot;CustomSmartPointer yaratildi.&quot;);
    drop(c);
    println!(&quot;main tugashidan oldin CustomSmartPointer drop qilindi.&quot;);
}</code></pre></pre>
<p><span class="caption"> 15-16 ro'yxat: qiymat o'z doirasidan (scope) chiqqanda to'g'ridan-to'g'ri <code>std::mem::drop</code>ni chaqirish </span></p>
<p>Run qilingan kod quyidagini print qiladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p><code>c</code> nuqtasida tozalash (drop qilish) uchun <code>drop</code> metodi kodini chaqirishini ko‚Äòrsatish uchun<code>CustomSmartPointerdagi ma‚Äôlumot bilan tozalash (drop qilish)</code> <code>CustomSmartPointer yaratildi</code> va <code>CustomSmartPointer main tugashidan oldin tozalandi (drop qilindi)</code> matnlari orasida print qilindi.</p>
<p>Siz <code>Drop</code> traiti implementatsiyasida ko‚Äòrsatilgan koddan har xil turda tozalashni qulay va xavfsiz qilishingiz mumkin: masalan, siz uni o‚Äòzingizning xotira taqsimlagichni yaratish uchun ishlatsangiz bo‚Äòladi. <code>Drop</code> traiti va Rustning ownership tizimi bilan tozalash uchun bosh qotirmasangiz ham bo‚Äòladi chunki Rust buni avtomatik ravishda qiladi.</p>
<p>Siz ishlatilib turgan qiymatlarni bexosdan tozalanib ketish muammolaridan xavotir olmasangiz bo‚Äòladi: ownership tizimi referencelarni doim to‚Äòg‚Äòriligiga hamda <code>drop</code> qiymat bir marta chaqrilib boshqa ishlatilmasligini ta‚Äôminlaydi.</p>
<p>Hozirda biz <code>Box&lt;T&gt;</code>ni va smart pointerlarni ba‚Äôzi bir xususiyatlarini tekshirib oldik, keling standart kutubxonada keltirilgan boshqa smart pointerlarni ham ko‚Äòrib chiqaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-reference-hisoblangan-smart-pointer"><a class="header" href="#rct-reference-hisoblangan-smart-pointer"><code>Rc&lt;T&gt;</code>, reference hisoblangan Smart Pointer</a></h2>
<p>Ko‚Äòp hollarda, ownership ochiq, ya‚Äôni tushunarli holda bo‚Äôladi: sizga qaysi o‚Äòzgaruvchi qaysi berilgan qiymatga egalik qilishini aniq bilasiz. Ammo, ayrim hollarda bitta qiymat ko‚Äòp egalarga ega bo‚Äòlishi mumkin. Masalan, grafik ma‚Äôlumotlar tuzilmasida (data structures), bir nechta edgelar bitta nodeni point qilishi mumkin, vas shu node unga point qilingan barcha edgelar tomonidan egalik qilinadi. Nodega edgelar point qilinmagungacha, shuningdek egalari bo‚Äòlmagungacha tozalanishi mumkin emas. </p>
<p>Rustning refenceni hisoblovchi Rc<T> turini ishlatishda siz bir nechta ownershipni aniq qilib yoqishingiz kerak. Qiymatni ishlatilib turganligi yoki ishlamay turganligini aniqlash uchun Rc<T> qiymatga ketayotgan refencelar sonini kuzatib boradi. Agar qiymatda nol (zero) referencelar bo‚Äòlsa, hech qanay reference lar bekor bo‚Äòlmasidan qiymat tozalanishi mumkin.</p>
<p><code>Rc&lt;T&gt;</code> ni zaldagi televizor sifatida tasavvur qiling. Agar bir kishi televizor ko‚Äòrish uchun xonaga kirsa, u televizorni yoqadi. Boshqalar esa shunchaki xonaga kirib tomosha qilsalar bo‚Äòladi. Xonadan oxirgi odam chiqib ketayotganda, ular televizorni o‚Äòchirib ketishadi chunki televizor boshqa ishlatilmaydi. Agar bir kishi boshqalar televizorni tomosha qilib o‚Äòtirganida o‚Äòchirsa boshqalar uchun g‚Äòalati bo‚Äòlishi mumkin.</p>
<p>Biz <code>Rc&lt;T&gt;</code>ni ma‚Äôlumotni heapda dasturning ko‚Äòp qismlarini o‚Äòqishi uchun ajratishni hohlasaganimizda foydalanamiz va biz kompilyatsiya vaqti qaysi qism ma‚Äôlumotini oxirgi foydalanishni yakunlaganini bila olmaymiz. Agar biz ma‚Äôlumotni qaysi qismi oxirida to‚Äòxtashini bilganimizda, biz shu qismni ma‚Äôlumotni egasi sifatida tayinlar edik va kompilyatsiya vaqtida qo‚Äòllaniladigan oddiy egalik (ownership) qoidalari kuchga kirar edi.</p>
<p>Shuni yodda tutish kerakki <code>Rc&lt;T&gt;</code> yakka-thread holatlardagina ishlatiladi. Biz 16-bo‚Äòlimda parralellik haqida suhlashganimizda, biz ko‚Äòp threadli dasturlarda referenceni hisoblashni qanday qilishni o‚Äòrganamiz. </p>
<h3 id="rctni-malumotni-ulashish-uchun-ishlatish"><a class="header" href="#rctni-malumotni-ulashish-uchun-ishlatish"><code>Rc&lt;T&gt;</code>ni Ma'lumotni Ulashish uchun ishlatish</a></h3>
<p>Keling kamchiligi bor bo‚Äòlgan 15-5 ro‚Äòyxat misolimizga qaytaylik. Esingizda bo‚Äòlsa biz <code>Box&lt;T&gt;</code>ni ishlatishni ko‚Äòrsatib o‚Äòtgan edik. Bu safar, biz 2ta ro‚Äòyxat ham egalikni (ownership) 3-ro‚Äòyxat bilan ulashadigan ro‚Äòyxat yaratamiz. Aniq qilib aytadigan bo‚Äòlsak, 15-3 shaklga o‚Äòxshashdir:</p>
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">15-3-shakl: Ikkita ro'yxatlar, ya'ni <code>b</code> va <code>c</code> egalikni uchinchi ro'yxat, ya'ni <code>a</code>ga ulashishi</span></p>
<p>Biz 5 va 10 dan iborat bo‚Äòlgan <code>a</code> ro‚Äòyxatni yaratamiz. Keyin yana ikkita ro‚Äòyxatni ham yaratamiz, ya‚Äôni 3dan boshlanadigan <code>b</code> va 4dan boshlanadigan <code>c</code>. <code>b</code> va <code>c</code> ro‚Äòyxatlari 5 va 10dan iborat bo‚Äòlgan <code>a</code> ro‚Äòyxatda davom etadi. Boshqacha qilib aytganda, ro‚Äòyxatlar birinchi 5 va 10dan iborat bo‚Äòlgan birinchi ro‚Äòyxat bilan ulashishadi.</p>
<p>15-17-ro‚Äòyxatda ko‚Äòrsatilgandek, bizning ssenariy bo‚Äòyicha <code>Box&lt;T&gt;</code> bilan <code>List</code>dagi ta‚Äôrifimiz yordamida implement qilishga urunsak ishga tushmaydi:</p>
<p><span class="filename">Fayl-nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<p><span class="caption">15-17-ro'yxat: Ko'rib turganimizdek, <code>Box&lt;T&gt;</code> yordamida uchunchi ro'yxatga ikkita ro'yxatni egaligini (ownership) ulashib bo'lmaydi </T></span></p>
<p>Ushbu kodni kompilyatsiya qilsak, biz yuqoridagi xatolikni ko'ramiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to previous error
</code></pre>
<p><code>Cons</code> variantlari o'zlariga tegishli bo'lgan ma'lumotlargagina egalik (own) qila oladi, shuninguchun biz <code>b</code> ro'yxatini yaratganimizda, <code>a</code> <code>b</code>ga o'tadi va <code>b</code> <code>a</code>ga egalik qiladi.Undan keyin, <code>c</code> ni yaratish uchun <code>a</code>dan foydalanmoqchi bo'lganizmizda bizga ruxsat bermaydi chunki <code>a</code> ko'chib ketganligi uchun.</p>
<p>Buning o'rniga havolalarni ushlab turish uchun <code>Cons</code> ta'rifini o'zgartirishimiz mumkin, lekin keyin biz layvtaym parametrlarini ko'rsatishimiz kerak bo'ladi. Layvtaym parametrlarini belgilash orqali, biz ro'yxatdagi har bir elementning yashashini ko'rsatamiz. 15-17 ro'yxatda ko'rsatilganidek bu elementlar va ro'yxatlarga tegishli, lekin har doim gam emas.</p>
<p>15-18-ro'yxatda ko'rsatilganidek, <code>Box&lt;T&gt;</code>ning o'rniga<code>Rc&lt;T&gt;</code>ni ishlatish uchun biz bizning <code>Ro'yxat</code>imizning mazmunini o'zgartiramiz. Har bir <code>Cons</code> varianti qiymatni o'zida ushlab turadi va <code>Rc&lt;T&gt;</code> <code>Ro'yxat</code>ni ko'rsatadi. <code>a</code>ning egaligini olishning o'rniga <code>b</code>ni yaratganimizda, <code>a</code> ni ushlab  turgan <code>Rc&lt;List&gt;</code>ni klonlaymiz, shu bilan birga referenslar sonini birdan ikkiga ko'paytiramiz va <code>Rc&lt;List&gt;</code>dagi ma'lumotlarning egaligini ulashish uchun <code>a</code> va <code>b</code>ga ruxsat beramiz. referenslar sonini ikkidan uchga ko'paytirgan holda, <code>c</code>ni yaratayotganimizda <code>a</code>ni ham klonlaymiz. <code>Rc::clone</code>ni har safar chaqirganimizda, <code>Rc&lt;List&gt;</code> tarkibidagi ma'lumotlarining referenslari soni oshiriladi, zero referenslar paydo bo'lmagungacha ma'lumotlar tozalanmaydi.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">Listing 15-18: A definition of <code>List</code> that uses
<code>Rc&lt;T&gt;</code></span></p>
<p>Biz scopeni ichiga <code>Rc&lt;T&gt;</code>ni kiritsh uchun <code>use</code> statementini qo'shishimiz kerak
chunki u muqaddimani ichida bo'lmagani uchun. <code>main</code>ni ichida 5 va 10ni saqlovch ro'yxatni
yaratamiz va uni <code>a</code>ga tegishli yangi <code>Rc&lt;List&gt;</code>ga joylashtiramiz. Keyin esa <code>b</code> va <code>c</code> yaratganimizda, <code>Rc::clone</code> funksiyasini chaqiramiz va argument sifatida <code>a</code>ga tegishli bo'lgan <code>Rc&lt;List&gt;</code>ga o'tkazib yuboramiz.</p>
<p><code>Rc::clone(&amp;a)</code>ning o'rniga biz <code>a.clone()</code> chaqirishimiz mumkin edi, lekin Rust 
qoidalariga muofiq ushbu holatda <code>Rc::clone</code> ishlatgan ma'qul. <code>Rc::clone</code>ning implementatsiyasi <code>clone</code>ning ko'p implementatsiya turiga o'xshab ma'lumotlarni to'liq 
nusxa olmaydi. <code>Rc::clone</code>ning chaqirilishi referenslarning sonini ko'paytiradi, va shuning uchun ham ko'p vaqt olmaydi. Ma'lumotlarni to'liq nusxalash esa ko'p vaqt talab etadi. Referenslarni hisoblash uchun <code>Rc::clone</code>ni ishlatsak, biz to'liq nusxalangan bilan referenslar soni ortgan nusxalar orasidagi farqni tasavvur qilishimiz mumkin. Kodning unumdorlik muammolarini qidirayotganimizda, bizga faqat to'liq nusxalangan nusxalarga e'tibor qaratib, <code>Rc::clone</code>ning chaqirilishini e'tiborga olmasak ham bo'ladi.</p>
<h3 id="rctni-nusxalash-referenslar-hisobini-orttiradi"><a class="header" href="#rctni-nusxalash-referenslar-hisobini-orttiradi"><code>Rc&lt;T&gt;</code>ni nusxalash Referenslar hisobini orttiradi</a></h3>
<p><code>a</code>da referenslarni yaratib va uni <code>Rc&lt;List&gt;</code>ga drop qilib referenslar sonini ortayotganligini keling bizning ishlab turgan 15-18-ro'yxatimizdagi misolga o'zgartirish kiritib ko'raylik, </p>
<p>15-19-ro'yxatda, <code>main</code>ni o'zgartirib ko'raylik chunki uning ichki scope(doirasi) <code>c</code>ro'yxatining atrofida shundan so'ng biz <code>c</code> scope(doirasida) chiqqanda qanday qilib referenslar soni ortayotganini ko'ramiz.</p>
<p><span class="filename">Fayl-nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">15-19-ro'yxat: Referens soni ortayotganligini print qilish</span></p>
<p>Dasturda referens soni o'zgargan har bir nuqtada, <code>Rc::strong_count</code> funksiyasini chaqirish yordamida biz referens sonini print qilamiz. Ushbu funksiyani nomi<code>count</code>deb emas <code>strong_count</code> deb nomlanadi, chunki <code>Rc&lt;T&gt;</code> turida  <code>weak_count</code> ham bor; biz <code>weak_count</code>ni <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">&quot;Referenslar siklini oldini olish: <code>Rc&lt;T&gt;</code>ni <code>Weak&lt;T&gt;</code>ga aylantirish&quot;</a> bo'limida ko'ramiz.</p>
<p>Ushbu kod quyidagini print qiladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p><code>a</code>da <code>Rc&lt;List&gt;</code>ning referens soni 1 ekanligini ko'rishimiz mumkin; keyinchalik har safar biz <code>clone</code> ni chaqirganimizda, son 1ga ortib boraveradi. <code>c</code> o'z scope(doirasi)dan chiqib ketganida,referens soni 1ga kamayadi. <code>Rc::clone</code> funksiyasi yordamida referens sonini ortirish uchun chaqirganimizdek referens soni kamaytirish uchun hech qanday funksiyasini chaqirishimiz kerak bo'lmaydi, chunki <code>Drop</code> traitining implementatsiyasi <code>Rc&lt;T&gt;</code> qiymati o'z scope(doirasi)dan chiqqanda avtomatik ravishda referens sonini kamaytiradi. </p>
<p><code>main</code> oxirida <code>b</code> va keyin <code>a</code>larning scope(doirasidan) chiqib, son/hisob 0ga tenglashib, <code>Rc&lt;List&gt;</code> to'liq tozalanganligini biz ushbu misolda ko'ra olmaymiz. <code>Rc&lt;T&gt;</code>ni ishlatish yordamida bitta qiymat ko'p egalarga ega bo'lishi mumkin, hamda son/hisob qiymat egalaridan biri bor bo'lgunga qadar yaroqliligini tekshirib turadi.</p>
<p>O'zgarmas o'zgaruvchilar yordamida, <code>Rc&lt;T&gt;</code> o'qish uchun ma'lumotlarni dasturning ko'p joylari orasida ulashish imkonini beradi. Agar <code>Rc&lt;T&gt;</code> ko'p o'zgaruvchan referenslarga ega bo'lish imkonini bergan bo'lsa, siz 4-Bo'limda ko'rsatilganidek borrowing qoidalarini birini buzishingiz mumkin: ko'p o'zgaruchilar bir xil joyga borrow qilib data race va nomuvofiqliklarga sabab bo'lishi mumkin. Lekin ma'lumotni o'zrgatira olish foydalidir! keyingi bo'limda, biz ichki o'zgaruvchanlik shakli(pattern) va <code>RefCell&lt;T&gt;</code> turi bilan <code>Rc&lt;T&gt;</code> yordamida o'zgarmaslik cheklovi bilan ishlash ko'rib chiqamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-va-ichki-ozgaruvchanlik-shaklipattern"><a class="header" href="#refcellt-va-ichki-ozgaruvchanlik-shaklipattern"><code>RefCell&lt;T&gt;</code> va Ichki O'zgaruvchanlik Shakli(pattern)</a></h2>
<p><em>Ichki o'zgaruvchanlik</em> bu Rustda ma'lumotlarga o'zgarmas referenslar mavjud bo'lganda ham ma'lumotni o'zgartirish imkonini beruvchi (dizayn) shakli/patternidir: odatda bu borrowing qoidalari bo'yicha esa taqiqlangan. Ma'lumotni o'zgaruvchan qilish uchun shakl/pattern Rustning o'zgaruvchanlik va borrowingni boshqaruchi oddiy qoidalarini chetlab o'tish uchun ma'lumotlar strukturasi ichiga <code>unsafe</code> kod ishlatiladi. Xavfsiz bo'lmagan kod bizning o'rnimizga kompilyatorga qoidalarni kompliyator yordamisiz tekshirayotganimizni ko'rsatadi; xavfsiz bo'lmagan kod haqida 19-bo'limda o'rganib chiqamiz.</p>
<p>Biz ichki o'zgaruvchanlik shakli/patterni ishlatadigan turlardan faqatgina borrowing qoidalari runtimeda amal qilingaligi paytida ishlatishimiz mumkin, kompilyator bunga kafolat bera olmaydi. Keyin <code>unsafe</code> kod xavfsiz APIga ulanadi va tashqi tur o'zgarmasligicha qoladi.</p>
<p>Keling ushbu tushunchani ichki o'zgaruvchanlik shakliga amal qiluvchi quyidagi <code>RefCell&lt;T&gt;</code> turiga qarab ko'rib chiqaylik.</p>
<h3 id="enforcing-borrowing-rules-at-runtime-with-refcellt-yordamida-borrowing-qoidalarini-runtime-vaqtida-kuch-bilan-ishlatish"><a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcellt-yordamida-borrowing-qoidalarini-runtime-vaqtida-kuch-bilan-ishlatish">Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code> yordamida Borrowing qoidalarini Runtime vaqtida kuch bilan ishlatish</a></h3>
<p><code>Rc&lt;T&gt;</code>lidan faqrli o'laroq, <code>RefCell&lt;T&gt;</code> turi o'zi egalik qilib turgan ma'lumotda yagona egalikni namoyish etadi. Xo'sh, <code>RefCell&lt;T&gt;</code> turi <code>Box&lt;T&gt;</code> turidan nimasi bilan farq qiladi? 4-bo'limda o'tilgan borrowing qoidalarini esga olaylik: </p>
<ul>
<li>Xohlagan belgilangan vaqtda, siz <em>yoki</em> (ikkalasini bir vaqtda ega bo'lish mumkin emas)bitta        o'zgaruvchan referens yoki xohlagan sondagi o'zgarmas referenslarga ega bo'lishingiz mumkin. </li>
<li>Referenslar har doim yaroqli bo'lishi shart</li>
</ul>
<p>Referenslar va <code>Box&lt;T&gt;</code> bilan, borrowing qoidalarining kompilyatsiya vaqtida o'zgarmaslar kuchga kiradi. <code>RefCell&lt;T&gt;</code> bilan esa ushbu o'zgarmaslar <em>runtime paytida</em> kuchga kiradi. Referenslar bilan, agar siz ushbu qoidalarni buzsangiz, sizda kompilyator xatoligi yuzaga keladi. <code>RefCell&lt;T&gt;</code> bilan suhbu qoidalarni buzganingizda, sizning dasturingizda panic vujudga kelib, dastur chiqib ketadi.</p>
<p>The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust‚Äôs default.</p>
<p>Borrowing qoidalarini kompilyatsiay vaqtida tekshirishning yaxshi tarafi xatolarni development vaqtida tezroq topishdir, va runtime unumdorligiga ta'sir ko'rsatmaydi chunki hamma analizlar oldindan qilingan bo'ladi. Ko'p hollarda borrowing qoidalarini kompilyatsiya vaqtida tekshirish eng yaxshi tanlovdir, sababi ushbu xususiyat Rustda odatiy  xususiyatidir. </p>
<p>Borrowing qoidalarini runtime vaqtida tekshrishning afzalligi shundaki, kompilyatsiya vaqtidagi tekshiruvlar tomonidan ruxsat etilmaganda ba'zi xotira uchun xavfsizlik ssenariylarga ruxsat beriladi. Rust kompilyatoriga o'xshagan statik analizlar o'z-o'zidan konservativdir. Kodni tahlil qilayotganda kodning ba'zi bir xususiyatlarini aniqlash qiyindir: bunga  Halting Problem mashxur misol bo'la oladi, bu kitob doirasidan tashqarida bo'lsada lekin izlanib o'rganish uchun qiziq mavzu</p>
<p>Agar Rust kompilyatori egalik (ownership) qoidalari asosida kompilyatsiya qilayotganini aqiqlay olmasa, bu to'g'ri, ya'ni ishlab turgan dasturni rad etishi mumkin, shuning uchun ham konservativ hisoblanadi va bu ba'zi tahlillar uchun qiyindir. Agar Rust xatolikka ega bo'lgan dasturni qabul qilsa, foydalanuvchilar Rust beradigan kafolatlarga ishona olmaydilar. Agarda, Rust ishlab turgan dasturni rad etsa, dasturchi uchun noqulaylik tug'diradi, lekin hech qanday qo'rqinchli narsa bo'lmaydi. <code>RefCell&lt;T&gt;</code> turi sizning kodingiz borrowing qoidlariga amal qilayotganiga ishonchingiz komil bo'lganda lekin kompilyator buni tushuna olmayotganda va kafolat bera olmaganda foydalidir.</p>
<p><code>RefCell&lt;T&gt;</code> <code>Rc&lt;T&gt;</code>ga o'xshab bitta potokli (oqimli) ssenariylarda ishlatilinadi va agar siz ko'p potokli (oqimli) holatda ishlatsangiz kompilyatsiya vaqtidagi xatolikni yuzaga keltiradi. Biz <code>RefCell&lt;T&gt;</code>ni ko'p potokli (oqimli) dasturda qanday qilib funksionalligini olishni 16-bo'limda ko'rib chiqamiz.</p>
<p>Quyida takrorlash uchun <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, yoki <code>RefCell&lt;T&gt;</code>ni tanlash sabablari:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> bitta ma'lumotga ko'p egalarga ega bo'lish imkonini beradi; <code>Box&lt;T&gt;</code> va <code>RefCell&lt;T&gt;</code>
esa yagona egaga egadirlar;</li>
<li><code>Box&lt;T&gt;</code> kompilyatsiya vaqtida o'zgaruvchan va o'zgarmas borrowlarni tekshrilishini ta'minlaydi;
<code>Rc&lt;T&gt;</code> kompilyatsiya vaqtida faqat o'zgarmas borrowlarni tekshrilishini ta'minlaydi; 
<code>RefCell&lt;T&gt;</code> runtimeda o'zgaruvchan va o'zgarmas borrowlarni tekshrilishini ta'minlaydi.</li>
<li>Because <code>RefCell&lt;T&gt;</code> runtimeda o'zgaruvchan borrowlar tekshirilishi ta'minlaydi, agar
<code>RefCell&lt;T&gt;</code> o'zgarmas bo'lsada <code>RefCell&lt;T&gt;</code> ichida qiymatni o'zgaruvchan qilishingiz mumkin.</li>
</ul>
<p>Qiymatni o'zgarmas qiymat ichida o'zgaruvchan qilish <em>ichki o'zgaruvchanlik</em> shaklidir (pattern).
Keling ichki o'zgaruvchanlikni foydali ekanligini va bu qanday sodir bo'lishini misollarda ko'rib
chiqaylik.</p>
<h3 id="ichki-ozgaruvchanlik-ozgaruvchan-borrowdan-ozgarmas-qiymatga"><a class="header" href="#ichki-ozgaruvchanlik-ozgaruvchan-borrowdan-ozgarmas-qiymatga">Ichki o'zgaruvchanlik: O'zgaruvchan Borrowdan O'zgarmas Qiymatga</a></h3>
<p>Borrowing qoilari natijasida, o'zgarmas qiyamtga ega bo'lganingizda, siz o'zgaruvchan borrow qila olmaysiz. Masalan, ushbu kod kompilyatsiya qilinmaydi:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>Agar siz ushbu kodni kompilyatsiya qilishga harakat qilsangiz, quyidagi xatolik kelib chiqadi:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
</code></pre>
<p>Shunday vaziyatlar borki qiymat o'zini-o'zi o'zining metodlarida o'zgarivchan qilishi
foydali hisoblanadi, lekin boshqa kodda o'zgarmas shaklda bo'ladi. Kodning doirasidan
tashqaridagi qiymat metodi qiymatni o'zgaruvchan qila olmaydi. <code>RefCell&lt;T&gt;</code>ni ishlatish ichki
o'zgaruvchanlikga ega bo'lishning bir yo'li hisoblanadi, lekin <code>RefCell&lt;T&gt;</code> borrowing 
qoidalarini to'liq aylanib o'tmaydi: kompilyatorda borrow tekshiruvchisi shu ichki o'zgaruvchanlikka
ruxsat beradi, va borrowing qoidalari runtimes tekshiriladi. Agar qoidalarni rad etsangiz,
kompilyator xatoligini o'rniga <code>panic!</code> ko'rasiz. </p>
<p><code>RefCell&lt;T&gt;</code>ni o'zgarmas qiymatni o'zgaruvchanga aylantirishni, hamda nimaga <code>RefCell&lt;T&gt;</code>ni
ishlatish foydali ekanligini amaliy misollarda ko'rib chiqaylik.</p>
<h4 id="ichki-ozgaruvchanlik-uchun-foydalanish-holatimisoli-soxta-obyektlar"><a class="header" href="#ichki-ozgaruvchanlik-uchun-foydalanish-holatimisoli-soxta-obyektlar">Ichki o'zgaruvchanlik uchun foydalanish holati/misoli: Soxta Obyektlar</a></h4>
<p>Ayrim hollarda test vaqti dasturchi boshqa turni o'rniga kerakli hatti-harakatni kuzatish
uchun va to'g'ri kompilyatsiya amalga oshirilganligini tasdiqlash uchun boshqa bir turni
ishlatib ko'radi. Ushbu to'ldiruvchi tur <em>test double</em> deb ataladi. Qiyin bo'lgan sahna ko'rinishida
aktyorning o'rniga chiqib, sahna ko'rinishi amalga oshirib beruvchi, ya'nikino yaratishda &quot;kaskadyor&quot;
misolida ko'rib chiqaylik. Test doublelari boshqa turlarda test o'tkazayotganimizda xizmat qiladi.
<em>Soxta obyektlar</em> test paytida nimalar sodir bo'lishini qayd etuvchi test doublelar o'ziga xos turlardan biri bo'lib, siz to'g'ri amallar amalga oshirilayotganini ko'zdan kechirishingiz mumkin.</p>
<p>Rustda boshqa dasturlash tillari kabi bir xil ma'noli obyektlarga ega emas,
va soxta obyekt funksionalligini olgan standart kutubxonasi yo'q. Aksincha, soxta 
obyektlar kabi ish bajaruvchi struct yaratishingiz mumkin. </p>
<p>Ushbu ssenariyni ko'rib chiqaylik: qiymatni maksimal qiymatga nisbatan kuzatuvchi
kutubxona yaratamiz va joriy qiymat maksimal qiymatga qanchalik yaqinligiga qarab bizga
xabar jo'natib turadi. Ushbu kutubxona foydalanuvchi uchun ruxsat etilgan API 'call'lar sonini
kuzatib borish uchun ishlatilishi mumkin, bu ishlatish mumkin bo'lgan bir misol.</p>
<p>Bizning kutubxonamiz faqatgina qiymatni maksimal qiymatga qanchalik yaqin ekanligi
va qaysi vaqtda qaysi xabar jo'natilishini kuzatib turish imkonini beredi. Bizning
kutubxonamizdan foydalanadigan ilovalar xabar jo'natish mexanizmini ta'minlashini
talab qiladi, ya'ni ilova xabarni ilova ichida, email orqali, matnli xabar ko'rinishida
yoki boshqa ko'rinishda yuborishi mumkin. Kutubxona ushbu tafsilotlarni bilishi talab etilmaydi.
Kutubxona uchun biz tomonimizdan qo'llaniladigan <code>Messenger</code> traitini implementatsiya qiladigan
narsa kerak xolos.</p>
<p><span class="filename">Faylnomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        }
    }
}</code></pre>
<p><span class="caption">15-20-ro'yxat: Qiymatni qanchalik maksimal qiymatga yaqinligini kuzatish va kerakli darajaga 
yetganda ogohlantiruvchi kutubxona</span></p>
<p>Ushbu kodning e'tiborli tomoni shundaki <code>Messenger</code> traitining <code>send</code> nomli metodi 
xabarning matni hamda<code>self</code>ga o'zgarmas referensni oladi. Ushbu trait bizning soxta 
obyektimizning implementatisiyasi uchun kerak bo'lgan interfeys hisoblanadi, shu 
holatda soxta obyekt haqiqiy obyektga o'xshab ishlatilishi mumkin. Yana bir muhim 
tomoni shundaki, biz <code>set_value</code>ni ko'rinishini <code>LimitTracker</code> orqali ko'rishimiz mumkin.<br />
Biz xohlaganimizcha o'tkazayotganimizni <code>value</code> parametri uchun o'zgartirishimiz mumkin, 
lekin <code>set_value</code> biz da'vo qilishimiz mumkin bo'lgan narsani return qilmaydi. Agar biz 
<code>Messenger</code> traitini implementatisiya qiladigan va ma'lum bir qiymatga ega bo'lgan <code>LimitTracker</code> 
yaratsak, <code>value</code> uchun turli raqamlar berganimizda, xabar kerakli xabar ko'rinishida jo'natildi 
deya olishni xohlaymiz.</p>
<p>Pochta orqali yoki matn xabar orqali xabar jo'natish o'rniga biz <code>send</code> ni ishga tushurib yuborilishi kerak bo'lgan xabarni 
kuzatish uchun soxta obyekt kerak bo'ladi. Obyektning yangi namunasini yaratishimiz mumkin, soxta obyektdan foydalanadigan 
<code>LimitTracker</code> yaratib, <code>LimitTracker</code>da <code>set_value</code> metodini qo'llashimiz va soxta obyekt biz kutgan xabar bor yoki yo'qligin 
tekshirib ko'ramiz. 15-21-ro'yxat soxta obyekt implementatsiya qilishga urinishi, lekin borrow tekshiruvchi ruxsat bermasligi ko'rsatilgan: </p>
<p><span class="filename">Faylnomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<p><span class="caption">15-21-ro'yxat: <code>MockMessenger</code>ning implementatsiya qilishga urinishi, ammo borrow checker bunga ruxsat bermayotgaligi ko'rsatilgan</span></p>
<p>Ushbu test kodimiz <code>Sent_messages</code> maydoniga ega bo ªlgan <code>MockMessenger</code> strukturasini belgilaydi va u <code>Vec</code>ga ega bo'lgan <code>String</code> qiymatlari bilan jo ªnatilishi kerak bo ªlgan xabarlarni kuzatib boradi. Shuningdek, biz bo'sh xabarlar ro'yxati bilan boshlanadigan yangi <code>MockMessenger</code> qiymatlarini yaratishni qulay qilish uchun <code>yangi</code> funksiyasini aniqlaymiz. Biz bo'sh xabarlar ro'yxati bilan boshlanadigan yangi MockMessenger qiymatlarini yaratamiz. Keyin biz <code>LimitTracker</code> ga <code>MockMessenger</code>ni berishimiz uchun <code>MockMessenger</code> uchun ‚ÄúMessenger‚Äù xususiyatini amalga oshiramiz. <code>send</code> usulining ta ºrifida biz uzatilgan xabarni parametr sifatida qabul qilamiz va uni <code>sent_messages</code>ning <code>MockMessenger</code> ro ªyxatida saqlaymiz. </p>
<p>Sinovda biz <code>LimitTracker</code>ga <code>value</code>ni <code>max</code> qiymatining 75 foizidan ko‚Äòprog‚Äòiga o‚Äòrnatish buyurilganda nima sodir bo‚Äòlishini sinab ko‚Äòramiz. Birinchidan, biz yangi <code>MockMessenger</code> ni yaratamiz, u xabarlarning bo'sh ro'yxati bilan boshlanadi. Keyin biz yangi <code>LimitTracker</code> yaratamiz va unga yangi <code>MockMessenger</code> va <code>max</code> qiymati 100 ga teng reference beramiz. 100dan 75dan katta bo'lgan, 80ga teng bo'lgan qiymatli <code>LimitTracker</code>dagi <code>set_value</code> metodini ishga tushiramiz. Keyin biz <code>MockMessenger</code> kuzatayotgan xabarlar ro ªyxatida bitta xabar bo ªlishi kerakligini ta ºkidlaymiz.</p>
<p>Biroq, bu testda ko'rsatilganidek, bitta muammo bor:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
2  |     fn send(&amp;self, msg: &amp;str);
   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error
warning: build failed, waiting for other jobs to finish...
</code></pre>
<p>Biz <code>MockMessenger</code>ni xabarlarni kuzatib borish uchun o‚Äòzgartira olmaymiz, chunki <code>send</code> metodi <code>self</code>ga o'zgarmas refernce oladi. Shuningdek, xato matnidagi <code>&amp;mut self</code> dan foydalanish taklifini ham qabul qila olmaymiz, chunki <code>send</code> signaturasi <code>Messenger</code> traiti ta ºrifidagi imzoga to ªg ªri kelmas edi (urunib ko'rganingizda qanaqa xatolik (error message) bo'lishini ko'rishingiz mumkin).</p>
<p>Ushbu holatda bizga ichgi o'zgaruvchanlik yordam berishi mumkin! Biz <code>RefCell&lt;T&gt;</code> orqali <code>sent_messages</code>ni joylyamiz, va keyin biz ko'rgan xabarlarni joylashtirish uchun <code>send</code> metodi <code>sent_messages</code>ni o'zgartira oladi. 15-22-ro'yxat bu qanday ko'rinishda bo'lishini ko'rsatadi:</p>
<p><span class="filename">Faylnomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">15-22-ro'yxat: tashqi qiymat o'zgarmas bo'lganida <code>RefCell&lt;T&gt;</code> yordamida ichki qiymatni o'zgaruvchan qilish</span></p>
<p><code>sent_messages</code> maydoni endi <code>Vec&lt;String&gt;</code> o ªrniga <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> turiga ega. 
<code>new</code> funksiyada biz yangisini yaratamiz <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> bo'sh vektor atrofidagi misol.
<code>new</code> funksiyasida biz yangi <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instancesini bo'sh vektor atrofida yaratib olamiz.</p>
<p><code>send</code> metodini ishga tushirishda, traitning ma'no/tarifiga o'xshash bo'lgan birinchi parametr <code>self</code>ning o'zgarmas borrowi bo'lib qolaveradi. Vvektor hisoblangan <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>ninig ichidagi qiymatga o'zgaruvchan reference olish uchun <code>self.sent_messages</code>ning <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>dagi <code>borrow_mut</code>ni ishga tushuramiz. Keyin test paytida yuborilgan xabarlarni kuzatib borish uchun vektorga o'zgaruvchan referenceda <code>push</code> ni ishga tushirishimiz mumkin.</p>
<p>Tasdiqlash uchun biz qilishimiz kerak bo'lgan oxirgi o'zgarish bu: ichki vektor ichida qancha itemlar borligini ko'rish uchun, vektorga o'zgarmas refrence olish uchun<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>dagi <code>borrow</code>ni ishga tushiramiz.</p>
<p><code>RefCell&lt;T&gt;</code>dan qanday ishlatish mumkiniligi bilan tanishdik, keling qanday ishlashi haqida o'raganib chiqaylik.</p>
<h4 id="runtime-vaqtidan-refcellt-yordamida-borrowlarni-kuzatish"><a class="header" href="#runtime-vaqtidan-refcellt-yordamida-borrowlarni-kuzatish">Runtime vaqtidan <code>RefCell&lt;T&gt;</code> yordamida Borrowlarni kuzatish</a></h4>
<p>O'zgarmas va o'zgaruvchan referencelarni yaratishda biz mos ravishda <code>&amp;</code> va <code>&amp;mut</code> sintaksisidan foydalanamiz. <code>RefCell&lt;T&gt;</code> bilan biz <code>RefCell&lt;T&gt;</code>ga tegishli xavfsiz API tarkibiga kiruvchi <code>borrow</code> va <code>borrow_mut</code> usullaridan foydalanamiz. <code>borrow</code> metodi <code>Ref&lt;T&gt;</code> smart pointer turini, <code>borrow_mut</code> esa <code>RefMut&lt;T&gt;</code> smart pointer turini qaytaradi. Ikkala tur ham <code>Deref</code> ni implementatsiya qiladi, shuning uchun biz ularni/doimiy oddiy reference kabi ko'rib chiqishimiz mumkin.</p>
<p><code>RefCell&lt;T&gt;</code> hozirda qancha <code>Ref&lt;T&gt;</code> va <code>RefMut&lt;T&gt;</code> smart pointerlari faol ekanligini kuzatib boradi. Har safar biz <code>borrow</code> ishga tushirganimizda, <code>RefCell&lt;T&gt;</code> qancha o'zgarmas borrowlar faolligini oshiradi. Agar <code>Ref&lt;T&gt;</code> qiymati chegarasidan chiqib ketsa, o'zgarmas borrowlar soni bittaga kamayadi. Kompilyatsiya vaqtidagi borrowing qoidalari kabi, <code>RefCell&lt;T&gt;</code> bizga istalgan vaqtda ko ªp o ªzgarmas yoki bitta o ªzgaruvchan borrowga ega bo ªlish imkonini beradi.</p>
<p>Agar biz referencelarda bo'lgani kabi kompilyator xatosini olishdan ko'ra, ushbu qoidalarni buzishga harakat qilsak, <code>RefCell&lt;T&gt;</code> amalga oshirilishi runtime vaqtida panic qo'yadi. 15-23 ro'yxatda 15-22 ro'yxatda <code>send</code> ning implementatsiyasining modifikatsiyasi ko'rsatilgan. <code>RefCell&lt;T&gt;</code> runtimeda buni amalga oshirishga to'sqinlik qilishini ko‚Äòrsatish uchun biz ataylab bir xil qamrov uchun faol ikkita o‚Äòzgaruvchan borrowni yaratishga harakat qilapmiz.</p>
<p><span class="filename">Faylnomi: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that <code>RefCell&lt;T&gt;</code> will panic</span></p>
<p><code>borrow_mut</code>dan qaytarilgan <code>RefMut&lt;T&gt;</code> smart pointer uchun <code>one_borrow</code> o'zgaruvchisini yaratamiz. Keyin <code>two_borrow</code> o'zgaruvchisida xuddi shu tarzda boshqa o'zgaruvchan borrow hosil qilamiz. Bu bir scopeda ikkita o'zgaruvchan reference qiladi, bu aslida mumkin emas. Kutubxonamiz uchun testlarni o'tkazganimizda, 15-23 ro'yxatdagi kod hech qanday xatosiz kompilyatsiya qilinadi, ammo test muvaffaqiyatsiz bo'ladi:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>E'tibor bering ushbu kod quyidagi panicni keltirib chiqardi <code>already borrowed: BorrowMutError</code>. Bu <code>RefCell&lt;T&gt;</code>runtime vaqtida borrowing qoidalari buzilishini boshqariishini ko'rsak bo'ladi</p>
<p>Ko'p marta qilganimizdek, ya'ni kompilyatsiya vaqtida emas, balki ish vaqtida borriwing 
xatolarini ko'rish, ishlab chiqish jarayonida keyinchalik kodingizda 
xatolar topishingiz mumkinligini anglatadi, ya'ni sizning kodingiz productionga 
deploy qilinmagungacha. Bundan tashqari, sizning kodingiz kompilyatsiya vaqtida emas, aksincha runtime 
vaqtida borrowlarni kuzatib borishi natijasida kichik runtime xatolik bo'lishi mumkin. 
Lekin, <code>RefCell&lt;T&gt;</code>dan foydalanish faqat o'zgaruvchan qiymatlar mumkin bo'lgan kontekstdan foydalanayotgan
vaqtingizdagi xabarlarni kuzatish uchun o'zini o'zgaritira oladigan soxta obyektni yaratish imkonini beradi. Doimiy referencelardan ko'ra ko'proq funksionallikni olishni xohlasangiz <code>RefCell&lt;T&gt;</code>dan foydalanishingiz mumkin, uning farqli tomomnlariga qaramasdan ham.</p>
<h3 id="rct-va-refcelltni-birlashtirish-orqali-ozgaruvchan-malumotlarning-bir-nechta-egalariga-ega-bolish"><a class="header" href="#rct-va-refcelltni-birlashtirish-orqali-ozgaruvchan-malumotlarning-bir-nechta-egalariga-ega-bolish"><code>Rc&lt;T&gt;</code> va <code>RefCell&lt;T&gt;</code>ni birlashtirish orqali o<code>zgaruvchan ma</code>lumotlarning bir nechta egalariga ega bo`lish</a></h3>
<p><code>RefCell&lt;T&gt;</code> dan foydalanishning keng tarqalgan usuli <code>Rc&lt;T&gt;</code> bilan kombinatsiyadir. Eslatib o'tamiz, <code>Rc&lt;T&gt;</code> sizga ba'zi ma'lumotlarning bir nechta egalariga ega bo'lish imkonini beradi, lekin u faqat ushbu ma'lumotlarga o'zgarmas ruxsat beradi. Agar sizda <code>RefCell&lt;T&gt;</code> ga ega <code>Rc&lt;T&gt;</code> bo ªlsa, siz bir nechta egalari bo ªlishi mumkin bo ªlgan <em>va</em> siz o'zgartira oladigan qiymatni olishingiz mumkin!</p>
<p>Misol uchun, 15-18-sonli ro'yxatdagi kamchiliklar ro'yxati misolini eslang, bu ro'yxatda bir nechta ro'yxatlarga boshqa ro'yxat egaligini ulashishga ruxsat berish uchun <code>Rc&lt;T&gt;</code> dan foydalanganmiz. <code>Rc&lt;T&gt;</code> faqat o ªzgarmas qiymatlarga ega bo ªlgani uchun biz ularni yaratganimizdan so ªng biz ro ªyxatdagi qiymatlarni o ªzgartira olmaymiz. Ro'yxatlardagi qiymatlarni o'zgartirish imkoniyatiga ega bo'lish uchun <code>RefCell&lt;T&gt;</code> ni qo'shaylik. 15-24-ro'yxat shuni ko'rsatadiki, <code>Cons</code> ta'rifida <code>RefCell&lt;T&gt;</code> dan foydalanib, biz barcha ro'yxatlarda saqlangan qiymatni o'zgartirishimiz mumkin:</p>
<p><span class="filename">src/main.rs nomli fayl:</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}</code></pre></pre>
<p><span class="caption">15-24-ro'yxat: <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> yordamida o'zgaruvchan <code>List</code> yaratish</span></p>
<p>Keyinchalik to'g'ridan-to'g'ri foydalana olishimiz mumkin bo'lgan <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> namunasi (instance) bo'lgan qiymatni yaratamiz <code>value</code> nomli o'zgaruvchiga joylashtiramiz. Keyin <code>a</code> bilan birga <code>value</code>ni o'z ichiga olgan <code>Cons</code> variantida <code>List</code> yaratamiz. <code>value</code>ni klonlashimiz kerak bo'ladi, shunda <code>value</code>dan <code>a</code>ga ownershipni (egalik) berishdan yoki <code>value</code>dan <code>a</code> borrowga ega bo;lishdan ko'ra <code>a</code> va <code>value</code>ning ikkalasi ham ichki <code>5</code>ga ownershipga (egalikka) ega bo'ladilar.</p>
<p>15-18-ro'yxatda qilganimizdek, <code>a</code> ro'yxatini <code>Rc&lt;T&gt;</code> ichiga o'rab olamiz, shunda <code>b</code> va <code>c</code> ro'yxatlarini yaratganimizda, ular ikkalasi ham <code>a</code> ga murojaat (refer) qilishlari mumkin bo'ladi</p>
<p><code>a</code>, <code>b</code> va <code>c</code> ro'yxatlarini yaratganimizdan so'ng, biz <code>qiymat</code> qiymatiga 10 qo'shmoqchimiz. Biz buni 5-bobda muhokama qilgan avtomatik yo ªqotish xususiyatidan foydalanadigan <code>value</code>da <code>borrow_mut</code> ni ishga tushurishh orqali, ya'ni <code>Rc&lt;T&gt;</code>ni ichki <code>RefCell&lt;T&gt;</code> qiymatiga yo'naltirish orqali amalga oshiramiz ([<code>-&gt;</code> Operatori Qayerda?‚Äù]ida ko'ring <a href="ch05-03-method-syntax.html#wheres-the---operator">wheres-the---operator</a><!-- ignore -->). <code>borrow_mut</code> usuli <code>RefMut&lt;T&gt;</code> smart pointerini qaytaradi va biz unda dereference operatoridan foydalanamiz va uning ichki qiymatni o`zgartiramiz.</p>
<p><code>a</code>, <code>b</code>, va <code>c</code> print qilganimizda, 5dan ko'ra 15lik qiymatni hammasi o'zgaritirish kiritganligini ko'rishimiz mumkin.</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Ushbu uslub juda jozibali! <code>RefCell&lt;T&gt;</code> dan foydalanib, biz tashqi o'zgarmas <code>List</code> qiymatiga ega bo'lamiz. Lekin biz <code>RefCell&lt;T&gt;</code> da uning ichki o'zgaruvchanligiga kirish/boshqarishni ta'minlaydigan metoddan foydalanishimiz mumkin, shunda kerak bo'lganda ma'lumotlarimizni o'zgartirishimiz mumkin. Runtime qarz olish (borrowing) qoidalari bizni ma'lumotlar o'zgaruvchanligidan (data races) himoya qilishini tekshiradi, va ba'zida ma'lumotlar tuzilmalarimizdagi bu moslashuvchanlik uchun biroz tezlikni oshirishga/o'zgaritishga (trading) arziydi. <code>RefCell&lt;T&gt;</code> ko'p oqimli (multithreaded) kod uchun ishlamaydi, shuni inobatga oling! <code>Mutex&lt;T&gt;</code> bu <code>RefCell&lt;T&gt;</code> ning xafsizroq versiyasidir va biz <code>Mutex&lt;T&gt;</code> ni 16-bobda muhokama qilamiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yonaltiruvchi-tsikllar-xotirani-oqishi-mumkin"><a class="header" href="#yonaltiruvchi-tsikllar-xotirani-oqishi-mumkin">Yo'naltiruvchi tsikllar xotirani oqishi mumkin</a></h2>
<p>Rustning xotira xavfsizligi kafolatlari buni qiyinlashtiradi, lekin imkonsiz emas
tasodifan hech qachon tozalanmaydigan xotira yaratish (<em>xotira oqish</em> deb nomlanadi).
Xotiraning oqishi to'liq oldini olish Rustning kafolatlaridan biri emas, ya'ni
xotira sƒ±zƒ±ntƒ±larƒ± Rust-da xotira xavfsizdir. Rust xotira oqishiga ruxsat berishini ko'rishimiz mumkin
<code>Rc&lt;T&gt;</code> va <code>RefCell&lt;T&gt;</code> dan foydalanib: bu yerda havolalar yaratish mumkin.
elementlar siklda bir-biriga ishora qiladi. Bu xotira oqishini yaratadi, chunki
tsikldagi har bir elementning mos yozuvlar soni hech qachon 0 ga etib bormaydi va qiymatlar
hech qachon tashlab ketilmaydi.</p>
<h3 id="malumot-siklini-yaratish"><a class="header" href="#malumot-siklini-yaratish">Malumot siklini yaratish</a></h3>
<p>Keling, mos yozuvlar sikli qanday sodir bo'lishi mumkinligini va uni qanday oldini olishni ko'rib chiqaylik,
Listingdagi <code>List</code> enum va <code>tail</code> usulining ta`rifidan boshlab
15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<p><span class="caption">Listing 15-25: A cons list definition that holds a
<code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to</span></p>
<p>Biz 15-5 ro ªyxatdagi ‚ÄúRo ªyxat‚Äù ta ºrifining boshqa variantidan foydalanmoqdamiz. The
<code>Cons</code> variantidagi ikkinchi element endi <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, ya`ni
Biz Listingda bo'lgani kabi &quot;i32&quot; qiymatini o'zgartirish imkoniyatiga ega bo'lish o'rniga
15-24, biz 'Kasalliklar' varianti ko'rsatayotgan 'Ro'yxat' qiymatini o'zgartirmoqchimiz.
Bizga kirishni qulay qilish uchun biz &quot;quyruq&quot; usulini ham qo'shmoqdamiz
ikkinchi element, agar bizda &quot;Kasalliklar&quot; varianti bo'lsa.</p>
<p>15-26 ro ªyxatda biz ‚Äúasosiy‚Äù funksiyani qo ªshmoqdamiz.
Ro'yxat 15-25. Bu kod <code>a</code> ro<code>yxatini va </code>b<code> ga ishora qiluvchi ro</code>yxatni yaratadi
<code>a</code> ichidagi ro'yxat. Keyin u <code>a</code> ro<code>yxatini </code>b<code> ga ishora qilib o</code>zgartiradi va a ni yaratadi
mos yozuvlar aylanishi. Yo'lda nima ekanligini ko'rsatish uchun `println!' iboralari mavjud
mos yozuvlar soni bu jarayonning turli nuqtalarida.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}</code></pre></pre>
<p><span class="caption">Listing 15-26: Creating a reference cycle of two <code>List</code>
values pointing to each other</span></p>
<p>Biz ‚Äúa‚Äù o‚Äòzgaruvchisida ‚ÄúRo‚Äòyxat‚Äù qiymatiga ega ‚ÄúRc<List>‚Äù misolini yaratamiz.
boshlang'ich ro'yxati &quot;5, Nil&quot; bilan. Keyin biz <code>Rc&lt;List&gt;</code> misol xoldingini yaratamiz
10 qiymati va nuqtalarni o'z ichiga olgan &quot;b&quot; o'zgaruvchisidagi boshqa &quot;Ro'yxat&quot; qiymati
<code>a</code> ro'yxatiga.</p>
<p>Biz &quot;a&quot; ni o'zgartiramiz, shuning uchun u &quot;Nil&quot; o'rniga &quot;b&quot; ga ishora qiladi va sikl hosil qiladi. Biz qilamiz
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> ga havola olish uchun <code>tail</code> usuli yordamida
&quot;a&quot; da, biz &quot;link&quot; o'zgaruvchisini qo'yamiz. Keyin biz &quot;borrow_mut&quot; dan foydalanamiz
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> ichidagi qiymatni <code>Rc&lt;List&gt;</code>dan o ªzgartirish uchun usul
Bu <code>b</code> dagi <code>Rc&lt;List&gt;</code> uchun <code>Nil</code> qiymatiga ega.</p>
<p>Ushbu kodni ishga tushirganimizda, oxirgi <code>println!</code> uchun izoh berilgan
lahzada biz ushbu natijani olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p><code>a</code> va <code>b</code>dagi <code>Rc&lt;List&gt;</code> misollarining mos yozuvlar soni 2 dan keyin
biz <code>a</code> ro<code>yxatini </code>b<code> ga ishora qilish uchun o</code>zgartiramiz. &quot;Asosiy&quot; oxirida Rust ni tushiradi
<code>b</code> o'zgaruvchisi, bu <code>b</code> <code>Rc&lt;List&gt;</code> misolining mos yozuvlar sonini kamaytiradi
2 dan 1 gacha. <code>Rc&lt;List&gt;</code> to'plamida bo'lgan xotira o'chirilmaydi.
bu nuqta, chunki uning mos yozuvlar soni 0 emas, 1. Keyin Rust <code>a</code> tushiradi, qaysi
<code>a</code> <code>Rc&lt;List&gt;</code> misolining mos yozuvlar sonini 2 dan 1 gacha kamaytiradi
yaxshi. Bu misolning xotirasini ham tashlab bo'lmaydi, chunki boshqasi
<code>Rc&lt;List&gt;</code> misoli hali ham unga ishora qiladi. Ro'yxatga ajratilgan xotira bo'ladi
abadiy yig'ilmagan qoladi. Ushbu mos yozuvlar siklini tasavvur qilish uchun biz yaratdik
15-4-rasmdagi diagramma.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other</span></p>
<p>Agar siz oxirgi <code>println!</code>-ni izohdan olib tashlasangiz va dasturni ishga tushirsangiz, Rust bunga harakat qiladi
bu siklni <code>a</code> bilan <code>b</code> <code>a</code> ga ishora qilib va ‚Äã‚Äãshunga o`xshash davom etguncha chop eting
stekni to'ldirib yuboradi.</p>
<p>Haqiqiy dunyo dasturi bilan taqqoslaganda, oqibatlar mos yozuvlar aylanishini yaratadi
bu misolda unchalik dahshatli emas: biz mos yozuvlar siklini yaratganimizdan so'ng,
dastur tugaydi. Ammo, agar murakkabroq dasturda ko'p xotira ajratilgan bo'lsa
siklda va uni uzoq vaqt ushlab tursa, dastur ko'proq xotiradan foydalanadi
kerak bo'lganidan ko'ra va tizimni to'sib qo'yishi mumkin, bu esa uning tugashiga olib keladi
mavjud xotira.</p>
<p>Malumot davrlarini yaratish oson emas, lekin bu ham imkonsiz emas.
Agar sizda <code>Rc&lt;T&gt;</code> qiymatlari yoki shunga o'xshash ichki o'rnatilgan <code>RefCell&lt;T&gt;</code> qiymatlari mavjud bo'lsa
ichki o'zgaruvchanlik va mos yozuvlar hisoblash bilan turlarning kombinatsiyasi, siz kerak
tsikllarni yaratmasligingizga ishonch hosil qiling; ularni qo'lga olish uchun siz Rustga tayanolmaysiz.
Malumot siklini yaratish dasturingizdagi mantiqiy xato bo'lishi mumkin
avtomatlashtirilgan testlar, kodlarni ko'rib chiqish va boshqa dasturiy ta'minotni ishlab chiqish amaliyotlaridan foydalaning
minimallashtirish.</p>
<p>Malumot davrlarini oldini olishning yana bir yechimi ma ºlumotlaringizni qayta tashkil etishdir
tuzilmalar shunday qilib, ba'zi havolalar egalik huquqini bildiradi, ba'zi havolalar esa bildirmaydi.
Natijada, siz ba'zi egalik munosabatlaridan tashkil topgan davrlarga ega bo'lishingiz mumkin va
ba'zi mulkiy bo'lmagan munosabatlar va faqat mulkchilik munosabatlari ta'sir qiladi
qiymat tushirilishi mumkinmi yoki yo'qmi. 15-25 ro'yxatda biz har doim &quot;Kasalliklar&quot; ni xohlaymiz
o'z ro'yxatiga egalik qilish variantlari mavjud, shuning uchun ma'lumotlar strukturasini qayta tashkil qilish mumkin emas.
Keling, ota-ona va tugunlardan tashkil topgan grafiklardan foydalangan holda misolni ko'rib chiqaylik
egalik bo'lmagan munosabatlar qachon oldini olish uchun to'g'ri yo'l ekanligini ko'rish
mos yozuvlar davrlari.</p>
<h3 id="preventing-reference-cycles-turning-an-rct-into-a-weakt"><a class="header" href="#preventing-reference-cycles-turning-an-rct-into-a-weakt">Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></a></h3>
<p>Hozirgacha biz &quot;Rc::clone&quot; ni chaqirish ko'rsatkichni oshirishini ko'rsatdik
<code>Rc&lt;T&gt;</code> misolining <code>kuchli_hisobchasi</code> va <code>Rc&lt;T&gt;</code> misoli faqat tozalanadi
yuqoriga, agar uning &quot;kuchli_hisoblash&quot; qiymati 0 bo'lsa. Shuningdek, &quot;kuchli_hisob&quot; ga * zaif havola* yaratishingiz mumkin
<code>Rc&lt;T&gt;</code> misolidagi qiymatni <code>Rc::downgrade</code> deb chaqirish va
<code>Rc&lt;T&gt;</code> ga havola. Kuchli havolalar egalik huquqini baham ko'rishingiz mumkin
<code>Rc&lt;T&gt;</code> misoli. Zaif havolalar egalik munosabatlarini bildirmaydi,
va <code>Rc&lt;T&gt;</code> namunasi tozalanganda ularning soni ta'sir qilmaydi. Ular
mos yozuvlar aylanishiga olib kelmaydi, chunki ba'zi zaif havolalarni o'z ichiga olgan har qanday tsikl
jalb qilingan qiymatlarning kuchli mos yozuvlar soni 0 bo'lsa, buziladi.</p>
<p><code>Rc::downgrade</code> ga qo<code>ng</code>iroq qilganingizda, siz <code>Zaif&lt;T&gt;</code> tipidagi aqlli ko<code>rsatgichga ega bo</code>lasiz.
<code>Rc&lt;T&gt;</code> misolidagi <code>strong_count</code> ni 1 ga oshirish o<code>rniga, </code>Rc::downgrade<code> </code>zaif_hisobni<code>1 ga oshiradi.</code>Rc<T><code>turi foydalanadi Qancha</code>Zaif<T><code>havolalari mavjudligini kuzatish uchun</code>zaif_hisob<code></code>kuchli_hisob<code>. Farqi shundaki, &quot;zaif_hisob&quot; uchun 0 bo'lishi shart emas </code>Rc<T>` namunasi tozalanadi.</p>
<p>Chunki <code>Zaif&lt;T&gt;</code> havola qiladigan qiymat o ªchirilgan bo ªlishi mumkin
<code>Zaif&lt;T&gt;</code> ko'rsatayotgan qiymatga ega bo'lgan har qanday narsaga ishonch hosil qilishingiz kerak
qiymati hali ham mavjud. Buni ‚ÄúZaif<T>‚Äù da ‚Äúyangilash‚Äù usulini chaqirish orqali bajaring
misol, bu <code>Option&lt;Rc&lt;T&gt;&gt;</code>ni qaytaradi. Siz &quot;Ba'zi&quot; natijasini olasiz
agar &quot;Rc<T>&quot; qiymati hali tushirilmagan bo'lsa va &quot;Yo'q&quot; natijasi, agar
<code>Rc&lt;T&gt;</code> qiymati olib tashlandi. Chunki <code>yangilash</code> <code>Option&lt;Rc&lt;T&gt;&gt;</code>ni qaytaradi,
Rust <code>Some</code> ishi va <code>None</code> ishi ko'rib chiqilishini ta'minlaydi va
yaroqsiz ko'rsatgich bo'lmaydi.</p>
<p>Misol sifatida, elementlari faqat keyingi haqida biladigan ro'yxatni ishlatish o'rniga
elementi bo ªlsa, biz daraxt yaratamiz, uning ob ºyektlari o ªz bolalari buyumlari haqida <em>va</em>
ularning ota-onalari.</p>
<h4 id="creating-a-tree-data-structure-a-node-with-child-nodes"><a class="header" href="#creating-a-tree-data-structure-a-node-with-child-nodes">Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</a></h4>
<p>Boshlash uchun biz ularning tugunlari haqida biladigan tugunlari bo'lgan daraxt quramiz.
Biz o'zining &quot;i32&quot; qiymatiga ega bo'lgan &quot;tugun&quot; nomli tuzilmani yaratamiz.
uning bolalar 'Tugun' qiymatlariga havolalar:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Biz &quot;Tugun&quot; o'z farzandlariga ega bo'lishini istaymiz va biz bu egalikni baham ko'rmoqchimiz
o'zgaruvchilar, shuning uchun biz daraxtdagi har bir &quot;Tugun&quot; ga to'g'ridan-to'g'ri kirishimiz mumkin. Buning uchun biz
<code>Vec&lt;T&gt;</code> elementlarini <code>Rc&lt;Node&gt;</code> tipidagi qiymatlar sifatida belgilang. Biz ham xohlaymiz
qaysi tugunlar boshqa tugunning bolalari ekanligini o'zgartiring, shuning uchun bizda <code>RefCell&lt;T&gt;</code> mavjud
<code>Vec&lt;Rc&lt;tugun&gt;&gt;</code> atrofidagi <code>bolalar</code>.</p>
<p>Keyinchalik, biz strukturaning ta'rifidan foydalanamiz va bitta &quot;Tugun&quot; nomini yaratamiz
<code>barg</code> qiymati 3 va bolalari yo'q va boshqa misol <code>filial</code>
15-27 ro ªyxatda ko ªrsatilganidek, qiymati 5 va ‚Äúbarg‚Äù uning farzandlaridan biri sifatida:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">Listing 15-27: Creating a <code>leaf</code> node with no children
and a <code>branch</code> node with <code>leaf</code> as one of its children</span></p>
<p>Biz <code>Rc&lt;tugun&gt;</code>ni <code>barg</code>da klonlaymiz va uni <code>filial</code>da saqlaymiz, ya<code>ni Endi ‚Äúbarg‚Äùdagi ‚Äútugun‚Äù ikkita egasiga ega: ‚Äúbarg‚Äù va ‚Äúnovda‚Äù. dan olishimiz mumkin 'branch.children' orqali 'shox'dan 'barg'ga, lekin undan olishning iloji yo'q 'barg'dan 'filialga'. Sababi, </code>barg<code> so</code>zi <code>filial</code> va
aloqadorligini bilmaydi. Biz ‚Äúbarg‚Äù ‚Äúfilial‚Äù uning ekanligini bilishini istaymiz
ota-ona. Biz buni keyin qilamiz.</p>
<h4 id="bolaning-ota-onasiga-havolani-qoshish"><a class="header" href="#bolaning-ota-onasiga-havolani-qoshish">Bolaning ota-onasiga havolani qo'shish</a></h4>
<p>Bola tugunni ota-onasidan xabardor qilish uchun biz &quot;ota-ona&quot; maydonini qo'shishimiz kerak
bizning &quot;tugun&quot; tuzilmasining ta'rifi. Muammo nima turini tanlashda
&quot;ota-ona&quot; bo'lishi kerak. Biz bilamizki, unda <code>Rc&lt;T&gt;</code> bo'lishi mumkin emas, chunki bu bo'lar edi
<code>leaf.parent</code> <code>filial</code>ga ishora qiluvchi mos yozuvlar siklini yarating va
<code>barg</code>ga ishora qiluvchi <code>filial.bolalar</code>, bu ularning <code>kuchli_hisobiga</code> olib keladi
qiymatlar hech qachon 0 bo'lmasligi kerak.</p>
<p>O'zaro munosabatlar haqida boshqa yo'l bilan o'ylab, ota-ona tuguniga ega bo'lishi kerak
bolalar: agar ota-ona tugunlari tushirilsa, uning tugunlari sifatida tushirilishi kerak
yaxshi. Biroq, bola o'z ota-onasiga egalik qilmasligi kerak: agar biz bola tugunini tashlasak,
ota-ona hali ham mavjud bo'lishi kerak. Bu zaif havolalar uchun holat!</p>
<p>Shunday qilib, &quot;Rc<T>&quot; o'rniga, &quot;ota-ona&quot; turini &quot;Zaif<T>&quot; dan foydalanamiz,
xususan <code>RefCell&lt;Zaif&lt;tugun&gt;&gt;</code>. Endi bizning &quot;tugun&quot; tuzilmasining ta'rifi ko'rinadi
shunga o'xshash:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>Tugun o'zining asosiy tuguniga murojaat qilishi mumkin, lekin uning ota-onasiga ega emas.
15-28 ro'yxatda biz ushbu yangi ta'rifdan foydalanish uchun &quot;asosiy&quot; ni yangilaymiz, shuning uchun &quot;barg&quot;
tugun o'zining ota-onasi &quot;filial&quot; ga murojaat qilish usuliga ega bo'ladi:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">Listing 15-28: A <code>leaf</code> node with a weak reference to its
parent node <code>branch</code></span></p>
<p>‚ÄúYaproq‚Äù tugunini yaratish 15-27 ro ªyxatga o ªxshaydi, bundan tashqari
&quot;ota-ona&quot; maydoni: &quot;barg&quot; ota-onasiz boshlanadi, shuning uchun biz yangisini yaratamiz,
bo'sh <code>Zaif&lt;tugun&gt;</code> mos yozuvlar misoli.</p>
<p>Shu nuqtada, biz yordamida <code>barg</code> ota-onasiga havola olishga harakat qilganimizda
&quot;yangilash&quot; usulida biz &quot;Yo'q&quot; qiymatini olamiz. Buni biz dan chiqishda ko'ramiz
birinchi <code>println!</code> bayonoti:</p>
<pre><code class="language-matn">barg ota-onasi = Yo'q
</code></pre>
<p>Biz <code>filial</code> tugunini yaratganimizda, u ham yangi <code>Zaif&lt;tugun&gt;</code>ga ega bo'ladi.
&quot;ota&quot; maydonida havola, chunki &quot;filial&quot; da asosiy tugun yo'q.
Bizda hamon ‚Äúbarg‚Äù ‚Äúfilial‚Äù farzandlaridan biri. Bir marta bizda
‚ÄúFilial‚Äùdagi ‚Äútugun‚Äù misolida biz ‚Äúbarg‚Äùni ‚Äúzaif<tugun>‚Äù qilish uchun o‚Äòzgartirishimiz mumkin.
uning ota-onasiga havola. Biz &quot;borrow_mut&quot; usulidan foydalanamiz
<code>barg</code>ning <code>ota</code> maydonida <code>RefCell&lt;Zaif&lt;tugun&gt;&gt;</code> va keyin biz
<code>Rc::downgrade</code> funksiyasidan <code>filial</code>ga <code>Zaif&lt;tugun&gt;</code> havolasini yaratish
<code>filialdagi </code>Rc<tugun>`</p>
<p>Biz ‚Äúbarg‚Äù ning ota-onasini yana chop qilsak, bu safar ‚ÄúBa‚Äôzi‚Äù variantini olamiz
&quot;filial&quot; ni ushlab turish: endi &quot;barg&quot; ota-onasiga kira oladi! Biz &quot;barg&quot; ni chop etganda, biz
Shuningdek, oxir-oqibat bizda bo'lgani kabi stekning to'lib ketishi bilan yakunlangan tsikldan qoching
Ro'yxat 15-26; <code>Zaif&lt;tugun&gt;</code> havolalari <code>(Zaif)</code> sifatida chop etiladi:</p>
<pre><code class="language-matn">barg ota = Ba'zi(tugun {qiymat: 5, ota: RefCell {qiymat: (zaif)},
bolalar: RefCell { qiymat: [tugun {qiymat: 3, ota: RefCell {qiymat: (zaif)},
bolalar: RefCell { qiymat: [] } }] } })
</code></pre>
<p>Cheksiz chiqishning yo'qligi ushbu kod mos yozuvlar yaratmaganligini ko'rsatadi
tsikl. Buni biz qo'ng'iroq qilishdan olgan qadriyatlarimizga qarab ham aytishimiz mumkin
<code>Rc::strong_count</code> va <code>Rc::weak_count</code>.</p>
<h4 id="kuchli_hisob-va-zaif_hisob-dagi-ozgarishlarni-vizualizatsiya-qilish"><a class="header" href="#kuchli_hisob-va-zaif_hisob-dagi-ozgarishlarni-vizualizatsiya-qilish">&quot;Kuchli_hisob&quot; va &quot;zaif_hisob&quot; dagi o'zgarishlarni vizualizatsiya qilish</a></h4>
<p>Keling, <code>Rc&lt;tugun&gt;</code> <code>kuchli_hisoblash</code> va <code>zaif_hisoblash</code> qiymatlari qanday ekanligini ko'rib chiqamiz.
misollar yangi ichki doirani yaratish va yaratishni ko'chirish orqali o'zgaradi
<code>filial</code> shu doiraga kiradi. Shunday qilib, biz &quot;filial&quot; bo'lganda nima sodir bo'lishini ko'rishimiz mumkin
yaratilgan va keyin u ko'lamdan chiqib ketganda tushib ketgan. O'zgartirishlar ko'rsatilgan
15-29 ro'yxatda:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">Listing 15-29: Creating <code>branch</code> in an inner scope and
examining strong and weak reference counts</span></p>
<p>'barg' yaratilgandan so'ng, uning 'Rc<tugun>' kuchli soni 1 va zaif bo'ladi.
0 ning soni. Ichki doirada biz &quot;filial&quot; yaratamiz va uni bog'laymiz.
<code>barg</code>, biz hisoblarni chop etganda, <code>filialdagi </code>Rc<tugun><code>kuchli soni 1 va zaif soni 1 bo‚Äòladi (‚Äúleaf.parent‚Äù ko‚Äòrsatish uchun</code>zaif<tugun><code>bilan</code>filial<code>ga). Hisoblarni ‚Äúbarg‚Äùda chop etganimizda, biz ko'ramiz uning kuchli soni 2 ga teng bo'ladi, chunki </code>filial<code>endi kloniga ega</code>barg<code>ning </code>Rc<tugun><code> </code>branch.children` da saqlanadi, lekin baribir zaif bo'ladi.
soni 0.</p>
<p>Ichki qamrov tugagach, &quot;filial&quot; doiradan chiqib ketadi va kuchli soni
<code>Rc&lt;Node&gt;</code> 0 ga kamayadi, shuning uchun uning <code>Tugun</code> tushiriladi. Zaif hisob 1
'leaf.parent' dan &quot;tugun&quot; tushirilgan yoki yo'qligiga ta'sir qilmaydi, shuning uchun biz
hech qanday xotira oqishiga yo'l qo'ymang!</p>
<p>Qo'llanish doirasi tugagandan so'ng &quot;barg&quot; ning ota-onasiga kirishga harakat qilsak, biz olamiz
Yana 'Yo'q'. Dastur oxirida <code>barg</code>dagi <code>Rc&lt;tugun&gt;</code> kuchli
soni 1 va kuchsiz soni 0, chunki &quot;barg&quot; o'zgaruvchisi endi yagona
yana <code>Rc&lt;tugun&gt;</code> ga murojaat qiling.</p>
<p>Hisoblash va qiymatni pasaytirishni boshqaradigan barcha mantiq o'rnatilgan
<code>Rc&lt;T&gt;</code> va <code>Zaif&lt;T&gt;</code> va ularning <code>Drop</code> xususiyatini amalga oshirish. tomonidan
bolaning ota-onasiga bo'lgan munosabati a bo'lishi kerakligini ko'rsatib
<code>Tugun</code> ta<code>rifida </code>zaif<T><code> havolasi, siz ota-onaga ega bo</code>lishingiz mumkin
tugunlar mos yozuvlar siklini yaratmasdan, bola tugunlariga ishora qiladi va aksincha
va xotira oqadi.</p>
<h2 id="xulosa-14"><a class="header" href="#xulosa-14">Xulosa</a></h2>
<p>Ushbu bobda turli xil kafolatlar berish uchun aqlli ko'rsatkichlardan qanday foydalanish kerakligi ko'rib chiqildi
Rust odatiy havolalar bilan sukut bo'yicha qiladi. The
<code>Box&lt;T&gt;</code> turi ma'lum o'lchamga ega va u yerda ajratilgan ma'lumotlarga ishora qiladi. The
<code>Rc&lt;T&gt;</code> turi to'pdagi ma'lumotlarga havolalar sonini kuzatib boradi
bu ma'lumotlar bir nechta egalariga ega bo'lishi mumkin. <code>RefCell&lt;T&gt;</code> turi ichki ko'rinishi bilan
o'zgaruvchanlik bizga o'zgarmas tur kerak bo'lganda foydalanishimiz mumkin bo'lgan turni beradi, lekin
ushbu turdagi ichki qiymatni o'zgartirish kerak; u qarz olishni ham majbur qiladi
kompilyatsiya vaqtida emas, balki ish vaqtidagi qoidalar.</p>
<p>Shuningdek, ko'plab imkoniyatlarni beradigan &quot;Deref&quot; va &quot;Drop&quot; xususiyatlari ham muhokama qilindi
aqlli ko'rsatkichlarning funksionalligi. Biz sabab bo'lishi mumkin bo'lgan mos yozuvlar davrlarini o'rganib chiqdik
xotira oqishi va ularni <code>Zaif&lt;T&gt;</code> yordamida qanday qilib oldini olish mumkin.</p>
<p>Agar ushbu bob sizni qiziqtirgan bo'lsa va siz o'zingiznikini amalga oshirmoqchi bo'lsangiz
aqlli ko'rsatkichlar, foydaliroq bo'lishi uchun <a href="../nomicon/index.html">‚ÄúThe Rustonomicon‚Äù</a> ni tekshiring
ma'lumot.</p>
<p>Keyinchalik, biz Rustdagi parallellik haqida gaplashamiz. Siz hatto bir nechta yangi narsalarni bilib olasiz
aqlli ko'rsatkichlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency"><a class="header" href="#fearless-concurrency">Fearless Concurrency</a></h1>
<p>Bir vaqtning o'zida dasturlashni(concurrent programming) xavfsiz va samarali boshqarish Rustning asosiy maqsadlaridan biridir. Dasturning turli qismlari mustaqil ravishda bajariladigan(execute) <em>concurrent programming</em> va dasturning turli qismlari bir vaqtning o'zida bajariladigan <em>parallel dasturlash</em> ko'proq kompyuterlar o'zlarining bir nechta protsessorlaridan foydalanishlari sababli tobora muhim ahamiyat kasb etmoqda. Tarixiy jihatdan, ushbu kontekstlarda dasturlash qiyin va xatolarga moyil bo'lgan: Rust buni o'zgartirishga umid qilmoqda.</p>
<p>Dastlab, Rust jamoasi xotira xavfsizligini ta'minlash va parallel muammolarning oldini olish turli usullar bilan hal qilinishi kerak bo'lgan ikkita alohida muammo deb o'ylagan. Vaqt o'tishi bilan jamoa egalik(ownership) va turdagi tizimlar(type system) xotira xavfsizligi <em>va</em> parallellik muammolarini boshqarishga yordam beradigan kuchli vositalar to'plami ekanligini aniqladi! Ownership(egalik) va turlarni tekshirishdan(type checking) foydalangan holda, ko'plab parallellik xatolar runtimedagi xatolardan ko'ra Rustda kompilyatsiya vaqtidagi xatolardir. Shuning uchun, runtime bilan bir vaqtda xatolik yuzaga kelgan aniq holatlarni takrorlash uchun ko'p vaqt sarflashdan ko'ra, noto'g'ri kod kompilyatsiya qilishni rad etadi va muammoni tushuntiruvchi xatoni taqdim etadi. Natijada, siz kodingizni ishlab chiqarishga(production) yuborilgandan keyin emas, balki uning ustida ishlayotganingizda tuzatishingiz mumkin. Biz Rustning bu jihatini <em>fearless</em> <em>concurrency</em> deb nomladik. Fearless concurrency sizga nozik xatolarsiz kod yozish imkonini beradi va yangi xatolarni kiritmasdan qayta tiklash oson.</p>
<blockquote>
<p>Eslatma: Oddiylik uchun biz ko'p muammolarni <em>concurrent</em> va yoki parallel
deb aniqroq bo'lishdan ko'ra <em>concurrent</em> deb ataymiz.
Agar bu kitob concurrency va yoki  parallellik haqida bo'lsa, biz aniqroq bo'lardik.
Ushbu bo'lim uchun, iltimos, biz concurrent ishlatganimizda,
parallel va/yoki concurrentni aqliy ravishda almashtiring.</p>
</blockquote>
<p>Ko'pgina tillar bir vaqtda muammolarni hal qilish(concurrent problem) uchun taklif qiladigan yechimlar haqida dogmatikdir. Misol uchun, Erlang xabarlarni bir vaqtda uzatish uchun oqlangan funksiyaga ega, ammo threadlar orasidagi holatni(state) almashishning noaniq usullariga ega. Mumkin bo'lgan yechimlarning faqat bir qismini qo'llab-quvvatlash high-leveldagi tillar uchun oqilona strategiyadir, chunki high-leveldagi til mavhumlikni qo'lga kiritish uchun ba'zi nazoratdan voz kechishdan foyda va'da qiladi. Biroq, low-leveldagi tillar har qanday vaziyatda eng yaxshi samaradorlik bilan yechimni ta'minlashi va hardwarega(qurilma) nisbatan kamroq abstraktsiyalarga ega bo'lishi kutilmoqda. Shu sababli, Rust sizning vaziyatingiz va talablaringizga mos keladigan tarzda muammolarni modellashtirish uchun turli xil vositalarni taklif qiladi.</p>
<p>Mana biz ushbu bobda muhokama qiladigan mavzular:</p>
<ul>
<li>Bir vaqtning o'zida bir nechta kod qismlarini ishlatish uchun threadlarni qanday yaratish kerak</li>
<li><em>Message-passing</em> Xabarlarni uzatish concurrency, bu yerda kanallar threadlar o'rtasida xabarlar yuboradi</li>
<li><em>Shared-state</em> bir vaqtning o'zida bir nechta thereadlar(multiple thread) ma'lumotlarning bir qismiga kirish huquqiga ega</li>
<li><code>Sync</code> va <code>Send</code> traitlari, Rustning parallellik kafolatlarini foydalanuvchi tomonidan belgilangan turlarga hamda standart kutubxona tomonidan taqdim etilgan turlarga kengaytiradi.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kodni-bir-vaqtning-ozida-ishga-tushirish-uchun-threadlardan-foydalanish"><a class="header" href="#kodni-bir-vaqtning-ozida-ishga-tushirish-uchun-threadlardan-foydalanish">Kodni bir vaqtning o'zida ishga tushirish uchun threadlardan foydalanish</a></h2>
<p>Kodni bir vaqtning o'zida ishga tushirish(simultaneously) uchun threadlardan foydalanish hozirgi operatsion tizimlarning ko'pchiligida bajarilgan(execute) dastur kodi <em>process</em> ishga tushiriladi va operatsion tizim bir vaqtning o'zida bir nechta processlarni boshqaradi.Dastur doirasida siz bir vaqtning o'zida ishlaydigan(simultaneously) mustaqil qismlarga(independent part) ham ega bo'lishingiz mumkin. Ushbu mustaqil qismlarni boshqaradigan xususiyatlar <em>threadlar</em> deb ataladi. Masalan, veb-server bir vaqtning o'zida bir nechta so'rovlarga(requestlar) javob berishi uchun bir nechta(multiple) threadlarga ega bo'lishi mumkin.</p>
<p>Bir vaqtning o'zida bir nechta vazifalarni(multiple task) bajarish uchun dasturingizdagi hisoblashni bir nechta(multiple) threadlarga bo'lish unumdorlikni oshirishi mumkin, ammo bu murakkablikni ham oshiradi.
Theredlar bir vaqtning o'zida(simultaneously) ishlashi mumkinligi sababli, kodingizning turli xil ish threadlaridagi qismlari qaysi tartibda ishlashi haqida hech qanday kafolat yo'q. Bu muammolarga olib kelishi mumkin, masalan:</p>
<ul>
<li>Race conditionlari, bu yerda threadlar ma'lumotlar yoki resurslarga mos kelmaydigan tartibda kirishadi</li>
<li>Deadlock, bu yerda ikkita thread bir-birini kutib, ikkala threadning davom etishiga to'sqinlik qiladi</li>
<li>Faqat ma'lum holatlarda yuzaga keladigan va qayta ishlab chiqarish va ishonchli tarzda tuzatish qiyin bo'lgan xatolar</li>
</ul>
<p>Rust threadlardan foydalanishning salbiy ta'sirini yumshatishga harakat qiladi, lekin multithreadli kontekstda dasturlash hali ham ehtiyotkorlik bilan o'ylashni talab qiladi va bitta threadda ishlaydigan dasturlardan farq qiladigan kod tuzilishini talab qiladi.</p>
<p>Dasturlash tillari threadlarni turli yo'llar bilan amalga oshiradi(impelement qiladi) va ko'pgina operatsion tizimlar yangi threadlarni yaratish uchun til chaqirishi mumkin bo'lgan API-ni taqdim etadi. Rust standart kutubxonasi(standard library) <em>1:1</em> threadni amalga oshirish modelidan foydalanadi, bunda dastur har bir til uchun bitta operatsion tizim threadidan foydalanadi. 1:1 modeliga turli xil o'zgarishlarni keltirib chiqaradigan boshqa theredlar modellarini amalga oshiradigan(implement qiladigan) cratelar mavjud.</p>
<h3 id="spawn-yordamida-yangi-thread-yaratish"><a class="header" href="#spawn-yordamida-yangi-thread-yaratish"><code>spawn</code> yordamida yangi thread yaratish</a></h3>
<p>Yangi thread yaratish uchun biz <code>thread::spawn</code> funksiyasini chaqiramiz va unga yangi threadda ishga tushirmoqchi bo'lgan kodni o'z ichiga olgan closureni (biz 13-bobda closurelar haqida gapirgan edik) o'tkazamiz. 16-1 ro'yxatdagi misol asosiy(main) threaddagi ba'zi matnni va yangi threaddagi boshqa matnni chop etadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;salom ochilgan threaddan {}-raqam!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;salom, main threaddan {}-raqam!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p><span class="caption">Ro'yxat 16-1: Bir narsani chop etish uchun yangi thread yaratish, main thread esa boshqa narsalarni chop etish</span></p>
<p>Esda tutingki, Rust dasturining asosiy ishi tugagach, barcha ochilgan threadlar ishlashni tugatgan yoki tugatmaganidan qat'i nazar, o'chiriladi. Ushbu dasturning chiqishi har safar bir oz boshqacha bo'lishi mumkin, ammo u quyidagilarga o'xshaydi:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">salom, main threaddan 1-raqam!
salom, ochilgan threaddan 1-raqam!
salom, main threaddan 2-raqam!
salom, ochilgan threaddan 2-raqam!
salom, main threaddan 3-raqam!
salom, ochilgan threaddan 3-raqam!
salom, main threaddan 4-raqam!
salom, ochilgan threaddan 4-raqam!
salom, ochilgan threaddan 5-raqam!
</code></pre>
<p><code>thread::sleep</code>ga chaqiruvlar threadni qisqa muddatga uning bajarilishini to'xtatishga majbur qiladi, bu esa boshqa threadning ishlashiga imkon beradi. Ehtimol, threadlar navbatma-navbat bo'ladi, lekin bu kafolatlanmaydi: bu sizning operatsion tizimingiz threadlarni qanday rejalashtirishiga(schedule) bog'liq. Bu ishga tushirishda birinchi bo'lib main thread chop etiladi, garchi ishlab chiqarilgan threadning chop etish bayonoti kodda birinchi bo'lib paydo bo'lsa ham. Va biz paydo bo'lgan thredga <code>i</code> 9 bo'lguncha chop etishni aytgan bo'lsak ham, asosiy thread yopilishidan oldin u 5 ga yetdi.</p>
<p>Agar siz ushbu kodni ishga tushirsangiz va faqat main threaddan olingan ma'lumotlarni ko'rsangiz yoki hech qanday o'xshashlikni ko'rmasangiz, operatsion tizimning threadlar o'rtasida almashishi uchun ko'proq imkoniyatlar yaratish uchun diapazonlardagi raqamlarni oshirib ko'ring.</p>
<h3 id="join-handlerlari-yordamida-barcha-threadlar-tugashini-kutilmoqda"><a class="header" href="#join-handlerlari-yordamida-barcha-threadlar-tugashini-kutilmoqda"><code>join</code> handlerlari yordamida barcha threadlar tugashini kutilmoqda</a></h3>
<p>16-1 ro'yxatidagi kod ko'pincha main thread tugashi tufayli paydo bo'lgan threadni muddatidan oldin to'xtatibgina qolmay, balki threadlarning ishlash tartibiga kafolat yo'qligi sababli, biz ham yangi ochilgangan threadning umuman ishga tushishiga kafolat bera olmaymiz!</p>
<p>O'zgaruvchida <code>thread::spawn</code> ning qaytish(return) qiymatini saqlash orqali ochilgangan threadning ishlamasligi yoki muddatidan oldin tugashi muammosini hal qilishimiz mumkin. <code>thread::spawn</code> ning qaytish turi(return type) <code>JoinHandle</code> dir. <code>JoinHandle</code> - bu tegishli qiymat bo'lib, biz <code>join</code> metodini chaqirganimizda, uning threadi tugashini kutamiz. 16-2 ro'yxatda biz 16-1 ro'yxatda yaratgan <code>JoinHandle</code> dan qanday foydalanish va <code>join</code>ni chaqirish orqali yaratilgan thread <code>main</code> chiqishdan oldin tugashini ko'rsatadi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;salom ochilgan threaddan {}-raqam!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;salom, main threaddan {}-raqam!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 16-2: <code>JoinHandle</code> ni <code>thread::spawn</code> dan saqlash, threadning oxirigacha ishga tushishini kafolatlash</span></p>
<p>Handleda <code>join</code>ni chaqirish, handle bilan ifodalangan thread tugaguncha ishlayotgan threadni bloklaydi. Threadni <em>bloklash</em> uning ish bajarishi yoki chiqishining oldini olish degani. Biz chaqiruvni(call) main threadning <code>foor</code> loop siklidan keyin qo'yganimiz sababli, 16-2 ro'yxatini ishga tushirish shunga o'xshash natijani berishi kerak:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">salom, main threaddan 1-raqam!
salom, main threaddan 2-raqam!
salom, ochilgan threaddan 1-raqam!
salom, main threaddan 3-raqam!
salom, ochilgan threaddan 2-raqam!
salom, main threaddan 4-raqam!
salom, ochilgan threaddan 3-raqam!
salom, ochilgan threaddan 4-raqam!
salom, ochilgan threaddan 5-raqam!
salom, ochilgan threaddan 6-raqam!
salom, ochilgan threaddan 7-raqam!
salom, ochilgan threaddan 8-raqam!
salom, ochilgan threaddan 9-raqam!
</code></pre>
<p>Ikki thread almashishda davom etadi, lekin main thread <code>handle.join()</code> chaqiruvi tufayli kutadi va hosil qilingan thread tugamaguncha tugamaydi.</p>
<p>Ammo keling, <code>main</code> da <code>for</code> loop siklidan oldin <code>handle.join()</code> ni ko‚Äòchirsak nima bo‚Äòlishini ko‚Äòrib chiqamiz, masalan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;salom ochilgan threaddan {}-raqam!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;salom, main threaddan {}-raqam!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
<p>Main thread ochilgan thread tugashini kutadi va keyin <code>for</code> loop siklini ishga tushiradi, shuning uchun bu yerda ko'rsatilganidek, chiqish boshqa qo'shilmaydi:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">salom, ochilgan threaddan 1-raqam!
salom, ochilgan threaddan 2-raqam!
salom, ochilgan threaddan 3-raqam!
salom, ochilgan threaddan 4-raqam!
salom, ochilgan threaddan 5-raqam!
salom, ochilgan threaddan 6-raqam!
salom, ochilgan threaddan 7-raqam!
salom, ochilgan threaddan 8-raqam!
salom, ochilgan threaddan 9-raqam!
salom, main threaddan 1-raqam!
salom, main threaddan 2-raqam!
salom, main threaddan 3-raqam!
salom, main threaddan 4-raqam!
</code></pre>
<p>Kichik tafsilotlar(detail), masalan, <code>join</code> deb ataladigan joy, sizning threadlaringiz bir vaqtning o'zida ishlashi yoki ishlamasligiga ta'sir qilishi mumkin.</p>
<h3 id="threadlar-bilan-move-closuredan-foydalanish"><a class="header" href="#threadlar-bilan-move-closuredan-foydalanish">Threadlar bilan <code>move</code> closuredan foydalanish</a></h3>
<p>Biz tez-tez closurelar <code>thread::spawn</code> ga o'tiladigan <code>move</code> kalit so'zidan foydalanamiz, chunki closure keyinchalik environmentdan foydalanadigan qiymatlarga ownershiplik(egalik) qiladi va shu tariqa bu qiymatlarga ownershiplik huquqini bir threaddan ikkinchisiga o'tkazadi. 13-bobning ‚ÄúMa‚Äôlumotnomalarni qo‚Äòlga kiritish yoki ownershiplik huquqini ko‚Äòchirish‚Äù bo‚Äòlimida biz closure kontekstida <code>move</code>ni muhokama qildik. Endi biz <code>move</code> va <code>thread::spawn</code> o'rtasidagi o'zaro ta'sirga ko'proq e'tibor qaratamiz.</p>
<p>Ro'yxat 16-1da e'tibor bering, biz <code>thread::spawn</code> ga o'tadigan closure hech qanday argument talab qilmaydi: biz ochilgan thread kodidagi main threaddan hech qanday ma'lumotdan foydalanmayapmiz. Tugallangan threaddagi main threaddan ma'lumotlarni ishlatish uchun ochilgan threadning yopilishi kerakli qiymatlarni olishi kerak. 16-3 ro'yxatda main threadda vector yaratish va uni ishlab ochilgan threadda ishlatishga urinish ko'rsatilgan. Biroq, bu hali ishlamaydi, buni birozdan keyin ko'rasiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Mana vektor: {:?}&quot;, v);
    });

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Ro'yxat 16-3: main thread tomonidan yaratilgan vectorni boshqa threadda ishlatishga urinish</span></p>
<p>Closure <code>v</code> dan foydalanadi, shuning uchun u <code>v</code> ni oladi va uni closure environmentining bir qismiga aylantiradi. Chunki <code>thread::spawn</code> bu closureni yangi threadda ishga tushiradi, biz ushbu yangi thread ichidagi <code>v</code> ga kirishimiz kerak. Ammo biz ushbu misolni kompilatsiya qilganimizda, biz quyidagi xatoni olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust <code>v</code> ni qanday capture qilishni <em>infers</em>(xulosa) qiladi va <code>println!</code> faqat <code>v</code> ga reference kerakligi sababli, closure <code>v</code> ni olishga harakat qiladi. Biroq, muammo bor: Rust ochilgan threrad qancha vaqt ishlashini ayta olmaydi, shuning uchun <code>v</code> ga reference har doim haqiqiy(valiq yaroqli) bo'lishini bilmaydi.</p>
<p>16-4 ro'yxatda <code>v</code> ga reference bo'lishi mumkin bo'lgan senariy ko'rsatilgan va u yaroqli(valiq) bo'lmaydi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Mana vektor: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
<p><span class="caption">Ro ªyxat 16-4: <code>v</code> tushiradigan main threaddan <code>v</code> ga referenceni olishga harakat qiluvchi yopilgan thread.</span></p>
<p>Agar Rust bizga ushbu kodni ishga tushirishga ruxsat bergan bo'lsa, ochilgan thread umuman ishlamasdan darhol fonga qo'yilishi mumkin. Ochilgan thread ichida <code>v</code> ga reference bor, lekin main thread darhol <code>v</code> ni tushiradi, biz 15-bobda muhokama qilgan <code>drop</code> funksiyasidan foydalangan holda. Keyin, ochilgan thread bajarila boshlaganda, <code>v</code> endi haqiqiy(valiq) emas, shuning uchun unga referense ham yaroqsiz. Oh yo'q!</p>
<p>16-3 ro'yxatdagi kompilyator xatosini tuzatish uchun xato xabari maslahatidan foydalanishimiz mumkin:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>Closuredan oldin <code>move</code> kalit so‚Äòzini qo‚Äòshish orqali biz closureni Rustga qiymatlarni olishi kerak degan xulosaga(infer) kelishga ruxsat berishdan ko‚Äòra, u foydalanadigan qiymatlarga ownershiklik qilishga majburlaymiz. 16-5 ro'yxatda ko'rsatilgan 16-3 ro'yxatga kiritilgan o'zgartirish biz xohlagan tarzda kompilatsiya bo'ladi va ishlaydi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Mana vektor: {:?}&quot;, v);
    });

    handle.join().unwrap();
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 16-5: <code>move</code> kalit so ªzidan foydalanib, closureni o ªzi foydalanadigan qiymatlarga ownershiplik qilishga majburlash</span></p>
<p>Kodni 16 4 ro'yxatida tuzatish uchun xuddi shu narsani sinab ko'rishimiz mumkin, bu yerda main thread <code>move</code> closuresi orqali <code>drop</code> deb ataladi. Biroq, bu tuzatish ishlamaydi, chunki 16-4-raqamli ro ªyxat boshqa sabablarga ko ªra amalga oshirilmaydi. Agar biz closurega <code>move</code> ni qo‚Äòshsak, biz <code>v</code> ni closure environmentiga o'tkazamiz va biz main threadda endi <code>drop</code> ni chaqira olmaymiz. Buning o'rniga biz ushbu kompilyator xatosini olamiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Here's a vector: {:?}&quot;, v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rustning ownershiplik(egalik) qoidalari bizni yana qutqardi! 16-3 ro ªyxatdagi koddan xatoga yo ªl qo ªydik, chunki Rust konservativ bo ªlib, thread uchun faqat <code>v</code> harfini oldi, bu esa main thread nazariy jihatdan ochilgangan threadning referenceni bekor qilishi mumkinligini anglatadi. Rustga <code>v</code> ownershiplik huquqini ochilgan threadga o'tkazishni aytish orqali biz Rustga main thread endi <code>v</code> dan foydalanmasligiga kafolat beramiz. Agar biz 16-4 ro'yxatni xuddi shunday o'zgartirsak, main threadda <code>v</code> dan foydalanmoqchi bo'lganimizda ownershiplik qoidalarini buzgan bo'lamiz. <code>move</code> kalit so'zi Rustning borrowing olishning konservativ defaultini bekor qiladi; ownershiplik qoidalarini buzishimizga yo'l qo'ymaydi.</p>
<p>Threadar va thread API haqida asosiy tushunchaga ega bo'lgan holda, keling, threadlar bilan nima qilishimiz mumkinligini ko'rib chiqaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="threadlar-orasidagi-malumotlarni-uzatish-uchun-message-passingxabar-uzatishdan-foydalanish"><a class="header" href="#threadlar-orasidagi-malumotlarni-uzatish-uchun-message-passingxabar-uzatishdan-foydalanish">Threadlar orasidagi ma'lumotlarni uzatish uchun Message Passing(xabar uzatish)dan foydalanish</a></h2>
<p>Xavfsiz concurrencyni ta'minlashning tobora ommalashib borayotgan yondashuvlaridan biri bu <em>message passing</em> bo'lib, bu yerda threadlar yoki actorlar bir-biriga ma'lumotlarni o'z ichiga olgan xabarlarni yuborish orqali muloqot qilishadi. <a href="https://golang.org/doc/effective_go.html#concurrency">Go tili texnik hujjatlaridagi</a> shiordagi g‚Äòoya: ‚ÄúXotirani almashish(share) orqali muloqot qilmang; Buning o'rniga, muloqot(communication) orqali xotirani share qiling.&quot;</p>
<p>Message-sending(xabar yuborish) concurrencyni amalga oshirish uchun Rustning standart kutubxonasi <em>channels</em> amalga oshirishni ta'minlaydi. Channel(kanal) - bu umumiy dasturlash tushunchasi bo'lib, uning yordamida ma'lumotlar bir threaddan ikkinchisiga yuboriladi.</p>
<p>Dasturlashdagi kanalni(channel) oqim yoki daryo kabi suvning yo'naltirilgan kanali kabi tasavvur qilishingiz mumkin. Agar siz daryoga rezina o'rdak kabi narsalarni qo'ysangiz, u suv yo'lining oxirigacha pastga tushadi.</p>
<p>Kanalning ikkita yarmi bor: uzatuvchi(transmitte) va qabul qiluvchi(receiver). Transmitterning yarmi daryoga rezina o'rdak qo'yadigan yuqori oqim joyidir va qabul qiluvchining yarmi rezina o'rdak quyi oqimga tushadi. Kodingizning bir qismi siz yubormoqchi bo'lgan ma'lumotlarga ega bo'lgan transmitterdagi metodlarni chaqiradi, boshqa qismi esa kelgan xabarlarni qabul qiluvchi tomonni tekshiradi. Agar transmitter yoki receiverning yarmi tushib qolsa, kanal <em>closed(yopiq)</em> deyiladi.</p>
<p>Bu yerda biz qiymatlarni yaratish va ularni kanalga yuborish uchun bitta threadga ega bo'lgan dasturni va qiymatlarni qabul qiladigan va ularni chop etadigan boshqa threadni ishlab chiqamiz. Featureni tasvirlash uchun kanal yordamida  threadlar orasidagi oddiy qiymatlarni yuboramiz. Texnika bilan tanishganingizdan so'ng, siz bir-biringiz bilan aloqa o'rnatishingiz kerak bo'lgan har qanday threadlar uchun kanallardan foydalanishingiz mumkin, masalan, chat tizimi yoki ko'p threadlar hisoblash qismlarini bajaradigan va qismlarni natijalarni jamlaydigan bitta threadga yuboradigan tizim.</p>
<p>Birinchidan, 16-6 ro'yxatda biz channel(kanal) yaratamiz, lekin u bilan hech narsa qilmaymiz.
E'tibor bering, bu hali kompilyatsiya qilinmaydi, chunki Rust kanal orqali qanday turdagi qiymatlarni yuborishimizni ayta olmaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">Ro'yxat 16-6: Kanal yaratish va ikkita yarmini <code>tx</code> va <code>rx</code> ga belgilash</span></p>
<p>Biz <code>mpsc::channel</code> funksiyasidan foydalanib yangi kanal yaratamiz; <code>mpsc</code> <em>multiple producer, single consumer</em> degan ma ºnoni anglatadi. Qisqa qilib aytganda, Rustning standart kutubxonasi kanallarni implement qilish usuli kanalda qiymatlarni ishlab chiqaradigan bir nechta <em>sending(jo'natish)</em> uchlari bo'lishi mumkin, ammo bu qiymatlarni qabul qiladigan consumer faqat bitta <em>receiving(qabul qiluvchi)</em> end bo'lishi mumkinligini anglatadi. Tasavvur qiling-a, bir nechta daryolar birlashib, bitta katta daryoga quyiladi: har qanday oqim oxirida bitta daryoga tushadi. Hozircha biz bitta ishlab chiqaruvchidan(single producer) boshlaymiz, lekin biz ushbu misol ishlaganda bir nechta producerlarni(multiple producer) qo'shamiz.</p>
<p><code>mpsc::channel</code> funksiyasi tupleni qaytaradi, uning birinchi elementi jo'natuvchi end - transmitter va ikkinchi element - receiver end - qabul qiluvchidir. <code>tx</code> va <code>rx</code> qisqartmalari an'anaviy ravishda ko'plab sohalarda mos ravishda <em>transmitter</em> va <em>receiver</em> uchun ishlatiladi, shuning uchun biz har bir endni ko'rsatish uchun o'zgaruvchilarimizni shunday nomlaymiz. Biz tuplelarni destruksiya pattern <code>let</code> statementdan foydalanmoqdamiz; Biz 18-bobda <code>let</code> statementlarida patternlardan foydalanish va destruksiyani muhokama qilamiz. Hozircha shuni bilingki, <code>let</code> statementdan shu tarzda foydalanish <code>mpsc::channel</code> tomonidan qaytarilgan tuple qismlarini ajratib olishning qulay usuli hisoblanadi.</p>
<p>16-7 ro'yxatda ko'rsatilganidek, transmitter uchini ochilgan threadga o'tkazamiz va u bitta threadni yuborsin, shunda hosil qilingan thread main thread bilan bog'lanadi. Bu daryoning yuqori oqimiga rezina o'rdak qo'yish yoki bir threaddan ikkinchisiga chat xabarini yuborishga o'xshaydi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;salom&quot;);
        tx.send(val).unwrap();
    });
}</code></pre></pre>
<p><span class="caption">Ro ªyxat 16-7: <code>tx</code> ni ochilgan threadga ko ªchirish va <code>salom</code> yuborish</span></p>
<p>Shunga qaramay, biz yangi thread yaratish uchun <code>thread::spawn</code> dan foydalanamiz va keyin <code>move</code> yordamida <code>tx</code> ni yopishga(close) o'tkazamiz, shunda hosil qilingan thread <code>tx</code>ga ega bo'ladi. Kanal orqali xabarlarni jo'natish uchun ochilgan thread transmitterga ega bo'lishi kerak. Transmitterda biz jo'natmoqchi bo'lgan qiymatni qabul qiluvchi <code>send</code> metodi mavjud. <code>send</code> metodi <code>Result&lt;T, E&gt;</code> typeni qaytaradi, shuning uchun agar qabul qiluvchi(receiver) allaqachon drop qilingan bo'lsa va qiymatni yuborish uchun joy bo'lmasa, yuborish operatsiyasi xatolikni qaytaradi. Ushbu misolda biz xatolik yuz berganda panic qo'yish uchun <code>unwrap</code> ni chaqiramiz. Ammo haqiqiy dasturda biz uni to'g'ri hal qilamiz: xatolarni to'g'ri hal qilish strategiyalarini ko'rib chiqish uchun 9-bobga qayting.</p>
<p>16-8 ro'yxatda biz main threaddagi qabul qiluvchidan(receive) qiymatni olamiz. Bu daryoning oxiridagi suvdan rezina o'rdakni olish yoki suhbat xabarini olish kabi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;salom&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Tushundim: {}&quot;, received);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 16-8: main threadda <code>salom</code> qiymatini olish va uni chop etish</span></p>
<p>Receiverda ikkita foydali metod mavjud: <code>recv</code> va <code>try_recv</code>. Biz <code>recv</code> dan foydalanmoqdamiz, bu <em>receive(qabul qilish)</em> ning qisqartmasi bo'lib, u main threadning bajarilishini bloklaydi va kanalga qiymat yuborilguncha kutadi. Qiymat yuborilgach, <code>recv</code> uni <code>Result&lt;T, E&gt;</code> shaklida qaytaradi. Transmitter yopilganda, <code>recv</code> boshqa qiymatlar kelmasligini bildirish uchun xatolikni qaytaradi.</p>
<p><code>try_recv</code> metodi bloklanmaydi, aksincha darhol <code>Result&lt;T, E&gt;</code>ni qaytaradi: <code>Ok</code> qiymati, agar mavjud bo‚Äòlsa, xabarni ushlab turadi va bu safar hech qanday xabar bo‚Äòlmasa, <code>Err</code> qiymati. <code>try_recv</code> dan foydalanish, agar ushbu thread xabarlarni kutayotganda boshqa ishi bo ªlsa foydali bo ªladi: biz tez-tez <code>try_recv</code> ni chaqiradigan, agar mavjud bo'lsa, xabarni ko'rib chiqadigan va boshqasi qayta tekshirilgunga qadar biroz vaqt ishlaydigan sikl yozishimiz mumkin.</p>
<p>Biz ushbu misolda soddalik uchun <code>recv</code> dan foydalandik; bizda main thread uchun xabarlarni kutishdan boshqa ishimiz yo'q, shuning uchun main threadi bloklash maqsadga muvofiqdir.</p>
<p>Kodni 16-8 ro'yxatda ishga tushirganimizda, biz main threaddan chop etilgan qiymatni ko'ramiz:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Tushundim: salom
</code></pre>
<p>Mukammal! Perfect!</p>
<h3 id="kanallar-va-ownershiplikegalkik-huquqini-otkazish"><a class="header" href="#kanallar-va-ownershiplikegalkik-huquqini-otkazish">Kanallar va ownershiplik(egalkik) huquqini o'tkazish</a></h3>
<p>Ownershiplik qoidalari xabarlarni jo'natishda muhim rol o'ynaydi, chunki ular xavfsiz, bir vaqtda kod yozishga yordam beradi. Bir vaqtning o'zida dasturlashda(concurrent programming) xatolarning oldini olish Rust dasturlarida ownershiplik haqida o'ylashning afzalligi hisoblanadi. Muammolarning oldini olish uchun kanallar va ownershiplik qanday ishlashini ko‚Äòrsatish uchun tajriba o‚Äòtkazamiz: biz kanalga yuborganimizdan so‚Äòng <code>val</code> qiymatidan foydalanishga harakat qilamiz. Nima uchun bu kodga ruxsat berilmaganligini bilish uchun 16-9-raqamdagi kodni kompilyatsiya qilib ko'ring:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;salom&quot;);
        tx.send(val).unwrap();
        println!(&quot;qandaysan {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Tushundim: {}&quot;, received);
}</code></pre>
<p><span class="caption">Ro ªyxat 16-9: <code>val</code>ni kanalga yuborganimizdan keyin foydalanishga urinish</span></p>
<p>Bu yerda biz <code>tx.send</code> orqali kanalga yuborganimizdan so‚Äòng <code>val</code>ni chop etishga harakat qilamiz.
Bunga ruxsat berish noto'g'ri fikr bo'ladi: qiymat boshqa threadga yuborilgandan so'ng, biz qiymatni qayta ishlatishdan oldin uni o'zgartirishi yoki tashlab yuborishi(drop) mumkin. Potensial ravishda, boshqa threadning o'zgartirishlari nomuvofiq yoki mavjud bo'lmagan ma'lumotlar tufayli xatolar yoki kutilmagan natijalarga olib kelishi mumkin. Biroq, agar biz 16-9 ro'yxatdagi kodni kompilyatsiya qilmoqchi bo'lsak, Rust bizga xato qiladi:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:31
   |
8  |         let val = String::from(&quot;hi&quot;);
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
</code></pre>
<p>Bizning concurrency xatomiz kompilyatsiya vaqtida xatolikka olib keldi. <code>send</code> funksiyasi o ªz parametriga ownershiplik qiladi va qiymat ko ªchirilganda qabul qiluvchi(receiver) unga ownershiplik qiladi. Bu bizni qiymatni yuborgandan keyin tasodifan qayta ishlatishdan to'xtatadi; ownershiplik tizimi hamma narsa yaxshi ekanligini tekshiradi.</p>
<h3 id="bir-nechta-qiymatlarni-yuborish-va-qabul-qiluvchiningreceiver-kutayotganini-korish"><a class="header" href="#bir-nechta-qiymatlarni-yuborish-va-qabul-qiluvchiningreceiver-kutayotganini-korish">Bir nechta qiymatlarni yuborish va qabul qiluvchining(receiver) kutayotganini ko'rish</a></h3>
<p>16-8 ro'yxatdagi kod kompilatsiya bo'ldi va ishga tushirildi, lekin u bizga ikkita alohida thread kanal orqali bir-biri bilan gaplashayotganini aniq ko'rsatmadi. 16-10-ro'yxatda biz 16-8-ro'yxatdagi kod bir vaqtda ishlayotganini tasdiqlovchi ba'zi o'zgartirishlar kiritdik: ochilgan thread endi bir nechta xabarlarni yuboradi va har bir xabar o'rtasida bir soniya pauza qiladi.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;qandaysan&quot;),
            String::from(&quot;otabek&quot;),
            String::from(&quot;vodiyga&quot;),
            String::from(&quot;ketti&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Tushundim: {}&quot;, received);
    }
}</code></pre>
<p><span class="caption">Ro'yxat 16-10: Bir nechta xabarlarni yuborish va har biri o'rtasida pauza qilish</span></p>
<p>Bu safar, ochilgan threadda biz main threadga yubormoqchi bo'lgan satrlar vektori mavjud. Biz ularni takrorlaymiz, har birini alohida yuboramiz va 1 soniyalik <code>Duration</code> qiymati bilan <code>thread::sleep</code> funksiyasini chaqirish orqali har biri o‚Äòrtasida pauza qilamiz.</p>
<p>Main threadda biz endi <code>recv</code> funksiyasini aniq chaqirmayapmiz: buning o'rniga biz <code>rx</code> ni iterator sifatida ko'rib chiqamiz. Qabul qilingan har bir qiymat uchun biz uni chop etamiz. Kanal yopilganda(close), iteratsiya tugaydi.</p>
<p>16-10 ro'yxatdagi kodni ishga tushirganda, har bir satr orasida 1 soniyalik pauza bilan quyidagi chiqishni ko'rishingiz kerak:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Tushundim: qandaysan
Tushundim: otabek
Tushundim: vodiyga
Tushundim: ketti
</code></pre>
<p>Bizda main threaddagi <code>for</code> siklida pauza yoki kechikishlar keltirib chiqaradigan kod yo‚Äòqligi sababli, biz main thread hosil qilingan threaddan qiymatlarni olishni kutayotganini aytishimiz mumkin.</p>
<h3 id="transmitterni-klonlash-orqali-bir-nechta-producerlarni-yaratish"><a class="header" href="#transmitterni-klonlash-orqali-bir-nechta-producerlarni-yaratish">Transmitterni klonlash orqali bir nechta producerlarni yaratish</a></h3>
<p>Avvalroq <code>mpsc</code> <em>multiple producer, single consumer</em> degan qisqartma ekanligini eslatib o'tgan edik. Keling, 16-10 ro'yxatdagi kodni ishlatish va kengaytirish uchun <code>mpsc</code> ni qo'yaylik va barchasi bir xil qabul qiluvchiga(receiver) qiymatlarni yuboradigan bir nechta threadlarni yaratamiz. Biz buni 16-11 ro'yxatda ko'rsatilganidek, transmitterni klonlash orqali amalga oshirishimiz mumkin:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;salom&quot;),
            String::from(&quot;threaddan&quot;),
            String::from(&quot;siz&quot;),
            String::from(&quot;uchun&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;ko'plab&quot;),
            String::from(&quot;habarlar&quot;),
            String::from(&quot;hammasi&quot;),
            String::from(&quot;ishlayapti&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Tushundim: {}&quot;, received);
    }

    // --snip--
<span class="boring">}</span></code></pre>
<p><span class="caption">Ro'yxat 16-11: Bir nechta producerlardan(multiple producer) bir nechta xabarlarni(multiple message) yuborish</span></p>
<p>Bu safar, birinchi ochilgan threadni yaratishdan oldin, biz transmitterda <code>clone</code> deb nomlaymiz. Bu bizga yangi transmitterni beradi, biz birinchi ochilgan threadga o'tishimiz mumkin. Biz asl transmitterni ikkinchi ochilgan threadga o'tkazamiz.
Bu bizga ikkita thread beradi, ularning har biri bitta qabul qiluvchiga(receiver) turli xabarlar yuboradi.</p>
<p>Kodni ishga tushirganingizda, chiqishingiz quyidagicha ko'rinishi kerak:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Tushundim: salom
Tushundim: threaddan
Tushundim: siz
Tushundim: uchun
Tushundim: ko'plab
Tushundim: habarlar
Tushundim: hammasi
Tushundim: ishlayapti
</code></pre>
<p>Tizimingizga qarab qiymatlarni boshqa tartibda ko'rishingiz mumkin. Bu concurrencyni qiziqarli va qiyin qiladi. Agar siz <code>thread::sleep</code> bilan tajriba o'tkazsangiz, unga turli threadlarda turli qiymatlar bersangiz, har bir ishga tushirish aniqroq bo'lmaydi va har safar har xil chiqish hosil qiladi.</p>
<p>Endi biz kanallar qanday ishlashini ko'rib chiqdik, keling, boshqa concurrency usulini ko'rib chiqaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrencyda-shared-state"><a class="header" href="#concurrencyda-shared-state">Concurrencyda Shared-State</a></h2>
<p>Message passing(Xabarni uzatish) - bu concurrencyni boshqarishning yaxshi usuli, ammo bu yagona emas. Yana bir usul bir nechta(multiple) threadlar bir xil umumiy ma'lumotlarga(shared data) kirishlari mumkin. Go tilidagi texnik hujjatlardagi shiorning ushbu qismini yana bir bor ko'rib chiqing: &quot;xotirani almashish(sharing memory) orqali muloqot(comminicate) qilmang.&quot;</p>
<p>Xotirani almashish(sharing memory) orqali muloqot(comminication) qanday ko'rinishga ega bo'lar edi? Bundan tashqari, nima uchun message-passing enthusiastlar memory sharingdan foydalanmaslik haqida ogohlantiradilar?</p>
<p>Qaysidir ma'noda, har qanday dasturlash tilidagi kanallar bitta ownershiplik huquqiga o'xshaydi, chunki qiymatni kanalga o'tkazganingizdan so'ng, siz boshqa qiymatdan foydalanmasligingiz kerak. Shared memory concurrencyda bir nechta ownershiplik huquqiga o'xshaydi: concurrencyda bir nechta threadlar bir xil xotira joyiga(memory location) kirishi mumkin. 15-bobda ko'rganingizdek, smart pointerlar bir nechta ownershiplik qilish imkoniyatini yaratdi, bir nechta(multiple) ownershiplik murakkablikni oshirishi mumkin, chunki bu turli ownerlarni boshqarish kerak. Rust type tizimi va ownershiplik qoidalari ushbu boshqaruvni to'g'ri bajarishga katta yordam beradi. Misol uchun, shared memory uchun eng keng tarqalgan concurrency primitivlaridan biri bo'lgan mutexlarni ko'rib chiqaylik.</p>
<h3 id="bir-vaqtning-ozida-bitta-threaddan-malumotlarga-kirishga-ruxsat-berish-uchun-mutexlardan-foydalanish"><a class="header" href="#bir-vaqtning-ozida-bitta-threaddan-malumotlarga-kirishga-ruxsat-berish-uchun-mutexlardan-foydalanish">Bir vaqtning o'zida bitta threaddan ma'lumotlarga kirishga ruxsat berish uchun mutexlardan foydalanish</a></h3>
<p><em>Mutex</em> bu <em>mutual exclusion</em> ning qisqartmasi bo ªlib, mutex istalgan vaqtda ba ºzi ma ºlumotlarga faqat bitta threadga kirish imkonini beradi. Mutexdagi ma'lumotlarga kirish uchun thread birinchi navbatda mutexning *lock(qulf)*ni olishni so'rab kirishni xohlashini bildirishi kerak. Lock(qulf) - bu mutexning bir qismi bo'lgan ma'lumotlar tuzilmasi bo'lib, u hozirda ma'lumotlarga kimning eksklyuziv kirish huquqiga ega ekanligini kuzatib boradi. Shuning uchun, mutex qulflash tizimi(locking system) orqali o'zida mavjud bo'lgan ma'lumotlarni <em>himoya qilish(guarding)</em> sifatida tavsiflanadi.</p>
<p>Mutexlardan foydalanish qiyinligi bilan mashhur, chunki siz ikkita qoidani eslab qolishingiz kerak:</p>
<ul>
<li>Ma'lumotlardan foydalanishdan oldin siz qulfni olishga harakat qilishingiz kerak.</li>
<li>Mutex himoya qiladigan ma'lumotlar bilan ishlashni tugatgandan so'ng, boshqa threadlar qulfni(lock) olishi uchun ma'lumotlarni qulfdan chiqarishingiz(unlock) kerak.</li>
</ul>
<p>Mutexni tushunish uchun bitta mikrofon bilan konferensiyada guruh muhokamasining haqiqiy hayotiy misolini tasavvur qiling. Panel ishtirokchisi gapirishdan oldin mikrofondan foydalanishni xohlashini so'rashi yoki signal berishi kerak. Mikrofonni olishganda, ular xohlagancha gaplashishi mumkin va keyin mikrofonni gapirishni so'ragan keyingi ishtirokchiga beradi. Agar panel ishtirokchisi mikrofon bilan ishlashni tugatgandan so'ng uni o'chirishni unutib qo'ysa, boshqa hech kim gapira olmaydi. Agar umumiy mikrofonni boshqarish noto'g'ri bo'lsa, panel rejalashtirilganidek ishlamaydi!</p>
<p>Mutexlarni boshqarish juda qiyin bo'lishi mumkin, shuning uchun ko'p odamlar kanallarga(channel) ishtiyoq bilan qarashadi. Biroq, Rust type tizimi va ownershiplik qoidalari tufayli siz qulflash(locking) va qulfni noto'g'ri ochishingiz(unlocking) mumkin emas.</p>
<h4 id="mutext-api"><a class="header" href="#mutext-api"><code>Mutex&lt;T&gt;</code> API</a></h4>
<p>Mutexdan qanday foydalanishga misol sifatida, keling, 16-12 ro'yxatda ko'rsatilganidek, bitta threadli kontekstda mutexdan foydalanishdan boshlaylik:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut raqam = m.lock().unwrap();
        *raqam = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}</code></pre></pre>
<p><span class="caption">Ro'yxat 16-12: <code>Mutex&lt;T&gt;</code> API-ni soddaligi uchun single-threadli kontekstda o ªrganish</span></p>
<p>Ko'pgina turlarda(type) bo'lgani kabi, biz bog'langan <code>new</code> funksiyasidan foydalangan holda <code>Mutex&lt;T&gt;</code> ni yaratamiz.
Mutex ichidagi ma'lumotlarga kirish uchun biz qulfni olish uchun <code>lock</code> metodidan foydalanamiz. Bu chaqiruv joriy threadni bloklaydi, shuning uchun u bizni qulflash navbati kelmaguncha hech qanday ishni bajara olmaydi.</p>
<p>Qulfni ushlab turgan boshqa thread panic qo'zg'atsa, <code>lock</code> chaqiruvi muvaffaqiyatsiz bo'ladi. Bunday holda, hech kim qulfni qo'lga kirita olmaydi, shuning uchun biz  <code>unwrap</code>ni tanladik va agar shunday vaziyatda bo'lsak, bu threadni panic qo'yishni tanladik.</p>
<p>Qulfni qo'lga kiritganimizdan so'ng, biz bu holatda <code>num</code> deb nomlangan return qiymatini ichidagi ma'lumotlarga o'zgaruvchan reference sifatida ko'rib chiqishimiz mumkin. Tur(type) tizimi <code>m</code> dagi qiymatni ishlatishdan oldin qulfni olishimizni ta'minlaydi. <code>m</code> turi <code>i32</code> emas, <code>Mutex&lt;i32&gt;</code>, shuning uchun biz <code>i32</code> qiymatidan foydalanish uchun <code>lock</code>ni chaqirishimiz kerak. Biz unuta olmaymiz; aks holda turdagi tizim bizga ichki <code>i32</code> ga kirishga ruxsat bermaydi.</p>
<p>Taxmin qilgan bolishingiz mumkinki Mutex<T> aqlli ko'rsatgich. Aniqroq qilib aytadigan bo'lsak, <code>lock</code> qo'ng'irog'i MutexGuard deb nomlangan  ochish
qo'ng'irog'i bilan oralgan LockResult-ga o'ralgan aqlli ko'rsatgichni qaytaradi . <code>MutexGuard</code> ko'rsatkichi esa bizning ichki ma'lumotlarimizga ishora
qilish uchun <code>Deref</code>ni amalga oshiradi( Derefdan foydalanadi). Aqlli ko'rsatgichda <code>Drop</code> ilovasi ham mavjud bo'lib, MutexGuard qo'llanilish doirasidan
tashqariga chiqqanda avtomatik ravishda  qulfni chiqaradi va bu esa ichki doiraning oxirida sodir bo'ladi. Natijada, biz qulfni(lock) bo'shatishni unutib
qo'ymaymiz va asosiysi mutexni boshqa threadlar tomonidan ishlatilishini bloklaymiz, chunki qulfni(lock) chiqarish avtomatik ravishda sodir bo'ladi.</p>
<p>Qulfni tashlaganimizdan so'ng, biz mutex qiymatini print qilishimiz(chop etishimiz ) va ichki <code>i32</code> ni 6 ga o'zgartira olganimizni ko'rishimiz mumkin.</p>
<h4 id="bitta-mutekstni--bir-nechta-mavzular-ortasida-ulashishalmashtirish"><a class="header" href="#bitta-mutekstni--bir-nechta-mavzular-ortasida-ulashishalmashtirish">Bitta <code>Muteks&lt;T&gt;</code>ni  Bir nechta mavzular o'rtasida ulashish(almashtirish):</a></h4>
<p>Keling, <code>Mutex&lt;T&gt;</code>-dan foydalanib, bir nechta oqimlar o'rtasida qiymatni  share qilishga(qiymatni almashtirishga) harakat qilaylik. Biz 10 ta threadni
aylantiramiz va ularning har biri hisoblagich qiymatini 1 ga oshiradi, shuning uchun hisoblagich 0 dan 10 gacha boradi. 16-13 ro'yxatdagi keyingi misolda
kompilyator xatosi (compiler error)bo'ladi va biz bu xatoni o'rganish uchun ishlatamiz. <code>Mutex&lt;T&gt;</code>-dan foydalanish va Rust uni to'g'ri ishlatishimizga
qanday yordam berishi haqida ko'proq o'rganamiz.</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Ro'yxat 16-13: <code>Mutex&lt;T&gt;</code> tomonidan qo'riqlanadigan hisoblagichni har biri o'nta threaddan amalga oshirishi.</span></p>
<p><code>Mutex&lt;T&gt;</code>ni ichida <code>i32</code> ni ushlab turish uchun hisoblagich o'zgaruvchisini yaratamiz, xuddi 16-12 ro'yxatdagi kabi(listing 16-12). Keyingi amal esa,
biz raqamlar oralig'ida takrorlash orqali 10 ta thread yaratamiz. Biz <code>thread::spawn</code> dan foydalanamiz va barcha threadlarga bir xil yopilishni beramiz:
hisoblagichni threadga o'tkazish uchun ishlatiladigan  qulflash usulini amalga oshirish orqali(chaqirish orqali) orqali <code>Mutex&lt;T&gt;</code> da blokirovkaga ega
bo'ladi va keyin mutexdagi qiymatga 1 qo'shiladi. Thread o'zining yopilishini tugatgandan so'ng, <code>num</code> doirasi tashqariga chiqadi va boshqa thread uni
olishi uchun qulfni bo'shatadi.</p>
<p>Asosiy threadda biz barcha birlashma tutqichlarini yig'amiz. Keyin, 16-2 ro'yxatdagidek,barcha threadlar tugashiga ishonch hosil qilish uchun har bir
tutqichga <code>join</code> chaqiramiz. O'sha paytda asosiy thread qulfni oladi va ushbu dasturning natijasini print(chop etadi).</p>
<p>Bu misol tuzilmasligiga ishora qilingan. Endi nima uchunligini o'ylab ko'raylik!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>Xato xabari <code>counter</code>(hisoblagich) qiymati tsiklning oldingi iteratsiyasida ko'chirilganligini bildiradi. Rust bizga qulflash <code>counter</code>(hisoblagichining)
egaligini bir nechta mavzularga o'tkaza olmasligimizni aytadi. Keling, 15-bobda muhokama qilgan bir nechta egalik usuli bilan kompilyator xatosini
tuzataylik.</p>
<h4 id="bir-nechta-mavzular-bilan-bir-nechta-egalik"><a class="header" href="#bir-nechta-mavzular-bilan-bir-nechta-egalik">Bir nechta mavzular bilan bir nechta egalik</a></h4>
<p>15-bobda mos yozuvlar hisoblangan qiymatni yaratish uchun aqlli ko'rsatkich Rc<T> yordamida bir nechta egalarga qiymat berdik. Bu yerda ham xuddi shunday
qilaylik va nima bo'lishini ko'ramiz.  <code>Mutex&lt;T&gt;</code>-ni  <code>Rc &lt;T&gt;</code>-ga 16-14-listingda o'rab olamiz va egalikni threadga ko'chirishdan oldin  <code>Rc&lt;T&gt;</code>-ni
klonlaymiz(nusxasini yaratmoq, cloning).</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre>
<p><span class="caption">Listing 16-14: <code>Rc&lt;T&gt;</code> ni ishlatib, bir nechta iplar (threads) <code>Mutex&lt;T&gt;</code> ga egalik qilishiga imkon berishga urinish.</span></p>
<p>Yana bir bor, biz kompilyatsiya qilamiz va... turli xatolarni olamiz! Kompilyator bizga ko'p narsani o'rgatmoqda.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `[closure@src/main.rs:11:36: 11:43]`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 11:43]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:704:8
   |
   = note: required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>Afsus, bu xato xabari juda uzun va yoqimsizroq(rasmiyligi uchun) ekan! Bu yerda diqqat qilish kerak bo'lgan muhim qism:
<code>Rc&lt;Mutex&lt;i32&gt;&gt; ` threadlar o'rtasida xavfsiz yuborilishi mumkin emas</code>. Kompilyator bizga buning sababini ham aytib beradi: <code>Send </code> xususiyati
<code>Rc&lt;Mutex&lt;i32&gt;&gt; </code> uchun amalga oshirilmagan. Keyingi bo'limda<code> Send</code>(Yuborish) haqida gaplashamiz: bu biz threadlar bilan ishlatadigan turlarni bir
vaqtda vaziyatlarda foydalanishga mo'ljallanganligini ta'minlaydigan xususiyatlardan biridir.</p>
<p>Afsuski, <code>Rc&lt;T&gt;</code> ni threadlar bo'ylab almashish xavfsiz emas(yuqorida ham aytilishicha mumkin ham emas). <code>Rc&lt;T&gt;</code> mos yozuvlar sonini boshqarganda, u clone
(klonlash) uchun har bir qo'ng'iroq uchun hisobni qo'shadi va har bir clone(klon) tushirilganda hisobdan ayiradi. Ammo hisobdagi o'zgarishlarni boshqa
oqim bilan to'xtatib qo'ymasligiga ishonch hosil qilish uchun u parallellik ibtidoiylaridan(parallallik ibtidoiysi bu concurrency yani raqobatga tegishli
mavzu) foydalanmaydi. Bu noto'g'ri hisob-kitoblarga olib kelishi mumkin - nozik xatolar, o'z navbatida, xotiraning oqishi yoki biz bilan ishlash
tugashidan oldin qiymatning tushib ketishiga olib kelishi mumkin. Bizga aynan <code>Rc&lt;T&gt;</code>ga o'xshash tur kerak bo'ladi, ammo u mos yozuvlar soniga
o'zgartirish kiritadi.</p>
<h4 id="arct-bilan-atomik-havolalarni-hisoblash"><a class="header" href="#arct-bilan-atomik-havolalarni-hisoblash"><code>Arc&lt;T&gt;</code> bilan atomik havolalarni hisoblash</a></h4>
<p>Yaxshiyamki, <code>Arc&lt;T&gt;</code> <code>Rc&lt;T&gt;</code> kabi bir xil vaziyatlarda foydalanish uchun xavfsiz tur. A atomik degan ma'noni anglatadi, ya'ni bu atomik havola orqali
hisoblangan tur. Atomlar parallellik ibtidoiyning(concurrency:konkurentlik) qo'shimcha turi bo'lib,bu yerda batafsik ko'rib chiqolmaymiz: batafsil
ma'lumot uchun <code>std::sync::atomic</code> uchun standart kutubxona hujjatlariga(dokumentatsiyasiga) qarang. Shu nuqtada, atomlar ibtidoiy turlar kabi ishlashini
bilishingiz kerak, lekin ularni threadlar bo'ylab almashish xavfsizdir.</p>
<p>Keyin nima uchun barcha ibtidoiy turlar atom emasligi va nega standart kutubxona turlari sukut bo'yicha <code>Arc&lt;T&gt;</code> dan foydalanish uchun amalga
oshirilmaganligi haqida hayron bo'lishingiz mumkin. Buning sababi shundaki, thread xavfsizligi faqat sizga kerak bo'lganda to'lamoqchi bo'lgan ishlash
jazosi bilan birga keladi(PERFORMANCE PENALTY-IJRO,BAJARISH UCHUN JAZO) .Agar siz faqat bitta oqim ichidagi qiymatlar ustida amllarni bajarayotgan
bo'lsangiz yani atomik kafolatlarni bajarish shart bo'lmasa, kodingiz tezroq ishlashi mumkin.</p>
<p>Keling, misolimizga qaytaylik: <code>Arc&lt;T&gt;</code> va <code>Rc&lt;T&gt;</code> bir xil APIga ega, shuning uchun biz dasturimizni <code>use</code>(foydalanish) qatorini, <code>new</code>(yangi) chaqiruvni
va <code>clone</code>(klonlash) uchun qo'ng'iroqni o'zgartirish orqali tuzatamiz. 16-15 ro'yxatdagi kod nihoyat togri boladi:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}</code></pre></pre>
<p><span class="caption">Ro'yxat 16-15: <code>Mutex&lt;T&gt;</code>-ni o'rash uchun <code>Arc&lt;T&gt;</code> dan foydalanish, bir nechta mavzular bo'ylab egalik huquqini baham ko'rish
uchun</span></p>
<p>Ushbu kod quyidagilarni print qiladi:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>Biz uddaladik! Biz 0 dan 10 gacha hisobladik, bu katta ishdek korinmasligi mumkin, ammo bu bizga <code>Mutex&lt;T&gt;</code> va thread xavfsizligi haqida ko‚Äòp narsalarni 
o‚Äòrgatadi. Hisoblagich faqat ko'paytirishdan koproq ish qila olishini orgatdi. Ushbu strategiyadan foydalanib, siz hisobni mustaqil qismlarga
bo'lishingiz, bu qismlarni threadlar bo'ylab ajratishingiz va keyin <code>Mutex&lt;T&gt;</code> dan foydalanib, har bir thread yakuniy natijani o'z qismi bilan yangilashi
mumkin.</p>
<p>E'tibor bering, agar siz oddiy raqamli amallarni bajarayotgan bo'lsangiz, standart kutubxonaning <code>std::sync::atomic</code> modulida taqdim etilgan <code>Mutex&lt;T&gt;</code>
turlaridan oddiyroq turlar mavjud. Ushbu turlar ibtidoiy turlarga xavfsiz, parallel, atomik kirishni ta'minlaydi va  ushbu misol uchun <code>Mutex&lt;T&gt;</code>ning
ibtidoiy turi bilan foydalanishni tanladik, shuning uchun <code>Mutex&lt;T&gt;</code> qanday ishlashiga e'tibor qaratishimiz mumkin.</p>
<h3 id="refcelltrct-va-mutextarct-ortasidagi-oxshashliklar"><a class="header" href="#refcelltrct-va-mutextarct-ortasidagi-oxshashliklar"><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> va <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> o'rtasidagi o'xshashliklar</a></h3>
<p>Hisoblagich(counter) o'zgarmasligini payqagan bo'lishingiz mumkin, lekin biz uning ichidagi qiymatga o'zgaruvchan havolani olishimiz mumkin; bu <code>Mutex&lt;T&gt; Cell</code> oilasi kabi ichki o'zgaruvchanlikni qollab quvvatlaydi. Xuddi shu tarzda biz <code>Rc&lt;T&gt;</code> ichidagi tarkibni o'zgartirishga ruxsat berish uchun 15-bobda
<code>RefCell&lt;T&gt;</code> dan foydalanganmiz, <code>Arc&lt;T&gt;</code> ichidagi tarkibni mutatsiya qilish uchun <code>Mutex&lt;T&gt;</code> dan foydalanamiz.</p>
<p>Yana bir muhim ma' lumot, <code>Mutex&lt;T&gt;</code> dan foydalanganda Rust sizni barcha turdagi mantiqiy xatolardan himoya qila olmaydi.  15-bobda <code>Rc&lt;T&gt;</code> dan
foydalanish oziga xos yozuvlar sikllarini yaratish xavfi bilan kelganligini eslang, bu erda ikkita <code>Rc&lt;T&gt;</code> qiymati bir-biriga tegishli bo'lib, xotira
susayishi, tanqisligiga olib keladi. Xuddi shunday, <code>Mutex&lt;T&gt;</code> ham boshi berk deadlocks(ko'chalarni) yaratish xavfi bilan birga keladi. Bular amal ikkita
resursni bloklashi kerak bo'lganda sodir bo'ladi va ikkita thread har biri locks(qulflardan) birini qo'lga kiritib. Agar siz ziddiyatlarga qiziqsangiz,
tanqislik deadlocks(ko'chasiga) ega Rust dasturini yaratishga harakat qiling; keyin har qanday tilda mutekslar uchun ziddiyatni yengilashtirish, yechim
topish strategiyalarini o'rganing va Rustda ularni amalga oshirishga kirishing. <code>Mutex&lt;T&gt;</code> va <code>MutexGuard</code> uchun standart kutubxona API hujjatlari
foydali ma'lumotlarni taqdim etadi.</p>
<p>Biz ushbu bobni <code>Send</code>(Yuborish) va <code>Sync</code>(Sinxronlashtirish) xususiyatlari va ularni maxsus turlar bilan qanday ishlatishimiz haqida gapirib,
yakunlaymiz. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="extensible-concurrency-with-the-sync-and-send-traits"><a class="header" href="#extensible-concurrency-with-the-sync-and-send-traits">Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</a></h2>
<p>Interestingly, the Rust language has <em>very</em> few concurrency features. Almost
every concurrency feature we‚Äôve talked about so far in this chapter has been
part of the standard library, not the language. Your options for handling
concurrency are not limited to the language or the standard library; you can
write your own concurrency features or use those written by others.</p>
<p>However, two concurrency concepts are embedded in the language: the
<code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<h3 id="allowing-transference-of-ownership-between-threads-with-send"><a class="header" href="#allowing-transference-of-ownership-between-threads-with-send">Allowing Transference of Ownership Between Threads with <code>Send</code></a></h3>
<p>The <code>Send</code> marker trait indicates that ownership of values of the type
implementing <code>Send</code> can be transferred between threads. Almost every Rust type
is <code>Send</code>, but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this cannot be
<code>Send</code> because if you cloned an <code>Rc&lt;T&gt;</code> value and tried to transfer ownership
of the clone to another thread, both threads might update the reference count
at the same time. For this reason, <code>Rc&lt;T&gt;</code> is implemented for use in
single-threaded situations where you don‚Äôt want to pay the thread-safe
performance penalty.</p>
<p>Therefore, Rust‚Äôs type system and trait bounds ensure that you can never
accidentally send an <code>Rc&lt;T&gt;</code> value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. When we switched to <code>Arc&lt;T&gt;</code>, which is <code>Send</code>, the code
compiled.</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as
well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which
we‚Äôll discuss in Chapter 19.</p>
<h3 id="allowing-access-from-multiple-threads-with-sync"><a class="header" href="#allowing-access-from-multiple-threads-with-sync">Allowing Access from Multiple Threads with <code>Sync</code></a></h3>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing
<code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is
<code>Sync</code> if <code>&amp;T</code> (an immutable reference to <code>T</code>) is <code>Send</code>, meaning the reference
can be sent safely to another thread. Similar to <code>Send</code>, primitive types are
<code>Sync</code>, and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> is also not <code>Sync</code> for the same reasons that it‚Äôs not
<code>Send</code>. The <code>RefCell&lt;T&gt;</code> type (which we talked about in Chapter 15) and the
family of related <code>Cell&lt;T&gt;</code> types are not <code>Sync</code>. The implementation of borrow
checking that <code>RefCell&lt;T&gt;</code> does at runtime is not thread-safe. The smart
pointer <code>Mutex&lt;T&gt;</code> is <code>Sync</code> and can be used to share access with multiple
threads as you saw in the <a href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">‚ÄúSharing a <code>Mutex&lt;T&gt;</code> Between Multiple
Threads‚Äù</a><!-- ignore --> section.</p>
<h3 id="implementing-send-and-sync-manually-is-unsafe"><a class="header" href="#implementing-send-and-sync-manually-is-unsafe">Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</a></h3>
<p>Because types that are made up of <code>Send</code> and <code>Sync</code> traits are automatically
also <code>Send</code> and <code>Sync</code>, we don‚Äôt have to implement those traits manually. As
marker traits, they don‚Äôt even have any methods to implement. They‚Äôre just
useful for enforcing invariants related to concurrency.</p>
<p>Manually implementing these traits involves implementing unsafe Rust code.
We‚Äôll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of <code>Send</code> and
<code>Sync</code> parts requires careful thought to uphold the safety guarantees. <a href="../nomicon/index.html">‚ÄúThe
Rustonomicon‚Äù</a> has more information about these guarantees and how to
uphold them.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This isn‚Äôt the last you‚Äôll see of concurrency in this book: the project in
Chapter 20 will use the concepts in this chapter in a more realistic situation
than the smaller examples discussed here.</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.</p>
<p>The Rust standard library provides channels for message passing and smart
pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won‚Äôt end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!</p>
<p>Next, we‚Äôll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we‚Äôll discuss how Rust‚Äôs idioms
relate to those you might be familiar with from object-oriented programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming-features-of-rust"><a class="header" href="#object-oriented-programming-features-of-rust">Object-Oriented Programming Features of Rust</a></h1>
<p>Object-oriented programming (OOP) is a way of modeling programs. Objects as a
programmatic concept were introduced in the programming language Simula in the
1960s. Those objects influenced Alan Kay‚Äôs programming architecture in which
objects pass messages to each other. To describe this architecture, he coined
the term <em>object-oriented programming</em> in 1967. Many competing definitions
describe what OOP is, and by some of these definitions Rust is object-oriented,
but by others it is not. In this chapter, we‚Äôll explore certain characteristics
that are commonly considered object-oriented and how those characteristics
translate to idiomatic Rust. We‚Äôll then show you how to implement an
object-oriented design pattern in Rust and discuss the trade-offs of doing so
versus implementing a solution using some of Rust‚Äôs strengths instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="obyektga-yonaltirilgan-dasturlash-xususiyatlari"><a class="header" href="#obyektga-yonaltirilgan-dasturlash-xususiyatlari">Obyektga Yo'naltirilgan Dasturlash Xususiyatlari</a></h2>
<p>Dasturlash jamiyatida bir tilni obyektga yo'naltirilgan deb hisoblash uchun qanday xususiyatlarga ega bo'lishi kerakligi haqida kelishuv yo'q. Rust ko'p
dasturlash paradigmalaridan, jumladan OOPdan ilhomlangan; masalan, 13-bobda funksional dasturlashdan kelgan xususiyatlarni o'rgandik. Ehtimol, OOP
tillari ma'lum umumiy xususiyatlarga ega, ya'ni obyektlar, inkapsulyatsiya va meros. Keling, har bir xususiyatning nimani anglatishini va Rust uni
qo'llab-quvvatlaydimi yoki yo'qligini ko'rib chiqaylik.</p>
<h3 id="obyektlar-malumotlar-va-xatti-harakatlarni-oz-ichiga-oladi"><a class="header" href="#obyektlar-malumotlar-va-xatti-harakatlarni-oz-ichiga-oladi">Obyektlar Ma'lumotlar va Xatti-harakatlarni O'z ichiga oladi</a></h3>
<p>Erich Gamma, Richard Helm, Ralph Johnson va John Vlissides tomonidan yozilgan *Design Patterns: Elements of Reusable Object-Oriented Software
(Addison-Wesley Professional, 1994), oddiygina <em>The Gang of Four</em> deb ataladigan kitob, obyektga yo'naltirilgan dizayn shablonlarining katalogidir. U
OOPni quyidagicha ta'riflaydi:</p>
<blockquote>
<p>Obyektga yo'naltirilgan dasturlar obyektlardan tashkil topgan. 
Bir <em>obyekt</em> ma'lumotlar va ushbu ma'lumotlar bilan ishlaydigan 
protseduralarni paketlaydi. Protseduralar odatda <em>metodlar</em><br />
yoki <em>operatsiyalar</em> deb ataladi.</p>
</blockquote>
<p>Ushbu ta'rifga ko'ra, Rust obyektga yo'naltirilgan: structlar va enumlar ma'lumotlarga ega va <code>impl</code> bloklari structlar va enumlarda metodlar taqdim
etadi. Garchi structlar va enumlar metodlar bilan <em>obyekt</em> deb atalmagan bo'lsa-da, ular The Gang of Four ta'rifiga ko'ra obyektlarning bir xil
funksionalligini ta'minlaydi.</p>
<h3 id="amalga-oshirish-tafsilotlarini-yashiruvchi-inkapsulyatsiya"><a class="header" href="#amalga-oshirish-tafsilotlarini-yashiruvchi-inkapsulyatsiya">Amalga oshirish Tafsilotlarini Yashiruvchi Inkapsulyatsiya</a></h3>
<p>OOP bilan odatda bog'liq bo'lgan yana bir jihat <em>inkapsulyatsiya</em> tushunchasi bo'lib, bu obyektning amalga oshirish tafsilotlari ushbu obyektni
ishlatadigan kod uchun ochiq bo'lmasligini anglatadi. Shuning uchun, obyekt bilan o'zaro ta'sir qilishning yagona usuli uning ommaviy APIi orqali amalga
oshiriladi; obyektni ishlatadigan kod obyektning ichki qismlariga kirib, ma'lumotlar yoki xatti-harakatlarni bevosita o'zgartira olmaydi. Bu dasturchiga
obyektning ichki qismlarini o'zgartirish va refaktor qilish imkonini beradi, obyektdan foydalanadigan kodni o'zgartirmasdan.</p>
<p>7-bobda inkapsulyatsiyani qanday boshqarish mumkinligini muhokama qildik: biz <code>pub</code> kalit so'zidan foydalanib, kodimizdagi qaysi modullar, turlar,
funksiyalar va metodlar ommaviy bo'lishi kerakligini va standart bo'lib hamma narsalar xususiy ekanligini hal qilishimiz mumkin. Masalan,
<code>AveragedCollection</code> deb nomlangan structni aniqlashimiz mumkin, u <code>i32</code> qiymatlarining vektorini o'z ichiga oladi. Struct shuningdek, vektordagi
qiymatlarning o'rtacha qiymatini o'z ichiga oluvchi maydonga ham ega bo'lishi mumkin, ya'ni o'rtacha qiymatga har safar ehtiyoj tug'ilganda hisoblanishi
shart emas. Boshqacha qilib aytganda, <code>AveragedCollection</code> biz uchun hisoblangan o'rtacha qiymatni keshlaydi. 17-1 ro'yxatda <code>AveragedCollection</code>
structining ta'rifi keltirilgan:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<p><span class="caption">Ro'yxat 17-1: <code>AveragedCollection</code> structi, integerlar ro'yxatini va yig'indi elementlarning o'rtacha qiymatini saqlaydi</span></p>
<p>Struct <code>pub</code> deb belgilangan, shuning uchun boshqa kodlar uni ishlatishi mumkin, lekin struct ichidagi maydonlar xususiy bo'lib qoladi. Bu holda bu
muhim, chunki biz ro'yxatga qiymat qo'shilgan yoki o'chirilganida o'rtacha qiymat ham yangilanishini ta'minlamoqchimiz. Buni biz <code>add</code>, <code>remove</code> va
<code>average</code> metodlarini structga tatbiq etish orqali amalga oshiramiz, bu 17-2 ro'yxatda ko'rsatilgan:</p>
<p><span class="filename">Fayl nomi: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<p><span class="caption">Ro'yxat 17-2: <code>AveragedCollection</code> ustida ommaviy <code>add</code>, <code>remove</code> va <code>average</code> metodlarining amalga oshirilishi</span></p>
<p><code>add</code>, <code>remove</code> va <code>average</code> ommaviy metodlar <code>AveragedCollection</code> nusxasidagi ma'lumotlarni kirish yoki o'zgartirishning yagona usuli. Element ro'yxatga
<code>add</code> metodi orqali qo'shilganda yoki <code>remove</code> metodi orqali olib tashlanganda, har biri <code>average</code> maydonini yangilash bilan shug'ullanadigan xususiy
<code>update_average</code> metodini chaqiradi.</p>
<p><code>list</code> va <code>average</code> maydonlarini xususiy qilib qoldiramiz, shunda tashqi kod <code>list</code> maydoniga elementlar qo'shish yoki olib tashlash imkoniga ega
bo'lmaydi; aks holda, <code>average</code> maydoni <code>list</code> o'zgarganda sinxronlashdan chiqib ketishi mumkin. 
<code>average</code> metodi <code>average</code> maydonidagi qiymatni qaytaradi, tashqi kodga <code>average</code>ni o'qish imkonini beradi, lekin uni o'zgartirish imkonini bermaydi.</p>
<p>Biz <code>AveragedCollection</code> structining amalga oshirish tafsilotlarini inkapsulyatsiya qilganimiz sababli, kelajakda uning jihatlarini osonlik bilan
o'zgartirishimiz mumkin. Masalan, <code>list</code> maydoni uchun <code>Vec&lt;i32&gt;</code> o'rniga <code>HashSet&lt;i32&gt;</code> dan foydalanishimiz mumkin. <code>add</code>, <code>remove</code> va <code>average</code> ommaviy
metodlarining imzolari o'zgarmagan holda, <code>AveragedCollection</code>dan foydalanadigan kodni o'zgartirish kerak bo'lmaydi. Agar <code>list</code>ni ommaviy qilsak, bu har
doim ham shunday bo'lmaydi: <code>HashSet&lt;i32&gt;</code> va <code>Vec&lt;i32&gt;</code> elementlarni qo'shish va olib tashlash uchun turli xil metodlarga ega, shuning uchun <code>list</code>ni
to'g'ridan-to'g'ri o'zgartirayotgan tashqi kod o'zgartirilishi kerak bo'ladi.</p>
<p>Agar inkapsulyatsiya tilni obyektga yo'naltirilgan deb hisoblash uchun zaruriy xususiyat bo'lsa, Rust bu talabga javob beradi. Kodning turli qismlari
uchun <code>pub</code>dan foydalanish yoki foydalanmaslik imkoniyati amalga oshirish tafsilotlarini inkapsulyatsiya qilish imkonini beradi.</p>
<h3 id="merozdan-foydalanish-tizimi-va-kodni-ulashish-sifatida"><a class="header" href="#merozdan-foydalanish-tizimi-va-kodni-ulashish-sifatida">Merozdan foydalanish Tizimi va Kodni Ulashish Sifatida</a></h3>
<p><em>Meros olish</em> bu mexanizm bo'lib, bunda obyekt boshqa obyektning ta'rifidan elementlarni meros qilib oladi va shunday qilib, ota obyektning ma'lumotlari
va xatti-harakatlarini qayta ta'riflashsiz oladi.</p>
<p>Agar til obyektga yo'naltirilgan til deb hisoblanishi uchun meros olishga ega bo'lishi kerak bo'lsa, Rust bunday til emas. Ota structning maydonlari va
metodlarini makrosiz meros qilib olishning hech qanday yo'li yo'q.</p>
<p>Biroq, agar siz dasturlash vositangizda meros olishga ega bo'lishga odatlangan bo'lsangiz, Rustda boshqa echimlardan foydalanishingiz mumkin, bu meros
olishga erishmoqchi bo'lgan sababingizga qarab o'zgaradi.</p>
<p>Meros olishni tanlashning ikki asosiy sababi bor. Biri kodni qayta ishlatish uchun: siz bir tur uchun ma'lum xatti-harakatni amalga oshirishingiz mumkin
va meros olish bu amalga oshirishni boshqa tur uchun qayta ishlatishga imkon beradi. Rust kodida siz buni cheklangan tarzda trait metodlari uchun 
standart amalga oshirishlar yordamida amalga oshirishingiz mumkin, bu 10-14 ro'yxatda <code>Summary</code> traitida <code>summarize</code> metodining standart amalga
oshirilishini qo'shganimizda ko'rsatilgan.</p>
<p><code>Summary</code> traitini amalga oshirgan har qanday tur <code>summarize</code> metodiga ega bo'ladi, hech qanday qo'shimcha kod yozmasdan. Bu ota sinfning metodini
amalga oshirishiga va meros qilib olingan bola sinfining metodni amalga oshirishiga o'xshaydi. <code>Summary</code> traitini amalga oshirganimizda <code>summarize</code>
metodining standart amalga oshirilishini ham bekor qilishimiz mumkin, bu meros qilib olingan bola sinfi ota sinfdan meros qilib olingan metodni amalga
oshirishini bekor qilishga o'xshaydi.</p>
<p>Meros olishdan foydalanishning boshqa sababi turi tizimiga bog'liq: bola turini ota turi bilan bir xil joylarda ishlatishga imkon berish. Bu shuningdek
<em>polimorfizm</em> deb ataladi, bu bir-birini almashtirish imkonini beradi, agar ular ma'lum xususiyatlarga ega bo'lsa.</p>
<blockquote>
<h3 id="polimorfizm"><a class="header" href="#polimorfizm">Polimorfizm</a></h3>
<p>Ko'pchilik uchun polimorfizm meros olish bilan sinonimdir. Ammo bu aslida ko'proq umumiy tushuncha bo'lib, u turli turlardagi ma'lumotlar bilan
ishlaydigan kodni anglatadi. Meros olish uchun bu turlar odatda quyi sinflardir.</p>
<p>Rust esa o'rniga turli xil turlar ustida abstraksiya qilish uchun generiklardan va bu turlarning nimani ta'minlashi kerakligini cheklash uchun trait
cheklovlaridan foydalanadi. Bu ba'zan <em>cheklangan parametrik polimorfizm</em> deb ataladi.</p>
</blockquote>
<p>Meros olish ko'pincha dastur dizayn yechimi sifatida ko'plab dasturlash tillarida sevilmay qoldi, chunki u ko'pincha kerakli koddan ko'proq kodni ulash
xavfini tug'diradi. Quyi sinflar har doim ham ota sinfining barcha xususiyatlarini ulashmasligi kerak, ammo meros olishda shunday bo'ladi. Bu dastur
dizaynini kamroq moslashuvchan qiladi. Shuningdek, bu quyi sinfda metodlarni chaqirish imkoniyatini beradi, bu metodlar quyi sinfga mos kelmasligi yoki
xatolarga olib kelishi mumkin, chunki metodlar quyi sinfga tatbiq etilmaydi. Bundan tashqari, ba'zi tillar faqat yagona meros olishga ruxsat beradi (bu
quyi sinf faqat bitta sinfdan meros olishi mumkinligini anglatadi), bu esa dastur dizaynining moslashuvchanligini yanada cheklaydi.</p>
<p>Ushbu sabablarga ko'ra, Rust meros olish o'rniga trait obyektlaridan foydalanish yo'lini tanlaydi. Keling, Rustda trait obyektlari qanday qilib
polimorfizmni ta'minlashini ko'rib chiqaylik.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-trait-objects-that-allow-for-values-of-different-types"><a class="header" href="#using-trait-objects-that-allow-for-values-of-different-types">Using Trait Objects That Allow for Values of Different Types</a></h2>
<p>In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-9 where
we defined a <code>SpreadsheetCell</code> enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.</p>
<p>However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, we‚Äôll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a <code>draw</code> method on each one to draw it to the
screen‚Äîa common technique for GUI tools. We‚Äôll create a library crate called
<code>gui</code> that contains the structure of a GUI library. This crate might include
some types for people to use, such as <code>Button</code> or <code>TextField</code>. In addition,
<code>gui</code> users will want to create their own types that can be drawn: for
instance, one programmer might add an <code>Image</code> and another might add a
<code>SelectBox</code>.</p>
<p>We won‚Äôt implement a fully fledged GUI library for this example but will show
how the pieces would fit together. At the time of writing the library, we can‚Äôt
know and define all the types other programmers might want to create. But we do
know that <code>gui</code> needs to keep track of many values of different types, and it
needs to call a <code>draw</code> method on each of these differently typed values. It
doesn‚Äôt need to know exactly what will happen when we call the <code>draw</code> method,
just that the value will have that method available for us to call.</p>
<p>To do this in a language with inheritance, we might define a class named
<code>Component</code> that has a method named <code>draw</code> on it. The other classes, such as
<code>Button</code>, <code>Image</code>, and <code>SelectBox</code>, would inherit from <code>Component</code> and thus
inherit the <code>draw</code> method. They could each override the <code>draw</code> method to define
their custom behavior, but the framework could treat all of the types as if
they were <code>Component</code> instances and call <code>draw</code> on them. But because Rust
doesn‚Äôt have inheritance, we need another way to structure the <code>gui</code> library to
allow users to extend it with new types.</p>
<h3 id="defining-a-trait-for-common-behavior"><a class="header" href="#defining-a-trait-for-common-behavior">Defining a Trait for Common Behavior</a></h3>
<p>To implement the behavior we want <code>gui</code> to have, we‚Äôll define a trait named
<code>Draw</code> that will have one method named <code>draw</code>. Then we can define a vector that
takes a <em>trait object</em>. A trait object points to both an instance of a type
implementing our specified trait and a table used to look up trait methods on
that type at runtime. We create a trait object by specifying some sort of
pointer, such as a <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart pointer, then the <code>dyn</code>
keyword, and then specifying the relevant trait. (We‚Äôll talk about the reason
trait objects must use a pointer in Chapter 19 in the section <a href="ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">‚ÄúDynamically
Sized Types and the <code>Sized</code> Trait.‚Äù</a><!-- ignore -->) We can
use trait objects in place of a generic or concrete type. Wherever we use a
trait object, Rust‚Äôs type system will ensure at compile time that any value
used in that context will implement the trait object‚Äôs trait. Consequently, we
don‚Äôt need to know all the possible types at compile time.</p>
<p>We‚Äôve mentioned that, in Rust, we refrain from calling structs and enums
‚Äúobjects‚Äù to distinguish them from other languages‚Äô objects. In a struct or
enum, the data in the struct fields and the behavior in <code>impl</code> blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. However, trait objects <em>are</em> more like
objects in other languages in the sense that they combine data and behavior.
But trait objects differ from traditional objects in that we can‚Äôt add data to
a trait object. Trait objects aren‚Äôt as generally useful as objects in other
languages: their specific purpose is to allow abstraction across common
behavior.</p>
<p>Listing 17-3 shows how to define a trait named <code>Draw</code> with one method named
<code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
<p><span class="caption">Listing 17-3: Definition of the <code>Draw</code> trait</span></p>
<p>This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
<code>Screen</code> that holds a vector named <code>components</code>. This vector is of type
<code>Box&lt;dyn Draw&gt;</code>, which is a trait object; it‚Äôs a stand-in for any type inside
a <code>Box</code> that implements the <code>Draw</code> trait.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
<p><span class="caption">Listing 17-4: Definition of the <code>Screen</code> struct with a
<code>components</code> field holding a vector of trait objects that implement the <code>Draw</code>
trait</span></p>
<p>On the <code>Screen</code> struct, we‚Äôll define a method named <code>run</code> that will call the
<code>draw</code> method on each of its <code>components</code>, as shown in Listing 17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-5: A <code>run</code> method on <code>Screen</code> that calls the
<code>draw</code> method on each component</span></p>
<p>This works differently from defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can only be substituted
with one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the <code>Screen</code> struct using a generic type and a trait bound
as in Listing 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-6: An alternate implementation of the <code>Screen</code>
struct and its <code>run</code> method using generics and trait bounds</span></p>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of
type <code>Button</code> or all of type <code>TextField</code>. If you‚Äôll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.</p>
<p>On the other hand, with the method using trait objects, one <code>Screen</code> instance
can hold a <code>Vec&lt;T&gt;</code> that contains a <code>Box&lt;Button&gt;</code> as well as a
<code>Box&lt;TextField&gt;</code>. Let‚Äôs look at how this works, and then we‚Äôll talk about the
runtime performance implications.</p>
<h3 id="implementing-the-trait"><a class="header" href="#implementing-the-trait">Implementing the Trait</a></h3>
<p>Now we‚Äôll add some types that implement the <code>Draw</code> trait. We‚Äôll provide the
<code>Button</code> type. Again, actually implementing a GUI library is beyond the scope
of this book, so the <code>draw</code> method won‚Äôt have any useful implementation in its
body. To imagine what the implementation might look like, a <code>Button</code> struct
might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in Listing 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
<p><span class="caption">Listing 17-7: A <code>Button</code> struct that implements the
<code>Draw</code> trait</span></p>
<p>The <code>width</code>, <code>height</code>, and <code>label</code> fields on <code>Button</code> will differ from the
fields on other components; for example, a <code>TextField</code> type might have those
same fields plus a <code>placeholder</code> field. Each of the types we want to draw on
the screen will implement the <code>Draw</code> trait but will use different code in the
<code>draw</code> method to define how to draw that particular type, as <code>Button</code> has here
(without the actual GUI code, as mentioned). The <code>Button</code> type, for instance,
might have an additional <code>impl</code> block containing methods related to what
happens when a user clicks the button. These kinds of methods won‚Äôt apply to
types like <code>TextField</code>.</p>
<p>If someone using our library decides to implement a <code>SelectBox</code> struct that has
<code>width</code>, <code>height</code>, and <code>options</code> fields, they implement the <code>Draw</code> trait on the
<code>SelectBox</code> type as well, as shown in Listing 17-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p><span class="caption">Listing 17-8: Another crate using <code>gui</code> and implementing
the <code>Draw</code> trait on a <code>SelectBox</code> struct</span></p>
<p>Our library‚Äôs user can now write their <code>main</code> function to create a <code>Screen</code>
instance. To the <code>Screen</code> instance, they can add a <code>SelectBox</code> and a <code>Button</code>
by putting each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the
<code>run</code> method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the
components. Listing 17-9 shows this implementation:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span></p>
<p>When we wrote the library, we didn‚Äôt know that someone might add the
<code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the
new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> trait, which
means it implements the <code>draw</code> method.</p>
<p>This concept‚Äîof being concerned only with the messages a value responds to
rather than the value‚Äôs concrete type‚Äîis similar to the concept of <em>duck
typing</em> in dynamically typed languages: if it walks like a duck and quacks
like a duck, then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code>
in Listing 17-5, <code>run</code> doesn‚Äôt need to know what the concrete type of each
component is. It doesn‚Äôt check whether a component is an instance of a <code>Button</code>
or a <code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By
specifying <code>Box&lt;dyn Draw&gt;</code> as the type of the values in the <code>components</code>
vector, we‚Äôve defined <code>Screen</code> to need values that we can call the <code>draw</code>
method on.</p>
<p>The advantage of using trait objects and Rust‚Äôs type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn‚Äôt implement a method but we call it anyway. Rust won‚Äôt compile
our code if the values don‚Äôt implement the traits that the trait objects need.</p>
<p>For example, Listing 17-10 shows what happens if we try to create a <code>Screen</code>
with a <code>String</code> as a component:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hi&quot;))],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-10: Attempting to use a type that doesn‚Äôt
implement the trait object‚Äôs trait</span></p>
<p>We‚Äôll get this error because <code>String</code> doesn‚Äôt implement the <code>Draw</code> trait:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `String` to the object type `dyn Draw`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` due to previous error
</code></pre>
<p>This error lets us know that either we‚Äôre passing something to <code>Screen</code> we
didn‚Äôt mean to pass and so should pass a different type or we should implement
<code>Draw</code> on <code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<h3 id="trait-objects-perform-dynamic-dispatch"><a class="header" href="#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a></h3>
<p>Recall in the <a href="ch10-01-syntax.html#performance-of-code-using-generics">‚ÄúPerformance of Code Using
Generics‚Äù</a><!-- ignore --> section in
Chapter 10 our discussion on the monomorphization process performed by the
compiler when we use trait bounds on generics: the compiler generates
nongeneric implementations of functions and methods for each concrete type that
we use in place of a generic type parameter. The code that results from
monomorphization is doing <em>static dispatch</em>, which is when the compiler knows
what method you‚Äôre calling at compile time. This is opposed to <em>dynamic
dispatch</em>, which is when the compiler can‚Äôt tell at compile time which method
you‚Äôre calling. In dynamic dispatch cases, the compiler emits code that at
runtime will figure out which method to call.</p>
<p>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn‚Äôt
know all the types that might be used with the code that‚Äôs using trait objects,
so it doesn‚Äôt know which method implemented on which type to call. Instead, at
runtime, Rust uses the pointers inside the trait object to know which method to
call. This lookup incurs a runtime cost that doesn‚Äôt occur with static
dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a
method‚Äôs code, which in turn prevents some optimizations. However, we did get
extra flexibility in the code that we wrote in Listing 17-5 and were able to
support in Listing 17-9, so it‚Äôs a trade-off to consider.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implementing-an-object-oriented-design-pattern"><a class="header" href="#implementing-an-object-oriented-design-pattern">Implementing an Object-Oriented Design Pattern</a></h2>
<p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the
pattern is that we define a set of states a value can have internally. The
states are represented by a set of <em>state objects</em>, and the value‚Äôs behavior
changes based on its state. We‚Äôre going to work through an example of a blog
post struct that has a field to hold its state, which will be a state object
from the set &quot;draft&quot;, &quot;review&quot;, or &quot;published&quot;.</p>
<p>The state objects share functionality: in Rust, of course, we use structs and
traits rather than objects and inheritance. Each state object is responsible
for its own behavior and for governing when it should change into another
state. The value that holds a state object knows nothing about the different
behavior of the states or when to transition between states.</p>
<p>The advantage of using the state pattern is that, when the business
requirements of the program change, we won‚Äôt need to change the code of the
value holding the state or the code that uses the value. We‚Äôll only need to
update the code inside one of the state objects to change its rules or perhaps
add more state objects.</p>
<p>First, we‚Äôre going to implement the state pattern in a more traditional
object-oriented way, then we‚Äôll use an approach that‚Äôs a bit more natural in
Rust. Let‚Äôs dig in to incrementally implementing a blog post workflow using the
state pattern.</p>
<p>The final functionality will look like this:</p>
<ol>
<li>A blog post starts as an empty draft.</li>
<li>When the draft is done, a review of the post is requested.</li>
<li>When the post is approved, it gets published.</li>
<li>Only published blog posts return content to print, so unapproved posts can‚Äôt
accidentally be published.</li>
</ol>
<p>Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we‚Äôve requested a review, the post
should remain an unpublished draft.</p>
<p>Listing 17-11 shows this workflow in code form: this is an example usage of the
API we‚Äôll implement in a library crate named <code>blog</code>. This won‚Äôt compile yet
because we haven‚Äôt implemented the <code>blog</code> crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}</code></pre>
<p><span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our <code>blog</code> crate to have</span></p>
<p>We want to allow the user to create a new draft blog post with <code>Post::new</code>. We
want to allow text to be added to the blog post. If we try to get the post‚Äôs
content immediately, before approval, we shouldn‚Äôt get any text because the
post is still a draft. We‚Äôve added <code>assert_eq!</code> in the code for demonstration
purposes. An excellent unit test for this would be to assert that a draft blog
post returns an empty string from the <code>content</code> method, but we‚Äôre not going to
write tests for this example.</p>
<p>Next, we want to enable a request for a review of the post, and we want
<code>content</code> to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when <code>content</code> is called.</p>
<p>Notice that the only type we‚Äôre interacting with from the crate is the <code>Post</code>
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in‚Äîdraft, waiting for review, or published. Changing from one state to another
will be managed internally within the <code>Post</code> type. The states change in
response to the methods called by our library‚Äôs users on the <code>Post</code> instance,
but they don‚Äôt have to manage the state changes directly. Also, users can‚Äôt
make a mistake with the states, like publishing a post before it‚Äôs reviewed.</p>
<h3 id="defining-post-and-creating-a-new-instance-in-the-draft-state"><a class="header" href="#defining-post-and-creating-a-new-instance-in-the-draft-state">Defining <code>Post</code> and Creating a New Instance in the Draft State</a></h3>
<p>Let‚Äôs get started on the implementation of the library! We know we need a
public <code>Post</code> struct that holds some content, so we‚Äôll start with the
definition of the struct and an associated public <code>new</code> function to create an
instance of <code>Post</code>, as shown in Listing 17-12. We‚Äôll also make a private
<code>State</code> trait that will define the behavior that all state objects for a <code>Post</code>
must have.</p>
<p>Then <code>Post</code> will hold a trait object of <code>Box&lt;dyn State&gt;</code> inside an <code>Option&lt;T&gt;</code>
in a private field named <code>state</code> to hold the state object. You‚Äôll see why the
<code>Option&lt;T&gt;</code> is necessary in a bit.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<p><span class="caption">Listing 17-12: Definition of a <code>Post</code> struct and a <code>new</code>
function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code>
struct</span></p>
<p>The <code>State</code> trait defines the behavior shared by different post states. The
state objects are <code>Draft</code>, <code>PendingReview</code>, and <code>Published</code>, and they will all
implement the <code>State</code> trait. For now, the trait doesn‚Äôt have any methods, and
we‚Äôll start by defining just the <code>Draft</code> state because that is the state we
want a post to start in.</p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that
holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct.
This ensures whenever we create a new instance of <code>Post</code>, it will start out as
a draft. Because the <code>state</code> field of <code>Post</code> is private, there is no way to
create a <code>Post</code> in any other state! In the <code>Post::new</code> function, we set the
<code>content</code> field to a new, empty <code>String</code>.</p>
<h3 id="storing-the-text-of-the-post-content"><a class="header" href="#storing-the-text-of-the-post-content">Storing the Text of the Post Content</a></h3>
<p>We saw in Listing 17-11 that we want to be able to call a method named
<code>add_text</code> and pass it a <code>&amp;str</code> that is then added as the text content of the
blog post. We implement this as a method, rather than exposing the <code>content</code>
field as <code>pub</code>, so that later we can implement a method that will control how
the <code>content</code> field‚Äôs data is read. The <code>add_text</code> method is pretty
straightforward, so let‚Äôs add the implementation in Listing 17-13 to the <code>impl Post</code> block:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Listing 17-13: Implementing the <code>add_text</code> method to add
text to a post‚Äôs <code>content</code></span></p>
<p>The <code>add_text</code> method takes a mutable reference to <code>self</code>, because we‚Äôre
changing the <code>Post</code> instance that we‚Äôre calling <code>add_text</code> on. We then call
<code>push_str</code> on the <code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to
the saved <code>content</code>. This behavior doesn‚Äôt depend on the state the post is in,
so it‚Äôs not part of the state pattern. The <code>add_text</code> method doesn‚Äôt interact
with the <code>state</code> field at all, but it is part of the behavior we want to
support.</p>
<h3 id="ensuring-the-content-of-a-draft-post-is-empty"><a class="header" href="#ensuring-the-content-of-a-draft-post-is-empty">Ensuring the Content of a Draft Post Is Empty</a></h3>
<p>Even after we‚Äôve called <code>add_text</code> and added some content to our post, we still
want the <code>content</code> method to return an empty string slice because the post is
still in the draft state, as shown on line 7 of Listing 17-11. For now, let‚Äôs
implement the <code>content</code> method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We‚Äôll change this later
once we implement the ability to change a post‚Äôs state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<p><span class="caption">Listing 17-14: Adding a placeholder implementation for
the <code>content</code> method on <code>Post</code> that always returns an empty string slice</span></p>
<p>With this added <code>content</code> method, everything in Listing 17-11 up to line 7
works as intended.</p>
<h3 id="requesting-a-review-of-the-post-changes-its-state"><a class="header" href="#requesting-a-review-of-the-post-changes-its-state">Requesting a Review of the Post Changes Its State</a></h3>
<p>Next, we need to add functionality to request a review of a post, which should
change its state from <code>Draft</code> to <code>PendingReview</code>. Listing 17-15 shows this code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Listing 17-15: Implementing <code>request_review</code> methods on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We give <code>Post</code> a public method named <code>request_review</code> that will take a mutable
reference to <code>self</code>. Then we call an internal <code>request_review</code> method on the
current state of <code>Post</code>, and this second <code>request_review</code> method consumes the
current state and returns a new state.</p>
<p>We add the <code>request_review</code> method to the <code>State</code> trait; all types that
implement the trait will now need to implement the <code>request_review</code> method.
Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first
parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the
method is only valid when called on a <code>Box</code> holding the type. This syntax takes
ownership of <code>Box&lt;Self&gt;</code>, invalidating the old state so the state value of the
<code>Post</code> can transform into a new state.</p>
<p>To consume the old state, the <code>request_review</code> method needs to take ownership
of the state value. This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code>
comes in: we call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code>
field and leave a <code>None</code> in its place, because Rust doesn‚Äôt let us have
unpopulated fields in structs. This lets us move the <code>state</code> value out of
<code>Post</code> rather than borrowing it. Then we‚Äôll set the post‚Äôs <code>state</code> value to the
result of this operation.</p>
<p>We need to set <code>state</code> to <code>None</code> temporarily rather than setting it directly
with code like <code>self.state = self.state.request_review();</code> to get ownership of
the <code>state</code> value. This ensures <code>Post</code> can‚Äôt use the old <code>state</code> value after
we‚Äôve transformed it into a new state.</p>
<p>The <code>request_review</code> method on <code>Draft</code> returns a new, boxed instance of a new
<code>PendingReview</code> struct, which represents the state when a post is waiting for a
review. The <code>PendingReview</code> struct also implements the <code>request_review</code> method
but doesn‚Äôt do any transformations. Rather, it returns itself, because when we
request a review on a post already in the <code>PendingReview</code> state, it should stay
in the <code>PendingReview</code> state.</p>
<p>Now we can start seeing the advantages of the state pattern: the
<code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value. Each
state is responsible for its own rules.</p>
<p>We‚Äôll leave the <code>content</code> method on <code>Post</code> as is, returning an empty string
slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state as well as in the
<code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code> state.
Listing 17-11 now works up to line 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="adding-approve-to-change-the-behavior-of-content"><a class="header" href="#adding-approve-to-change-the-behavior-of-content">Adding <code>approve</code> to Change the Behavior of <code>content</code></a></h3>
<p>The <code>approve</code> method will be similar to the <code>request_review</code> method: it will
set <code>state</code> to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<p><span class="caption">Listing 17-16: Implementing the <code>approve</code> method on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We add the <code>approve</code> method to the <code>State</code> trait and add a new struct that
implements <code>State</code>, the <code>Published</code> state.</p>
<p>Similar to the way <code>request_review</code> on <code>PendingReview</code> works, if we call the
<code>approve</code> method on a <code>Draft</code>, it will have no effect because <code>approve</code> will
return <code>self</code>. When we call <code>approve</code> on <code>PendingReview</code>, it returns a new,
boxed instance of the <code>Published</code> struct. The <code>Published</code> struct implements the
<code>State</code> trait, and for both the <code>request_review</code> method and the <code>approve</code>
method, it returns itself, because the post should stay in the <code>Published</code>
state in those cases.</p>
<p>Now we need to update the <code>content</code> method on <code>Post</code>. We want the value
returned from <code>content</code> to depend on the current state of the <code>Post</code>, so we‚Äôre
going to have the <code>Post</code> delegate to a <code>content</code> method defined on its <code>state</code>,
as shown in Listing 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 17-17: Updating the <code>content</code> method on <code>Post</code> to
delegate to a <code>content</code> method on <code>State</code></span></p>
<p>Because the goal is to keep all these rules inside the structs that implement
<code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass the post
instance (that is, <code>self</code>) as an argument. Then we return the value that‚Äôs
returned from using the <code>content</code> method on the <code>state</code> value.</p>
<p>We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the
value inside the <code>Option</code> rather than ownership of the value. Because <code>state</code>
is an <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, when we call <code>as_ref</code>, an <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> is returned. If we didn‚Äôt call <code>as_ref</code>, we would get an error because
we can‚Äôt move <code>state</code> out of the borrowed <code>&amp;self</code> of the function parameter.</p>
<p>We then call the <code>unwrap</code> method, which we know will never panic, because we
know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code>
value when those methods are done. This is one of the cases we talked about in
the <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">‚ÄúCases In Which You Have More Information Than the
Compiler‚Äù</a><!-- ignore --> section of Chapter 9 when we
know that a <code>None</code> value is never possible, even though the compiler isn‚Äôt able
to understand that.</p>
<p>At this point, when we call <code>content</code> on the <code>&amp;Box&lt;dyn State&gt;</code>, deref coercion
will take effect on the <code>&amp;</code> and the <code>Box</code> so the <code>content</code> method will
ultimately be called on the type that implements the <code>State</code> trait. That means
we need to add <code>content</code> to the <code>State</code> trait definition, and that is where
we‚Äôll put the logic for what content to return depending on which state we
have, as shown in Listing 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<p><span class="caption">Listing 17-18: Adding the <code>content</code> method to the <code>State</code>
trait</span></p>
<p>We add a default implementation for the <code>content</code> method that returns an empty
string slice. That means we don‚Äôt need to implement <code>content</code> on the <code>Draft</code>
and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code>
method and return the value in <code>post.content</code>.</p>
<p>Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We‚Äôre taking a reference to a <code>post</code> as an argument and returning a
reference to part of that <code>post</code>, so the lifetime of the returned reference is
related to the lifetime of the <code>post</code> argument.</p>
<p>And we‚Äôre done‚Äîall of Listing 17-11 now works! We‚Äôve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout <code>Post</code>.</p>
<blockquote>
<h4 id="why-not-an-enum"><a class="header" href="#why-not-an-enum">Why Not An Enum?</a></h4>
<p>You may have been wondering why we didn‚Äôt use an <code>enum</code> with the different
possible post states as variants. That‚Äôs certainly a possible solution, try
it and compare the end results to see which you prefer! One disadvantage of
using an enum is every place that checks the value of the enum will need a
<code>match</code> expression or similar to handle every possible variant. This could
get more repetitive than this trait object solution.</p>
</blockquote>
<h3 id="trade-offs-of-the-state-pattern"><a class="header" href="#trade-offs-of-the-state-pattern">Trade-offs of the State Pattern</a></h3>
<p>We‚Äôve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on <code>Post</code> know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the <code>State</code>
trait on the <code>Published</code> struct.</p>
<p>If we were to create an alternative implementation that didn‚Äôt use the state
pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or
even in the <code>main</code> code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those <code>match</code> expressions
would need another arm.</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don‚Äôt
need <code>match</code> expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.</p>
<p>The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:</p>
<ul>
<li>Add a <code>reject</code> method that changes the post‚Äôs state from <code>PendingReview</code> back
to <code>Draft</code>.</li>
<li>Require two calls to <code>approve</code> before the state can be changed to <code>Published</code>.</li>
<li>Allow users to add text content only when a post is in the <code>Draft</code> state.
Hint: have the state object responsible for what might change about the
content but not responsible for modifying the <code>Post</code>.</li>
</ul>
<p>One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between <code>PendingReview</code> and <code>Published</code>, such as <code>Scheduled</code>,
we would have to change the code in <code>PendingReview</code> to transition to
<code>Scheduled</code> instead. It would be less work if <code>PendingReview</code> didn‚Äôt need to
change with the addition of a new state, but that would mean switching to
another design pattern.</p>
<p>Another downside is that we‚Äôve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
<code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>;
however, this would violate object safety, because the trait doesn‚Äôt know what
the concrete <code>self</code> will be exactly. We want to be able to use <code>State</code> as a
trait object, so we need its methods to be object safe.</p>
<p>Other duplication includes the similar implementations of the <code>request_review</code>
and <code>approve</code> methods on <code>Post</code>. Both methods delegate to the implementation of
the same method on the value in the <code>state</code> field of <code>Option</code> and set the new
value of the <code>state</code> field to the result. If we had a lot of methods on <code>Post</code>
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see the <a href="ch19-06-macros.html#macros">‚ÄúMacros‚Äù</a><!-- ignore --> section in Chapter 19).</p>
<p>By implementing the state pattern exactly as it‚Äôs defined for object-oriented
languages, we‚Äôre not taking as full advantage of Rust‚Äôs strengths as we could.
Let‚Äôs look at some changes we can make to the <code>blog</code> crate that can make
invalid states and transitions into compile time errors.</p>
<h4 id="encoding-states-and-behavior-as-types"><a class="header" href="#encoding-states-and-behavior-as-types">Encoding States and Behavior as Types</a></h4>
<p>We‚Äôll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we‚Äôll encode the states into different
types. Consequently, Rust‚Äôs type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.</p>
<p>Let‚Äôs consider the first part of <code>main</code> in Listing 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
</span>}</code></pre>
<p>We still enable the creation of new posts in the draft state using <code>Post::new</code>
and the ability to add text to the post‚Äôs content. But instead of having a
<code>content</code> method on a draft post that returns an empty string, we‚Äôll make it so
draft posts don‚Äôt have the <code>content</code> method at all. That way, if we try to get
a draft post‚Äôs content, we‚Äôll get a compiler error telling us the method
doesn‚Äôt exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code won‚Äôt even compile.
Listing 17-19 shows the definition of a <code>Post</code> struct and a <code>DraftPost</code> struct,
as well as methods on each:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<p><span class="caption">Listing 17-19: A <code>Post</code> with a <code>content</code> method and a
<code>DraftPost</code> without a <code>content</code> method</span></p>
<p>Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that
stores the blog post text. The structs no longer have the <code>state</code> field because
we‚Äôre moving the encoding of the state to the types of the structs. The <code>Post</code>
struct will represent a published post, and it has a <code>content</code> method that
returns the <code>content</code>.</p>
<p>We still have a <code>Post::new</code> function, but instead of returning an instance of
<code>Post</code>, it returns an instance of <code>DraftPost</code>. Because <code>content</code> is private
and there aren‚Äôt any functions that return <code>Post</code>, it‚Äôs not possible to create
an instance of <code>Post</code> right now.</p>
<p>The <code>DraftPost</code> struct has an <code>add_text</code> method, so we can add text to
<code>content</code> as before, but note that <code>DraftPost</code> does not have a <code>content</code> method
defined! So now the program ensures all posts start as draft posts, and draft
posts don‚Äôt have their content available for display. Any attempt to get around
these constraints will result in a compiler error.</p>
<h4 id="implementing-transitions-as-transformations-into-different-types"><a class="header" href="#implementing-transitions-as-transformations-into-different-types">Implementing Transitions as Transformations into Different Types</a></h4>
<p>So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let‚Äôs implement
these constraints by adding another struct, <code>PendingReviewPost</code>, defining the
<code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code>, and
defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as
shown in Listing 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<p><span class="caption">Listing 17-20: A <code>PendingReviewPost</code> that gets created by
calling <code>request_review</code> on <code>DraftPost</code> and an <code>approve</code> method that turns a
<code>PendingReviewPost</code> into a published <code>Post</code></span></p>
<p>The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code>, thus
consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming
them into a <code>PendingReviewPost</code> and a published <code>Post</code>, respectively. This way,
we won‚Äôt have any lingering <code>DraftPost</code> instances after we‚Äôve called
<code>request_review</code> on them, and so forth. The <code>PendingReviewPost</code> struct doesn‚Äôt
have a <code>content</code> method defined on it, so attempting to read its content
results in a compiler error, as with <code>DraftPost</code>. Because the only way to get a
published <code>Post</code> instance that does have a <code>content</code> method defined is to call
the <code>approve</code> method on a <code>PendingReviewPost</code>, and the only way to get a
<code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code>,
we‚Äôve now encoded the blog post workflow into the type system.</p>
<p>But we also have to make some small changes to <code>main</code>. The <code>request_review</code> and
<code>approve</code> methods return new instances rather than modifying the struct they‚Äôre
called on, so we need to add more <code>let post =</code> shadowing assignments to save
the returned instances. We also can‚Äôt have the assertions about the draft and
pending review posts‚Äô contents be empty strings, nor do we need them: we can‚Äôt
compile code that tries to use the content of posts in those states any longer.
The updated code in <code>main</code> is shown in Listing 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}</code></pre>
<p><span class="caption">Listing 17-21: Modifications to <code>main</code> to use the new
implementation of the blog post workflow</span></p>
<p>The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this
implementation doesn‚Äôt quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the <code>Post</code> implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.</p>
<p>Try the tasks suggested at the start of this section on the <code>blog</code> crate as it
is after Listing 17-21 to see what you think about the design of this version
of the code. Note that some of the tasks might be completed already in this
design.</p>
<p>We‚Äôve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust‚Äôs features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won‚Äôt always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don‚Äôt have.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code‚Äôs
maintainability. Rust also has other features, like ownership, that
object-oriented languages don‚Äôt have. An object-oriented pattern won‚Äôt always
be the best way to take advantage of Rust‚Äôs strengths, but is an available
option.</p>
<p>Next, we‚Äôll look at patterns, which are another of Rust‚Äôs features that enable
lots of flexibility. We‚Äôve looked at them briefly throughout the book but
haven‚Äôt seen their full capability yet. Let‚Äôs go!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns-and-matching"><a class="header" href="#patterns-and-matching">Patterns and Matching</a></h1>
<p><em>Patterns</em> are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with <code>match</code>
expressions and other constructs gives you more control over a program‚Äôs
control flow. A pattern consists of some combination of the following:</p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<p>Some example patterns include <code>x</code>, <code>(a, 3)</code>, and <code>Some(Color::Red)</code>. In the
contexts in which patterns are valid, these components describe the shape of
data. Our program then matches values against the patterns to determine whether
it has the correct shape of data to continue running a particular piece of code.</p>
<p>To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the <code>match</code> expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesn‚Äôt, the code associated with the pattern won‚Äôt run.</p>
<p>This chapter is a reference on all things related to patterns. We‚Äôll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, you‚Äôll know how to use patterns to express many concepts in
a clear way.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="all-the-places-patterns-can-be-used"><a class="header" href="#all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</a></h2>
<p>Patterns pop up in a number of places in Rust, and you‚Äôve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.</p>
<h3 id="match-arms"><a class="header" href="#match-arms"><code>match</code> Arms</a></h3>
<p>As discussed in Chapter 6, we use patterns in the arms of <code>match</code> expressions.
Formally, <code>match</code> expressions are defined as the keyword <code>match</code>, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm‚Äôs pattern, like this:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>For example, here's the <code>match</code> expression from Listing 6-5 that matches on an
<code>Option&lt;i32&gt;</code> value in the variable <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>The patterns in this <code>match</code> expression are the <code>None</code> and <code>Some(i)</code> on the
left of each arrow.</p>
<p>One requirement for <code>match</code> expressions is that they need to be <em>exhaustive</em> in
the sense that all possibilities for the value in the <code>match</code> expression must
be accounted for. One way to ensure you‚Äôve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.</p>
<p>The particular pattern <code>_</code> will match anything, but it never binds to a
variable, so it‚Äôs often used in the last match arm. The <code>_</code> pattern can be
useful when you want to ignore any value not specified, for example. We‚Äôll
cover the <code>_</code> pattern in more detail in the <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">‚ÄúIgnoring Values in a
Pattern‚Äù</a><!-- ignore --> section later in this
chapter.</p>
<h3 id="conditional-if-let-expressions"><a class="header" href="#conditional-if-let-expressions">Conditional <code>if let</code> Expressions</a></h3>
<p>In Chapter 6 we discussed how to use <code>if let</code> expressions mainly as a shorter
way to write the equivalent of a <code>match</code> that only matches one case.
Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if
the pattern in the <code>if let</code> doesn‚Äôt match.</p>
<p>Listing 18-1 shows that it‚Äôs also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. Doing so gives us more flexibility than a
<code>match</code> expression in which we can express only one value to compare with the
patterns. Also, Rust doesn't require that the conditions in a series of <code>if let</code>, <code>else if</code>, <code>else if let</code> arms relate to each other.</p>
<p>The code in Listing 18-1 determines what color to make your background based on
a series of checks for several conditions. For this example, we‚Äôve created
variables with hardcoded values that a real program might receive from user
input.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {color}, as the background&quot;);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-1: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>,
and <code>else</code></span></p>
<p>If the user specifies a favorite color, that color is used as the background.
If no favorite color is specified and today is Tuesday, the background color is
green. Otherwise, if the user specifies their age as a string and we can parse
it as a number successfully, the color is either purple or orange depending on
the value of the number. If none of these conditions apply, the background
color is blue.</p>
<p>This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>You can see that <code>if let</code> can also introduce shadowed variables in the same way
that <code>match</code> arms can: the line <code>if let Ok(age) = age</code> introduces a new
shadowed <code>age</code> variable that contains the value inside the <code>Ok</code> variant. This
means we need to place the <code>if age &gt; 30</code> condition within that block: we can‚Äôt
combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The
shadowed <code>age</code> we want to compare to 30 isn‚Äôt valid until the new scope starts
with the curly bracket.</p>
<p>The downside of using <code>if let</code> expressions is that the compiler doesn‚Äôt check
for exhaustiveness, whereas with <code>match</code> expressions it does. If we omitted the
last <code>else</code> block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.</p>
<h3 id="while-let-conditional-loops"><a class="header" href="#while-let-conditional-loops"><code>while let</code> Conditional Loops</a></h3>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a
<code>while</code> loop to run for as long as a pattern continues to match. In Listing
18-2 we code a <code>while let</code> loop that uses a vector as a stack and prints the
values in the vector in the opposite order in which they were pushed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-2: Using a <code>while let</code> loop to print values
for as long as <code>stack.pop()</code> returns <code>Some</code></span></p>
<p>This example prints 3, 2, and then 1. The <code>pop</code> method takes the last element
out of the vector and returns <code>Some(value)</code>. If the vector is empty, <code>pop</code>
returns <code>None</code>. The <code>while</code> loop continues running the code in its block as
long as <code>pop</code> returns <code>Some</code>. When <code>pop</code> returns <code>None</code>, the loop stops. We can
use <code>while let</code> to pop every element off our stack.</p>
<h3 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h3>
<p>In a <code>for</code> loop, the value that directly follows the keyword <code>for</code> is a
pattern. For example, in <code>for x in y</code> the <code>x</code> is the pattern. Listing 18-3
demonstrates how to use a pattern in a <code>for</code> loop to destructure, or break
apart, a tuple as part of the <code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} is at index {}&quot;, value, index);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-3: Using a pattern in a <code>for</code> loop to
destructure a tuple</span></p>
<p>The code in Listing 18-3 will print the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>We adapt an iterator using the <code>enumerate</code> method so it produces a value and
the index for that value, placed into a tuple. The first value produced is the
tuple <code>(0, 'a')</code>. When this value is matched to the pattern <code>(index, value)</code>,
<code>index</code> will be <code>0</code> and <code>value</code> will be <code>'a'</code>, printing the first line of the
output.</p>
<h3 id="let-statements"><a class="header" href="#let-statements"><code>let</code> Statements</a></h3>
<p>Prior to this chapter, we had only explicitly discussed using patterns with
<code>match</code> and <code>if let</code>, but in fact, we‚Äôve used patterns in other places as well,
including in <code>let</code> statements. For example, consider this straightforward
variable assignment with <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Every time you've used a <code>let</code> statement like this you've been using patterns,
although you might not have realized it! More formally, a <code>let</code> statement looks
like this:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the <code>PATTERN</code> slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
<code>let x = 5;</code> example, <code>x</code> is a pattern that means ‚Äúbind what matches here to
the variable <code>x</code>.‚Äù Because the name <code>x</code> is the whole pattern, this pattern
effectively means ‚Äúbind everything to the variable <code>x</code>, whatever the value is.‚Äù</p>
<p>To see the pattern matching aspect of <code>let</code> more clearly, consider Listing
18-4, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span></p>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code>
to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, so Rust
binds <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple
pattern as nesting three individual variable patterns inside it.</p>
<p>If the number of elements in the pattern doesn‚Äôt match the number of elements
in the tuple, the overall type won‚Äôt match and we‚Äôll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which won‚Äôt work.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don‚Äôt match the number of elements in the tuple</span></p>
<p>Attempting to compile this code results in this type error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>To fix the error, we could ignore one or more of the values in the tuple using
<code>_</code> or <code>..</code>, as you‚Äôll see in the <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">‚ÄúIgnoring Values in a
Pattern‚Äù</a><!-- ignore --> section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named <code>foo</code> that takes one parameter named <code>x</code> of type
<code>i32</code>, should by now look familiar.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span></p>
<p>The <code>x</code> part is a pattern! As we did with <code>let</code>, we could match a tuple in a
function‚Äôs arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
<p><span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span></p>
<p>This code prints <code>Current location: (3, 5)</code>. The values <code>&amp;(3, 5)</code> match the
pattern <code>&amp;(x, y)</code>, so <code>x</code> is the value <code>3</code> and <code>y</code> is the value <code>5</code>.</p>
<p>We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.</p>
<p>At this point, you‚Äôve seen several ways of using patterns, but patterns don‚Äôt
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. We‚Äôll discuss
these two concepts next.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refutability-whether-a-pattern-might-fail-to-match"><a class="header" href="#refutability-whether-a-pattern-might-fail-to-match">Refutability: Whether a Pattern Might Fail to Match</a></h2>
<p>Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are <em>irrefutable</em>. An example would be <code>x</code> in the
statement <code>let x = 5;</code> because <code>x</code> matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
<em>refutable</em>. An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than
<code>Some</code>, the <code>Some(x)</code> pattern will not match.</p>
<p>Function parameters, <code>let</code> statements, and <code>for</code> loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values don‚Äôt match. The <code>if let</code> and <code>while let</code> expressions accept
refutable and irrefutable patterns, but the compiler warns against
irrefutable patterns because by definition they‚Äôre intended to handle possible
failure: the functionality of a conditional is in its ability to perform
differently depending on success or failure.</p>
<p>In general, you shouldn‚Äôt have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, you‚Äôll need to change either the pattern or the construct you‚Äôre
using the pattern with, depending on the intended behavior of the code.</p>
<p>Let‚Äôs look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a
<code>let</code> statement, but for the pattern we‚Äôve specified <code>Some(x)</code>, a refutable
pattern. As you might expect, this code will not compile.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-8: Attempting to use a refutable pattern with
<code>let</code></span></p>
<p>If <code>some_option_value</code> was a <code>None</code> value, it would fail to match the pattern
<code>Some(x)</code>, meaning the pattern is refutable. However, the <code>let</code> statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a <code>None</code> value. At compile time, Rust will complain that we‚Äôve tried to
use a refutable pattern where an irrefutable pattern is required:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:1
  |
  = note:
/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:5: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     let x = if let Some(x) = some_option_value { x } else { todo!() };
  |     ++++++++++                                 ++++++++++++++++++++++
help: alternatively, you might want to use let else to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>Because we didn‚Äôt cover (and couldn‚Äôt cover!) every valid value with the
pattern <code>Some(x)</code>, Rust rightfully produces a compiler error.</p>
<p>If we have a refutable pattern where an irrefutable pattern is needed, we can
fix it by changing the code that uses the pattern: instead of using <code>let</code>, we
can use <code>if let</code>. Then if the pattern doesn‚Äôt match, the code will just skip
the code in the curly brackets, giving it a way to continue validly. Listing
18-9 shows how to fix the code in Listing 18-8.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-9: Using <code>if let</code> and a block with refutable
patterns instead of <code>let</code></span></p>
<p>We‚Äôve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving an error. If we give <code>if let</code> a pattern that will always match, such as <code>x</code>, as shown in Listing 18-10,
the compiler will give a warning.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with <code>if let</code></span></p>
<p>Rust complains that it doesn‚Äôt make sense to use <code>if let</code> with an irrefutable
pattern:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a <code>match</code> with only one arm, but
this syntax isn‚Äôt particularly useful and could be replaced with a simpler
<code>let</code> statement.</p>
<p>Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, let‚Äôs cover all the syntax we can use to create
patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h2>
<p>In this section, we gather all the syntax valid in patterns and discuss why and
when you might want to use each one.</p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">Matching Literals</a></h3>
<p>As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>This code prints <code>one</code> because the value in <code>x</code> is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.</p>
<h3 id="matching-named-variables"><a class="header" href="#matching-named-variables">Matching Named Variables</a></h3>
<p>Named variables are irrefutable patterns that match any value, and we‚Äôve used
them many times in the book. However, there is a complication when you use
named variables in <code>match</code> expressions. Because <code>match</code> starts a new scope,
variables declared as part of a pattern inside the <code>match</code> expression will
shadow those with the same name outside the <code>match</code> construct, as is the case
with all variables. In Listing 18-11, we declare a variable named <code>x</code> with the
value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. We then create a
<code>match</code> expression on the value <code>x</code>. Look at the patterns in the match arms and
<code>println!</code> at the end, and try to figure out what the code will print before
running this code or reading further.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {y}&quot;),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {y}&quot;, x);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-11: A <code>match</code> expression with an arm that
introduces a shadowed variable <code>y</code></span></p>
<p>Let‚Äôs walk through what happens when the <code>match</code> expression runs. The pattern
in the first match arm doesn‚Äôt match the defined value of <code>x</code>, so the code
continues.</p>
<p>The pattern in the second match arm introduces a new variable named <code>y</code> that
will match any value inside a <code>Some</code> value. Because we‚Äôre in a new scope inside
the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at
the beginning with the value 10. This new <code>y</code> binding will match any value
inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to
the inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for
that arm executes and prints <code>Matched, y = 5</code>.</p>
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first
two arms wouldn‚Äôt have matched, so the value would have matched to the
underscore. We didn‚Äôt introduce the <code>x</code> variable in the pattern of the
underscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn‚Äôt
been shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>When the <code>match</code> expression is done, its scope ends, and so does the scope of
the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and
<code>y</code>, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We‚Äôll talk about match guards later in the <a href="ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">‚ÄúExtra
Conditionals with Match Guards‚Äù</a><!--
ignore --> section.</p>
<h3 id="multiple-patterns"><a class="header" href="#multiple-patterns">Multiple Patterns</a></h3>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax,
which is the pattern <em>or</em> operator. For example, in the following code we match
the value of <code>x</code> against the match arms, the first of which has an <em>or</em> option,
meaning if the value of <code>x</code> matches either of the values in that arm, that
arm‚Äôs code will run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>This code prints <code>one or two</code>.</p>
<h3 id="matching-ranges-of-values-with-"><a class="header" href="#matching-ranges-of-values-with-">Matching Ranges of Values with <code>..=</code></a></h3>
<p>The <code>..=</code> syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the given
range, that arm will execute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient for multiple match values than using the <code>|</code> operator to express the
same idea; if we were to use <code>|</code> we would have to specify <code>1 | 2 | 3 | 4 | 5</code>.
Specifying a range is much shorter, especially if we want to match, say, any
number between 1 and 1,000!</p>
<p>The compiler checks that the range isn‚Äôt empty at compile time, and because the
only types for which Rust can tell if a range is empty or not are <code>char</code> and
numeric values, ranges are only allowed with numeric or <code>char</code> values.</p>
<p>Here is an example using ranges of <code>char</code> values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust can tell that <code>'c'</code> is within the first pattern‚Äôs range and prints <code>early ASCII letter</code>.</p>
<h3 id="destructuring-to-break-apart-values"><a class="header" href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></h3>
<p>We can also use patterns to destructure structs, enums, and tuples to use
different parts of these values. Let‚Äôs walk through each value.</p>
<h4 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h4>
<p>Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can
break apart using a pattern with a <code>let</code> statement.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<p><span class="caption">Listing 18-12: Destructuring a struct‚Äôs fields into
separate variables</span></p>
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code>
and <code>y</code> fields of the <code>p</code> struct. This example shows that the names of the
variables in the pattern don‚Äôt have to match the field names of the struct.
However, it‚Äôs common to match the variable names to the field names to make it
easier to remember which variables came from which fields. Because of this
common usage, and because writing <code>let Point { x: x, y: y } = p;</code> contains a
lot of duplication, Rust has a shorthand for patterns that match struct fields:
you only need to list the name of the struct field, and the variables created
from the pattern will have the same names. Listing 18-13 behaves in the same
way as the code in Listing 18-12, but the variables created in the <code>let</code>
pattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span></p>
<p>This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields
of the <code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the
values from the <code>p</code> struct.</p>
<p>We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.</p>
<p>In Listing 18-14, we have a <code>match</code> expression that separates <code>Point</code> values
into three cases: points that lie directly on the <code>x</code> axis (which is true when
<code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {x}&quot;),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {y}&quot;),
        Point { x, y } =&gt; {
            println!(&quot;On neither axis: ({x}, {y})&quot;);
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span></p>
<p>The first arm will match any point that lies on the <code>x</code> axis by specifying that
the <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still
creates an <code>x</code> variable that we can use in the code for this arm.</p>
<p>Similarly, the second arm matches any point on the <code>y</code> axis by specifying that
the <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the
value of the <code>y</code> field. The third arm doesn‚Äôt specify any literals, so it
matches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code>
containing a 0, so this code will print <code>On the y axis at 7</code>.</p>
<p>Remember that a <code>match</code> expression stops checking arms once it has found the
first matching pattern, so even though <code>Point { x: 0, y: 0}</code> is on the <code>x</code> axis
and the <code>y</code> axis, this code would only print <code>On the x axis at 0</code>.</p>
<h4 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h4>
<p>We've destructured enums in this book (for example, Listing 6-5 in Chapter 6),
but haven‚Äôt yet explicitly discussed that the pattern to destructure an enum
corresponds to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the <code>Message</code> enum from Listing 6-2 and write
a <code>match</code> with patterns that will destructure each inner value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;);
        }
        Message::Move { x, y } =&gt; {
            println!(&quot;Move in the x direction {x} and in the y direction {y}&quot;);
        }
        Message::Write(text) =&gt; {
            println!(&quot;Text message: {text}&quot;);
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!(&quot;Change the color to red {r}, green {g}, and blue {b}&quot;,)
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span></p>
<p>This code will print <code>Change the color to red 0, green 160, and blue 255</code>. Try
changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p>For enum variants without any data, like <code>Message::Quit</code>, we can‚Äôt destructure
the value any further. We can only match on the literal <code>Message::Quit</code> value,
and no variables are in that pattern.</p>
<p>For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.</p>
<p>For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one
element and <code>Message::ChangeColor</code> that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we‚Äôre
matching.</p>
<h4 id="destructuring-nested-structs-and-enums"><a class="header" href="#destructuring-nested-structs-and-enums">Destructuring Nested Structs and Enums</a></h4>
<p>So far, our examples have all been matching structs or enums one level deep,
but matching can work on nested items too! For example, we can refactor the
code in Listing 18-15 to support RGB and HSV colors in the <code>ChangeColor</code>
message, as shown in Listing 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(&quot;Change color to red {r}, green {g}, and blue {b}&quot;);
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(&quot;Change color to hue {h}, saturation {s}, value {v}&quot;)
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-16: Matching on nested enums</span></p>
<p>The pattern of the first arm in the <code>match</code> expression matches a
<code>Message::ChangeColor</code> enum variant that contains a <code>Color::Rgb</code> variant; then
the pattern binds to the three inner <code>i32</code> values. The pattern of the second
arm also matches a <code>Message::ChangeColor</code> enum variant, but the inner enum
matches <code>Color::Hsv</code> instead. We can specify these complex conditions in one
<code>match</code> expression, even though two enums are involved.</p>
<h4 id="destructuring-structs-and-tuples"><a class="header" href="#destructuring-structs-and-tuples">Destructuring Structs and Tuples</a></h4>
<p>We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>This code lets us break complex types into their component parts so we can use
the values we‚Äôre interested in separately.</p>
<p>Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.</p>
<h3 id="ignoring-values-in-a-pattern"><a class="header" href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></h3>
<p>You‚Äôve seen that it‚Äôs sometimes useful to ignore values in a pattern, such as
in the last arm of a <code>match</code>, to get a catchall that doesn‚Äôt actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the <code>_</code>
pattern (which you‚Äôve seen), using the <code>_</code> pattern within another pattern,
using a name that starts with an underscore, or using <code>..</code> to ignore remaining
parts of a value. Let‚Äôs explore how and why to use each of these patterns.</p>
<h4 id="ignoring-an-entire-value-with-_"><a class="header" href="#ignoring-an-entire-value-with-_">Ignoring an Entire Value with <code>_</code></a></h4>
<p>We‚Äôve used the underscore as a wildcard pattern that will match any value but
not bind to the value. This is especially useful as the last arm in a <code>match</code>
expression, but we can also use it in any pattern, including function
parameters, as shown in Listing 18-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<p><span class="caption">Listing 18-17: Using <code>_</code> in a function signature</span></p>
<p>This code will completely ignore the value <code>3</code> passed as the first argument,
and will print <code>This code only uses the y parameter: 4</code>.</p>
<p>In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn‚Äôt include the unused parameter. Ignoring
a function parameter can be especially useful in cases when, for example,
you're implementing a trait when you need a certain type signature but the
function body in your implementation doesn‚Äôt need one of the parameters. You
then avoid getting a compiler warning about unused function parameters, as you
would if you used a name instead.</p>
<h4 id="ignoring-parts-of-a-value-with-a-nested-_"><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>
<p>We can also use <code>_</code> inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting‚Äôs value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Can't overwrite an existing customized value&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-18: Using an underscore within patterns that
match <code>Some</code> variants when we don‚Äôt need to use the value inside the
<code>Some</code></span></p>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then
<code>setting is Some(5)</code>. In the first match arm, we don‚Äôt need to match on or use
the values inside either <code>Some</code> variant, but we do need to test for the case
when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that
case, we print the reason for not changing <code>setting_value</code>, and it doesn‚Äôt get
changed.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are
<code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow
<code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {first}, {third}, {fifth}&quot;)
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span></p>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be
ignored.</p>
<h4 id="ignoring-an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>If you create a variable but don‚Äôt use it anywhere, Rust will usually issue a
warning because an unused variable could be a bug. However, sometimes it‚Äôs
useful to be able to create a variable you won‚Äôt use yet, such as when you‚Äôre
prototyping or just starting a project. In this situation, you can tell Rust
not to warn you about the unused variable by starting the name of the variable
with an underscore. In Listing 18-20, we create two unused variables, but when
we compile this code, we should only get a warning about one of them.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<p><span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span></p>
<p>Here we get a warning about not using the variable <code>y</code>, but we don‚Äôt get a
warning about not using <code>_x</code>.</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name
that starts with an underscore. The syntax <code>_x</code> still binds the value to the
variable, whereas <code>_</code> doesn‚Äôt bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_s) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span></p>
<p>We‚Äôll receive an error because the <code>s</code> value will still be moved into <code>_s</code>,
which prevents us from using <code>s</code> again. However, using the underscore by itself
doesn‚Äôt ever bind to the value. Listing 18-22 will compile without any errors
because <code>s</code> doesn‚Äôt get moved into <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-22: Using an underscore does not bind the
value</span></p>
<p>This code works just fine because we never bind <code>s</code> to anything; it isn‚Äôt moved.</p>
<h4 id="ignoring-remaining-parts-of-a-value-with-"><a class="header" href="#ignoring-remaining-parts-of-a-value-with-">Ignoring Remaining Parts of a Value with <code>..</code></a></h4>
<p>With values that have many parts, we can use the <code>..</code> syntax to use specific
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The <code>..</code> pattern ignores any parts of a value that we haven‚Äôt
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
<code>Point</code> struct that holds a coordinate in three-dimensional space. In the
<code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore
the values in the <code>y</code> and <code>z</code> fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-23: Ignoring all fields of a <code>Point</code> except
for <code>x</code> by using <code>..</code></span></p>
<p>We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker
than having to list <code>y: _</code> and <code>z: _</code>, particularly when we‚Äôre working with
structs that have lots of fields in situations where only one or two fields are
relevant.</p>
<p>The syntax <code>..</code> will expand to as many values as it needs to be. Listing 18-24
shows how to use <code>..</code> with a tuple.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {first}, {last}&quot;);
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span></p>
<p>In this code, the first and last value are matched with <code>first</code> and <code>last</code>. The
<code>..</code> will match and ignore everything in the middle.</p>
<p>However, using <code>..</code> must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using <code>..</code> ambiguously, so it will not
compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}</code></pre>
<p><span class="caption">Listing 18-25: An attempt to use <code>..</code> in an ambiguous
way</span></p>
<p>When we compile this example, we get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<p>It‚Äôs impossible for Rust to determine how many values in the tuple to ignore
before matching a value with <code>second</code> and then how many further values to
ignore thereafter. This code could mean that we want to ignore <code>2</code>, bind
<code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore
<code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth.
The variable name <code>second</code> doesn‚Äôt mean anything special to Rust, so we get a
compiler error because using <code>..</code> in two places like this is ambiguous.</p>
<h3 id="extra-conditionals-with-match-guards"><a class="header" href="#extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in
a <code>match</code> arm, that must also match for that arm to be chosen. Match guards are
useful for expressing more complex ideas than a pattern alone allows.</p>
<p>The condition can use variables created in the pattern. Listing 18-26 shows a
<code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match
guard of <code>if x % 2 == 0</code> (which will be true if the number is even).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {} is even&quot;, x),
        Some(x) =&gt; println!(&quot;The number {} is odd&quot;, x),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-26: Adding a match guard to a pattern</span></p>
<p>This example will print <code>The number 4 is even</code>. When <code>num</code> is compared to the
pattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code>. Then
the match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to
0, and because it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would
have been false because the remainder of 5 divided by 2 is 1, which is not
equal to 0. Rust would then go to the second arm, which would match because the
second arm doesn‚Äôt have a match guard and therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so
the match guard gives us the ability to express this logic. The downside of
this additional expressiveness is that the compiler doesn't try to check for
exhaustiveness when match guard expressions are involved.</p>
<p>In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that we created a new variable inside the
pattern in the <code>match</code> expression instead of using the variable outside the
<code>match</code>. That new variable meant we couldn‚Äôt test against the value of the
outer variable. Listing 18-27 shows how we can use a match guard to fix this
problem.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {n}&quot;),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {y}&quot;, x);
}</code></pre></pre>
<p><span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span></p>
<p>This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second
match arm doesn‚Äôt introduce a new variable <code>y</code> that would shadow the outer <code>y</code>,
meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the
pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify
<code>Some(n)</code>. This creates a new variable <code>n</code> that doesn‚Äôt shadow anything because
there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>The match guard <code>if n == y</code> is not a pattern and therefore doesn‚Äôt introduce
new variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new shadowed <code>y</code>, and
we can look for a value that has the same value as the outer <code>y</code> by comparing
<code>n</code> to <code>y</code>.</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-28 shows the precedence when combining a pattern that uses <code>|</code> with a match
guard. The important part of this example is that the <code>if y</code> match guard
applies to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only
applies to <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-28: Combining multiple patterns with a match
guard</span></p>
<p>The match condition states that the arm only matches if the value of <code>x</code> is
equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the
pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code>
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints <code>no</code>. The reason is that the <code>if</code>
condition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value
<code>6</code>. In other words, the precedence of a match guard in relation to a pattern
behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
<code>|</code> operator, the arm would have matched and the program would have printed
<code>yes</code>.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same
time as we‚Äôre testing that value for a pattern match. In Listing 18-29, we want
to test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also
want to bind the value to the variable <code>id_variable</code> so we can use it in the
code associated with the arm. We could name this variable <code>id</code>, the same as the
field, but for this example we‚Äôll use a different name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 18-29: Using <code>@</code> to bind to a value in a pattern
while also testing it</span></p>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3..=7</code>, we‚Äôre capturing whatever value matched the range
while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn‚Äôt have a variable that contains the actual value
of the <code>id</code> field. The <code>id</code> field‚Äôs value could have been 10, 11, or 12, but
the code that goes with that pattern doesn‚Äôt know which it is. The pattern code
isn‚Äôt able to use the value from the <code>id</code> field, because we haven‚Äôt saved the
<code>id</code> value in a variable.</p>
<p>In the last arm, where we‚Äôve specified a variable without a range, we do have
the value available to use in the arm‚Äôs code in a variable named <code>id</code>. The
reason is that we‚Äôve used the struct field shorthand syntax. But we haven‚Äôt
applied any test to the value in the <code>id</code> field in this arm, as we did with the
first two arms: any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Rust‚Äôs patterns are very useful in distinguishing between different kinds of
data. When used in <code>match</code> expressions, Rust ensures your patterns cover every
possible value, or your program won‚Äôt compile. Patterns in <code>let</code> statements and
function parameters make those constructs more useful, enabling the
destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.</p>
<p>Next, for the penultimate chapter of the book, we‚Äôll look at some advanced
aspects of a variety of Rust‚Äôs features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kengaytirilgan-xususiyatlar"><a class="header" href="#kengaytirilgan-xususiyatlar">Kengaytirilgan xususiyatlar</a></h1>
<p>Hozirgacha Rust dasturlash tilining eng ko'p qo'llaniladigan qismlarini o'rgandingiz. 
20-bobda yana bir loyihani amalga oshirishimizdan oldin, siz vaqti-vaqti bilan duch kelishingiz 
mumkin bo'lgan, lekin har doim ham ishlatilmaydigan Rust xususiyatlari haqida gaplashamiz. 
Qachondir tushunmovchiliklarga duch kelganingizda, ushbu bobdan qo'llanma sifatida foydalanishingiz mumkin. 
Bu yerda ko'rib chiqiladigan xususiyatlar, funksiyalar faqat muayyan vaziyatlardagina foydali bo'ladi.
Garchi bu funksiyalarga tez-tez murojaat qilmasligingiz mumkin bo‚Äòlsa-da, Rust tili taklif qiladigan 
barcha imkoniyatlarni tushunib olishingizni istaymiz.</p>
<p>Ushbu bobda biz quyidagilarni ko'rib chiqamiz:</p>
<ul>
<li>
<p>Xavfsiz bo‚Äòlmagan (Unsafe) Rust: Rustning ayrim kafolatlaridan qanday qilib voz kechish va bu kafolatlarni qo‚Äòlda, ya‚Äôni 
o‚Äòzingiz mustaqil tarzda boshqarish mas‚Äôuliyatini qanday olishni ko‚Äòrib chiqamiz.</p>
</li>
<li>
<p>Kengaytirilgan traitlar: bog‚Äòlangan turlar (associated types), standart tur parametrlari (default type parameters), 
to‚Äòliq aniqlangan sintaksis (fully qualified syntax), supertraitlar (supertraits) va newtype namunasi (newtype pattern).</p>
</li>
<li>
<p>Kengaytirilgan turlar: newtype namunasi (newtype pattern), tur aliaslari (type aliases),  hech qachon yuz bermaydigan tur
(the never type ‚Äî !) va dinamik o'lchamdagi turlar (dynamically sized types)</p>
</li>
<li>
<p>Kengaytirilgan funksiyalar va yopiq funksiyalar (Closures): funksiya ko'rsatkichlari (function pointers) va closure qaytaradigan funksiyalar (returning closures)</p>
</li>
<li>
<p>Andozalar (Macros): kodni jamlash (kompilyatsiya) vaqtida boshqa kodni aniqlovchi kodni yozish usullari.</p>
</li>
</ul>
<p>Bu ‚Äî har bir dasturchi uchun foydali bo'lgan Rust imkoniyatlarining to‚Äòliq to‚Äòplamidir! Keling, to'plamga sho'ng'iymiz!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>All the code we‚Äôve discussed so far has had Rust‚Äôs memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn‚Äôt enforce these memory safety guarantees: it‚Äôs called <em>unsafe Rust</em>
and works just like regular Rust, but gives us extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it‚Äôs better for it to reject some valid programs than to accept some invalid
programs. Although the code <em>might</em> be okay, if the Rust compiler doesn‚Äôt have
enough information to be confident, it will reject the code. In these cases,
you can use unsafe code to tell the compiler, ‚ÄúTrust me, I know what I‚Äôm
doing.‚Äù Be warned, however, that you use unsafe Rust at your own risk: if you
use unsafe code incorrectly, problems can occur due to memory unsafety, such as
null pointer dereferencing.</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn‚Äôt let you do unsafe operations, you
couldn‚Äôt do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let‚Äôs explore what we can do with unsafe
Rust and how to do it.</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust that you
can‚Äôt in safe Rust, which we call <em>unsafe superpowers</em>. Those superpowers
include the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of <code>union</code>s</li>
</ul>
<p>It‚Äôs important to understand that <code>unsafe</code> doesn‚Äôt turn off the borrow checker
or disable any other of Rust‚Äôs safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. You‚Äôll still get some degree of safety inside of an unsafe block.</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you‚Äôll ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>People are fallible, and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with <code>unsafe</code> you‚Äôll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small; you‚Äôll be thankful later when you investigate memory
bugs.</p>
<p>To isolate unsafe code as much as possible, it‚Äôs best to enclose unsafe code
within a safe abstraction and provide a safe API, which we‚Äôll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>
from leaking out into all the places that you or your users might want to use
the functionality implemented with <code>unsafe</code> code, because using a safe
abstraction is safe.</p>
<p>Let‚Äôs look at each of the five unsafe superpowers in turn. We‚Äôll also look at
some abstractions that provide a safe interface to unsafe code.</p>
<h3 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h3>
<p>In Chapter 4, in the <a href="ch04-02-references-and-borrowing.html#dangling-references">‚ÄúDangling References‚Äù</a><!-- ignore
--> section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn‚Äôt the
dereference operator; it‚Äôs part of the type name. In the context of raw
pointers, <em>immutable</em> means that the pointer can‚Äôt be directly assigned to
after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren‚Äôt guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don‚Äôt implement any automatic cleanup</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust‚Äôs guarantees don‚Äôt apply.</p>
<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-1: Creating raw pointers from references</span></p>
<p>Notice that we don‚Äôt include the <code>unsafe</code> keyword in this code. We can create
raw pointers in safe code; we just can‚Äôt dereference raw pointers outside an
unsafe block, as you‚Äôll see in a bit.</p>
<p>We‚Äôve created raw pointers by using <code>as</code> to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can‚Äôt make that assumption about just any raw
pointer.</p>
<p>To demonstrate this, next we‚Äôll create a raw pointer whose validity we can‚Äôt be
so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary
location in memory. Trying to use arbitrary memory is undefined: there might be
data at that address or there might not, the compiler might optimize the code
so there is no memory access, or the program might error with a segmentation
fault. Usually, there is no good reason to write code like this, but it is
possible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span></p>
<p>Recall that we can create raw pointers in safe code, but we can‚Äôt <em>dereference</em>
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        println!(&quot;r2 is: {}&quot;, *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-3: Dereferencing raw pointers within an
<code>unsafe</code> block</span></p>
<p>Creating a pointer does no harm; it‚Äôs only when we try to access the value that
it points at that we might end up dealing with an invalid value.</p>
<p>Note also that in Listing 19-1 and 19-3, we created <code>*const i32</code> and <code>*mut i32</code>
raw pointers that both pointed to the same memory location, where <code>num</code> is
stored. If we instead tried to create an immutable and a mutable reference to
<code>num</code>, the code would not have compiled because Rust‚Äôs ownership rules don‚Äôt
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you‚Äôll see in the next section,
<a href="ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">‚ÄúCalling an Unsafe Function or
Method.‚Äù</a><!-- ignore --> Another case is
when building up safe abstractions that the borrow checker doesn‚Äôt understand.
We‚Äôll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.</p>
<h3 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h3>
<p>The second type of operation you can perform in an unsafe block is calling
unsafe functions. Unsafe functions and methods look exactly like regular
functions and methods, but they have an extra <code>unsafe</code> before the rest of the
definition. The <code>unsafe</code> keyword in this context indicates the function has
requirements we need to uphold when we call this function, because Rust can‚Äôt
guarantee we‚Äôve met these requirements. By calling an unsafe function within an
<code>unsafe</code> block, we‚Äôre saying that we‚Äôve read this function‚Äôs documentation and
take responsibility for upholding the function‚Äôs contracts.</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn‚Äôt do anything in its
body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we‚Äôll get an error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>With the <code>unsafe</code> block, we‚Äôre asserting to Rust that we‚Äôve read the function‚Äôs
documentation, we understand how to use it properly, and we‚Äôve verified that
we‚Äôre fulfilling the contract of the function.</p>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other
unsafe operations within an unsafe function, we don‚Äôt need to add another
<code>unsafe</code> block.</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h4>
<p>Just because a function contains unsafe code doesn‚Äôt mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let‚Äôs study the <code>split_at_mut</code> function
from the standard library, which requires some unsafe code. We‚Äôll explore how
we might implement it. This safe method is defined on mutable slices: it takes
one slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-4: Using the safe <code>split_at_mut</code>
function</span></p>
<p>We can‚Äôt implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won‚Äôt compile. For simplicity, we‚Äôll
implement <code>split_at_mut</code> as a function rather than a method and only for slices
of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 19-5: An attempted implementation of
<code>split_at_mut</code> using only safe Rust</span></p>
<p>This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it‚Äôs
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the
slice.</p>
<p>When we try to compile the code in Listing 19-5, we‚Äôll get an error.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>Rust‚Äôs borrow checker can‚Äôt understand that we‚Äôre borrowing different parts of
the slice; it only knows that we‚Äôre borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren‚Äôt overlapping, but Rust isn‚Äôt smart enough to know this. When we
know code is okay, but Rust doesn‚Äôt, it‚Äôs time to reach for unsafe code.</p>
<p>Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-6: Using unsafe code in the implementation of
the <code>split_at_mut</code> function</span></p>
<p>Recall from <a href="ch04-03-slices.html#the-slice-type">‚ÄúThe Slice Type‚Äù</a><!-- ignore --> section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code>
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type
<code>*mut i32</code>, which we‚Äôve stored in the variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>add</code>
method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at
<code>mid</code>, and we create a slice using that pointer and the remaining number of
items after <code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>add</code> method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>add</code> so we could call them. By looking at
the code and by adding the assertion that <code>mid</code> must be less than or equal to
<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of <code>unsafe</code>.</p>
<p>Note that we don‚Äôt need to mark the resulting <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We‚Äôve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way, because it creates only valid pointers from the
data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span></p>
<p>We don‚Äôt own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>values</code> as though it‚Äôs a valid slice results in undefined behavior.</p>
<h4 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">Using <code>extern</code> Functions to Call External Code</a></h4>
<p>Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has the keyword <code>extern</code> that facilitates the creation
and use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.</p>
<p>Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
always unsafe to call from Rust code. The reason is that other languages don‚Äôt
enforce Rust‚Äôs rules and guarantees, and Rust can‚Äôt check them, so
responsibility falls on the programmer to ensure safety.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">Listing 19-8: Declaring and calling an <code>extern</code> function
defined in another language</span></p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external
functions from another language we want to call. The <code>&quot;C&quot;</code> part defines which
<em>application binary interface (ABI)</em> the external function uses: the ABI
defines how to call the function at the assembly level. The <code>&quot;C&quot;</code> ABI is the
most common and follows the C programming language‚Äôs ABI.</p>
<blockquote>
<h4 id="calling-rust-functions-from-other-languages"><a class="header" href="#calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages
to call Rust functions. Instead of creating a whole <code>extern</code> block, we add
the <code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword
for the relevant function. We also need to add a <code>#[no_mangle]</code> annotation to
tell the Rust compiler not to mangle the name of this function. <em>Mangling</em> is
when a compiler changes the name we‚Äôve given a function to a different name
that contains more information for other parts of the compilation process to
consume but is less human readable. Every programming language compiler
mangles names slightly differently, so for a Rust function to be nameable by
other languages, we must disable the Rust compiler‚Äôs name mangling.</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from
C code, after it‚Äôs compiled to a shared library and linked from C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>This usage of <code>extern</code> does not require <code>unsafe</code>.</p>
</blockquote>
<h3 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h3>
<p>In this book, we‚Äôve not yet talked about <em>global variables</em>, which Rust does
support but can be problematic with Rust‚Äôs ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}</code></pre></pre>
<p><span class="caption">Listing 19-9: Defining and using an immutable static
variable</span></p>
<p>Static variables are similar to constants, which we discussed in the
<a href="ch03-01-variables-and-mutability.html#constants">‚ÄúDifferences Between Variables and
Constants‚Äù</a><!-- ignore --> section
in Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by
convention. Static variables can only store references with the <code>'static</code>
lifetime, which means the Rust compiler can figure out the lifetime and we
aren‚Äôt required to annotate it explicitly. Accessing an immutable static
variable is safe.</p>
<p>A subtle difference between constants and immutable static variables is that
values in a static variable have a fixed address in memory. Using the value
will always access the same data. Constants, on the other hand, are allowed to
duplicate their data whenever they‚Äôre used. Another difference is that static
variables can be mutable. Accessing and modifying mutable static variables is
<em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}</code></pre></pre>
<p><span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span></p>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any
code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. This
code compiles and prints <code>COUNTER: 3</code> as we would expect because it‚Äôs single
threaded. Having multiple threads access <code>COUNTER</code> would likely result in data
races.</p>
<p>With mutable data that is globally accessible, it‚Äôs difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it‚Äôs preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.</p>
<h3 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></h3>
<p>We can use <code>unsafe</code> to implement an unsafe trait. A trait is unsafe when at
least one of its methods has some invariant that the compiler can‚Äôt verify. We
declare that a trait is <code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code>
and marking the implementation of the trait as <code>unsafe</code> too, as shown in
Listing 19-11.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre></pre>
<p><span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span></p>
<p>By using <code>unsafe impl</code>, we‚Äôre promising that we‚Äôll uphold the invariants that
the compiler can‚Äôt verify.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in the
<a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">‚ÄúExtensible Concurrency with the <code>Sync</code> and <code>Send</code>
Traits‚Äù</a><!-- ignore -->
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of <code>Send</code> and <code>Sync</code> types. If we implement a
type that contains a type that is not <code>Send</code> or <code>Sync</code>, such as raw pointers,
and we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust
can‚Äôt verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with <code>unsafe</code>.</p>
<h3 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">Accessing Fields of a Union</a></h3>
<p>The final action that works only with <code>unsafe</code> is accessing fields of a
<em>union</em>. A <code>union</code> is similar to a <code>struct</code>, but only one declared field is
used in a particular instance at one time. Unions are primarily used to
interface with unions in C code. Accessing union fields is unsafe because Rust
can‚Äôt guarantee the type of the data currently being stored in the union
instance. You can learn more about unions in <a href="../reference/items/unions.html">the Rust Reference</a>.</p>
<h3 id="when-to-use-unsafe-code"><a class="header" href="#when-to-use-unsafe-code">When to Use Unsafe Code</a></h3>
<p>Using <code>unsafe</code> to take one of the five actions (superpowers) just discussed
isn‚Äôt wrong or even frowned upon. But it is trickier to get <code>unsafe</code> code
correct because the compiler can‚Äôt help uphold memory safety. When you have a
reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code>
annotation makes it easier to track down the source of problems when they occur.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-traits"><a class="header" href="#advanced-traits">Advanced Traits</a></h2>
<p>We first covered traits in the <a href="ch10-02-traits.html#traits-defining-shared-behavior">‚ÄúTraits: Defining Shared
Behavior‚Äù</a><!-- ignore --> section of Chapter
10, but we didn‚Äôt discuss the more advanced details. Now that you know more
about Rust, we can get into the nitty-gritty.</p>
<h3 id="specifying-placeholder-types-in-trait-definitions-with-associated-types"><a class="header" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used instead of the
placeholder type for the particular implementation. That way, we can define a
trait that uses some types without needing to know exactly what those types are
until the trait is implemented.</p>
<p>We‚Äôve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they‚Äôre used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait that the
standard library provides. The associated type is named <code>Item</code> and stands in
for the type of the values the type implementing the <code>Iterator</code> trait is
iterating over. The definition of the <code>Iterator</code> trait is as shown in Listing
19-12.</p>
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<p><span class="caption">Listing 19-12: The definition of the <code>Iterator</code> trait
that has an associated type <code>Item</code></span></p>
<p>The type <code>Item</code> is a placeholder, and the <code>next</code> method‚Äôs definition shows that
it will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the
<code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code>
method will return an <code>Option</code> containing a value of that concrete type.</p>
<p>Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. To examine the difference between the two concepts, we‚Äôll look at an
implementation of the <code>Iterator</code> trait on a type named <code>Counter</code> that specifies
the <code>Item</code> type is <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This syntax seems comparable to that of generics. So why not just define the
<code>Iterator</code> trait with generics, as shown in Listing 19-13?</p>
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<p><span class="caption">Listing 19-13: A hypothetical definition of the
<code>Iterator</code> trait using generics</span></p>
<p>The difference is that when using generics, as in Listing 19-13, we must
annotate the types in each implementation; because we can also implement
<code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple
implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
<code>next</code> method on <code>Counter</code>, we would have to provide type annotations to
indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>With associated types, we don‚Äôt need to annotate types because we can‚Äôt
implement a trait on a type multiple times. In Listing 19-12 with the
definition that uses associated types, we can only choose what the type of
<code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>.
We don‚Äôt have to specify that we want an iterator of <code>u32</code> values everywhere
that we call <code>next</code> on <code>Counter</code>.</p>
<p>Associated types also become part of the trait‚Äôs contract: implementors of the
trait must provide a type to stand in for the associated type placeholder.
Associated types often have a name that describes how the type will be used,
and documenting the associated type in the API documentation is good practice.</p>
<h3 id="default-generic-type-parameters-and-operator-overloading"><a class="header" href="#default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. You specify a default type
when declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>
<p>A great example of a situation where this technique is useful is with <em>operator
overloading</em>, in which you customize the behavior of an operator (such as <code>+</code>)
in particular situations.</p>
<p>Rust doesn‚Äôt allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in <code>std::ops</code> by implementing the traits associated with the operator. For
example, in Listing 19-14 we overload the <code>+</code> operator to add two <code>Point</code>
instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>
struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
<p><span class="caption">Listing 19-14: Implementing the <code>Add</code> trait to overload
the <code>+</code> operator for <code>Point</code> instances</span></p>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code>
values of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an
associated type named <code>Output</code> that determines the type returned from the <code>add</code>
method.</p>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its
definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>This code should look generally familiar: a trait with one method and an
associated type. The new part is <code>Rhs=Self</code>: this syntax is called <em>default
type parameters</em>. The <code>Rhs</code> generic type parameter (short for ‚Äúright hand
side‚Äù) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don‚Äôt
specify a concrete type for <code>Rhs</code> when we implement the <code>Add</code> trait, the type
of <code>Rhs</code> will default to <code>Self</code>, which will be the type we‚Äôre implementing
<code>Add</code> on.</p>
<p>When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>Rhs</code> because we
wanted to add two <code>Point</code> instances. Let‚Äôs look at an example of implementing
the <code>Add</code> trait where we want to customize the <code>Rhs</code> type rather than using the
default.</p>
<p>We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different
units. This thin wrapping of an existing type in another struct is known as the
<em>newtype pattern</em>, which we describe in more detail in the <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">‚ÄúUsing the Newtype
Pattern to Implement External Traits on External Types‚Äù</a><!-- ignore
--> section. We want to add values in millimeters to values in meters and have
the implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code>
for <code>Millimeters</code> with <code>Meters</code> as the <code>Rhs</code>, as shown in Listing 19-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<p><span class="caption">Listing 19-15: Implementing the <code>Add</code> trait on
<code>Millimeters</code> to add <code>Millimeters</code> to <code>Meters</code></span></p>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the
value of the <code>Rhs</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>You‚Äôll use default type parameters in two main ways:</p>
<ul>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won‚Äôt need</li>
</ul>
<p>The standard library‚Äôs <code>Add</code> trait is an example of the second purpose:
usually, you‚Äôll add two like types, but the <code>Add</code> trait provides the ability to
customize beyond that. Using a default type parameter in the <code>Add</code> trait
definition means you don‚Äôt have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn‚Äôt needed, making
it easier to use the trait.</p>
<p>The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.</p>
<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><a class="header" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as
another trait‚Äôs method, nor does Rust prevent you from implementing both traits
on one type. It‚Äôs also possible to implement a method directly on the type with
the same name as methods from traits.</p>
<p>When calling methods with the same name, you‚Äôll need to tell Rust which one you
want to use. Consider the code in Listing 19-16 where we‚Äôve defined two traits,
<code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement
both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented
on it. Each <code>fly</code> method does something different.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 19-16: Two traits are defined to have a <code>fly</code>
method and are implemented on the <code>Human</code> type, and a <code>fly</code> method is
implemented on <code>Human</code> directly</span></p>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
<p><span class="caption">Listing 19-17: Calling <code>fly</code> on an instance of
<code>Human</code></span></p>
<p>Running this code will print <code>*waving arms furiously*</code>, showing that Rust
called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait,
we need to use more explicit syntax to specify which <code>fly</code> method we mean.
Listing 19-18 demonstrates this syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
<p><span class="caption">Listing 19-18: Specifying which trait‚Äôs <code>fly</code> method we
want to call</span></p>
<p>Specifying the trait name before the method name clarifies to Rust which
implementation of <code>fly</code> we want to call. We could also write
<code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used
in Listing 19-18, but this is a bit longer to write if we don‚Äôt need to
disambiguate.</p>
<p>Running this code prints the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that
both implement one <em>trait</em>, Rust could figure out which implementation of a
trait to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are not methods don‚Äôt have a <code>self</code>
parameter. When there are multiple types or traits that define non-method
functions with the same function name, Rust doesn't always know which type you
mean unless you use <em>fully qualified syntax</em>. For example, in Listing 19-19 we
create a trait for an animal shelter that wants to name all baby dogs <em>Spot</em>.
We make an <code>Animal</code> trait with an associated non-method function <code>baby_name</code>.
The <code>Animal</code> trait is implemented for the struct <code>Dog</code>, on which we also
provide an associated non-method function <code>baby_name</code> directly.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}</code></pre></pre>
<p><span class="caption">Listing 19-19: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span></p>
<p>We implement the code for naming all puppies Spot in the <code>baby_name</code> associated
function that is defined on <code>Dog</code>. The <code>Dog</code> type also implements the trait
<code>Animal</code>, which describes characteristics that all animals have. Baby dogs are
called puppies, and that is expressed in the implementation of the <code>Animal</code>
trait on <code>Dog</code> in the <code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated
function defined on <code>Dog</code> directly. This code prints the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>This output isn‚Äôt what we wanted. We want to call the <code>baby_name</code> function that
is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints
<code>A baby dog is called a puppy</code>. The technique of specifying the trait name that
we used in Listing 19-18 doesn‚Äôt help here; if we change <code>main</code> to the code in
Listing 19-20, we‚Äôll get a compilation error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}</code></pre>
<p><span class="caption">Listing 19-20: Attempting to call the <code>baby_name</code>
function from the <code>Animal</code> trait, but Rust doesn‚Äôt know which implementation to
use</span></p>
<p>Because <code>Animal::baby_name</code> doesn‚Äôt have a <code>self</code> parameter, and there could be
other types that implement the <code>Animal</code> trait, Rust can‚Äôt figure out which
implementation of <code>Animal::baby_name</code> we want. We‚Äôll get this compiler error:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of
<code>Animal</code> for <code>Dog</code> as opposed to the implementation of <code>Animal</code> for some other
type, we need to use fully qualified syntax. Listing 19-21 demonstrates how to
use fully qualified syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
<p><span class="caption">Listing 19-21: Using fully qualified syntax to specify
that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as
implemented on <code>Dog</code></span></p>
<p>We‚Äôre providing Rust with a type annotation within the angle brackets, which
indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as
implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an
<code>Animal</code> for this function call. This code will now print what we want:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as follows:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>For associated functions that aren‚Äôt methods, there would not be a <code>receiver</code>:
there would only be the list of other arguments. You could use fully qualified
syntax everywhere that you call functions or methods. However, you‚Äôre allowed
to omit any part of this syntax that Rust can figure out from other information
in the program. You only need to use this more verbose syntax in cases where
there are multiple implementations that use the same name and Rust needs help
to identify which implementation you want to call.</p>
<h3 id="using-supertraits-to-require-one-traits-functionality-within-another-trait"><a class="header" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait‚Äôs Functionality Within Another Trait</a></h3>
<p>Sometimes, you might write a trait definition that depends on another trait:
for a type to implement the first trait, you want to require that type to also
implement the second trait. You would do this so that your trait definition can
make use of the associated items of the second trait. The trait your trait
definition is relying on is called a <em>supertrait</em> of your trait.</p>
<p>For example, let‚Äôs say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print a given value formatted so that it's
framed in asterisks. That is, given a <code>Point</code> struct that implements the
standard library trait <code>Display</code> to result in <code>(x, y)</code>, when we call
<code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code>, it
should print the following:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of the <code>outline_print</code> method, we want to use the
<code>Display</code> trait‚Äôs functionality. Therefore, we need to specify that the
<code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and
provide the functionality that <code>OutlinePrint</code> needs. We can do that in the
trait definition by specifying <code>OutlinePrint: Display</code>. This technique is
similar to adding a trait bound to the trait. Listing 19-22 shows an
implementation of the <code>OutlinePrint</code> trait.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><span class="caption">Listing 19-22: Implementing the <code>OutlinePrint</code> trait that
requires the functionality from <code>Display</code></span></p>
<p>Because we‚Äôve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that is automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a
colon and specifying the <code>Display</code> trait after the trait name, we‚Äôd get an
error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in
the current scope.</p>
<p>Let‚Äôs see what happens when we try to implement <code>OutlinePrint</code> on a type that
doesn‚Äôt implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
<p>We get an error saying that <code>Display</code> is required but not implemented:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
<p>Then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<h3 id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"><a class="header" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a></h3>
<p>In Chapter 10 in the <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">‚ÄúImplementing a Trait on a
Type‚Äù</a><!-- ignore --> section, we mentioned the
orphan rule that states we‚Äôre only allowed to implement a trait on a type if
either the trait or the type are local to our crate. It‚Äôs possible to get
around this restriction using the <em>newtype pattern</em>, which involves creating a
new type in a tuple struct. (We covered tuple structs in the <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">‚ÄúUsing Tuple
Structs without Named Fields to Create Different Types‚Äù</a><!--
ignore --> section of Chapter 5.) The tuple struct will have one field and be a
thin wrapper around the type we want to implement a trait for. Then the wrapper
type is local to our crate, and we can implement the trait on the wrapper.
<em>Newtype</em> is a term that originates from the Haskell programming language.
There is no runtime performance penalty for using this pattern, and the wrapper
type is elided at compile time.</p>
<p>As an example, let‚Äôs say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the
orphan rule prevents us from doing directly because the <code>Display</code> trait and the
<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct
that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on
<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 19-23.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}</code></pre></pre>
<p><span class="caption">Listing 19-23: Creating a <code>Wrapper</code> type around
<code>Vec&lt;String&gt;</code> to implement <code>Display</code></span></p>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>,
because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the
tuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it
doesn‚Äôt have the methods of the value it‚Äôs holding. We would have to implement
all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods
delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a
<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,
implementing the <code>Deref</code> trait (discussed in Chapter 15 in the <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">‚ÄúTreating Smart
Pointers Like Regular References with the <code>Deref</code>
Trait‚Äù</a><!-- ignore --> section) on the <code>Wrapper</code> to return
the inner type would be a solution. If we don‚Äôt want the <code>Wrapper</code> type to have
all the methods of the inner type‚Äîfor example, to restrict the <code>Wrapper</code> type‚Äôs
behavior‚Äîwe would have to implement just the methods we do want manually.</p>
<p>This newtype pattern is also useful even when traits are not involved. Let‚Äôs
switch focus and look at some advanced ways to interact with Rust‚Äôs type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h2>
<p>The Rust type system has some features that we‚Äôve so far mentioned but haven‚Äôt
yet discussed. We‚Äôll start by discussing newtypes in general as we examine why
newtypes are useful as types. Then we‚Äôll move on to type aliases, a feature
similar to newtypes but with slightly different semantics. We‚Äôll also discuss
the <code>!</code> type and dynamically sized types.</p>
<h3 id="using-the-newtype-pattern-for-type-safety-and-abstraction"><a class="header" href="#using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</a></h3>
<blockquote>
<p>Note: This section assumes you‚Äôve read the earlier section <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">‚ÄúUsing the
Newtype Pattern to Implement External Traits on External
Types.‚Äù</a><!-- ignore --></p>
</blockquote>
<p>The newtype pattern is also useful for tasks beyond those we‚Äôve discussed so
far, including statically enforcing that values are never confused and
indicating the units of a value. You saw an example of using newtypes to
indicate units in Listing 19-15: recall that the <code>Millimeters</code> and <code>Meters</code>
structs wrapped <code>u32</code> values in a newtype. If we wrote a function with a
parameter of type <code>Millimeters</code>, we couldn‚Äôt compile a program that
accidentally tried to call that function with a value of type <code>Meters</code> or a
plain <code>u32</code>.</p>
<p>We can also use the newtype pattern to abstract away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type.</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a
<code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person‚Äôs ID
associated with their name. Code using <code>People</code> would only interact with the
public API we provide, such as a method to add a name string to the <code>People</code>
collection; that code wouldn‚Äôt need to know that we assign an <code>i32</code> ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the <a href="ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">‚ÄúEncapsulation that
Hides Implementation
Details‚Äù</a><!-- ignore -->
section of Chapter 17.</p>
<h3 id="creating-type-synonyms-with-type-aliases"><a class="header" href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></h3>
<p>Rust provides the ability to declare a <em>type alias</em> to give an existing type
another name. For this we use the <code>type</code> keyword. For example, we can create
the alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code>
and <code>Meters</code> types we created in Listing 19-15, <code>Kilometers</code> is not a separate,
new type. Values that have the type <code>Kilometers</code> will be treated the same as
values of type <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}</span></code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both
types and we can pass <code>Kilometers</code> values to functions that take <code>i32</code>
parameters. However, using this method, we don‚Äôt get the type checking benefits
that we get from the newtype pattern discussed earlier. In other words, if we
mix up <code>Kilometers</code> and <code>i32</code> values somewhere, the compiler will not give us
an error.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-24: Using a long type in many places</span></p>
<p>A type alias makes this code more manageable by reducing the repetition. In
Listing 19-25, we‚Äôve introduced an alias named <code>Thunk</code> for the verbose type and
can replace all uses of the type with the shorter alias <code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-25: Introducing a type alias <code>Thunk</code> to reduce
repetition</span></p>
<p>This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (<em>thunk</em> is a word for code
to be evaluated at a later time, so it‚Äôs an appropriate name for a closure that
gets stored).</p>
<p>Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing
repetition. Consider the <code>std::io</code> module in the standard library. I/O
operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations
fail to work. This library has a <code>std::io::Error</code> struct that represents all
possible I/O errors. Many of the functions in <code>std::io</code> will be returning
<code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code>, such as these functions in
the <code>Write</code> trait:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>The <code>Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code>std::io</code> has this type
alias declaration:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Because this declaration is in the <code>std::io</code> module, we can use the fully
qualified alias <code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code>
filled in as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up
looking like this:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives
us a consistent interface across all of <code>std::io</code>. Because it‚Äôs an alias, it‚Äôs
just another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></h3>
<p>Rust has a special type named <code>!</code> that‚Äôs known in type theory lingo as the
<em>empty type</em> because it has no values. We prefer to call it the <em>never type</em>
because it stands in the place of the return type when a function will never
return. Here is an example:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>This code is read as ‚Äúthe function <code>bar</code> returns never.‚Äù Functions that return
never are called <em>diverging functions</em>. We can‚Äôt create values of the type <code>!</code>
so <code>bar</code> can never possibly return.</p>
<p>But what use is a type you can never create values for? Recall the code from
Listing 2-5, part of the number guessing game; we‚Äôve reproduced a bit of it
here in Listing 19-26.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Raqamni topish o'yini!&quot;);
</span><span class="boring">
</span><span class="boring">    let yashirin_raqam = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Yashirin raqam: {yashirin_raqam}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Iltimos, taxminingizni kiriting.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut taxmin = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut taxmin)
</span><span class="boring">            .expect(&quot;Satrni o‚Äòqib bo‚Äòlmadi&quot;);
</span><span class="boring">
</span>        let taxmin: u32 = match taxmin.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;Sizning taxminingiz: {taxmin}&quot;);
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match taxmin.cmp(&amp;yashirin_raqam) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Raqam Kichik!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Raqam katta!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;Siz yutdingiz!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 19-26: A <code>match</code> with an arm that ends in
<code>continue</code></span></p>
<p>At the time, we skipped over some details in this code. In Chapter 6 in <a href="ch06-02-match.html#the-match-control-flow-operator">‚ÄúThe
<code>match</code> Control Flow Operator‚Äù</a><!-- ignore -->
section, we discussed that <code>match</code> arms must all return the same type. So, for
example, the following code doesn‚Äôt work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}</span></code></pre>
<p>The type of <code>guess</code> in this code would have to be an integer <em>and</em> a string,
and Rust requires that <code>guess</code> have only one type. So what does <code>continue</code>
return? How were we allowed to return a <code>u32</code> from one arm and have another arm
that ends with <code>continue</code> in Listing 19-26?</p>
<p>As you might have guessed, <code>continue</code> has a <code>!</code> value. That is, when Rust
computes the type of <code>guess</code>, it looks at both match arms, the former with a
value of <code>u32</code> and the latter with a <code>!</code> value. Because <code>!</code> can never have a
value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can
be coerced into any other type. We‚Äôre allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn‚Äôt return a value; instead, it moves control
back to the top of the loop, so in the <code>Err</code> case, we never assign a value to
<code>guess</code>.</p>
<p>The never type is useful with the <code>panic!</code> macro as well. Recall the <code>unwrap</code>
function that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic with
this definition:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}</code></pre>
<p>In this code, the same thing happens as in the <code>match</code> in Listing 19-26: Rust
sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>, so the result
of the overall <code>match</code> expression is <code>T</code>. This code works because <code>panic!</code>
doesn‚Äôt produce a value; it ends the program. In the <code>None</code> case, we won‚Äôt be
returning a value from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}</span></code></pre>
<p>Here, the loop never ends, so <code>!</code> is the value of the expression. However, this
wouldn‚Äôt be true if we included a <code>break</code>, because the loop would terminate
when it got to the <code>break</code>.</p>
<h3 id="dynamically-sized-types-and-the-sized-trait"><a class="header" href="#dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the <code>Sized</code> Trait</a></h3>
<p>Rust needs to know certain details about its types, such as how much space to
allocate for a value of a particular type. This leaves one corner of its type
system a little confusing at first: the concept of <em>dynamically sized types</em>.
Sometimes referred to as <em>DSTs</em> or <em>unsized types</em>, these types let us write
code using values whose size we can know only at runtime.</p>
<p>Let‚Äôs dig into the details of a dynamically sized type called <code>str</code>, which
we‚Äôve been using throughout the book. That‚Äôs right, not <code>&amp;str</code>, but <code>str</code> on
its own, is a DST. We can‚Äôt know how long the string is until runtime, meaning
we can‚Äôt create a variable of type <code>str</code>, nor can we take an argument of type
<code>str</code>. Consider the following code, which does not work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}</span></code></pre>
<p>Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two <code>str</code> values would need to take up the
same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of
storage and <code>s2</code> needs 15. This is why it‚Äôs not possible to create a variable
holding a dynamically sized type.</p>
<p>So what do we do? In this case, you already know the answer: we make the types
of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. Recall from the <a href="ch04-03-slices.html#string-slices">‚ÄúString
Slices‚Äù</a><!-- ignore --> section of Chapter 4 that the slice data
structure just stores the starting position and the length of the slice. So
although a <code>&amp;T</code> is a single value that stores the memory address of where the
<code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its
length. As such, we can know the size of a <code>&amp;str</code> value at compile time: it‚Äôs
twice the length of a <code>usize</code>. That is, we always know the size of a <code>&amp;str</code>, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or
<code>Rc&lt;str&gt;</code>. In fact, you‚Äôve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‚ÄúUsing Trait Objects That
Allow for Values of Different
Types‚Äù</a><!--
ignore --> section, we mentioned that to use traits as trait objects, we must
put them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> would work too).</p>
<p>To work with DSTs, Rust provides the <code>Sized</code> trait to determine whether or not
a type‚Äôs size is known at compile time. This trait is automatically implemented
for everything whose size is known at compile time. In addition, Rust
implicitly adds a bound on <code>Sized</code> to every generic function. That is, a
generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>is actually treated as though we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>A trait bound on <code>?Sized</code> means ‚Äú<code>T</code> may or may not be <code>Sized</code>‚Äù and this
notation overrides the default that generic types must have a known size at
compile time. The <code>?Trait</code> syntax with this meaning is only available for
<code>Sized</code>, not any other traits.</p>
<p>Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>.
Because the type might not be <code>Sized</code>, we need to use it behind some kind of
pointer. In this case, we‚Äôve chosen a reference.</p>
<p>Next, we‚Äôll talk about functions and closures!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-functions-and-closures"><a class="header" href="#advanced-functions-and-closures">Advanced Functions and Closures</a></h2>
<p>This section explores some advanced features related to functions and closures,
including function pointers and returning closures.</p>
<h3 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h3>
<p>We‚Äôve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you‚Äôve already defined rather than defining a new closure. Functions
coerce to the type <code>fn</code> (with a lowercase f), not to be confused with the <code>Fn</code>
closure trait. The <code>fn</code> type is called a <em>function pointer</em>. Passing functions
with function pointers will allow you to use functions as arguments to other
functions.</p>
<p>The syntax for specifying that a parameter is a function pointer is similar to
that of closures, as shown in Listing 19-27, where we‚Äôve defined a function
<code>add_one</code> that adds one to its parameter. The function <code>do_twice</code> takes two
parameters: a function pointer to any function that takes an <code>i32</code> parameter
and returns an <code>i32</code>, and one <code>i32 value</code>. The <code>do_twice</code> function calls the
function <code>f</code> twice, passing it the <code>arg</code> value, then adds the two function call
results together. The <code>main</code> function calls <code>do_twice</code> with the arguments
<code>add_one</code> and <code>5</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}</code></pre></pre>
<p><span class="caption">Listing 19-27: Using the <code>fn</code> type to accept a function
pointer as an argument</span></p>
<p>This code prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly rather than declaring a generic type parameter with one
of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), meaning you can always pass a function pointer as an argument for a
function that expects a closure. It‚Äôs best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.</p>
<p>That said, one example of where you would want to only accept <code>fn</code> and not
closures is when interfacing with external code that doesn‚Äôt have closures: C
functions can accept functions as arguments, but C doesn‚Äôt have closures.</p>
<p>As an example of where you could use either a closure defined inline or a named
function, let‚Äôs look at a use of the <code>map</code> method provided by the <code>Iterator</code>
trait in the standard library. To use the <code>map</code> function to turn a vector of
numbers into a vector of strings, we could use a closure, like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure,
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p>Note that we must use the fully qualified syntax that we talked about earlier
in the <a href="ch19-03-advanced-traits.html#advanced-traits">‚ÄúAdvanced Traits‚Äù</a><!-- ignore --> section because
there are multiple functions available named <code>to_string</code>. Here, we‚Äôre using the
<code>to_string</code> function defined in the <code>ToString</code> trait, which the standard
library has implemented for any type that implements <code>Display</code>.</p>
<p>Recall from the <a href="ch06-01-defining-an-enum.html#enum-values">‚ÄúEnum values‚Äù</a><!-- ignore --> section of Chapter
6 that the name of each enum variant that we define also becomes an initializer
function. We can use these initializer functions as function pointers that
implement the closure traits, which means we can specify the initializer
functions as arguments for methods that take closures, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>Here we create <code>Status::Value</code> instances using each <code>u32</code> value in the range
that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>.
Some people prefer this style, and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.</p>
<h3 id="returning-closures"><a class="header" href="#returning-closures">Returning Closures</a></h3>
<p>Closures are represented by traits, which means you can‚Äôt return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. However, you can‚Äôt do that with closures because they don‚Äôt have a
concrete type that is returnable; you‚Äôre not allowed to use the function
pointer <code>fn</code> as a return type, for example.</p>
<p>The following code tries to return a closure directly, but it won‚Äôt compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre>
<p>The compiler error is as follows:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;
help: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:8]`, which implements `Fn(i32) -&gt; i32`
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` due to previous error
</code></pre>
<p>The error references the <code>Sized</code> trait again! Rust doesn‚Äôt know how much space
it will need to store the closure. We saw a solution to this problem earlier.
We can use a trait object:</p>
<pre><code class="language-rust noplayground">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}</code></pre>
<p>This code will compile just fine. For more about trait objects, refer to the
section <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‚ÄúUsing Trait Objects That Allow for Values of Different
Types‚Äù</a><!--
ignore --> in Chapter 17.</p>
<p>Next, let‚Äôs look at macros!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>We‚Äôve used macros like <code>println!</code> throughout this book, but we haven‚Äôt fully
explored what a macro is and how it works. The term <em>macro</em> refers to a family
of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds
of <em>procedural</em> macros:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute
used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens
specified as their argument</li>
</ul>
<p>We‚Äôll talk about each of these in turn, but first, let‚Äôs look at why we even
need macros when we already have functions.</p>
<h3 id="the-difference-between-macros-and-functions"><a class="header" href="#the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code>
attribute, which generates an implementation of various traits for you. We‚Äôve
also used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these
macros <em>expand</em> to produce more code than the code you‚Äôve written manually.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don‚Äôt.</p>
<p>A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call <code>println!(&quot;hello&quot;)</code> with one argument or
<code>println!(&quot;hello {}&quot;, name)</code> with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can‚Äôt, because it gets
called at runtime and a trait needs to be implemented at compile time.</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you‚Äôre writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.</p>
<p>Another important difference between macros and functions is that you must
define macros or bring them into scope <em>before</em> you call them in a file, as
opposed to functions you can define anywhere and call anywhere.</p>
<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming"><a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</a></h3>
<p>The most widely used form of macros in Rust is the <em>declarative macro</em>. These
are also sometimes referred to as ‚Äúmacros by example,‚Äù ‚Äú<code>macro_rules!</code> macros,‚Äù
or just plain ‚Äúmacros.‚Äù At their core, declarative macros allow you to write
something similar to a Rust <code>match</code> expression. As discussed in Chapter 6,
<code>match</code> expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let‚Äôs explore how to
use <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8
covered how we can use the <code>vec!</code> macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector
of five string slices. We wouldn‚Äôt be able to use a function to do the same
because we wouldn‚Äôt know the number or type of values up front.</p>
<p>Listing 19-28 shows a slightly simplified definition of the <code>vec!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<p><span class="caption">Listing 19-28: A simplified version of the <code>vec!</code> macro
definition</span></p>
<blockquote>
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library
includes code to preallocate the correct amount of memory up front. That code
is an optimization that we don‚Äôt include here to make the example simpler.</p>
</blockquote>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can‚Äôt be brought into scope.</p>
<p>We then start the macro definition with <code>macro_rules!</code> and the name of the
macro we‚Äôre defining <em>without</em> the exclamation mark. The name, in this case
<code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>
<p>The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code>
expression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>,
followed by <code>=&gt;</code> and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.</p>
<p>Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Let‚Äôs walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see the <a href="../reference/macros-by-example.html">Rust
Reference</a>.</p>
<p>First, we use a set of parentheses to encompass the whole pattern. We use a
dollar sign (<code>$</code>) to declare a variable in the macro system that will contain
the Rust code matching the pattern. The dollar sign makes it clear this is a
macro variable as opposed to a regular Rust variable. Next comes a set of
parentheses that captures values that match the pattern within the parentheses
for use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any
Rust expression and gives the expression the name <code>$x</code>.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character
could optionally appear after the code that matches the code in <code>$()</code>. The <code>*</code>
specifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three
times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>Now let‚Äôs look at the pattern in the body of the code associated with this arm:
<code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code>
in the pattern zero or more times depending on how many times the pattern
matches. The <code>$x</code> is replaced with each expression matched. When we call this
macro with <code>vec![1, 2, 3];</code>, the code generated that replaces this macro call
will be the following:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>We‚Äôve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.</p>
<p>To learn more about how to write macros, consult the online documentation or
other resources, such as <a href="https://veykril.github.io/tlborm/">‚ÄúThe Little Book of Rust Macros‚Äù</a> started by
Daniel Keep and continued by Lukas Wirth.</p>
<h3 id="procedural-macros-for-generating-code-from-attributes"><a class="header" href="#procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</a></h3>
<p>The second form of macros is the <em>procedural macro</em>, which acts more like a
function (and is a type of procedure). Procedural macros accept some code as an
input, operate on that code, and produce some code as an output rather than
matching against patterns and replacing the code with other code as declarative
macros do. The three kinds of procedural macros are custom derive,
attribute-like, and function-like, and all work in a similar fashion.</p>
<p>When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. In Listing 19-29, we show how to define a
procedural macro, where <code>some_attribute</code> is a placeholder for using a specific
macro variety.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<p><span class="caption">Listing 19-29: An example of defining a procedural
macro</span></p>
<p>The function that defines a procedural macro takes a <code>TokenStream</code> as an input
and produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by
the <code>proc_macro</code> crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input <code>TokenStream</code>, and the code the macro produces
is the output <code>TokenStream</code>. The function also has an attribute attached to it
that specifies which kind of procedural macro we‚Äôre creating. We can have
multiple kinds of procedural macros in the same crate.</p>
<p>Let‚Äôs look at the different kinds of procedural macros. We‚Äôll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.</p>
<h3 id="how-to-write-a-custom-derive-macro"><a class="header" href="#how-to-write-a-custom-derive-macro">How to Write a Custom <code>derive</code> Macro</a></h3>
<p>Let‚Äôs create a crate named <code>hello_macro</code> that defines a trait named
<code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than
making our users implement the <code>HelloMacro</code> trait for each of their types,
we‚Äôll provide a procedural macro so users can annotate their type with
<code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code>
function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has
been defined. In other words, we‚Äôll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p><span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span></p>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we‚Äôre done. The
first step is to make a new library crate, like this:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Next, we‚Äôll define the <code>HelloMacro</code> trait and its associated function:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<p>We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>However, they would need to write the implementation block for each type they
wanted to use with <code>hello_macro</code>; we want to spare them from having to do this
work.</p>
<p>Additionally, we can‚Äôt yet provide the <code>hello_macro</code> function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn‚Äôt have reflection capabilities, so it can‚Äôt look up the type‚Äôs
name at runtime. We need a macro to generate code at compile time.</p>
<p>The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named <code>foo</code>, a custom derive procedural macro crate is
called <code>foo_derive</code>. Let‚Äôs start a new crate called <code>hello_macro_derive</code> inside
our <code>hello_macro</code> project:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Our two crates are tightly related, so we create the procedural macro crate
within the directory of our <code>hello_macro</code> crate. If we change the trait
definition in <code>hello_macro</code>, we‚Äôll have to change the implementation of the
procedural macro in <code>hello_macro_derive</code> as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
<code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the
procedural macro code. However, the way we‚Äôve structured the project makes it
possible for programmers to use <code>hello_macro</code> even if they don‚Äôt want the
<code>derive</code> functionality.</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.
We‚Äôll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you‚Äôll see
in a moment, so we need to add them as dependencies. Add the following to the
<em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>To start defining the procedural macro, place the code in Listing 19-31 into
your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code
won‚Äôt compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<p><span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span></p>
<p>Notice that we‚Äôve split the code into the <code>hello_macro_derive</code> function, which
is responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code>
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(<code>hello_macro_derive</code> in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (<code>impl_hello_macro</code> in this case) will be different
depending on your procedural macro‚Äôs purpose.</p>
<p>We‚Äôve introduced three new crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, and <a href="https://crates.io/crates/quote"><code>quote</code></a>. The
<code>proc_macro</code> crate comes with Rust, so we didn‚Äôt need to add that to the
dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler‚Äôs API that
allows us to read and manipulate Rust code from our code.</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we
can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.</p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library
specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we‚Äôve
annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and
specified the name <code>HelloMacro</code>, which matches our trait name; this is the
convention most procedural macros follow.</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a
<code>TokenStream</code> to a data structure that we can then interpret and perform
operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in
<code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the <code>DeriveInput</code>
struct we get from parsing the <code>struct Pancakes;</code> string:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<p><span class="caption">Listing 19-32: The <code>DeriveInput</code> instance we get when
parsing the code that has the macro‚Äôs attribute in Listing 19-30</span></p>
<p>The fields of this struct show that the Rust code we‚Äôve parsed is a unit struct
with the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code>. There are more
fields on this struct for describing all sorts of Rust code; check the <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>syn</code>
documentation for <code>DeriveInput</code></a> for more information.</p>
<p>Soon we‚Äôll define the <code>impl_hello_macro</code> function, which is where we‚Äôll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is
added to the code that our crate users write, so when they compile their crate,
they‚Äôll get the extra functionality that we provide in the modified
<code>TokenStream</code>.</p>
<p>You might have noticed that we‚Äôre calling <code>unwrap</code> to cause the
<code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function
fails here. It‚Äôs necessary for our procedural macro to panic on errors because
<code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to
conform to the procedural macro API. We‚Äôve simplified this example by using
<code>unwrap</code>; in production code, you should provide more specific error messages
about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>
into a <code>DeriveInput</code> instance, let‚Äôs generate the code that implements the
<code>HelloMacro</code> trait on the annotated type, as shown in Listing 19-33.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<p><span class="caption">Listing 19-33: Implementing the <code>HelloMacro</code> trait using
the parsed Rust code</span></p>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the
annotated type using <code>ast.ident</code>. The struct in Listing 19-32 shows that when
we run the <code>impl_hello_macro</code> function on the code in Listing 19-30, the
<code>ident</code> we get will have the <code>ident</code> field with a value of <code>&quot;Pancakes&quot;</code>. Thus,
the <code>name</code> variable in Listing 19-33 will contain an <code>Ident</code> struct instance
that, when printed, will be the string <code>&quot;Pancakes&quot;</code>, the name of the struct in
Listing 19-30.</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the <code>quote!</code>
macro‚Äôs execution, so we need to convert it to a <code>TokenStream</code>. We do this by
calling the <code>into</code> method, which consumes this intermediate representation and
returns a value of the required <code>TokenStream</code> type.</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics: we can
enter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable
<code>name</code>. You can even do some repetition similar to the way regular macros work.
Check out <a href="https://docs.rs/quote">the <code>quote</code> crate‚Äôs docs</a> for a thorough introduction.</p>
<p>We want our procedural macro to generate an implementation of our <code>HelloMacro</code>
trait for the type the user annotated, which we can get by using <code>#name</code>. The
trait implementation has the one function <code>hello_macro</code>, whose body contains the
functionality we want to provide: printing <code>Hello, Macro! My name is</code> and then
the name of the annotated type.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust
expression, such as <code>1 + 2</code>, and at compile time turns the expression into a
string literal, such as <code>&quot;1 + 2&quot;</code>. This is different than <code>format!</code> or
<code>println!</code>, macros which evaluate the expression and then turn the result into
a <code>String</code>. There is a possibility that the <code>#name</code> input might be an
expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also
saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code>
and <code>hello_macro_derive</code>. Let‚Äôs hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add
<code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code>
crate‚Äôs <em>Cargo.toml</em>. If you‚Äôre publishing your versions of <code>hello_macro</code> and
<code>hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they would be regular
dependencies; if not, you can specify them as <code>path</code> dependencies as follows:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Put the code in Listing 19-30 into <em>src/main.rs</em>, and run <code>cargo run</code>: it
should print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the
<code>HelloMacro</code> trait from the procedural macro was included without the
<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the
trait implementation.</p>
<p>Next, let‚Äôs explore how the other kinds of procedural macros differ from custom
derive macros.</p>
<h3 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">Attribute-like macros</a></h3>
<p>Attribute-like macros are similar to custom derive macros, but instead of
generating code for the <code>derive</code> attribute, they allow you to create new
attributes. They‚Äôre also more flexible: <code>derive</code> only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here‚Äôs an example of using an attribute-like macro: say you have an attribute
named <code>route</code> that annotates functions when using a web application framework:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {</code></pre>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the
contents of the attribute: the <code>GET, &quot;/&quot;</code> part. The second is the body of the
item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest
of the function‚Äôs body.</p>
<p>Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the <code>proc-macro</code> crate type and implement a
function that generates the code you want!</p>
<h3 id="function-like-macros"><a class="header" href="#function-like-macros">Function-like macros</a></h3>
<p>Function-like macros define macros that look like function calls. Similarly to
<code>macro_rules!</code> macros, they‚Äôre more flexible than functions; for example, they
can take an unknown number of arguments. However, <code>macro_rules!</code> macros can be
defined only using the match-like syntax we discussed in the section
<a href="ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">‚ÄúDeclarative Macros with <code>macro_rules!</code> for General
Metaprogramming‚Äù</a><!-- ignore --> earlier. Function-like macros take a
<code>TokenStream</code> parameter and their definition manipulates that <code>TokenStream</code>
using Rust code as the other two types of procedural macros do. An example of a
function-like macro is an <code>sql!</code> macro that might be called like so:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>This macro would parse the SQL statement inside it and check that it‚Äôs
syntactically correct, which is much more complex processing than a
<code>macro_rules!</code> macro can do. The <code>sql!</code> macro would be defined like this:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>This definition is similar to the custom derive macro‚Äôs signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Whew! Now you have some Rust features in your toolbox that you likely won‚Äôt use
often, but you‚Äôll know they‚Äôre available in very particular circumstances.
We‚Äôve introduced several complex topics so that when you encounter them in
error message suggestions or in other peoples‚Äô code, you‚Äôll be able to
recognize these concepts and syntax. Use this chapter as a reference to guide
you to solutions.</p>
<p>Next, we‚Äôll put everything we‚Äôve discussed throughout the book into practice
and do one more project!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="songi-loyiha-kop-oqimli-multithreaded-veb-server-qurish"><a class="header" href="#songi-loyiha-kop-oqimli-multithreaded-veb-server-qurish">So'ngi Loyiha: Ko'p oqimli (Multithreaded) Veb Server qurish</a></h1>
<p>Bu uzoq safar bo‚Äòldi, lekin nihoyat kitobning oxiriga yetdik. Ushbu bobda biz yakuniy boblarda o‚Äòrganilgan ba‚Äôzi tushunchalarni amalda qo‚Äòllash uchun yana bir loyihani birga quramiz, shuningdek, avvalgi darslarni ham eslab o‚Äòtamiz.</p>
<p>Yakuniy loyihamizda biz ‚Äúsalom‚Äù deb javob beradigan va veb-brauzerda 20-1-rasmga o‚Äòxshash ko‚Äòrinadigan veb-server yaratamiz.</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">20-rasm: Bizning yakuniy umumiy loyihamiz</span></p>
<p>Veb-serverni yaratish bo‚Äòyicha rejamiz quyidagicha:</p>
<ol>
<li>TCP va HTTP haqida biroz ma‚Äôlumot olish.</li>
<li>Soket orqali TCP ulanishlarini tinglash.</li>
<li>Bir nechta HTTP so‚Äòrovlarini tahlil qilish.</li>
<li>To‚Äòg‚Äòri HTTP javobini (response) yaratish.</li>
<li>Serverimiz unumdorligini oqimlar to‚Äòplami (thread pool) yordamida oshirish.</li>
</ol>
<p>Boshlashdan oldin bir narsani aytib o‚Äòtishimiz kerak: biz foydalanadigan usul Rust tilida veb-server qurishning eng yaxshi usuli bo‚Äòlmaydi. Rust hamjamiyati 
<a href="https://crates.io/">crates.io</a> saytida chop etilgan, to‚Äòliq funksiyali veb-server va oqimlar to‚Äòplami (thread pool) kutubxonalarini yaratgan. Bu kutubxonalar biz quradigan versiyadan ko‚Äòra ancha mukammal. Biroq, ushbu bobdagi maqsadimiz ‚Äì sizni o‚Äòrgatish, eng oson yo‚Äòlni tanlash emas. Rust tizim dasturlash tili bo‚Äòlganligi sababli, biz o‚Äòzimiz ishlamoqchi bo‚Äòlgan abstraktsiya darajasini tanlashimiz mumkin va boshqa tillarda amalga oshirish qiyin yoki imkonsiz bo‚Äòlgan chuqur darajadagi ishlarni bajarish imkoniyatiga egamiz. Shuning uchun biz HTTP server va oqimlar to‚Äòplamini qo‚Äòlda yozamiz, shunda siz kelajakda foydalanishingiz mumkin bo‚Äòlgan kutubxonalar ortida qanday g‚Äòoya va texnikalar yotganini tushunib olasiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-a-single-threaded-web-server"><a class="header" href="#building-a-single-threaded-web-server">Building a Single-Threaded Web Server</a></h2>
<p>We‚Äôll start by getting a single-threaded web server working. Before we begin,
let‚Äôs look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.</p>
<p>The two main protocols involved in web servers are <em>Hypertext Transfer
Protocol</em> <em>(HTTP)</em> and <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both protocols
are <em>request-response</em> protocols, meaning a <em>client</em> initiates requests and a
<em>server</em> listens to the requests and provides a response to the client. The
contents of those requests and responses are defined by the protocols.</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn‚Äôt specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It‚Äôs technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We‚Äôll work with the
raw bytes of TCP and HTTP requests and responses.</p>
<h3 id="listening-to-the-tcp-connection"><a class="header" href="#listening-to-the-tcp-connection">Listening to the TCP Connection</a></h3>
<p>Our web server needs to listen to a TCP connection, so that‚Äôs the first part
we‚Äôll work on. The standard library offers a <code>std::net</code> module that lets us do
this. Let‚Äôs make a new project in the usual fashion:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 20-1 in <em>src/main.rs</em> to start. This code will
listen at the local address <code>127.0.0.1:7878</code> for incoming TCP streams. When it
gets an incoming stream, it will print <code>Connection established!</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}</code></pre></pre>
<p><span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span></p>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address
<code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn‚Äôt
represent the authors‚Äô computer specifically), and <code>7878</code> is the port. We‚Äôve
chosen this port for two reasons: HTTP isn‚Äôt normally accepted on this port so
our server is unlikely to conflict with any other web server you might have
running on your machine, and 7878 is <em>rust</em> typed on a telephone.</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it
will return a new <code>TcpListener</code> instance. The function is called <code>bind</code>
because, in networking, connecting to a port to listen to is known as ‚Äúbinding
to a port.‚Äù</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that it‚Äôs
possible for binding to fail. For example, connecting to port 80 requires
administrator privileges (nonadministrators can listen only on ports higher
than 1023), so if we tried to connect to port 80 without being an
administrator, binding wouldn‚Äôt work. Binding also wouldn‚Äôt work, for example,
if we ran two instances of our program and so had two programs listening to the
same port. Because we‚Äôre writing a basic server just for learning purposes, we
won‚Äôt worry about handling these kinds of errors; instead, we use <code>unwrap</code> to
stop the program if errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, we will read from the <code>TcpStream</code> to see what
the client sent and then write our response to the stream to send data back to
the client. Overall, this <code>for</code> loop will process each connection in turn and
produce a series of streams for us to handle.</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors; if there aren‚Äôt any errors, the
program prints a message. We‚Äôll add more functionality for the success case in
the next listing. The reason we might receive errors from the <code>incoming</code> method
when a client connects to the server is that we‚Äôre not actually iterating over
connections. Instead, we‚Äôre iterating over <em>connection attempts</em>. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.</p>
<p>Let‚Äôs try running this code! Invoke <code>cargo run</code> in the terminal and then load
<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message
like ‚ÄúConnection reset,‚Äù because the server isn‚Äôt currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes, you‚Äôll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the <em>favicon.ico</em> icon that appears in the
browser tab.</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn‚Äôt responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we‚Äôve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you‚Äôre done running a particular version of the code. Then restart the
program by invoking the <code>cargo run</code> command after you‚Äôve made each set of code
changes to make sure you‚Äôre running the newest code.</p>
<h3 id="reading-the-request"><a class="header" href="#reading-the-request">Reading the Request</a></h3>
<p>Let‚Äôs implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we‚Äôll start a new function for processing connections. In
this new <code>handle_connection</code> function, we‚Äôll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!(&quot;Request: {:#?}&quot;, http_request);
}</code></pre></pre>
<p><span class="caption">Listing 20-2: Reading from the <code>TcpStream</code> and printing
the data</span></p>
<p>We bring <code>std::io::prelude</code> and <code>std::io::BufReader</code> into scope to get access
to traits and types that let us read from and write to the stream. In the <code>for</code>
loop in the <code>main</code> function, instead of printing a message that says we made a
connection, we now call the new <code>handle_connection</code> function and pass the
<code>stream</code> to it.</p>
<p>In the <code>handle_connection</code> function, we create a new <code>BufReader</code> instance that
wraps a mutable reference to the <code>stream</code>. <code>BufReader</code> adds buffering by
managing calls to the <code>std::io::Read</code> trait methods for us.</p>
<p>We create a variable named <code>http_request</code> to collect the lines of the request
the browser sends to our server. We indicate that we want to collect these
lines in a vector by adding the <code>Vec&lt;_&gt;</code> type annotation.</p>
<p><code>BufReader</code> implements the <code>std::io::BufRead</code> trait, which provides the <code>lines</code>
method. The <code>lines</code> method returns an iterator of <code>Result&lt;String, std::io::Error&gt;</code> by splitting the stream of data whenever it sees a newline
byte. To get each <code>String</code>, we map and <code>unwrap</code> each <code>Result</code>. The <code>Result</code>
might be an error if the data isn‚Äôt valid UTF-8 or if there was a problem
reading from the stream. Again, a production program should handle these errors
more gracefully, but we‚Äôre choosing to stop the program in the error case for
simplicity.</p>
<p>The browser signals the end of an HTTP request by sending two newline
characters in a row, so to get one request from the stream, we take lines until
we get a line that is the empty string. Once we‚Äôve collected the lines into the
vector, we‚Äôre printing them out using pretty debug formatting so we can take a
look at the instructions the web browser is sending to our server.</p>
<p>Let‚Äôs try this code! Start the program and make a request in a web browser
again. Note that we‚Äôll still get an error page in the browser, but our
program‚Äôs output in the terminal will now look similar to this:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    &quot;GET / HTTP/1.1&quot;,
    &quot;Host: 127.0.0.1:7878&quot;,
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0&quot;,
    &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Language: en-US,en;q=0.5&quot;,
    &quot;Accept-Encoding: gzip, deflate, br&quot;,
    &quot;DNT: 1&quot;,
    &quot;Connection: keep-alive&quot;,
    &quot;Upgrade-Insecure-Requests: 1&quot;,
    &quot;Sec-Fetch-Dest: document&quot;,
    &quot;Sec-Fetch-Mode: navigate&quot;,
    &quot;Sec-Fetch-Site: none&quot;,
    &quot;Sec-Fetch-User: ?1&quot;,
    &quot;Cache-Control: max-age=0&quot;,
]
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that
we‚Äôre printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after <code>GET</code> in the first line
of the request. If the repeated connections are all requesting <em>/</em>, we know the
browser is trying to fetch <em>/</em> repeatedly because it‚Äôs not getting a response
from our program.</p>
<p>Let‚Äôs break down this request data to understand what the browser is asking of
our program.</p>
<h3 id="a-closer-look-at-an-http-request"><a class="header" href="#a-closer-look-at-an-http-request">A Closer Look at an HTTP Request</a></h3>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the
client is requesting. The first part of the request line indicates the <em>method</em>
being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making
this request. Our client used a <code>GET</code> request, which means it is asking for
information.</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>Uniform Resource
Identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,
the same as a <em>Uniform Resource Locator</em> <em>(URL)</em>. The difference between URIs
and URLs isn‚Äôt important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.</p>
<p>The last part is the HTTP version the client uses, and then the request line
ends in a <em>CRLF sequence</em>. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,
which are terms from the typewriter days!) The CRLF sequence can also be
written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>Looking at the request line data we received from running our program so far,
we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the
version.</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are
headers. <code>GET</code> requests have no body.</p>
<p>Try making a request from a different browser or asking for a different
address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>Now that we know what the browser is asking for, let‚Äôs send back some data!</p>
<h3 id="writing-a-response"><a class="header" href="#writing-a-response">Writing a Response</a></h3>
<p>We‚Äôre going to implement sending data in response to a client request.
Responses have the following format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.</p>
<p>Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let‚Äôs write this to the stream as our response to a
successful request! From the <code>handle_connection</code> function, remove the
<code>println!</code> that was printing the request data and replace it with the code in
Listing 20-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span></p>
<p>The first new line defines the <code>response</code> variable that holds the success
message‚Äôs data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string
data to bytes. The <code>write_all</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends
those bytes directly down the connection. Because the <code>write_all</code> operation
could fail, we use <code>unwrap</code> on any error result as before. Again, in a real
application you would add error handling here.</p>
<p>With these changes, let‚Äôs run our code and make a request. We‚Äôre no longer
printing any data to the terminal, so we won‚Äôt see any output other than the
output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should
get a blank page instead of an error. You‚Äôve just hand-coded receiving an HTTP
request and sending a response!</p>
<h3 id="returning-real-html"><a class="header" href="#returning-real-html">Returning Real HTML</a></h3>
<p>Let‚Äôs implement the functionality for returning more than a blank page. Create
the new file <em>hello.html</em> in the root of your project directory, not in the
<em>src</em> directory. You can input any HTML you want; Listing 20-4 shows one
possibility.</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: A sample HTML file to return in a
response</span></p>
<p>This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we‚Äôll modify <code>handle_connection</code> as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = &quot;HTTP/1.1 200 OK&quot;;
    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-5: Sending the contents of <em>hello.html</em> as the
body of the response</span></p>
<p>We‚Äôve added <code>fs</code> to the <code>use</code> statement to bring the standard library‚Äôs
filesystem module into scope. The code for reading the contents of a file to a
string should look familiar; we used it in Chapter 12 when we read the contents
of a file for our I/O project in Listing 12-4.</p>
<p>Next, we use <code>format!</code> to add the file‚Äôs contents as the body of the success
response. To ensure a valid HTTP response, we add the <code>Content-Length</code> header
which is set to the size of our response body, in this case the size of
<code>hello.html</code>.</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you
should see your HTML rendered!</p>
<p>Currently, we‚Äôre ignoring the request data in <code>http_request</code> and just sending
back the contents of the HTML file unconditionally. That means if you try
requesting <em>127.0.0.1:7878/something-else</em> in your browser, you‚Äôll still get
back this same HTML response. At the moment, our server is very limited and
does not do what most web servers do. We want to customize our responses
depending on the request and only send back the HTML file for a well-formed
request to <em>/</em>.</p>
<h3 id="validating-the-request-and-selectively-responding"><a class="header" href="#validating-the-request-and-selectively-responding">Validating the Request and Selectively Responding</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let‚Äôs add functionality to check that the browser is
requesting <em>/</em> before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for <em>/</em> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == &quot;GET / HTTP/1.1&quot; {
        let status_line = &quot;HTTP/1.1 200 OK&quot;;
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
<p><span class="caption">Listing 20-6: Handling requests to <em>/</em> differently from
other requests</span></p>
<p>We‚Äôre only going to be looking at the first line of the HTTP request, so rather
than reading the entire request into a vector, we‚Äôre calling <code>next</code> to get the
first item from the iterator. The first <code>unwrap</code> takes care of the <code>Option</code> and
stops the program if the iterator has no items. The second <code>unwrap</code> handles the
<code>Result</code> and has the same effect as the <code>unwrap</code> that was in the <code>map</code> added in
Listing 20-2.</p>
<p>Next, we check the <code>request_line</code> to see if it equals the request line of a GET
request to the <em>/</em> path. If it does, the <code>if</code> block returns the contents of our
HTML file.</p>
<p>If the <code>request_line</code> does <em>not</em> equal the GET request to the <em>/</em> path, it
means we‚Äôve received some other request. We‚Äôll add code to the <code>else</code> block in
a moment to respond to all other requests.</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<em>127.0.0.1:7878/something-else</em>, you‚Äôll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.</p>
<p>Now let‚Äôs add the code in Listing 20-7 to the <code>else</code> block to return a response
with the status code 404, which signals that the content for the request was
not found. We‚Äôll also return some HTML for a page to render in the browser
indicating the response to the end user.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == &quot;GET / HTTP/1.1&quot; {
</span><span class="boring">        let status_line = &quot;HTTP/1.1 200 OK&quot;;
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than <em>/</em> was requested</span></p>
<p>Here, our response has a status line with status code 404 and the reason phrase
<code>NOT FOUND</code>. The body of the response will be the HTML in the file <em>404.html</em>.
You‚Äôll need to create a <em>404.html</em> file next to <em>hello.html</em> for the error
page; again feel free to use any HTML you want or use the example HTML in
Listing 20-8.</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span></p>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em> should
return the contents of <em>hello.html</em>, and any other request, like
<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<h3 id="a-touch-of-refactoring"><a class="header" href="#a-touch-of-refactoring">A Touch of Refactoring</a></h3>
<p>At the moment the <code>if</code> and <code>else</code> blocks have a lot of repetition: they‚Äôre both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let‚Äôs make the code more
concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large <code>if</code> and <code>else</code> blocks.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == &quot;GET / HTTP/1.1&quot; {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 20-9: Refactoring the <code>if</code> and <code>else</code> blocks to
contain only the code that differs between the two cases</span></p>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement, as discussed in Chapter 18.</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let‚Äôs examine how that can be a problem by simulating some
slow requests. Then we‚Äôll fix it so our server can handle multiple requests at
once.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="turning-our-single-threaded-server-into-a-multithreaded-server"><a class="header" href="#turning-our-single-threaded-server-into-a-multithreaded-server">Turning Our Single-Threaded Server into a Multithreaded Server</a></h2>
<p>Right now, the server will process each request in turn, meaning it won‚Äôt
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We‚Äôll need to fix
this, but first, we‚Äôll look at the problem in action.</p>
<h3 id="simulating-a-slow-request-in-the-current-server-implementation"><a class="header" href="#simulating-a-slow-request-in-the-current-server-implementation">Simulating a Slow Request in the Current Server Implementation</a></h3>
<p>We‚Äôll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to <em>/sleep</em> with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
<p><span class="caption">Listing 20-10: Simulating a slow request by sleeping for
5 seconds</span></p>
<p>We switched from <code>if</code> to <code>match</code> now that we have three cases. We need to
explicitly match on a slice of <code>request_line</code> to pattern match against the
string literal values; <code>match</code> doesn‚Äôt do automatic referencing and
dereferencing like the equality method does.</p>
<p>The first arm is the same as the <code>if</code> block from Listing 20-9. The second arm
matches a request to <em>/sleep</em>. When that request is received, the server will
sleep for 5 seconds before rendering the successful HTML page. The third arm is
the same as the <code>else</code> block from Listing 20-9.</p>
<p>You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then open two browser windows: one for
<em>http://127.0.0.1:7878/</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If
you enter the <em>/</em> URI a few times, as before, you‚Äôll see it respond quickly.
But if you enter <em>/sleep</em> and then load <em>/</em>, you‚Äôll see that <em>/</em> waits until
<code>sleep</code> has slept for its full 5 seconds before loading.</p>
<p>There are multiple techniques we could use to avoid requests backing up behind
a slow request; the one we‚Äôll implement is a thread pool.</p>
<h3 id="improving-throughput-with-a-thread-pool"><a class="header" href="#improving-throughput-with-a-thread-pool">Improving Throughput with a Thread Pool</a></h3>
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it‚Äôs returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.</p>
<p>We‚Äôll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server‚Äôs resources and grinding
the processing of requests to a halt.</p>
<p>Rather than spawning unlimited threads, then, we‚Äôll have a fixed number of
threads waiting in the pool. Requests that come in are sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process up
to <code>N</code> requests concurrently, where <code>N</code> is the number of threads. If each
thread is responding to a long-running request, subsequent requests can still
back up in the queue, but we‚Äôve increased the number of long-running requests
we can handle before reaching that point.</p>
<p>This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the <em>fork/join model</em>, the
<em>single-threaded async I/O model</em>, or the <em>multi-threaded async I/O model</em>. If
you‚Äôre interested in this topic, you can read more about other solutions and
try to implement them; with a low-level language like Rust, all of these
options are possible.</p>
<p>Before we begin implementing a thread pool, let‚Äôs talk about what using the
pool should look like. When you‚Äôre trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it‚Äôs
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.</p>
<p>Similar to how we used test-driven development in the project in Chapter 12,
we‚Äôll use compiler-driven development here. We‚Äôll write the code that calls the
functions we want, and then we‚Äôll look at errors from the compiler to determine
what we should change next to get the code to work. Before we do that, however,
we‚Äôll explore the technique we‚Äôre not going to use as a starting point.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="spawning-a-thread-for-each-request"><a class="header" href="#spawning-a-thread-for-each-request">Spawning a Thread for Each Request</a></h4>
<p>First, let‚Äôs explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn‚Äôt our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point to get a working multithreaded server first. Then we‚Äôll add the
thread pool as an improvement, and contrasting the two solutions will be
easier. Listing 20-11 shows the changes to make to <code>main</code> to spawn a new thread
to handle each stream within the <code>for</code> loop.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 20-11: Spawning a new thread for each
stream</span></p>
<p>As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
<em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you‚Äôll indeed see
that the requests to <em>/</em> don‚Äôt have to wait for <em>/sleep</em> to finish. However, as
we mentioned, this will eventually overwhelm the system because you‚Äôd be making
new threads without any limit.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="creating-a-finite-number-of-threads"><a class="header" href="#creating-a-finite-number-of-threads">Creating a Finite Number of Threads</a></h4>
<p>We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn‚Äôt require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code>
struct we want to use instead of <code>thread::spawn</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-12: Our ideal <code>ThreadPool</code> interface</span></p>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a
similar interface as <code>thread::spawn</code> in that it takes a closure the pool should
run for each stream. We need to implement <code>pool.execute</code> so it takes the
closure and gives it to a thread in the pool to run. This code won‚Äôt yet
compile, but we‚Äôll try so the compiler can guide us in how to fix it.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="building-threadpool-using-compiler-driven-development"><a class="header" href="#building-threadpool-using-compiler-driven-development">Building <code>ThreadPool</code> Using Compiler Driven Development</a></h4>
<p>Make the changes in Listing 20-12 to <em>src/main.rs</em>, and then let‚Äôs use the
compiler errors from <code>cargo check</code> to drive our development. Here is the first
error we get:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we‚Äôll
build one now. Our <code>ThreadPool</code> implementation will be independent of the kind
of work our web server is doing. So, let‚Äôs switch the <code>hello</code> crate from a
binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.</p>
<p>Create a <em>src/lib.rs</em> that contains the following, which is the simplest
definition of a <code>ThreadPool</code> struct that we can have for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
<p>Then edit <em>main.rs</em> file to bring <code>ThreadPool</code> into scope from the library
crate by adding the following code to the top of <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
<p>This code still won‚Äôt work, but let‚Äôs check it again to get the next error that
we need to address:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>This error indicates that next we need to create an associated function named
<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter
that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.
Let‚Äôs implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter, because we know that a
negative number of threads doesn‚Äôt make any sense. We also know we‚Äôll use this
4 as the number of elements in a collection of threads, which is what the
<code>usize</code> type is for, as discussed in the <a href="ch03-02-data-types.html#integer-types">‚ÄúInteger Types‚Äù</a><!--
ignore --> section of Chapter 3.</p>
<p>Let‚Äôs check the code again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Now the error occurs because we don‚Äôt have an <code>execute</code> method on <code>ThreadPool</code>.
Recall from the <a href="ch20-02-multithreaded.html#creating-a-finite-number-of-threads">‚ÄúCreating a Finite Number of
Threads‚Äù</a><!-- ignore --> section that we
decided our thread pool should have an interface similar to <code>thread::spawn</code>. In
addition, we‚Äôll implement the <code>execute</code> function so it takes the closure it‚Äôs
given and gives it to an idle thread in the pool to run.</p>
<p>We‚Äôll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a
parameter. Recall from the <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">‚ÄúMoving Captured Values Out of the Closure and the
<code>Fn</code> Traits‚Äù</a><!-- ignore --> section in Chapter 13 that we can take
closures as parameters with three different traits: <code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>. We need to decide which kind of closure to use here. We know we‚Äôll
end up doing something similar to the standard library <code>thread::spawn</code>
implementation, so we can look at what bounds the signature of <code>thread::spawn</code>
has on its parameter. The documentation shows us the following:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>The <code>F</code> type parameter is the one we‚Äôre concerned with here; the <code>T</code> type
parameter is related to the return value, and we‚Äôre not concerned with that. We
can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably
what we want as well, because we‚Äôll eventually pass the argument we get in
<code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we
want to use because the thread for running a request will only execute that
request‚Äôs closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound
<code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the
closure from one thread to another and <code>'static</code> because we don‚Äôt know how long
the thread will take to execute. Let‚Äôs create an <code>execute</code> method on
<code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure
that takes no parameters and returns the unit type <code>()</code>. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: it does
nothing, but we‚Äôre trying only to make our code compile. Let‚Äôs check it again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>It compiles! But note that if you try <code>cargo run</code> and make a request in the
browser, you‚Äôll see the errors in the browser that we saw at the beginning of
the chapter. Our library isn‚Äôt actually calling the closure passed to <code>execute</code>
yet!</p>
<blockquote>
<p>Note: A saying you might hear about languages with strict compilers, such as
Haskell and Rust, is ‚Äúif the code compiles, it works.‚Äù But this saying is not
universally true. Our project compiles, but it does absolutely nothing! If we
were building a real, complete project, this would be a good time to start
writing unit tests to check that the code compiles <em>and</em> has the behavior we
want.</p>
</blockquote>
<h4 id="validating-the-number-of-threads-in-new"><a class="header" href="#validating-the-number-of-threads-in-new">Validating the Number of Threads in <code>new</code></a></h4>
<p>We aren‚Äôt doing anything with the parameters to <code>new</code> and <code>execute</code>. Let‚Äôs
implement the bodies of these functions with the behavior we want. To start,
let‚Äôs think about <code>new</code>. Earlier we chose an unsigned type for the <code>size</code>
parameter, because a pool with a negative number of threads makes no sense.
However, a pool with zero threads also makes no sense, yet zero is a perfectly
valid <code>usize</code>. We‚Äôll add code to check that <code>size</code> is greater than zero before
we return a <code>ThreadPool</code> instance and have the program panic if it receives a
zero by using the <code>assert!</code> macro, as shown in Listing 20-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if
<code>size</code> is zero</span></p>
<p>We‚Äôve also added some documentation for our <code>ThreadPool</code> with doc comments.
Note that we followed good documentation practices by adding a section that
calls out the situations in which our function can panic, as discussed in
Chapter 14. Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct
to see what the generated docs for <code>new</code> look like!</p>
<p>Instead of adding the <code>assert!</code> macro as we‚Äôve done here, we could change <code>new</code>
into <code>build</code> and return a <code>Result</code> like we did with <code>Config::build</code> in the I/O
project in Listing 12-9. But we‚Äôve decided in this case that trying to create a
thread pool without any threads should be an unrecoverable error. If you‚Äôre
feeling ambitious, try to write a function named <code>build</code> with the following
signature to compare with the <code>new</code> function:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="creating-space-to-store-the-threads"><a class="header" href="#creating-space-to-store-the-threads">Creating Space to Store the Threads</a></h4>
<p>Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the <code>ThreadPool</code> struct
before returning the struct. But how do we ‚Äústore‚Äù a thread? Let‚Äôs take another
look at the <code>thread::spawn</code> signature:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the
closure returns. Let‚Äôs try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we‚Äôre passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>The code in Listing 20-14 will compile but doesn‚Äôt create any threads yet.
We‚Äôve changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
<p><span class="caption">Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold
the threads</span></p>
<p>We‚Äôve brought <code>std::thread</code> into scope in the library crate, because we‚Äôre
using <code>thread::JoinHandle</code> as the type of the items in the vector in
<code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can
hold <code>size</code> items. The <code>with_capacity</code> function performs the same task as
<code>Vec::new</code> but with an important difference: it preallocates space in the
vector. Because we know we need to store <code>size</code> elements in the vector, doing
this allocation up front is slightly more efficient than using <code>Vec::new</code>,
which resizes itself as elements are inserted.</p>
<p>When you run <code>cargo check</code> again, it should succeed.</p>
<h4 id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"><a class="header" href="#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</a></h4>
<p>We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of
threads. Here, we‚Äôll look at how we actually create threads. The standard
library provides <code>thread::spawn</code> as a way to create threads, and
<code>thread::spawn</code> expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them <em>wait</em> for code that we‚Äôll send later. The standard library‚Äôs
implementation of threads doesn‚Äôt include any way to do that; we have to
implement it manually.</p>
<p>We‚Äôll implement this behavior by introducing a new data structure between the
<code>ThreadPool</code> and the threads that will manage this new behavior. We‚Äôll call
this data structure <em>Worker</em>, which is a common term in pooling
implementations. The Worker picks up code that needs to be run and runs the
code in the Worker‚Äôs thread. Think of people working in the kitchen at a
restaurant: the workers wait until orders come in from customers, and then
they‚Äôre responsible for taking those orders and fulfilling them.</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,
we‚Äôll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single
<code>JoinHandle&lt;()&gt;</code> instance. Then we‚Äôll implement a method on <code>Worker</code> that will
take a closure of code to run and send it to the already running thread for
execution. We‚Äôll also give each worker an <code>id</code> so we can distinguish between
the different workers in the pool when logging or debugging.</p>
<p>Here is the new process that will happen when we create a <code>ThreadPool</code>. We‚Äôll
implement the code that sends the closure to the thread after we have <code>Worker</code>
set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty
closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<p>If you‚Äôre up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.</p>
<p>Ready? Here is Listing 20-15 with one way to make the preceding modifications.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>
instances instead of holding threads directly</span></p>
<p>We‚Äôve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>
because it‚Äôs now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>
instances. We use the counter in the <code>for</code> loop as an argument to
<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>External code (like our server in <em>src/main.rs</em>) doesn‚Äôt need to know the
implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,
so we make the <code>Worker</code> struct and its <code>new</code> function private. The
<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>
instance that is created by spawning a new thread using an empty closure.</p>
<blockquote>
<p>Note: If the operating system can‚Äôt create a thread because there aren‚Äôt
enough system resources, <code>thread::spawn</code> will panic. That will cause our
whole server to panic, even though the creation of some threads might
succeed. For simplicity‚Äôs sake, this behavior is fine, but in a production
thread pool implementation, you‚Äôd likely want to use
<a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> and its
<a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore --> method that returns <code>Result</code> instead.</p>
</blockquote>
<p>This code will compile and will store the number of <code>Worker</code> instances we
specified as an argument to <code>ThreadPool::new</code>. But we‚Äôre <em>still</em> not processing
the closure that we get in <code>execute</code>. Let‚Äôs look at how to do that next.</p>
<h4 id="sending-requests-to-threads-via-channels"><a class="header" href="#sending-requests-to-threads-via-channels">Sending Requests to Threads via Channels</a></h4>
<p>The next problem we‚Äôll tackle is that the closures given to <code>thread::spawn</code> do
absolutely nothing. Currently, we get the closure we want to execute in the
<code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we
create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch the code to run from
a queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>The channels we learned about in Chapter 16‚Äîa simple way to communicate between
two threads‚Äîwould be perfect for this use case. We‚Äôll use a channel to function
as the queue of jobs, and <code>execute</code> will send a job from the <code>ThreadPool</code> to
the <code>Worker</code> instances, which will send the job to its thread. Here is the plan:</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sender.</li>
<li>Each <code>Worker</code> will hold on to the receiver.</li>
<li>We‚Äôll create a new <code>Job</code> struct that will hold the closures we want to send
down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute through the
sender.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiver and execute the
closures of any jobs it receives.</li>
</ol>
<p>Let‚Äôs start by creating a channel in <code>ThreadPool::new</code> and holding the sender
in the <code>ThreadPool</code> instance, as shown in Listing 20-16. The <code>Job</code> struct
doesn‚Äôt hold anything for now but will be the type of item we‚Äôre sending down
the channel.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-16: Modifying <code>ThreadPool</code> to store the
sender of a channel that transmits <code>Job</code> instances</span></p>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the
sender. This will successfully compile.</p>
<p>Let‚Äôs try passing a receiver of the channel into each worker as the thread pool
creates the channel. We know we want to use the receiver in the thread that the
workers spawn, so we‚Äôll reference the <code>receiver</code> parameter in the closure. The
code in Listing 20-17 won‚Äôt quite compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-17: Passing the receiver to the workers</span></p>
<p>We‚Äôve made some small and straightforward changes: we pass the receiver into
<code>Worker::new</code>, and then we use it inside the closure.</p>
<p>When we try to check this code, we get this error:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This
won‚Äôt work, as you‚Äôll recall from Chapter 16: the channel implementation that
Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can‚Äôt
just clone the consuming end of the channel to fix this code. We also don‚Äôt
want to send a message multiple times to multiple consumers; we want one list
of messages with multiple workers such that each message gets processed once.</p>
<p>Additionally, taking a job off the channel queue involves mutating the
<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>;
otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple workers own the
receiver, and <code>Mutex</code> will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
<p><span class="caption">Listing 20-18: Sharing the receiver among the workers
using <code>Arc</code> and <code>Mutex</code></span></p>
<p>In <code>ThreadPool::new</code>, we put the receiver in an <code>Arc</code> and a <code>Mutex</code>. For each
new worker, we clone the <code>Arc</code> to bump the reference count so the workers can
share ownership of the receiver.</p>
<p>With these changes, the code compiles! We‚Äôre getting there!</p>
<h4 id="implementing-the-execute-method"><a class="header" href="#implementing-the-execute-method">Implementing the <code>execute</code> Method</a></h4>
<p>Let‚Äôs finally implement the <code>execute</code> method on <code>ThreadPool</code>. We‚Äôll also change
<code>Job</code> from a struct to a type alias for a trait object that holds the type of
closure that <code>execute</code> receives. As discussed in the <a href="ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">‚ÄúCreating Type Synonyms
with Type Aliases‚Äù</a><!-- ignore -->
section of Chapter 19, type aliases allow us to make long types shorter for
ease of use. Look at Listing 20-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>
that holds each closure and then sending the job down the channel</span></p>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we
send that job down the sending end of the channel. We‚Äôre calling <code>unwrap</code> on
<code>send</code> for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can‚Äôt stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use <code>unwrap</code> is that we know the failure case won‚Äôt happen, but the
compiler doesn‚Äôt know that.</p>
<p>But we‚Äôre not quite done yet! In the worker, our closure being passed to
<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let‚Äôs make the change
shown in Listing 20-20 to <code>Worker::new</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {id} got a job; executing.&quot;);

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker‚Äôs thread</span></p>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we
call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex
is in a <em>poisoned</em> state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to
change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to
you.</p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the
channel. A final <code>unwrap</code> moves past any errors here as well, which might occur
if the thread holding the sender has shut down, similar to how the <code>send</code>
method returns <code>Err</code> if the receiver shuts down.</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p>Our thread pool is now in a working state! Give it a <code>cargo run</code> and make some
requests:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won‚Äôt get
overloaded if the server receives a lot of requests. If we make a request to
<em>/sleep</em>, the server will be able to serve other requests by having another
thread run them.</p>
<blockquote>
<p>Note: if you open <em>/sleep</em> in multiple browser windows simultaneously, they
might load one at a time in 5 second intervals. Some web browsers execute
multiple instances of the same request sequentially for caching reasons. This
limitation is not caused by our web server.</p>
</blockquote>
<p>After learning about the <code>while let</code> loop in Chapter 18, you might be wondering
why we didn‚Äôt write the worker thread code as shown in Listing 20-21.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {id} got a job; executing.&quot;);

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
<p><span class="caption">Listing 20-21: An alternative implementation of
<code>Worker::new</code> using <code>while let</code></span></p>
<p>This code compiles and runs but doesn‚Äôt result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public
<code>unlock</code> method because the ownership of the lock is based on the lifetime of
the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the
lock. However, this implementation can also result in the lock being held
longer than intended if we aren‚Äôt mindful of the lifetime of the
<code>MutexGuard&lt;T&gt;</code>.</p>
<p>The code in Listing 20-20 that uses <code>let job = receiver.lock().unwrap().recv().unwrap();</code> works because with <code>let</code>, any
temporary values used in the expression on the right hand side of the equals
sign are immediately dropped when the <code>let</code> statement ends. However, <code>while let</code> (and <code>if let</code> and <code>match</code>) does not drop temporary values until the end of
the associated block. In Listing 20-21, the lock remains held for the duration
of the call to <code>job()</code>, meaning other workers cannot receive jobs.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="graceful-shutdown-and-cleanup"><a class="header" href="#graceful-shutdown-and-cleanup">Graceful Shutdown and Cleanup</a></h2>
<p>The code in Listing 20-20 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the <code>workers</code>,
<code>id</code>, and <code>thread</code> fields that we‚Äôre not using in a direct way that reminds us
we‚Äôre not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they‚Äôre in the middle of
serving a request.</p>
<p>Next, then, we‚Äôll implement the <code>Drop</code> trait to call <code>join</code> on each of the
threads in the pool so they can finish the requests they‚Äôre working on before
closing. Then we‚Äôll implement a way to tell the threads they should stop
accepting new requests and shut down. To see this code in action, we‚Äôll modify
our server to accept only two requests before gracefully shutting down its
thread pool.</p>
<h3 id="implementing-the-drop-trait-on-threadpool"><a class="header" href="#implementing-the-drop-trait-on-threadpool">Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></a></h3>
<p>Let‚Äôs start with implementing <code>Drop</code> on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-22 shows a first attempt at a <code>Drop</code> implementation; this code won‚Äôt
quite work yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-22: Joining each thread when the thread pool
goes out of scope</span></p>
<p>First, we loop through each of the thread pool <code>workers</code>. We use <code>&amp;mut</code> for
this because <code>self</code> is a mutable reference, and we also need to be able to
mutate <code>worker</code>. For each worker, we print a message saying that this
particular worker is shutting down, and then we call <code>join</code> on that worker‚Äôs
thread. If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust panic and go
into an ungraceful shutdown.</p>
<p>Here is the error we get when we compile this code:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
   |
note: this function takes ownership of the receiver `self`, which moves `worker.thread`
  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1581:17

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
</code></pre>
<p>The error tells us we can‚Äôt call <code>join</code> because we only have a mutable borrow
of each <code>worker</code> and <code>join</code> takes ownership of its argument. To solve this
issue, we need to move the thread out of the <code>Worker</code> instance that owns
<code>thread</code> so <code>join</code> can consume the thread. We did this in Listing 17-15: if
<code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> instead, we can call the
<code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and
leave a <code>None</code> variant in its place. In other words, a <code>Worker</code> that is running
will have a <code>Some</code> variant in <code>thread</code>, and when we want to clean up a
<code>Worker</code>, we‚Äôll replace <code>Some</code> with <code>None</code> so the <code>Worker</code> doesn‚Äôt have a
thread to run.</p>
<p>So we know we want to update the definition of <code>Worker</code> like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Now let‚Äôs lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`
   |
note: the method `join` exists on the type `JoinHandle&lt;()&gt;`
  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1581:5
help: consider using `Option::expect` to unwrap the `JoinHandle&lt;()&gt;` value, panicking if the value is an `Option::None`
   |
52 |             worker.thread.expect(&quot;REASON&quot;).join().unwrap();
   |                          +++++++++++++++++

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` due to 2 previous errors
</code></pre>
<p>Let‚Äôs address the second error, which points to the code at the end of
<code>Worker::new</code>; we need to wrap the <code>thread</code> value in <code>Some</code> when we create a
new <code>Worker</code>. Make the following changes to fix this error:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>The first error is in our <code>Drop</code> implementation. We mentioned earlier that we
intended to call <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>.
The following changes will do so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As discussed in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code>
variant out and leaves <code>None</code> in its place. We‚Äôre using <code>if let</code> to destructure
the <code>Some</code> and get the thread; then we call <code>join</code> on the thread. If a worker‚Äôs
thread is already <code>None</code>, we know that worker has already had its thread
cleaned up, so nothing happens in that case.</p>
<h3 id="signaling-to-the-threads-to-stop-listening-for-jobs"><a class="header" href="#signaling-to-the-threads-to-stop-listening-for-jobs">Signaling to the Threads to Stop Listening for Jobs</a></h3>
<p>With all the changes we‚Äôve made, our code compiles without any warnings.
However, the bad news is this code doesn‚Äôt function the way we want it to yet.
The key is the logic in the closures run by the threads of the <code>Worker</code>
instances: at the moment, we call <code>join</code>, but that won‚Äôt shut down the threads
because they <code>loop</code> forever looking for jobs. If we try to drop our
<code>ThreadPool</code> with our current implementation of <code>drop</code>, the main thread will
block forever waiting for the first thread to finish.</p>
<p>To fix this problem, we‚Äôll need a change in the <code>ThreadPool</code> <code>drop</code>
implementation and then a change in the <code>Worker</code> loop.</p>
<p>First, we‚Äôll change the <code>ThreadPool</code> <code>drop</code> implementation to explicitly drop
the <code>sender</code> before waiting for the threads to finish. Listing 20-23 shows the
changes to <code>ThreadPool</code> to explicitly drop <code>sender</code>. We use the same <code>Option</code>
and <code>take</code> technique as we did with the thread to be able to move <code>sender</code> out
of <code>ThreadPool</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-23: Explicitly drop <code>sender</code> before joining
the worker threads</span></p>
<p>Dropping <code>sender</code> closes the channel, which indicates no more messages will be
sent. When that happens, all the calls to <code>recv</code> that the workers do in the
infinite loop will return an error. In Listing 20-24, we change the <code>Worker</code>
loop to gracefully exit the loop in that case, which means the threads will
finish when the <code>ThreadPool</code> <code>drop</code> implementation calls <code>join</code> on them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p><span class="caption">Listing 20-24: Explicitly break out of the loop when
<code>recv</code> returns an error</span></p>
<p>To see this code in action, let‚Äôs modify <code>main</code> to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-25.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        status_line,
</span><span class="boring">        contents.len(),
</span><span class="boring">        contents
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}</span></code></pre>
<p><span class="caption">Listing 20-25: Shut down the server after serving two
requests by exiting the loop</span></p>
<p>You wouldn‚Äôt want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.</p>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration
to the first two items at most. The <code>ThreadPool</code> will go out of scope at the
end of <code>main</code>, and the <code>drop</code> implementation will run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output similar to this:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests. The server stopped accepting connections after the second connection,
and the <code>Drop</code> implementation on <code>ThreadPool</code> starts executing before worker 3
even starts its job. Dropping the <code>sender</code> disconnects all the workers and
tells them to shut down. The workers each print a message when they disconnect,
and then the thread pool calls <code>join</code> to wait for each worker thread to finish.</p>
<p>Notice one interesting aspect of this particular execution: the <code>ThreadPool</code>
dropped the <code>sender</code>, and before any worker received an error, we tried to join
worker 0. Worker 0 had not yet gotten an error from <code>recv</code>, so the main thread
blocked waiting for worker 0 to finish. In the meantime, worker 3 received a
job and then all threads received an error. When worker 0 finished, the main
thread waited for the rest of the workers to finish. At that point, they had
all exited their loops and stopped.</p>
<p>Congrats! We‚Äôve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We‚Äôre able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.</p>
<p>Here‚Äôs the full code for reference:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        status_line,
        contents.len(),
        contents
    );

    stream.write_all(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
<p>We could do more here! If you want to continue enhancing this project, here are
some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods.</li>
<li>Add tests of the library‚Äôs functionality.</li>
<li>Change calls to <code>unwrap</code> to more robust error handling.</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests.</li>
<li>Find a thread pool crate on <a href="https://crates.io/">crates.io</a> and implement a
similar web server using the crate instead. Then compare its API and
robustness to the thread pool we implemented.</li>
</ul>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Well done! You‚Äôve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You‚Äôre now ready to implement your own Rust
projects and help with other peoples‚Äô projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ilova"><a class="header" href="#ilova">Ilova</a></h1>
<p>Quyidagi bo'limlarda siz o'zingiz uchun foydali bo'lishi mumkin bo'lgan ma'lumotnomalar mavjud
Rust sayohati.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ilova-a-kalit-sozlar"><a class="header" href="#ilova-a-kalit-sozlar">Ilova A: Kalit so'zlar</a></h2>
<p>Quyidagi ro'yxatda Rust tili tomonidan joriy yoki kelajakda foydalanish uchun ajratilgan kalit so'zlar mavjud.
Shunday qilib, ularni identifikator sifatida ishlatib bo'lmaydi (raw identifikatorlar bo'limida muhokama qilinadigan ‚Äú<a href="appendix-01-keywords.html#raw-identifiers">Raw identifikatorlardan</a><!-- ignore -->‚Äù tashqari)
Identifikatorlar - bu funksiyalar, o'zgaruvchilar, parametrlar, struct field, modullar, cratelar, konstantalar, macroslar, statik qiymatlar, atributlar, turlar, traitlar yoki lifetimelarining nomlari.</p>
<h3 id="hozirda-foydalanilayotgan-kalit-sozlar"><a class="header" href="#hozirda-foydalanilayotgan-kalit-sozlar">Hozirda foydalanilayotgan kalit so'zlar</a></h3>
<p>Quyida hozirda foydalanilayotgan kalit so‚Äòzlar ro‚Äòyxati keltirilgan, ularning funksiyalari tasvirlangan.</p>
<ul>
<li><code>as</code> - primitiv castingni amalga oshiring, elementni o'z ichiga olgan o'ziga xos traitni ajrating yoki <code>use</code> statementaridagi elementlarning nomini o'zgartiring</li>
<li><code>async</code> -  joriy threadni bloklash o'rniga <code>Future</code> ni return qiling</li>
<li><code>await</code> - <code>Future</code> natijasi tayyor bo'lgunga qadar executionni to'xtatib turing</li>
<li><code>break</code> - zudlik bilan loopdan chiqing</li>
<li><code>const</code> - konstanta elementlarni yoki konstanta raw pointerlarni aniqlang</li>
<li><code>continue</code> - keyingi sikl iteratsiyasiga davom eting</li>
<li><code>crate</code> - modul yo'lida, crate rootga ishora qiladi</li>
<li><code>dyn</code> - trait objectga dinamik jo'natish</li>
<li><code>else</code> - <code>if</code> va <code>if let</code> uchun zaxira control flow konstruksiyalari</li>
<li><code>enum</code> - enumerationni aniqlash</li>
<li><code>extern</code> - tashqi funksiya yoki o‚Äòzgaruvchini bog‚Äòlash</li>
<li><code>false</code> - Boolean  false(noto'g'ri) so'z</li>
<li><code>fn</code> - funksiya yoki funktsiya pointer turini aniqlang</li>
<li><code>for</code> - iteratordagi elementlarni ko'rib chiqing, implement  trait yoki yuqori darajali  lifetimeni belgilang</li>
<li><code>if</code> - shartli expression natijasiga asoslangan branch</li>
<li><code>impl</code> - o'ziga inherent yoki trait funksionalligini implement</li>
<li><code>in</code> - <code>for</code> sikl sintaksisining bir qismi</li>
<li><code>let</code> - o'zgaruvchini bog'lash</li>
<li><code>loop</code> - shartsiz loop</li>
<li><code>match</code> - qiymatni patternlarga moslashtirish</li>
<li><code>mod</code> - modulni aniqlash</li>
<li><code>move</code> - make a closure take ownership of all its captures</li>
<li><code>mut</code> - reference, raw pointerlar yoki pattern bindingdagi o'zgaruvchanlikni bildiradi</li>
<li><code>pub</code> - struct fieldlarida, <code>impl</code> bloklarida yoki modullarda ommaviy ko'rinishni bildiradi</li>
<li><code>ref</code> - reference orqali bog'lash</li>
<li><code>return</code> - funksiyadan qaytish(return)</li>
<li><code>Self</code> - biz belgilayotgan yoki implement qilayotgan tur uchun turdagi alias</li>
<li><code>self</code> - metod mavzusi yoki joriy modul</li>
<li><code>static</code> - global o'zgaruvchi yoki butun dasturning bajarilishi uchun lifetime</li>
<li><code>struct</code> - structurani aniqlash</li>
<li><code>super</code> - joriy modulning parent moduli</li>
<li><code>trait</code> - traitni aniqlash</li>
<li><code>true</code> - Boolean true(to'g'ri) so'z</li>
<li><code>type</code> - turdagi alias yoki associated turni aniqlash</li>
<li><code>union</code> - define a <a href="../reference/items/unions.html">union</a><!-- ignore -->; is only a keyword when used
in a union declaration</li>
<li><code>unsafe</code> - xavfli kod, funksiyalar, traitlar yoki implementationlarni bildiradi</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>where</code> - denote clauses that constrain a type</li>
<li><code>while</code> - expression natijasi asosida shartli ravishda sikl</li>
</ul>
<h3 id="kelajakda-foydalanish-uchun-ajratilgan-kalit-sozlar"><a class="header" href="#kelajakda-foydalanish-uchun-ajratilgan-kalit-sozlar">Kelajakda foydalanish uchun ajratilgan kalit so'zlar</a></h3>
<p>Quyidagi kalit so'zlar hali hech qanday funksiyaga ega emas, lekin kelajakda foydalanish uchun Rust tomonidan zahiralangan.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="raw-identifikatorlar"><a class="header" href="#raw-identifikatorlar">Raw identifikatorlar</a></h3>
<p><em>Raw identifikatorlar</em> odatda ruxsat berilmaydigan kalit so'zlardan foydalanish imkonini beruvchi sintaksisdir. Kalit so‚Äòz oldiga <code>r#</code> qo‚Äòyish orqali raw identifikatordan foydalanasiz.</p>
<p>Masalan, <code>match</code> kalit so'zdir. Agar siz o'z nomi sifatida <code>match</code> dan foydalanadigan quyidagi funksiyani kompilyatsiya qilmoqchi bo'lsangiz:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>you‚Äôll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Xato, funksiya identifikatori sifatida <code>match</code> kalit so‚Äòzidan foydalana olmasligingizni ko‚Äòrsatadi. Funksiya nomi sifatida <code>match</code> dan foydalanish uchun siz raw identifikator sintaksisidan foydalanishingiz kerak, masalan:</p>
<p><span class="filename">Fayl nomi: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}</code></pre></pre>
<p>Ushbu kod hech qanday xatosiz kompilyatsiya qilinadi. Funksiya nomidagi <code>r#</code> prefiksi uning ta ºrifida, shuningdek, funksiya <code>main</code>da chaqirilgan joyiga e ºtibor bering.</p>
<p>Raw identifikatorlari identifikator sifatida tanlagan har qanday so'zdan foydalanishga imkon beradi, hatto bu so'z zahiradagi kalit so'z bo'lsa ham. Bu bizga identifikator nomlarini tanlashda ko'proq erkinlik beradi, shuningdek, bu so'zlar kalit so'zlar bo'lmagan tilda yozilgan dasturlar bilan integratsiyalashish imkonini beradi. Bunga qo'shimcha ravishda, raw identifikatorlar sizga cratetagidan boshqa Rust nashrida yozilgan kutubxonalardan foydalanish imkonini beradi. Misol uchun, <code>try</code> 2015 yilgi nashrda kalit so'z emas, balki 2018 yilgi nashrda mavjud. Agar siz 2015-yil nashri yordamida yozilgan kutubxonaga bog ªliq bo ªlsangiz va <code>try</code> funksiyasiga ega bo ªlsangiz, bu funksiyani 2018-yilgi nashr kodingizdan chaqirish uchun <code>r#try</code> raw identifikator sintaksisidan foydalanishingiz kerak bo ªladi.
Nashrlar haqida qo'shimcha ma'lumot <a href="appendix-05-editions.html">E ilovasiga</a><!-- ignore --> qarang.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="b-ilova-operatorlar-va-belgilar"><a class="header" href="#b-ilova-operatorlar-va-belgilar">B-ilova: Operatorlar va Belgilar</a></h2>
<p>Ushbu qo'shimchada Rust sintaksisining lug'ati, shu jumladan o'z-o'zidan yoki yo'llar (paths), umumlashmalar (generiklar), turlar, makroslar, atributlar, sharhlar, katakchalar (tuples) va qavslar kontekstida paydo bo'ladigan operatorlar va boshqa belgilar mavjud.</p>
<h3 id="operatorlar"><a class="header" href="#operatorlar">Operatorlar</a></h3>
<p>B-1 jadvalida Rust tili operatorlari, operator qanday kontekstda ko'rinishi, qisqa tushuntirish va ushbu operator yuklanishi mumkinmi (overload) yoki yo'qmi ko'rsatilgan. Agar operator yuklanishi mumkin bo'lsa, bu operatorni yuklash uchun foydalanish kerak bo'lgan tegishli trait keltirilgan.</p>
<p><span class="caption">Jadval B-1: Operatorlar</span></p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Misol</th><th>Tushuntirish</th><th>Yuklanishi mumkinmi?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Makros chaqiruvi</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bit yoki mantiqiy inkor</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Tengsizlik taqqoslash</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Bo'linishning qolg'i</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Bo'linishning qolg'i va tayinlash</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Qarz olish</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Ushbu tur qarzga olinganligini ko'rsatadi</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitlik VA</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitlik VA va tayinlash</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Mantiqiy VA</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arifmetik ko'paytirish</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arifmetik ko'paytirish va tayinlash</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Havolani bekor qilish</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Ushbu tur xom ko'rsatkich ekanligini ko'rsatadi</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Murakkab turdagi cheklov</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arifmetik qo'shish</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arifmetik qo'shish va tayinlash</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argument va element ajratuvchisi</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Arifmetik inkor</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arifmetik ayirish</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arifmetik ayirish va tayinlash</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Funktsiya va yopilishning qaytish turi</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>A'zoga (elementga) kirish</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>O'ngdan tashqari raqamlar oralig'ini bildiradi</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Raqamlar oralig'ini, shu jumladan o'ng tomonni bildiradi</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Strukturani yangilash sintaksisi</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>&quot;Va boshqa hamma narsa&quot;ni bog'lash</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Eskirgan, yangi sintaksisdan foydalaning ..= ) Inklyuziv diapazonni aniqlashda ishlatiladi</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arifmetik bo'lish</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arifmetik bo'lish va tayinlash</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Turlarning cheklovlari</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Tuzilish maydonini ishga tushirish</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Tsikl yorlig'i</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Ko'rsatma va elementning oxiri belgisi</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Qat'iy o'lchamdagi massiv sintaksisining qismi</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Bitlik chapga surish</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Bitlik chapga surish va tayinlash</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>&quot;Kamroq&quot; taqqoslash</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>&quot;Kamroq yoki teng&quot; taqqoslash</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Tayinlash/ekvivalentlik</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Tenglik taqqoslash</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Moslama qolipining qismi</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>&quot;Kattaroq&quot; taqqoslash</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>&quot;Kattaroq yoki teng&quot; taqqoslash</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Bitlik o'ngga surish</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Bitlik o'ngga surish va tayinlash</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Naqshni bog'lash (Pattern binding)</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitlik istisno YOKI</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitlik istisno YOKI va tayinlash</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Muqobil naqshlar</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitlik YOKI</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitlik YOKI va tayinlash</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Qisqa mantiqiy YOKI</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Xato qaytarish</td><td></td></tr>
</tbody></table>
</div>
<h3 id="operator-bolmagan-belgilar"><a class="header" href="#operator-bolmagan-belgilar">Operator bo'lmagan Belgilar</a></h3>
<p>Quyidagi ro'yxatda operator sifatida ishlamaydigan barcha belgilar mavjud; ya'ni ular funktsiya yoki usul chaqiruvi kabi harakat qilmaydi.</p>
<p>B-2 jadvali o'z-o'zidan paydo bo'ladigan va turli joylarda qabul qilinadigan belgilarni ko'rsatadi.</p>
<p><span class="caption">Jadval B-2: Mustaqil Sintaksis</span></p>
<div class="table-wrapper"><table><thead><tr><th>Belgi</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Nomlangan umrbod yoki tsikl yorlig'i</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, va h.k.</td><td>Ma'lum turdagi sonli literal</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>Qator (String) literal</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, va h.k.</td><td>Qochish belgilarini qayta ishlamaydigan xom satrli literal</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Bayt string literal; string o'rniga bayt massivini hosil qiladi</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, va h.k.</td><td>Xom satr baytli harf, xom va baytli harflarning kombinatsiyasi</td></tr>
<tr><td><code>'...'</code></td><td>Belgilar literal</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII bayt literal</td></tr>
<tr><td><code>|...| expr</code></td><td>Yopilish</td></tr>
<tr><td><code>!</code></td><td>Har doim bo'sh pastki tur divergiruvchi funksiyalar uchun</td></tr>
<tr><td><code>_</code></td><td>‚ÄúE'tiborsiz‚Äù pattern binding; shuningdek, butun sonli literalni o'qilishi uchun ishlatiladi</td></tr>
</tbody></table>
</div>
<p>Jadval B-3 modul ierarxiyasi orqali elementga yo'l kontekstida ko'rinadigan belgilarni ko'rsatadi.</p>
<p><span class="caption">Jadval B-3: Yo'lga Tegishli Sintaksis</span></p>
<div class="table-wrapper"><table><thead><tr><th>Belgi</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Nomlar maydoni yo'li</td></tr>
<tr><td><code>::path</code></td><td>Crate ildiziga nisbatan yo'l (ya'ni, aniq absolyut yo'l)</td></tr>
<tr><td><code>self::path</code></td><td>Joriy modulga nisbatan yo'l (ya'ni, aniq nisbiy yo'l)</td></tr>
<tr><td><code>super::path</code></td><td>Joriy modulning ota moduliga nisbatan yo'l</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Tegishli konstantalar, funksiyalar va turlar</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>To'g'ridan-to'g'ri nomlanishi mumkin bo'lmagan turga tegishli element (masalan, <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, va hokazo.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Usul chaqiruvini aniqlashtirish uchun usulni aniqlagan traitni nomlash</td></tr>
<tr><td><code>type::method(...)</code></td><td>Usul chaqiruvini aniqlashtirish uchun usul aniqlangan tur nomini ko'rsatish</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Usul chaqiruvini aniqlashtirish uchun trait va tur nomini ko'rsatish</td></tr>
</tbody></table>
</div>
<p>Jadval B-4 generik turdagi parametrlarni ishlatish kontekstida ko'rinadigan belgilarni ko'rsatadi.</p>
<p><span class="caption">Jadval B-4: Generiklar</span></p>
<div class="table-wrapper"><table><thead><tr><th>Belgi</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Turdagi umumlashtirilgan parametrlar uchun parametrlarni belgilaydi (masalan, <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Ifodada generik tur, funksiya yoki usul parametrlari; ko'pincha turbofish deb ataladi (masalan, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Umumlashtirilgan funksiyani aniqlash</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Umumlashtirilgan tuzilmani aniqlash</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Umumlashtirilgan enum aniqlash</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Umumlashtirilgan amalga oshirishning ta'rifi</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Yuqori darajadagi umrbod cheklovlar</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Bir yoki bir nechta tegishli turlarga aniq tayinlangan generik tur (masalan, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Jadval b-5 ko'rsatadi belgilar turi cheklangan umumlashtirilgan parametr turlaridan foydalanish kontekstida paydo bo'ladi</p>
<p><span class="caption">Jadval B-5: Trait Cheklovlari</span></p>
<div class="table-wrapper"><table><thead><tr><th>Belgi</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td><code>T</code> Umumlashtirilgan parametri <code>U</code>ni amalga oshiruvchi turlar bilan cheklangan</td></tr>
<tr><td><code>T: 'a</code></td><td><code>T</code> Umumlashtirilgan turi <code>a</code> umrbodidan uzoqroq bo'lishi kerak (ya'ni, tur hech qanday <code>a</code>dan qisqaroq bo'lgan ko'rsatkichlarga ega bo'lmasligi kerak)</td></tr>
<tr><td><code>T: 'static</code></td><td><code>T</code> Umumlashtirilgan turi faqat <code>static</code> umrbod ko'rsatkichlarini o'z ichiga oladi</td></tr>
<tr><td><code>'b: 'a</code></td><td><code>'b</code> umrbodi <code>a</code> umrbodidan uzoqroq bo'lishi kerak</td></tr>
<tr><td><code>T: ?Sized</code></td><td>Umumlashtirilgan tur parametri dinamik o'lchamli tur bo'lishiga ruxsat beradi</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Murakkab tur cheklovi</td></tr>
</tbody></table>
</div>
<p>Jadval B-6 makrolarni chaqirish yoki aniqlash va elementga atributlarni belgilash kontekstida ko'rinadigan belgilarni ko'rsatadi.</p>
<p><span class="caption">Jadval B-6: Makrolar va Atributlar</span></p>
<div class="table-wrapper"><table><thead><tr><th>Belgi</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Tashqi atribut</td></tr>
<tr><td><code>#![meta]</code></td><td>Ichki atribut</td></tr>
<tr><td><code>$ident</code></td><td>Makro almashtirish</td></tr>
<tr><td><code>$ident:kind</code></td><td>Makro qo'lga olish</td></tr>
<tr><td><code>$(‚Ä¶)‚Ä¶</code></td><td>Makro takrorlash</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Makro chaqiruvi</td></tr>
</tbody></table>
</div>
<p>B-7 jadvalida sharhlar yaratadigan belgilar ko'rsatilgan.</p>
<p><span class="caption">Jadval B-7: Kommentariyalar</span></p>
<div class="table-wrapper"><table><thead><tr><th>Belgi</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Ichki bir qatorli hujjat sharhi</td></tr>
<tr><td><code>//!</code></td><td>Tashqi bir qatorli hujjat sharhi</td></tr>
<tr><td><code>///</code></td><td>Tashqi chiziqli doc kommentariya</td></tr>
<tr><td><code>/*...*/</code></td><td>Ko'p qatorli sharh</td></tr>
<tr><td><code>/*!...*/</code></td><td>Ichki ko'p qatorli hujjat sharhi</td></tr>
<tr><td><code>/**...*/</code></td><td>Tashqi ko'p qatorli hujjat sharhi</td></tr>
</tbody></table>
</div>
<p>B-8 jadvalida katakchalardan (tuple-lardan) foydalanish kontekstida paydo bo'ladigan belgilar ko'rsatilgan.</p>
<p><span class="caption">Jadval B-8: Katakchalar (tuples)</span></p>
<div class="table-wrapper"><table><thead><tr><th>Belgi</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Bo'sh tupl (ya'ni, birlik), literal va tur</td></tr>
<tr><td><code>(expr)</code></td><td>Qavs ichidagi ifoda</td></tr>
<tr><td><code>(expr,)</code></td><td>Yagona elementli tupl ifodasi</td></tr>
<tr><td><code>(type,)</code></td><td>Yagona elementli tupl turi</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Tupl ifodasi</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tupl turi</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Funksiya chaqiruvi ifodasi; shuningdek, tupl strukturasi va tupl enum variantlarini boshlash uchun ishlatiladi</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, va h.k.</td><td>Tupl indekslash</td></tr>
</tbody></table>
</div>
<p>B-9 jadvali jingalak qavslardan (&quot;{}&quot;) foydalanadigan kontekstlarni ko'rsatadi.</p>
<p><span class="caption">Jadval B-9: Jingalak Qavslar</span></p>
<div class="table-wrapper"><table><thead><tr><th>Kontekst</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Blok ifodasi</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> literal</td></tr>
</tbody></table>
</div>
<p>Jadval B-10 to'rtburchak qavslar ishlatiladigan kontekstlarni ko'rsatadi.</p>
<p><span class="caption">Jadval B-10: To'rtburchak Qavslar</span></p>
<div class="table-wrapper"><table><thead><tr><th>Kontekst</th><th>Tushuntirish</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Array (yig'ilma) literal</td></tr>
<tr><td><code>[expr; len]</code></td><td><code>len</code> nusxalarini o'z ichiga olgan array literal</td></tr>
<tr><td><code>[type; len]</code></td><td><code>len</code> nusxalarini o'z ichiga olgan array turi</td></tr>
<tr><td><code>expr[expr]</code></td><td>To'plamni indekslash. Yuklanishi mumkin (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>To'plamni kesishga o'xshash qilib indekslash, <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> yoki <code>RangeFull</code> ni &quot;indeks&quot; sifatida ishlatish</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-c-derivable-traits"><a class="header" href="#appendix-c-derivable-traits">Appendix C: Derivable Traits</a></h2>
<p>In various places in the book, we‚Äôve discussed the <code>derive</code> attribute, which
you can apply to a struct or enum definition. The <code>derive</code> attribute generates
code that will implement a trait with its own default implementation on the
type you‚Äôve annotated with the <code>derive</code> syntax.</p>
<p>In this appendix, we provide a reference of all the traits in the standard
library that you can use with <code>derive</code>. Each section covers:</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you‚Äôre allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<p>If you want different behavior from that provided by the <code>derive</code> attribute,
consult the <a href="../std/index.html">standard library documentation</a><!-- ignore -->
for each trait for details of how to manually implement them.</p>
<p>These traits listed here are the only ones defined by the standard library that
can be implemented on your types using <code>derive</code>. Other traits defined in the
standard library don‚Äôt have sensible default behavior, so it‚Äôs up to you to
implement them in the way that makes sense for what you‚Äôre trying to accomplish.</p>
<p>An example of a trait that can‚Äôt be derived is <code>Display</code>, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn‚Äôt have this insight, so
it can‚Äôt provide appropriate default behavior for you.</p>
<p>The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement <code>derive</code> for their own traits, making the list of
traits you can use <code>derive</code> with truly open-ended. Implementing <code>derive</code>
involves using a procedural macro, which is covered in the
<a href="ch19-06-macros.html#macros">‚ÄúMacros‚Äù</a><!-- ignore --> section of Chapter 19.</p>
<h3 id="debug-for-programmer-output"><a class="header" href="#debug-for-programmer-output"><code>Debug</code> for Programmer Output</a></h3>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you
indicate by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p>The <code>Debug</code> trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program‚Äôs execution.</p>
<p>The <code>Debug</code> trait is required, for example, in use of the <code>assert_eq!</code> macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances weren‚Äôt equal.</p>
<h3 id="partialeq-and-eq-for-equality-comparisons"><a class="header" href="#partialeq-and-eq-for-equality-comparisons"><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons</a></h3>
<p>The <code>PartialEq</code> trait allows you to compare instances of a type to check for
equality and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When <code>PartialEq</code> is derived on
structs, two instances are equal only if <em>all</em> fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.</p>
<p>The <code>PartialEq</code> trait is required, for example, with the use of the
<code>assert_eq!</code> macro, which needs to be able to compare two instances of a type
for equality.</p>
<p>The <code>Eq</code> trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be
applied to types that also implement <code>PartialEq</code>, although not all types that
implement <code>PartialEq</code> can implement <code>Eq</code>. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the
<code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
<h3 id="partialord-and-ord-for-ordering-comparisons"><a class="header" href="#partialord-and-ord-for-ordering-comparisons"><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons</a></h3>
<p>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting
purposes. A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, and <code>&gt;=</code> operators. You can only apply the <code>PartialOrd</code> trait to types
that also implement <code>PartialEq</code>.</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an
<code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don‚Äôt produce an
ordering. An example of a value that doesn‚Äôt produce an ordering, even though
most values of that type can be compared, is the not-a-number (<code>NaN</code>) floating
point value. Calling <code>partial_cmp</code> with any floating point number and the <code>NaN</code>
floating point value will return <code>None</code>.</p>
<p>When derived on structs, <code>PartialOrd</code> compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.</p>
<p>The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method
from the <code>rand</code> crate that generates a random value in the range specified by a
range expression.</p>
<p>The <code>Ord</code> trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The <code>Ord</code> trait implements the <code>cmp</code> method,
which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid
ordering will always be possible. You can only apply the <code>Ord</code> trait to types
that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When
derived on structs and enums, <code>cmp</code> behaves the same way as the derived
implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>,
a data structure that stores data based on the sort order of the values.</p>
<h3 id="clone-and-copy-for-duplicating-values"><a class="header" href="#clone-and-copy-for-duplicating-values"><code>Clone</code> and <code>Copy</code> for Duplicating Values</a></h3>
<p>The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">‚ÄúWays Variables and Data Interact:
Clone‚Äù</a><!-- ignore --> section in
Chapter 4 for more information on <code>Clone</code>.</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the
whole type, calls <code>clone</code> on each of the parts of the type. This means all the
fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a
slice. The slice doesn‚Äôt own the type instances it contains, but the vector
returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls
<code>clone</code> on each item. Thus, the type stored in the slice must implement <code>Clone</code>.</p>
<p>The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">‚ÄúStack-Only Data:
Copy‚Äù</a><!-- ignore --> section in Chapter 4 for more
information on <code>Copy</code>.</p>
<p>The <code>Copy</code> trait doesn‚Äôt define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.</p>
<p>You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code>. A type that
implements <code>Copy</code> must also implement <code>Clone</code>, because a type that implements
<code>Copy</code> has a trivial implementation of <code>Clone</code> that performs the same task as
<code>Copy</code>.</p>
<p>The <code>Copy</code> trait is rarely required; types that implement <code>Copy</code> have
optimizations available, meaning you don‚Äôt have to call <code>clone</code>, which makes
the code more concise.</p>
<p>Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code>, but the
code might be slower or have to use <code>clone</code> in places.</p>
<h3 id="hash-for-mapping-a-value-to-a-value-of-fixed-size"><a class="header" href="#hash-for-mapping-a-value-to-a-value-of-fixed-size"><code>Hash</code> for Mapping a Value to a Value of Fixed Size</a></h3>
<p>The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
<code>Hash</code> implements the <code>hash</code> method. The derived implementation of the <code>hash</code>
method combines the result of calling <code>hash</code> on each of the parts of the type,
meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p>An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code>
to store data efficiently.</p>
<h3 id="default-for-default-values"><a class="header" href="#default-for-default-values"><code>Default</code> for Default Values</a></h3>
<p>The <code>Default</code> trait allows you to create a default value for a type. Deriving
<code>Default</code> implements the <code>default</code> function. The derived implementation of the
<code>default</code> function calls the <code>default</code> function on each part of the type,
meaning all fields or values in the type must also implement <code>Default</code> to
derive <code>Default</code>.</p>
<p>The <code>Default::default</code> function is commonly used in combination with the struct
update syntax discussed in the <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">‚ÄúCreating Instances From Other Instances With
Struct Update
Syntax‚Äù</a><!-- ignore -->
section in Chapter 5. You can customize a few fields of a struct and then
set and use a default value for the rest of the fields by using
<code>..Default::default()</code>.</p>
<p>The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on
<code>Option&lt;T&gt;</code> instances, for example. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method
<code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type
<code>T</code> stored in the <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-d---useful-development-tools"><a class="header" href="#appendix-d---useful-development-tools">Appendix D - Useful Development Tools</a></h2>
<p>In this appendix, we talk about some useful development tools that the Rust
project provides. We‚Äôll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.</p>
<h3 id="automatic-formatting-with-rustfmt"><a class="header" href="#automatic-formatting-with-rustfmt">Automatic Formatting with <code>rustfmt</code></a></h3>
<p>The <code>rustfmt</code> tool reformats your code according to the community code style.
Many collaborative projects use <code>rustfmt</code> to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.</p>
<p>To install <code>rustfmt</code>, enter the following:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>This command gives you <code>rustfmt</code> and <code>cargo-fmt</code>, similar to how Rust gives you
both <code>rustc</code> and <code>cargo</code>. To format any Cargo project, enter the following:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on <code>rustfmt</code>, see <a href="https://github.com/rust-lang/rustfmt">its documentation</a>.</p>
<h3 id="fix-your-code-with-rustfix"><a class="header" href="#fix-your-code-with-rustfix">Fix Your Code with <code>rustfix</code></a></h3>
<p>The rustfix tool is included with Rust installations and can automatically fix
compiler warnings that have a clear way to correct the problem that‚Äôs likely
what you want. It‚Äôs likely you‚Äôve seen compiler warnings before. For example,
consider this code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>Here, we‚Äôre calling the <code>do_something</code> function 100 times, but we never use the
variable <code>i</code> in the body of the <code>for</code> loop. Rust warns us about that:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>The warning suggests that we use <code>_i</code> as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the <code>rustfix</code> tool by running the command <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>When we look at <em>src/main.rs</em> again, we‚Äôll see that <code>cargo fix</code> has changed the
code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}</code></pre></pre>
<p>The <code>for</code> loop variable is now named <code>_i</code>, and the warning no longer appears.</p>
<p>You can also use the <code>cargo fix</code> command to transition your code between
different Rust editions. Editions are covered in Appendix E.</p>
<h3 id="more-lints-with-clippy"><a class="header" href="#more-lints-with-clippy">More Lints with Clippy</a></h3>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code.</p>
<p>To install Clippy, enter the following:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>To run Clippy‚Äôs lints on any Cargo project, enter the following:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}</code></pre></pre>
<p>Running <code>cargo clippy</code> on this project results in this error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>This error lets you know that Rust already has a more precise <code>PI</code> constant
defined, and that your program would be more correct if you used the constant
instead. You would then change your code to use the <code>PI</code> constant. The
following code doesn‚Äôt result in any errors or warnings from Clippy:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}</code></pre></pre>
<p>For more information on Clippy, see <a href="https://github.com/rust-lang/rust-clippy">its documentation</a>.</p>
<h3 id="ide-integration-using-rust-analyzer"><a class="header" href="#ide-integration-using-rust-analyzer">IDE Integration Using <code>rust-analyzer</code></a></h3>
<p>To help IDE integration, the Rust community recommends using
<a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->. This tool is a set of
compiler-centric utilities that speaks the <a href="http://langserver.org/">Language Server Protocol</a><!--
ignore -->, which is a specification for IDEs and programming languages to
communicate with each other. Different clients can use <code>rust-analyzer</code>, such as
<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">the Rust analyzer plug-in for Visual Studio Code</a>.</p>
<p>Visit the <code>rust-analyzer</code> project‚Äôs <a href="https://rust-analyzer.github.io">home page</a><!-- ignore -->
for installation instructions, then install the language server support in your
particular IDE. Your IDE will gain abilities such as autocompletion, jump to
definition, and inline errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-e---editions"><a class="header" href="#appendix-e---editions">Appendix E - Editions</a></h2>
<p>In Chapter 1, you saw that <code>cargo new</code> adds a bit of metadata to your
<em>Cargo.toml</em> file about an edition. This appendix talks about what that means!</p>
<p>The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, ‚ÄúWow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!‚Äù</p>
<p>Every two or three years, the Rust team produces a new Rust <em>edition</em>. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.</p>
<p>Editions serve different purposes for different people:</p>
<ul>
<li>For active Rust users, a new edition brings together incremental changes into
an easy-to-understand package.</li>
<li>For non-users, a new edition signals that some major advancements have
landed, which might make Rust worth another look.</li>
<li>For those developing Rust, a new edition provides a rallying point for the
project as a whole.</li>
</ul>
<p>At the time of this writing, three Rust editions are available: Rust 2015, Rust
2018, and Rust 2021. This book is written using Rust 2021 edition idioms.</p>
<p>The <code>edition</code> key in <em>Cargo.toml</em> indicates which edition the compiler should
use for your code. If the key doesn‚Äôt exist, Rust uses <code>2015</code> as the edition
value for backward compatibility reasons.</p>
<p>Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.</p>
<p>All Rust compiler versions support any edition that existed prior to that
compiler‚Äôs release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you‚Äôre using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.</p>
<p>To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.</p>
<p>For more details, the <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition
Guide</em></a> is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ilova-f-kitobning-tarjimalari"><a class="header" href="#ilova-f-kitobning-tarjimalari">Ilova F: Kitobning tarjimalari</a></h2>
<p>Ingliz tilidan boshqa tillardagi manbalar uchun.Ko'pchilik hali ham davom etmoqda; yordam berish yoki yangi tarjima haqida bizga xabar berish uchun <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Tarjimalar yorlig‚Äòiga</a> qarang!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Portugu√™s</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Portugu√™s</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">ÁÆÄ‰Ωì‰∏≠Êñá</a></li>
<li><a href="https://github.com/rust-tw/book-tw">Ê≠£È´î‰∏≠Êñá</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</a></li>
<li><a href="https://github.com/thecodix/book">Espa√±ol</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a></li>
<li><a href="https://github.com/EmanueleGurini/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">–†—É—Å—Å–∫–∏–π</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">ÌïúÍµ≠Ïñ¥</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">Êó•Êú¨Ë™û</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Fran√ßais</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ŒµŒªŒªŒ∑ŒΩŒπŒ∫ŒÆ</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">‡§π‡§ø‡§Ç‡§¶‡•Ä</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">‡πÑ‡∏ó‡∏¢</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
<li><a href="https://github.com/rust-lang-uz/i10n">O'zbek</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-g---how-rust-is-made-and-nightly-rust"><a class="header" href="#appendix-g---how-rust-is-made-and-nightly-rust">Appendix G - How Rust is Made and ‚ÄúNightly Rust‚Äù</a></h2>
<p>This appendix is about how Rust is made and how that affects you as a Rust
developer.</p>
<h3 id="stability-without-stagnation"><a class="header" href="#stability-without-stagnation">Stability Without Stagnation</a></h3>
<p>As a language, Rust cares a <em>lot</em> about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can‚Äôt
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.</p>
<p>Our solution to this problem is what we call ‚Äústability without stagnation‚Äù,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.</p>
<h3 id="choo-choo-release-channels-and-riding-the-trains"><a class="header" href="#choo-choo-release-channels-and-riding-the-trains">Choo, Choo! Release Channels and Riding the Trains</a></h3>
<p>Rust development operates on a <em>train schedule</em>. That is, all development is
done on the <code>master</code> branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three <em>release channels</em> for Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.</p>
<p>Here‚Äôs an example of how the development and release process works: let‚Äôs
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the <code>master</code>
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Every six weeks, it‚Äôs time to prepare a new release! The <code>beta</code> branch of the
Rust repository branches off from the <code>master</code> branch used by nightly. Now,
there are two releases:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there‚Äôs still a nightly release every night:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Let‚Äôs say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to <code>master</code>, so that nightly is fixed, and then the fix is backported to the
<code>beta</code> branch, and a new release of beta is produced:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Six weeks after the first beta was created, it‚Äôs time for a stable release! The
<code>stable</code> branch is produced from the <code>beta</code> branch:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hooray! Rust 1.5 is done! However, we‚Äôve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the <em>next</em> version of Rust, 1.6.
So after <code>stable</code> branches off of <code>beta</code>, the next version of <code>beta</code> branches
off of <code>nightly</code> again:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>This is called the ‚Äútrain model‚Äù because every six weeks, a release ‚Äúleaves the
station‚Äù, but still has to take a journey through the beta channel before it
arrives as a stable release.</p>
<p>Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it‚Äôs six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there‚Äôs no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.</p>
<p>Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it‚Äôs easy to upgrade to: if a beta release doesn‚Äôt
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
<code>rustc</code> is still a piece of software, and bugs do exist.</p>
<h3 id="unstable-features"><a class="header" href="#unstable-features">Unstable Features</a></h3>
<p>There‚Äôs one more catch with this release model: unstable features. Rust uses a
technique called ‚Äúfeature flags‚Äù to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
<code>master</code>, and therefore, in nightly, but behind a <em>feature flag</em>. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.</p>
<p>If you‚Äôre using a beta or stable release of Rust, you can‚Äôt use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won‚Äôt break. Stability without stagnation.</p>
<p>This book only contains information about stable features, as in-progress
features are still changing, and surely they‚Äôll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.</p>
<h3 id="rustup-and-the-role-of-rust-nightly"><a class="header" href="#rustup-and-the-role-of-rust-nightly">Rustup and the Role of Rust Nightly</a></h3>
<p>Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you‚Äôll have stable Rust installed. To
install nightly, for example:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>You can see all of the <em>toolchains</em> (releases of Rust and associated
components) you have installed with <code>rustup</code> as well. Here‚Äôs an example on one
of your authors‚Äô Windows computer:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use <code>rustup override</code> in that project‚Äôs directory to set the
nightly toolchain as the one <code>rustup</code> should use when you‚Äôre in that directory:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Now, every time you call <code>rustc</code> or <code>cargo</code> inside of
<em>~/projects/needs-nightly</em>, <code>rustup</code> will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!</p>
<h3 id="the-rfc-process-and-teams"><a class="header" href="#the-rfc-process-and-teams">The RFC Process and Teams</a></h3>
<p>So how do you learn about these new features? Rust‚Äôs development model follows
a <em>Request For Comments (RFC) process</em>. If you‚Äôd like an improvement in Rust,
you can write up a proposal, called an RFC.</p>
<p>Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There‚Äôs
a full list of the teams <a href="https://www.rust-lang.org/governance">on Rust‚Äôs
website</a>, which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there‚Äôs consensus to accept or reject the feature.</p>
<p>If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the <code>master</code> branch behind a feature gate, as we discussed
in the <a href="appendix-07-nightly-rust.html#unstable-features">‚ÄúUnstable Features‚Äù</a><!-- ignore --> section.</p>
<p>After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it‚Äôs
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
